*********************************************************************************
*
* Table of Script Routine Start Addresses
*
script_routines_jmp_table:
       data 0                                              ; (00) - Unused
       data script_routine_01                              ; (01) - Load HL (Script Data Pointer) with New Address
       data script_routine_02                              ; (02) - Move Entity at IX (and if Berk, Carried Entity) Left One Character
       data script_routine_03                              ; (03) - Move Entity at IX (and if Berk, Carried Entity) Right One Character
       data script_routine_04                              ; (04) - If Current Character and Target Entity are in the Same Room then Set Pending Sound
       data 0                                              ; (05) - Unused
       data script_routine_06                              ; (06) - Set Berk's Facing Into Screen Flag, and Reset his Facing Left and Facing Right flags
       data script_routine_07                              ; (07) - Reset Berk's Facing Into Screen, Facing Left and Facing Right Flags
       data script_routine_08                              ; (08) - Set Must Process Current Script Data Flag for Entity at IX
       data script_routine_09                              ; (09) - Reset Must Process Current Script Data Flag for Entity at IX
       data script_routine_10                              ; (10) - Reset Entity's Walking Left and Walking Right flags
       data script_routine_11                              ; (11) - Set Entity Walking Left Flag
       data script_routine_12                              ; (12) - Set Entity Walking Right Flag
       data script_routine_13                              ; (13) - Set Berk's Facing Left Flag, and Reset his Facing Into Screen and Facing Right Flags
       data script_routine_14                              ; (14) - Set Berk's Facing Right Flag, and Reset his Facing Into Screen and Facing Left Flags
       data script_routine_15                              ; (15) - Jump to New Address if Berk Is Carrying Something
       data script_routine_16                              ; (16) - Have Berk Hold an Entity, and Position it Appropriately Between his Hands
       data script_routine_17                              ; (17) - Have Berk Put Down an Entity in Front of Him, if Appropriate
       data script_routine_18                              ; (18) - Have Berk Put Down an Entity Behind Him, if Appropriate
       data script_routine_19                              ; (19) - Move Carried Entity to Berk's Left as he Faces Left
       data script_routine_20                              ; (20) - Move Carried Entity to Berk's Right as he Faces Right
       data script_routine_21                              ; (21) - Move Carried Entity in Front of Berk as he Faces Out of Screen
       data script_routine_22                              ; (22) - Move Carried Entity Behind Berk as he Faces Into Screen
       data script_routine_23                              ; (23) - Start Loop (1 / 3)
       data script_routine_24                              ; (24) - End Loop (1 / 3)
       data script_routine_25                              ; (25) - Start Loop (2 / 3)
       data script_routine_26                              ; (26) - End Loop (2 / 3)
       data script_routine_27                              ; (27) - Start Loop (3 / 3)
       data script_routine_28                              ; (28) - End Loop (3 / 3)
       data script_routine_29                              ; (29) - Make Berk Start Falling, and Drop his Carried Entity if Appropriate
       data script_routine_30                              ; (30) - Check Berk's Fall Velocity, and React to Landing
       data script_routine_31                              ; (31) - React to Berk's Landing
       data script_routine_32                              ; (32) - Update Berk's Position and State (Flying) Depending Upon Control Input
       data script_routine_33                              ; (33) - Advance Berk's Jump and Select Next Phase if Current Phase Complete
       data script_routine_34                              ; (34) - Move Entity at IX (and if Berk, Carried Entity) Up One Character
       data script_routine_35                              ; (35) - Move Entity at IX (and if Berk, Carried Entity) Down One Character
       data script_routine_36                              ; (36) - Set Boni's Room (Level 1) to Zero
       data script_routine_37                              ; (37) - Remove Flying Skeleton Creature from Level 1, and Terminate Script Processing
       data script_routine_38                              ; (38) - Close the Trap Door
       data script_routine_39                              ; (39) - Open the Trap Door
       data script_routine_40                              ; (40) - Move Spider Down One Character, and if at Bottom, Advance it to Bounce / Climb Up Mode
       data script_routine_41                              ; (41) - Move Spider Up One Character and, if Home, Reset its Timer and Make it Wait
       data script_routine_42                              ; (42) - Decrease Remaining Time Until Spider Next Descends and if Zero, Start Descent
       data script_routine_43                              ; (43) - Select Next Action for Drutt Depending Upon Control Input
       data script_routine_44                              ; (44) - Move Entity Up One Character
       data script_routine_45                              ; (45) - Move Entity Down One Character
       data script_routine_46                              ; (46) - Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling
                                                           ; if Appropriate
       data script_routine_47                              ; (47) - Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity
                                                           ; Falling if Appropriate
       data script_routine_48_49                           ; (48) - Return
       data script_routine_48_49                           ; (49) - Return
       data script_routine_50                              ; (50) - Advance Drutt's Jump and Select Next Phase if Current Phase Complete
       data script_routine_51                              ; (51) - Swap Drutt's Current Depth Level if Possible
       data script_routine_52                              ; (52) - Increase Worm's Age and Decrease Time Until Direction Change, or React to Drutt's
                                                           ; Presence
       data script_routine_53                              ; (53) - Move Worm Left if Possible, Otherwise Choose New Direction
       data script_routine_54                              ; (54) - Move Worm Right if Possible, Otherwise Choose New Direction
       data script_routine_55                              ; (55) - Choose New Direction and Start Crawling (Worm)
       data script_routine_56                              ; (56) - Give Berk Power Corresponding to Entity Eaten
       data script_routine_57                              ; (57) - Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside
                                                           ; Current Room
       data script_routine_58                              ; (58) - Have Berk Interact Appropriately with a Door in Front of Him
       data script_routine_59                              ; (59) - Have Berk Interact Appropriately with a Door Behind Him
       data script_routine_60                              ; (60) - Check Position of Apebeast and Turn If Appropriate
       data script_routine_61                              ; (61) - Fire Bubo's Projectile
       data script_routine_62                              ; (62) - Move Entity at IX into Room to the Left, if Appropriate
       data script_routine_63                              ; (63) - Have Skeleton Advance or Retreat Based Upon Positions of Berk and Fake Boni
       data script_routine_64                              ; (64) - Set Random (1 to 10) Number of Iterations in Following Loop Script Instruction

*********************************************************************************
* Script Routine (04) If Current Character and Target Entity are in the Same Room then Set Pending Sound Input:  HL
* Current position in script data IX  Address of complex state data for an entity
script_routine_04:
       inc  hl                         ; INC HL            ; Advance HL to parameter (sound index)...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load A with sound index
       bl   @request_entity_sound      ; CALL 59601        ; If current character is in same room as target entity at IX then set pending sound to A
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (62) Move Entity at IX into Room to the Left, if Appropriate
script_routine_62:
       bl   @move_into_left_room       ; CALL 54348        ; Move entity at IX into room to the left, if appropriate
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (16) Have Berk Hold an Entity, and Position it Appropriately Between his Hands
script_routine_16:
       bl   @position_carried_item                   ; CALL 48850        ; Have Berk hold an entity, and position it appropriately between his hands
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (17) Have Berk Put Down an Entity in Front of Him, if Appropriate Output: D  Depth offset for
* entity being put down
script_routine_17:
       movb @bytes+0,d                 ; LD D,0            ; Load D with depth offset of 0 (as Berk is putting down an entity in front of him)
       jmp  _48160                     ; JR 48160          ; Have Berk put down an entity, if appropriate

*********************************************************************************
* Script Routine (18) Have Berk Put Down an Entity Behind Him, if Appropriate Input:  D  (Entry at #R48160 only)
* Depth offset for entity being put down IX  Address of complex state data (current level) for Berk
script_routine_18:
       movb @bytes+255,d               ; LD D,255          ; Load D with depth offset of -1 (as Berk is putting down an entity behind him)
* This entry point is used by the routine at #R48154.
_48160:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is reset...
       andi tmp0,16*256                ;
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;
!
* Berk is carrying something
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       movb a,@berk_entity_held                  ; LD (34221),A      ; ...
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...and reset its Is Being Carried Flag
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load E with height of entity minus one...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       movb @berk_coloured_creature,a                  ; LD A,(34222)      ; Load A with y-coordinate minus one of top edge of coloured creature slot Berk is interacting
                                                           ; with...
       socb a,a                        ; OR A              ; ...and if this is not zero...
       jne  _48198                     ; JR NZ,48198       ; ...then skip ahead to #R48198
* Value at #R34222 is zero (i.e. Berk not interacting with a coloured creature slot on Level 3)
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load A with y-coordinate of Berk's bottom edge...
       ab   d,a                        ; ADD A,D           ; ...plus depth offset...
* At this point, A holds either the y-coordinate of Berk's bottom edge plus depth offset, or the y-coordinate minus
* one of the top edge of (actually the y-coordinate of the bottom of the space within) a coloured creature slot on
* Level 3. This value in A is the y-coordinate that the carried entity's bottom edge will take on when that entity
* is put down.
_48198:
       movb a,@6(iy)                   ; LD (IY+6),A       ; Set the y-coordinate of the bottom edge of the put-down entity to value in A
       sb   @e,a                       ; SUB E             ; Set the y-coordinate of the top edge of the put-down entity...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...to that of the bottom edge, minus the height as appropriate
       sb   a,a                        ; XOR A             ; Set value at #R34222 to zero...
       movb a,@berk_coloured_creature                  ; LD (34222),A      ; ...as Berk is not (any longer) interacting with a coloured creature slot on Level 3
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (10) Reset Walking Left and Walking Right Flags
*
* Used by the routine at #R36542. Output: E  Combination of flags to (re)set
script_routine_10:
       movb @bytes+0,@e                ; LD E,0            ; Reset Entity Walking Left and Entity Walking Right flags...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (12) Reset Walking Left Flag and Set Walking Right Flag Output: E  Combination of flags to (re)set
script_routine_12:
       movb one,@e                     ; LD E,1            ; Set Entity Walking Right Flag, reset Entity Walking Left Flag...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (11) Set Walking Left Flag and Reset Walking Right Flag Input:  E  (Entry at #R48222 only)
* Combination of flags to (re)set IX  Address of complex state data for an entity
script_routine_11:
       movb @bytes+2,@e                ; LD E,2            ; Prepare to set Entity Walking Left Flag and reset Entity Walking Right Flag
* This entry point is used by the routines at #R48212 and #R48216.
_48222:
       movb @11(ix),a                  ; LD A,(IX+11)      ; (Re)set Walking Left and Walking Right flags as prepared in E...
       andi a,240*256                  ; AND 240           ; ...and reset Unused (11,2) and Unused (11,3) flags...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (07) Reset Berk's Facing Into Screen, Facing Left and Facing Right Flags Output: B  Combination of
* flags to (re)set
script_routine_07:
       sb   b,b                        ; LD B,0            ; Reset Berk's Facing Into Screen, Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (06) Set Berk's Facing Into Screen Flag, and Reset his Facing Left and Facing Right Flags Output: B
* Combination of flags to (re)set
script_routine_06:
       movb @bytes+2,b                 ; LD B,2            ; Set Berk's Facing Into Screen Flag, and reset his Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (13) Set Berk's Facing Left Flag, and Reset his Facing Into Screen and Facing Right Flags Output: B
* Combination of flags to (re)set
script_routine_13:
       movb @bytes+4,b                 ; LD B,4            ; Set Berk's Facing Left Flag, and reset his Facing Into Screen and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (14) Set Berk's Facing Right Flag, and Reset his Facing Into Screen and Facing Left Flags Input:  B
* (Entry at #R48248 only) Combination of flags to (re)set IX  Address of complex state data (current level) for Berk
script_routine_14:
       movb @bytes+8,b                 ; LD B,8            ; Prepare to set Berk's Facing Right Flag, and reset his Facing Into Screen and Facing Left
                                                           ; flags
* This entry point is used by the routines at #R48234, #R48238 and #R48242.
_48248:
       movb @9(ix),a                   ; LD A,(IX+9)       ; Load A with Berk's flags...
       andi a,241*256                  ; AND 241           ; ...clearing Facing Into Screen, Facing Left and Facing Right flags
       ab   b,a                        ; ADD A,B           ; Combine with flags in B...
       movb a,@9(ix)                   ; LD (IX+9),A       ; ...and store
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (09) Reset Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
script_routine_09:
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Must Process Current Script Data Flag
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (08) Set Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
script_routine_08:
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Must Process Current Script Data Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (15) Jump to New Address if Berk Is Carrying Something Input:  HL  Current position in script data
* IX  Address of complex state data for an entity
script_routine_15:
       inct hl                         ; INC HL            ; Advance HL to parameter for current instruction...
                                       ; INC HL            ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is carrying an entity...
       andi tmp0,16*256                ;
       jne  _48287                     ; JR NZ,48287       ; ...then read parameter address into HL and execute next script instruction at that address
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (01) Load HL (Script Data Pointer) with New Address
*
* Functionality analogous to JP instruction. Input:  HL  Address in script data Output: HL  New address in script
* data
script_routine_01:
       inct hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
                                       ; INC HL            ; ...
* This entry point is used by the routine at #R48274.
_48287:
       movb *hl+,@c                    ; LD C,(HL)         ; Read WORD at this location into HL...
                                       ; INC HL            ; ...(i.e. update Script Data Pointer to this address)...
       movb *hl,b                      ; LD B,(HL)         ; ...
       mov  bc,hl                      ; PUSH BC           ; ...
                                       ; POP HL            ; ...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (23) Start Loop (1 / 3)
*
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34285 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34285. Output: HL  Address of next
* script instruction to execute
script_routine_23:
       bl   @load_instr_and_advance    ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_23_24_loop_count ; LD (34285),A      ; Store repeat count at #R34285
       mov  hl,@script_23_24_loop_addr ; LD (34286),HL     ; Store address to return to (i.e. first instruction in loop) at #R34285...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (24) End Loop (1 / 3) Output: HL  Address of next script instruction to execute
script_routine_24:
       movb @script_23_24_loop_count,a ; LD A,(34285)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_23_24_loop_count ; LD (34285),A      ; ...and store
       mov  @script_23_24_loop_addr,hl ; LD HL,(34286)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (25) Start Loop (2 / 3)
*
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34288 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34288. Output: HL  Address of next
* script instruction to execute
script_routine_25:
       bl   @load_instr_and_advance                   ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_25_26_loop_count ; LD (34288),A      ; Store repeat count at #R34288
       mov  hl,@script_25_26_loop_addr ; LD (34289),HL     ; Store address to return to (i.e. first instruction in loop) at #R34288...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (26) End Loop (2 / 3) Output: HL  Address of next script instruction to execute
script_routine_26:
       movb @script_25_26_loop_count,a ; LD A,(34288)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script        ;
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_25_26_loop_count ; LD (34288),A      ; ...and store
       mov  @script_25_26_loop_addr,hl ; LD HL,(34289)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (27) Start Loop (3 / 3)
*
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34291 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34291. Output: HL  Address of next
* script instruction to execute
script_routine_27:
       bl   @load_instr_and_advance                   ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_27_28_loop_count ; LD (34291),A      ; Store repeat count at #R34291
       mov  hl,@script_27_28_loop_addr ; LD (34292),HL     ; Store address to return to (i.e. first instruction in loop) at #R34291...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (28) End Loop (3 / 3) Output: HL  Address of next script instruction to execute
script_routine_28:
       movb @script_27_28_loop_count,a ; LD A,(34291)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_27_28_loop_count ; LD (34291),A      ; ...and store
       mov  @script_27_28_loop_addr,hl ; LD HL,(34292)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (32) Update Berk's Position and State (Flying) Depending Upon Control Input
*
* See pokes Input:  IX  (Entry at #R48487 only) Address of complex state data (current level) for Berk IX  (Entry at
* #R48541 only) Address of complex state data for an entity Output: HL  Address of next script instruction to
* execute
script_routine_32:
       bl    @dec_power_duration                   ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was not with entity of class 130 (causes Berk and Drutt to bounce off or
                                                           ; bang head)...
       jne  _48507                     ; JR NZ,48507       ; ...then skip ahead to #R48507
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset entity's Is Flying Flag
       li   hl,_35359                  ; LD HL,35359       ; Load HL with script data address for Berk starting to fall downwards
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_48507:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is 121 or greater...
       cb   a,@bytes+121               ; CP 121            ; ...
       jhe  _48527                     ; JR NC,48527       ; ...then skip ahead to #R48527
       movb @control_input,a                  ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right pressed...
       andi tmp0,1*256                 ;
       jeq  !                          ; JP NZ,48593       ; ...then move Berk right one character, and into new room if appropriate
       b    @move_entity_right                    ;
!
       movb a,tmp0                     ; BIT 1,A           ; If left pressed...
       andi tmp0,2*256                 ;
       jeq  !                          ; JP NZ,48641       ; ...then move Berk left one character, and into new room if appropriate
       b    @move_entity_left                    ;
!
_48527:
       equ  $
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is less than 98...
       cb   a,@bytes+98                ; CP 98             ; ...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       bl    @change_room_up                   ; CALL 55433        ; Change Berk's room up one if appropriate
       bl    @move_carried_to_front                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37718. It is also the start of the routine triggered by instruction
* 34 in script data.
script_routine_34:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease y-coordinates of entity's top and bottom edges by one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@4(iy)                 ; DEC (IY+4)        ; ...and decrease its top and bottom y-coordinates by one character...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (35) Move Entity at IX (and if Berk, Carried Entity) Down One Character
*
* Used by the routine at #R37778. Input:  IX  Address of complex state data for an entity
script_routine_35:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase y-coordinates of entity's top and bottom edges by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@4(iy)                 ; INC (IY+4)        ; ...and increase its top and bottom y-coordinates by one character...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Right One Character, and Into New Room if Appropriate
*
* Used by the routine at #R48487. Input:  IX  (Entry at #R48593 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48615 only) Address of complex state data for an entity
* jumped - not called
move_entity_right:
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Berk's right side is less than x-coordinate of right of current room...
       cb   a,@e                       ; CP E              ; ...
       jl   script_routine_03                     ; JR C,48615        ; ...then skip ahead to #R48615 (move Berk right by one character
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the right, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   ; instruction and execute)
!
       bl   @do_move_into_right_room   ; CALL 54383        ; Move Berk into room to right of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       bl    @move_carried_to_front                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 03 in script data.
script_routine_03:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Increase x-coordinates of entity's left and right edges by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...and increase its left and right x-coordinates by one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Left One Character, and Into New Room if Appropriate
*
* Used by the routine at #R48487. Input:  IX  (Entry at #R48641 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48660 only) Address of complex state data for an entity
* jumped - not called
move_entity_left:
       movb @bytes+100,a               ; LD A,100          ; If Berk's left-side x-coordinate is greater than 100 (x-coordinate of left side of room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   script_routine_02                     ; JR C,48660        ; ...then skip ahead to #R48660 (move Berk left by one character)
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the left, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   ; instruction and execute)
!
       bl   @do_move_into_left_room   ; CALL 54419        ; Move Berk into room to left of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       bl   @move_carried_to_front                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 02 in script data.
script_routine_02:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Decrease x-coordinates of entity's left and right edges by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...and decrease its left and right x-coordinates by one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (22) Move Carried Entity Behind Berk as he Faces Into Screen
script_routine_22:
       bl   @move_carried_to_back                   ; CALL 48715        ; Move carried entity behind Berk as he faces into screen
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (21) Move Carried Entity in Front of Berk as he Faces Out of Screen
script_routine_21:
       bl   @move_carried_to_front                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (19) Move Carried Entity to Berk's Left as he Faces Left
script_routine_19:
       bl   @move_carried_to_left                   ; CALL 48738        ; Move carried entity to Berk's left as he faces left
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (20) Move Carried Entity to Berk's Right as he Faces Right
script_routine_20:
       bl   @move_carried_to_right                   ; CALL 48727        ; Move carried entity to Berk's right as he faces right
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (29) Make Berk Start Falling, and Drop his Carried Entity if Appropriate Input:  IX  Address of
* complex state data for an entity
script_routine_29:
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set Berk's initial velocity factor to 2
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set Berk's "Can Fall" flag
       bl   @drop_item                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (30) Check Berk's Fall Velocity, and React to Landing
*
* See trivia and pokes Input:  IX  Address of complex state data (current level) for Berk Output: HL  Address of
* next script instruction to execute
script_routine_30:
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If Berk's "Can Fall" Flag is reset (i.e. Berk has landed)...
       andi tmp0,64*256                ;
       jeq  _48958                     ; JR Z,48958        ; ...then skip ahead to #R48958
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;
       jne  _48952                     ; JR NZ,48952       ; ...then skip ahead to #R48952
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       b    @execute_script            ; JP 48098          ; ...and execute
_48952:
       li   hl,_35367                  ; LD HL,35367       ; Point HL at script data for Berk falling rapidly (horizontal, arms outstretched)...
       b    @execute_script            ; JP 48098          ; ...and execute
_48958:
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;
       jne  _48970                     ; JR NZ,48970       ; ...then skip ahead to #R48970
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @execute_script            ; JP 48098          ; ...and execute
_48970:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (31) React to Berk's Landing
*
* See trivia Input:  IX  Address of complex state data for an entity Output: HL  Address of next script instruction
* to execute
script_routine_31:
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;
       jne  _48988                     ; JR NZ,48988       ; ...then skip ahead to #R48988
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @execute_script            ; JP 48098          ; ...and execute
_48988:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (33) Advance Berk's Jump and Select Next Phase if Current Phase Complete Output: HL  Address of
* next script instruction to execute
script_routine_33:
       bl   @handle_berk_jump                   ; CALL 55041        ; Handle Berk's jump, and load A with Jump State Index as appropriate...
       movb @e,a                       ; LD A,E            ; ...
       socb a,a                        ; OR A              ; If Jump State Index is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       sb   one,a                      ; DEC A             ; Decrease Jump State Index
       li   de,berks_jump_script_data                  ; LD DE,48994       ; Load DE with start address of Table of Addresses of Berk's Jump Script Data
       bl   @load_table_addr           ; CALL 53814        ; Advance DE by 2xA Bytes, load WORD at this location into HL...
       .ex_de_hl                       ; EX DE,HL          ; ...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

*********************************************************************************
* Script Routine (43) Select Next Action for Drutt Depending Upon Control Input Input:  IX  Address of complex state
* data (current level) for Drutt Output: HL  Address of next script instruction to execute
script_routine_43:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check Drutt for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
       cb   a,@bytes+129               ; CP 129            ; ...and if collision was not with entity of class 129 (causes other entities to start
                                                           ; falling)...
       jne  _51792                     ; JR NZ,51792       ; ...then skip ahead to #R51792
       bl   @prepare_falling           ; CALL 55516        ; Set Drutt's Can Fall Flag and initial velocity factor to 2
       b    @script_routine_45         ; JP 52038          ; Move Drutt down one character, advance HL to next script instruction and execute
_51792:
       mov  @worm_state_addr,iy        ; LD IY,(34244)     ; Load IY with address of current level's complex state data for worm
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       jeq  _51841                     ; JR Z,51841        ; ...then skip ahead to #R51841
* Drutt Mode Flag is set (i.e. Drutt Mode)
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Drutt's Under Player Control Flag
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1*256                 ;
       jne  _51904                     ; JR NZ,51904       ; ...then randomly select script data for rightward hop of size three or four, and execute
       movb a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2*256                 ;
       jne  _51924                     ; JR NZ,51924       ; ...then randomly select script data for leftward hop of size three or four, and execute
       movb a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4*256                 ;
       jeq  !                          ; JP NZ,51954       ; ...then point HL at script data for Drutt swapping depth levels and execute
       b    @_51954                    ;
!
       movb a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8*256                 ;
       jeq  !                          ; JP NZ,51944       ; ...then jump to #R51944 (start Drutt jumping)
       b    @_51944                    ;
!
* At this point, no control has been pressed, so Drutt is effectively not under player control
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is zero (i.e. not in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51960                    ; JP 51960          ; Move Drutt closer to the worm and eat it if close enough
* Drutt Mode Flag is reset (i.e. Berk Mode)
_51841:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is not zero (i.e. is in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  !                          ; JP NZ,51960       ; ...then move Drutt closer to the worm and eat it if close enough
       b    @_51960                    ;
!
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt is in the same room as Berk...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
* The following code will make Drutt move closer to the target (a worm, or Berk if in Berk Mode) if the target's
* room is directly to the left or right of Drutt's room (i.e. no vertical separation). Otherwise, Drutt will perform
* a random action. This entry point is used by the routine at #R51960.
_51864:
       bl   @find_direction_to_room    ; CALL 53194        ; Load A with value indicating which direction room A lies relative to Drutt's current room
       cb   a,one                      ; CP 1              ; If target room is to the right...
       jeq  _51904                     ; JR Z,51904        ; ...then randomly select script data for rightward hop of size three or four, and execute
       cb   a,@bytes+2                 ; CP 2              ; If target room is to the left...
       jeq  _51924                     ; JR Z,51924        ; ...then randomly select script data for leftward hop of size three or four, and execute
* This entry point is used by the routine at #R51960.
_51875:
       movb @bytes+7,a                 ; LD A,7            ; Load A with a random number, 0-6...
       bl   @rnd_no                    ; CALL 54222        ; ...
       li   de,drutts_script_data_actions                  ; LD DE,51890       ; Point DE at Table of Addresses of Script Data for Drutt's Actions...
       bl   @load_table_addr           ; CALL 53814        ; ...and load DE with entry of index A in this table
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (now contains address of randomly selected script data)
       b    @execute_script            ; JP 48098          ; Execute script data at address in HL

* Randomly Select Script Data for Rightward Hop of Size Three or Four, and Execute
*
* Used by the routine at #R51779.
_51904:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51918                     ; JR Z,51918        ; ...then skip ahead to #R51918
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @execute_script            ; JP 48098          ; ...and execute
_51918:
       li   hl,_51562                  ; LD HL,51562       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size
                                                           ; three...
       b    @execute_script            ; JP 48098          ; ...and execute

* Randomly Select Script Data for Leftward Hop of Size Three or Four, and Execute
*
* Used by the routine at #R51779.
_51924:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51938                     ; JR Z,51938        ; ...then skip ahead to #R51938
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @execute_script            ; JP 48098          ; ...and execute
_51938:
       li   hl,_51608                  ; LD HL,51608       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size three...
       b    @execute_script            ; JP 48098          ; ...and execute

* Start Drutt Jumping
*
* Used by the routine at #R51779.
_51944:
       movb @bytes+130,@12(ix)         ; LD (IX+12),130    ; Set Drutt's Is Jumping Flag and set initial Jump Velocity to 2
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @execute_script            ; JP 48098          ; ...and execute

* Point HL at Script Data for Drutt Swapping Depth Levels and Execute
*
* Used by the routine at #R51779.
_51954:
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script            ; JP 48098          ; ...and execute

* Move Drutt Closer to the Worm and Eat it if Close Enough
*
* Used by the routine at #R51779. Input:  IX  Address of complex state data (current level) for Drutt IY  Address of
* complex state data (current level) for Worm
_51960:
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt and worm are not in the same room...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  !                          ; JP NZ,51864       ; ...then move Drutt closer to worm if appropriate, otherwise make Drutt perform random action
       b    @_51864                    ;
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If Drutt's left edge...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the worm's...
       jl   _52017                     ; JR C,52017        ; ...then skip ahead to #R52017
       movb @7(iy),a                   ; LD A,(IY+7)       ; If worm's right edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of Drutt's left edge...
       jl   _52023                     ; JR C,52023        ; ...then skip ahead to #R52023
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of Drutt's top edge...
       cb   a,@bytes+120               ; CP 120            ; ...is less than 120...
       jhe  !                          ; JP C,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51875                    ;
!
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is the same as Drutt's...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jeq  _52007                     ; JR Z,52007        ; ...then skip ahead to #R52007
* Drutt and worm in same room, at different depth and same x-coordinate
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt and worm in same room, at same depth and same x-coordinate
_52007:
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set worm's depth to zero (i.e. remove from play)
       li   hl,_51706                  ; LD HL,51706       ; Point HL at script data for Drutt eating a worm...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt's left edge to left of worm's
_52017:
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @execute_script            ; JP 48098          ; ...and execute
* Worm's right edge to left of Drutt's left edge
_52023:
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (44) Move Entity Up One Character
*
* Used by the routine at #R48026. Input:  IX  Address of complex state data for an entity
script_routine_44:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move entity up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (45) Move Entity Down One Character
*
* Used by the routine at #R51779. Input:  IX  Address of complex state data for an entity
script_routine_45:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (46) Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if
* Appropriate
script_routine_46:
       bl   @push_left                 ; CALL 52053        ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                           ; appropriate
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (47) Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if
* Appropriate
script_routine_47:
       bl   @push_right                ; CALL 52148        ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                           ; appropriate
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (50) Advance Drutt's Jump and Select Next Phase if Current Phase Complete
*
* The CALL at #R52243 will be RETurned from if Drutt's Is Jumping Flag is reset. Otherwise, E will be loaded with
* Drutt's jump state index (see #R55041). Output: HL  Address of next script instruction to execute
script_routine_50:
       bl   @handle_drutt_jump        ; CALL 55023        ; Handle Drutt's jump, and load A with Jump State Index as appropriate
       movb @e,a                       ; LD A,E            ; If jump state index is zero...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       cb   a,one                      ; CP 1              ; If jump state index is 1...
       jeq  _52259                     ; JR Z,52259        ; ...then skip ahead to #R52259
       cb   a,@bytes+2                 ; CP 2              ; If jump state index is not 2...
       jne  _52265                     ; JR NZ,52265       ; ...then skip ahead to #R52265
* Jump state index is 1 (landed on floor / platform and Back (control input) bit set) or 2 (unused)
_52259:
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 2
_52265:
       cb   a,@bytes+3                 ; CP 3              ; If jump state index is not 3...
       jne  _52275                     ; JR NZ,52275       ; ...then skip ahead to #R52275
* Jump state index is 3 (Drutt's jump velocity less than 4, and back not pressed, i.e. terminate jumping)
       li   hl,drutt_facing_out_script ; LD HL,51524       ; Point HL at script data for Drutt facing out of screen...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 3
_52275:
       cb   a,@bytes+4                 ; CP 4              ; If jump state index is not 4...
       jne  _52285                     ; JR NZ,52285       ; ...then skip ahead to #R52285
* Jump state index is 4 (bounced off an obstruction to the right or Left (control input) Bit set)
       li   hl,_51686                  ; LD HL,51686       ; Point HL at script data for Drutt Jumping Left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 4
_52285:
       cb   a,@bytes+5                 ; CP 5              ; If jump state index is not 5...
       jne  _52295                     ; JR NZ,52295       ; ...then skip ahead to #R52295
* Jump state index is 5 (bounced off an obstruction to the left or Right (control input) Bit set)
       li   hl,_51696                  ; LD HL,51696       ; Point HL at script data for Drutt Jumping Right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 5
_52295:
       cb   a,@bytes+6                 ; CP 6              ; If jump state index is not 6...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
* Jump state index is 6 (Drutt has banged his head on something above him)
       bl   @prepare_falling           ; CALL 55516        ; Set Drutt's Can Fall Flag and set initial velocity factor of 2
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (51) Swap Drutt's Current Depth Level if Possible
script_routine_51:
       bl   @swap_drutts_depth         ; CALL 52315        ; Swap Drutt's current depth level if possible
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (53) Move Worm Left if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
script_routine_53:
       bl    @chk_coll_left            ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52908                     ; JR NC,52908       ; ...and if a collision occurred, then have worm choose new direction
       bl   @move_into_left_room       ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; ...and if worm can't enter new room then have worm choose new direction
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move worm left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (54) Move Worm Right if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
script_routine_54:
       bl   @chk_coll_right            ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52908                     ; JR NC,52908       ; ...and if a collision occurred, then have worm choose new direction
       bl   @move_into_right_room      ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; ...and if worm can't enter new room then have worm choose new direction
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move worm right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Execute Script Data for Worm Choosing Next Direction
*
* Used by the routines at #R52870 and #R52889.
_52908:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (55) Choose New Direction and Start Crawling (Worm) Input:  IX  Address of complex state data for
* an entity
script_routine_55:
       bl   @increase_worms_age        ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       movb @bytes+20,a                ; LD A,20           ; Load A with a random number, 5-24...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   @bytes+5,a                 ; ADD A,5           ; ...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...and set worm's Time Until Direction Change to this value
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if zero (1 in 2 chance)...
       jne  _52951                     ; JR NZ,52951       ; ...then skip ahead to #R52951
* Have worm move left
       bl    @chk_coll_left            ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52961                     ; JR NC,52961       ; ...and if a collision occurred, then start worm crawling right
       bl   @move_into_left_room       ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52961                     ; JR NC,52961       ; ...and if worm can't enter new room then start worm crawling right
_52945:
       li   hl,_52765                  ; LD HL,52765       ; Point HL at script data for worm, crawling left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Have worm move right
_52951:
       bl   @chk_coll_right            ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52945                     ; JR NC,52945       ; ...and if a collision occurred, then start worm crawling left
       bl   @move_into_right_room      ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52945                     ; JR NC,52945       ; ...and if worm can't enter new room then start worm crawling left
_52961:
       li   hl,_52781                  ; LD HL,52781       ; Point HL at script data for worm, crawling right...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (52) Increase Worm's Age and Decrease Time Until Direction Change, or React to Drutt's Presence
*
* When both Drutt and the worm are in the same room, and the worm is alerted to Drutt's presence, then the worm will
* take on its alarmed appearance and start fleeing in the direction away from Drutt. As long as Drutt remains in the
* same room as the worm, and within the "alerting" distance, the worm will continue fleeing in the same direction,
* and its Time Until Direction Change will be frozen. Input:  IX  Address of complex state data for an entity
* Output: HL  Address of next script instruction to execute
script_routine_52:
       bl   @increase_worms_age        ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt
       movb *ix,a                      ; LD A,(IX+0)       ; If Drutt and the worm are in the same room...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  _53004                     ; JR Z,53004        ; ...then skip ahead to #R53004
* Drutt and worm in different rooms, so countdown to next direction change resumes as worm out of danger
_52982:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset In Danger Flag
       movb @12(ix),a                  ; LD A,(IX+12)      ; If worm's Time Until Direction Change is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _52998                     ; JR Z,52998        ; ...then skip ahead to #R52998 (have worm choose new direction)
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease worm's Time Until Direction Change
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_52998:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt and worm in same room, so worm potentially in danger
_53004:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of worm's left edge...
       ab   one,a                      ; INC A             ; ...plus one...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...minus x-coordinate of Drutt's left edge
       jlt  _53034                     ; JR C,53034        ; If negative then skip ahead to #R53034
       cb   a,@bytes+10                ; CP 10             ; If worm's left edge is 9 characters or more to the right of Drutt's...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2*256                 ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52817                  ; LD HL,52817       ; Point HL at script data for worm, fleeing right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt's left edge more than one character to the right of worm's left edge
_53034:
       neg a                           ; NEG               ; If worm's left edge is 11 characters or more to the left of Drutt's...
       cb   a,@bytes+10                ; CP 10             ; ...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2*256                 ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52797                  ; LD HL,52797       ; Point HL at script data for worm, fleeing left...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (48, 49) Return
*
* This script routine terminates the script data currently under execution until the next game cycle.
script_routine_48_49:
       .ret                            ; RET               ; Return

*********************************************************************************
* Script Routine (59) Have Berk Interact Appropriately with a Door Behind Him Output: BC  Address of script data to
* execute upon arrival of new level
script_routine_59:
       li   bc,_35113                  ; LD BC,35113       ; Load BC with address of script data for Berk facing into screen, ready to respond to control
                                                           ; input
       jmp  _36393                     ; JR 36393          ; Have Berk interact appropriately with a door

*********************************************************************************
* Script Routine (58) Have Berk Interact Appropriately with a Door in Front of Him Input:  BC  (entry at #R36393
* only) Address of script data to execute upon arrival of new level
script_routine_58:
       li   bc,_35081                  ; LD BC,35081       ; Load BC with address of script data for Berk facing out of screen, ready to respond to
                                                           ; control input
* This entry point is used by the routine at #R36385.
_36393:
       mov  bc,@script_for_next_level  ; LD (34266),BC     ; Store script data address in BC at #R34266
       movb @game_flags,a              ; LD A,(34208)      ; Load E with Game Flags...
       movb a,@e                       ; LD E,A            ; ...
       movb @berk_entity_held,a        ; LD A,(34221)      ; Load A with class of entity currently held by Berk...
       cb   a,@bytes+17                ; CP 17             ; ... and if this is not 17 (Key)...
       jne  _36429                     ; JR NZ,36429       ; ...then skip ahead to #R36429
* Berk is holding a key
       movb @bytes+7,a                 ; LD A,7            ; Set door colour to 7 (white, i.e. unlocked)...
       movb a,@_50711+1                ; LD (50712),A      ; ...
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the key and load IY with its complex state data address
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set depth of key to 0 (i.e. out of display)
       socb @bits+4,@e                 ; SET 4,E           ; Set Level Exit Door Unlocked Flag...
       movb @e,a                       ; LD A,E            ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
* Berk is not holding a key
_36429:
       movb @e,tmp0                    ; BIT 4,E           ; If Level Exit Door Unlocked Flag is reset...
       andi tmp0,16*256                ;
       jeq  _36462                     ; JR Z,36462        ; ...then skip ahead to #R36462
       movb a,d                        ; LD D,A            ; Load D with class of entity currently held by Berk
       movb @current_level,a           ; LD A,(34207)      ; Set Zero Flag if current level is Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       movb d,a                        ; LD A,D            ; Load A with class of entity currently held by Berk
       jne  _36446                     ; JR NZ,36446       ; If Zero Flag is not set (i.e. we are not on Level 4) then skip ahead to #R36446
* Level 4
       cb   a,@bytes+19                ; CP 19             ; Set Zero Flag if class of entity currently held by Berk is 19 (Boni)
       jmp  _36448                     ; JR 36448          ; Skip ahead to #R36448
* Not Level 4
_36446:
       cb   a,@bytes+18                ; CP 18             ; Set Zero Flag if class of entity currently held by Berk is 18 (Drutt)
_36448:
       jne  _36462                     ; JR NZ,36462       ; If Zero Flag is not set (i.e. Berk is not holding Drutt on Levels 1-3 or Boni on Level 4)
                                                           ; then skip ahead to #R36462
* Berk is holding the correct character
       bl   @remove_current_power      ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       bl   @next_level                ; CALL 36638        ; Advance to next level and if back to Level 1 then exit this routine and make Berk start
                                                           ; falling
* New level is not Level 1
       mov  @script_for_next_level,hl  ; LD HL,(34266)     ; Load HL with script data address stored at #R34266...
       b    @execute_script            ; JP 48098          ; ...and execute
* Door is locked or Berk is not holding the correct character
_36462:
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       bl   @set_bert_killed           ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (56) Give Berk Power Corresponding to Entity Eaten Input:  IX  Address of complex state data
* (current level) for Berk
script_routine_56:
       bl   @remove_current_power      ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       movb @berk_entity_held,a        ; LD A,(34221)      ; Set current power value to class of entity currently held by Berk...
       movb a,@berks_current_power     ; LD (34220),A      ; ...
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. none)...
       movb a,@berk_entity_held        ; LD (34221),A      ; ...
       movb a,@remaining_power_cycles  ; LD (34224),A      ; Set number of elapsed game-cycles in current block to zero
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       movb a,@1(iy)                   ; LD (IY+1),A       ; ...and set its depth to zero (i.e. outside room)
       movb @10(iy),a                  ; LD A,(IY+10)      ; Initialise remaining duration of power to value encoded entity's complex state data (bits
                                                           ; 0-4)...
       andi a,31*256                   ; AND 31            ; ...
       movb a,@remaining_power_groups  ; LD (34225),A      ; ...
       movb @berks_current_power,a     ; LD A,(34220)      ; If Berk's current power is not floating (Level 3)...
       cb   a,@bytes+10                ; CP 10             ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
* Power is floating
       movb @bytes+12,@12(ix)          ; LD (IX+12),12     ; Set distance Berk will be pushed by Drutt while floating to 12
       socb @bits+7,@9(ix)             ; SET 7,(IX+9)      ; Set Berk's Moving Upwards Flag
       movb @bytes+240,@11(ix)         ; LD (IX+11),240    ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags, and set his
                                                           ; Impassable Leftwards, Impassable Rightwards, Interaction (11,6) and Interaction (11,7) flags
       socb @bits+7,@8(ix)             ; SET 7,(IX+8)      ; Set bit 7 of Berk's class value (i.e. set "Spans Full Depth" Flag)
       ab   one,@6(ix)                 ; INC (IX+6)        ; Increase y-coordinate of Berk's bottom edge by two characters...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       li   hl,_35515                  ; LD HL,35515       ; Point HL at script data for Berk gaining floating power...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (57) Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
script_routine_57:
       bl   @cycle_colors_and_refresh  ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (36) Remove Boni from Level 1
script_routine_36:
       sb   a,a                        ; XOR A             ; Set Boni's room (Level 1) to zero...
       movb a,@bonis_state_data_1      ; LD (43606),A      ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (37) Remove Flying Skeleton Creature from Level 1, and Terminate Script Processing Input:  IX
* Address of complex state data for an entity
script_routine_37:
       sb   a,a                        ; XOR A             ; Set current room of Flying Skeleton Creature (Level 1) to zero...
       movb a,@_43619                  ; LD (43619),A      ; ...
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Flying Skeleton Creature's Inactive Flag
       .ret                            ; RET               ; Return (i.e. terminate further script processing)

*********************************************************************************
* Script Routine (38) Close the Trap Door
script_routine_38:
       bl   @close_trap_door                   ; CALL 36996        ; Close the Trap Door
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (39) Open the Trap Door
script_routine_39:
       bl   @open_trap_door                   ; CALL 37004        ; Open the Trap Door
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (41) Move Spider Up One Character and, if Home, Reset its Timer and Make it Wait Input:  IX Address
* of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_41:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of bottom of entity IX (spider) is not 106...
       cb   a,@bytes+106               ; CP 106            ; ...
       jeq  !                          ; JP NZ,48541       ; ...then move entity up one character and return
       b    @script_routine_34         ;
!
       movb @bytes+20,@c               ; LD C,20           ; Load C with 20
       movb @8(ix),a                   ; LD A,(IX+8)       ; If entity class is not 27 (right-most spider, Level 1)...
       cb   a,@bytes+27                ; CP 27             ; ...
       jne  _37744                     ; JR NZ,37744       ; ...then skip ahead to #R37744
* The following code affects the behaviour of the right-most spider depending upon how many times Berk has been
* killed by a spider. See (trivia) and (pokes).
       movb @berk_killed_by_spider,a   ; LD A,(34223)      ; Load number of times Berk has been killed by a spider into A...
       srl  a,2                        ; SRL A             ; ...and divide by four, discarding remainder...
                                       ; SRL A             ; ...
       ab   @c,a                       ; ADD A,C           ; Add this value to C, in C...
       movb a,@c                       ; LD C,A            ; ...
_37744:
       movb @c,@12(ix)                 ; LD (IX+12),C      ; Load spider's timer with this value
       li   hl,_37792                  ; LD HL,37792       ; Point HL at script data for spider waiting...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (42) Decrease Remaining Time Until Spider Next Descends and if Zero, Start Descent Input:  IX
* Address of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_42:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If spider's Must Process Current Script Data Flag is reset...
       andi tmp0,1*256                 ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If Spider's timer is zero...
                                       ; OR A              ; ...
       jeq  _37772                     ; JR Z,37772        ; ...then skip ahead to #R37772
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining time on spider's timer
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_37772:
       li   hl,_37800                  ; LD HL,37800       ; Point HL at script data for spider moving down...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (40) Move Spider Down One Character, and if at Bottom, Advance it to Bounce / Climb Up Mode Input:
* IX  Address of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_40:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If entity's bottom y-coordinate is less than 119...
       cb   a,@bytes+119               ; CP 119            ; ...
       jhe  !                          ; JP C,48567        ; ...then move entity down one character and process next script data
       b    @script_routine_35         ;
!
       li   hl,_37816                  ; LD HL,37816       ; Point HL at script data for bounce / climb up mode...
       b    @execute_script            ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (61) Fire Bubo's Projectile
*
* Note that Bubo normally can't fire when being carried (see instructions at #R38119), however if he starts to fire
* immediately before being picked up, then his Being Carried Flag will be set by the time execution reaches this
* routine. Input:  IX  Address of complex state data for Bubo (Level 2) IY  Address of complex state data for Bubo's
* projectile
script_routine_61:
       socb @bits+1,@9(iy)             ; SET 1,(IY+9)      ; Set projectile's Fired Flag
       movb @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Bubo is being carried...
       andi tmp0,32*256                ;
       jne  _38181                     ; JR NZ,38181       ; ...then skip ahead to #R38181
       movb @bytes+251,@12(iy)         ; LD (IY+12),251    ; Set projectile's Velocity Factor to -5
       jmp  _38185                     ; JR 38185          ; Skip ahead to #R38185
_38181:
       movb @bytes+246,@12(iy)         ; LD (IY+12),246    ; Set projectile's Velocity Factor to -10
_38185:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set projectile's x-coordinate to one more than Bubo's...
       ab   one,a                      ; INC A             ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set projectile's y-coordinate to be three less than Bubo's...
       sb   @bytes+3,a                 ; SUB 3             ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Set projectile's room to be same as Bubo's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set projectile's depth to zero
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
* Script Routine (60) Check Position of Apebeast and Turn If Appropriate Input:  IX  Address of complex state data
* for an entity Output: HL  Address of next script instruction to execute
script_routine_60:
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Apebeast's Walking Right Flag is set...
       andi tmp0,1*256                 ;
       jne  _38575                     ; JR NZ,38575       ; ...then skip ahead to #R38575
* Apebeast walking left
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is less than x-coordinate of left edge of Apebeast...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       li   hl,_38432                  ; LD HL,38432       ; Point HL at script data for Apebeast walking right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Apebeast walking right
_38575:
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       ab   @bytes+13,a                ; ADD A,13          ; ...plus 13...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...is equal to or greater than x-coordinate of right edge of Apebeast...
       jl   !                          ; JP NC,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       li   hl,_38450                  ; LD HL,38450       ; Point HL at script data for Apebeast walking left...
       b    @execute_script                    ; JP 48098          ; ...and execute

*********************************************************************************
* The skeleton will step forward once, and then step back, if Berk is close enough and Fake Boni is in a room to the
* right. If Fake Boni is in the Skeleton's room, or a room to the left of this, then the Skeleton will step forward
* repeatedly while Berk is close enough and will only back off when Berk moves out of range. The range is nine, so
* if the distance between Berk's right edge and the Skeleton's left edge is less than nine then the Skeleton will
* advance. A distance of nine or more will see the Skeleton retreat. Note that the calculated range is based upon
* the Skeleton's state data at #R45404, in which the x-coordinates of his left and right edges do not match his
* apparent position or width graphically. Input:  IX  Address of complex state data for an entity Output: HL Address
* of next script instruction to execute
script_routine_63:
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is 3 (Skeleton's room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  _41580                     ; JR Z,41580        ; ...then jump to #R41580
* Berk is not in Skeleton's room, or Fake Boni is in a room right of the Skeleton's room
_41561:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge is at least 128...
       cb   a,@bytes+128               ; CP 128            ; ...
       jhe  _41574                     ; JR NC,41574       ; ...then skip ahead to #R41574
       li   hl,_41318                  ; LD HL,41318       ; Point HL at script data for Skeleton stepping back (right)...
       b    @execute_script            ; JP 48098          ; ...and execute
_41574:
       li   hl,skeleton_idling_script  ; LD HL,41232       ; Point HL at script data for Skeleton Idling...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk is in Skeleton's room
_41580:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Skeleton's Must Process Current Script Data Flag is reset...
       andi tmp0,1*256                 ;
       jeq  _41597                     ; JR Z,41597        ; ...then skip ahead to #R41597
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Skeleton's Must Process Current Script Data Flag
       movb @_45430,a                  ; LD A,(45430)      ; If Fake Boni is in a room with index of 4 or more (room above Pit, or Pit)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
_41597:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge...
       sb   @bytes+9,a                 ; SUB 9             ; ...is at least nine characters to the right of Berk's right edge...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Skeleton's Must Process Current Script Data Flag
       li   hl,_41280                  ; LD HL,41280       ; Point HL at script data for Skeleton stepping forward (left)...
       b    @execute_script                    ; JP 48098          ; ...and execute

*********************************************************************************
* Script Routine (64) Set Random (1 to 10) Number of Iterations in Following Loop Script Instruction
script_routine_64:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 1-10...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       .push hl                        ; PUSH HL           ; Store HL (current position in script data)
       li   bc,4                       ; LD BC,4           ; Advance HL by four bytes...
       a    bc,hl                      ; ADD HL,BC         ; ...to number of iterations in next (loop) instruction...
       movb a,*hl                      ; LD (HL),A         ; ...and set number of iterations to number generated
       .pop hl                         ; POP HL            ; Restore HL (current position in script data)
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

*********************************************************************************
*
* Support routines
*

*********************************************************************************
* Load A with Script Instruction Parameter then Advance HL to Next Instruction
*
* Used by the routines at #R48295, #R48324 and #R48353.
load_instr_and_advance:
       inct hl                         ; INC HL            ; Advance HL by two bytes, beyond end of current instruction...
                                       ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load value here into A
       inct hl                         ; INC HL            ; Advance HL by two more bytes to start of next instruction...
                                       ; INC HL            ; ...
       rt                              ; RET               ; Return
*// load_instr_and_advance

*********************************************************************************
* Move Carried Entity in Front of Berk as he Faces Out of Screen
*
* Used by the routines at #R36008, #R48487, #R48593, #R48641 and #R48692.
move_carried_to_front:
       .proc
       bl   @load_carried_item_data                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       jmp  move_carried_front_back_end                     ; JR 48719          ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850) and return

*********************************************************************************
* Move Carried Entity Behind Berk as he Faces into Screen
*
* Used by the routine at #R48686.
move_carried_to_back:
       .proc
       bl   @load_carried_item_data                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routine at #R48710.
move_carried_front_back_end:
       xor  one,a                      ; XOR 1             ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850)...
       ab   one,a                      ; INC A             ; ...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...
       jmp  move_carried_end                     ; JR 48749          ; Set carried entity's horizontal position and depth and return

*********************************************************************************
* Move Carried Entity to Berk's Right as he Faces Right
*
* Used by the routines at #R48704 and #R54383.
move_carried_to_right:
       .proc
       bl   @load_carried_item_data                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
       neg a                           ; NEG               ; Subtract width of carried entity minus one divided by two...
       ab   @7(ix),a                   ; ADD A,(IX+7)      ; ...from Berk's right-side x-coordinate and load into A
       jmp  move_carried_end                     ; JR 48749          ; Set carried entity's calculated horizontal position and depth and return

*********************************************************************************
* Move Carried Entity to Berk's Left as he Faces Left
*
* Used by the routines at #R48698 and #R54419. Input:  IY  Address of complex state data for an entity carried by
* Berk
move_carried_to_left:
       .proc
       bl   @load_carried_item_data                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   a,a                        ; ADD A,A           ; Double A to give width minus one... (see bugs)
       ab   one,a                      ; INC A             ; ...and add one to get width of entity
       neg a                           ; NEG               ; Subtract width of carried entity...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...from Berk's left-side x-coordinate and load into A
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routines at #R48715 and #R48727.
move_carried_end:
       movb a,@5(iy)                   ; LD (IY+5),A       ; Set carried entity's horizontal position and depth...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb d,@1(iy)                   ; LD (IY+1),D       ; ...
       .endproc                        ; RET               ; Return

*********************************************************************************
* Load A, D and E with Positional Data for a Carried Entity or Return
*
* Used by the routines at #R48710, #R48715, #R48727 and #R48738. Input:  IX  Address of complex state data for an
* entity Output: A  Width of carried entity (characters) minus 1, divided by two D  Depth of entity at IX (Berk) E
* Width of carried entity (characters) minus 1 IY  Address of complex state data for entity held by Berk
load_carried_item_data:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity IX is Berk and his Carrying Something Flag is set...
       andi tmp0,16*256                ;
       jne  load_carried_item_data_1   ; JR NZ,48768       ; ...then skip ahead to #R48768
                                       ; POP BC            ; Pop top value (return address) off stack...
       .endproc                        ; RET               ; ...and return to routine that called the calling routine
load_carried_item_data_1:
       .proc
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       movb *ix,a                      ; LD A,(IX+0)       ; Set this entity's room to be same as Berk's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       bl   @position_carried_item_1   ; CALL 48897        ; Move carried entity into vertical position appropriate to its height
       movb @carried_entity_width,a    ; LD A,(34272)      ; Load A and E with width of entity (characters) carried by Berk, minus 1...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; Divide A by two, removing remainder
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load carried entity's depth into D
       .endproc                        ; RET               ; Return

*********************************************************************************
* Have Berk Hold an Entity, and Position it Appropriately Between his Hands
*
* The instruction blocks #R48872-#R48894 and #R48897-#R48916 move the entity that Berk is carrying into position
* (i.e. between Berk's hands), at a horizontal or vertical position appropriate to the height / width of that
* entity. These instructions result in the following x- or y-coordinates (left or top of carried entity relative to
* left or top of carrier, i.e. Berk): Input:  IX  Address of complex state data (current level) for Berk IY  (entry
* at #R48897) Address of complex state data for an entity carried by Berk Output: IY  Address of complex state data
* for entity held by Berk
position_carried_item:
       mov  @bert_interaction_state,iy ; LD IY,(34256)     ; Load IY with address of complex state data for entity to be held by Berk...
       mov  iy,@bert_held_state        ; LD (34260),IY     ; ...and store at #R34260 as address of state data for entity held by Berk
       socb @bits+5,@10(iy)            ; SET 5,(IY+10)     ; Set the entity's Is Being Carried Flag
       socb @bits+4,@9(ix)             ; SET 4,(IX+9)      ; Set Berk's Carrying Something Flag
       movb @8(iy),a                   ; LD A,(IY+8)       ; Set class of entity held by Berk to be this entity's class...
       movb a,@berk_entity_held        ; LD (34221),A      ; ...
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with the width of the entity, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       movb a,@carried_entity_width                  ; LD (34272),A      ; ...and store at #R34272
       movb a,@e                       ; LD E,A            ; Load E with width of entity, minus 1
       srl  a,1                                            ; SRL A             ; Move entity defined at IY into horizontal position appropriate to its height (see notes
                                                           ; above)...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
* This entry point is used by the routine at #R48760.
position_carried_item_1:
       movb @6(iy),a                   ; LD A,(IY+6)       ; Move entity defined at IY into vertical position appropriate to its height (see notes
                                                           ; above)...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; ...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       ab   @4(ix),a                   ; ADD A,(IX+4)      ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       rt                              ; RET               ; Return

*********************************************************************************
* Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if Appropriate
*
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
push_left:
       .proc
       bl    @chk_coll_left            ; CALL 54666        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; left...
       joc  push_left_2                ; JR C,52087        ; ...and if a collision has not occurred, then skip ahead to #R52087
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  push_left_1                ; JR NC,52076       ; ...then skip ahead to #R52076
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2*256                 ;
       jeq  push_left_2                ; JR Z,52087        ; ...then skip ahead to #R52087 (move Drutt left without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       bl   @move_pushed_item_left     ; CALL 52098        ; Advance position of entity pushed left by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       jmp  push_left_3                ; RET               ; Return
* Collision with entity of class 22 or greater
push_left_1:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  push_left_2                ; JR Z,52087        ; ...then skip ahead to #R52087
* At this point, the entity to Drutt's left is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
push_left_2:
       bl   @move_into_left_room       ; CALL 54348        ; Move Drutt into room to the left, if appropriate...
       jne  push_left_3                ; RET NC            ; ...and if Drutt can't enter new room then return
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Drutt left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
push_left_3:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Advance Position of Entity Pushed Left by Drutt
*
* Used by the routine at #R52053. Input:  IY  Address of complex state data for entity pushed by Drutt
move_pushed_item_left:
       .proc
       mov  iy,ix                      ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
                                       ; POP IX            ; ...to IX
       bl    @chk_coll_left            ; CALL 54666        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the left...
       joc  move_pushed_item_left_1    ; JR C,52112        ; ...and if a collision has not occurred, then skip ahead to #R52112
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  move_pushed_item_left_3    ; JR Z,52134        ; ...then skip ahead to #R52134
       jmp  move_pushed_item_left_4    ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
move_pushed_item_left_1:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of left edge of pushed entity is at least 103...
       cb   a,@bytes+103               ; CP 103            ; ...i.e. not yet at left edge of room...
       jhe  move_pushed_item_left_2    ; JR NC,52127       ; ...then skip ahead to #R52127
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of current character's current room...
       jeq  move_pushed_item_left_4    ; RET Z             ; ...and if there is no room to the left then return
       bl   @move_into_left_room       ; CALL 54348        ; Move pushed entity into room to the left, if appropriate...
       jnc  move_pushed_item_left_4    ; RET NC            ; ...and if pushed entity can't enter new room then return
move_pushed_item_left_2:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move pushed entity left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       jmp  move_pushed_item_left_4    ; RET               ; Return
move_pushed_item_left_3:
       bl   @prepare_falling           ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       sb   @bytes+2,@5(ix)            ; DEC (IX+5)        ; Move pushed entity left one character...
       sb   @bytes+2,@7(ix)            ; DEC (IX+7)        ; ...
                                       ; CALL 52127        ; Move pushed entity left two characters...
                                       ; JR 52127          ; ...and return
move_pushed_item_left_4:
       .endproc

*********************************************************************************
* Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if Appropriate
*
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
push_right:
       .proc
       bl   @chk_coll_right            ; CALL 54569        ; Check Drutt for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       joc  push_right_2               ; JR C,52182        ; ...and if a collision has not occurred, then skip ahead to #R52182
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class 22 or greater (can't be picked up)...
       jhe  push_right_1               ; JR NC,52171       ; ...then skip ahead to #R52171
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2*256                 ;
       jeq  push_right_2               ; JR Z,52182        ; ...then skip ahead to #R52182 (move Drutt right without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       bl   @move_pushed_item_right    ; CALL 52193        ; Advance position of entity pushed right by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       jmp  push_right_3               ; RET               ; Return
* Collision with entity of class 22 or greater
push_right_1:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  push_right_2               ; JR Z,52182        ; ...then skip ahead to #R52182
* At this point, the entity to Drutt's right is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
push_right_2:
       bl   @move_into_right_room      ; CALL 54313        ; Move Drutt into room to the right, if appropriate...
       jnc  push_right_3               ; RET NC            ; ...and if Drutt can't enter new room then return
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Drutt right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
push_right_3:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Advance Position of Entity Pushed Right by Drutt
*
* Used by the routine at #R52148. Input:  IY  Address of complex state data for entity pushed by Drutt
move_pushed_item_right:
       .proc
       mov iy,ix                       ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
                                       ; POP IX            ; ...to IX
       bl   @chk_coll_right            ; CALL 54569        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the right...
       joc  move_pushed_item_right_1   ; JR C,52207        ; ...and if a collision has not occurred, then skip ahead to #R52207
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  move_pushed_item_right_3   ; JR Z,52235        ; ...then skip ahead to #R52235
       jmp  move_pushed_item_right_4   ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
move_pushed_item_right_1:
       movb @tmp_width_current_room,a  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       sb   @bytes+2,a                 ; SUB 2             ; ...minus 2...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; ...and if x-coordinate of right edge of pushed entity is less than this...
       cb   a,@e                       ; CP E              ; ...i.e. not yet at right edge of room...
       jl   move_pushed_item_right_2   ; JR C,52227        ; ...then skip ahead to #R52227
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jeq  move_pushed_item_right_4   ; RET Z             ; ...and if there is no room to the right then return
       bl   @move_into_right_room      ; CALL 54313        ; Move pushed entity into room to the right, if appropriate...
       jne  move_pushed_item_right_4   ; RET NC            ; ...and if pushed entity can't enter new room then return
move_pushed_item_right_2:
       equ  $
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move pushed entity right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       sb   a,a                        ; XOR A             ; Load A with zero (see trivia)
       jmp  move_pushed_item_right_4   ; RET               ; Return
move_pushed_item_right_3:
       bl    @prepare_falling          ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       ab   @bytes+2,@5(ix)            ; INC (IX+5)        ; Move pushed entity right one character...
       ab   @bytes+2,@7(ix)            ; INC (IX+7)        ; ...
                                       ; CALL 52227        ; Move pushed entity right two characters...
                                       ; JR 52227          ; ...and return
move_pushed_item_right_4:
       .endproc

*********************************************************************************
* Swap Drutt's Current Depth Level if Possible
*
* Used by the routine at #R52309. Input:  IX  Address of complex state data (current level) for Drutt
swap_drutts_depth:
       .proc
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's depth is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  swap_drutts_depth_2                     ; JR NZ,52351       ; ...then skip ahead to #R52351
* Drutt's depth is 1
       movb @tmp_room_dim_data,a       ; LD A,(34230)      ; If Drutt's current depth is the same as number of available depth levels in current room...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...i.e. room has depth of 1...
       jeq  swap_drutts_depth_3        ; RET Z             ; ...then return (as there is no other depth level for Drutt to move to)
* The following collision check is usually only satisfied by Berk. This prevents Drutt from jumping back a depth
* level while in front of (at same depth level as) Berk.
       bl    @chk_coll_same_depth_rev  ; CALL 54878        ; Check Drutt for collision with another entity (only those defined before, and in reverse
                                                           ; order) at same depth level whose Interaction (11,7) Flag is set...
       jnc  swap_drutts_depth_3        ; RET NC            ; ...and if a collision occurred, then return
* The following collision check prevents Drutt from jumping back when there is an obstruction (e.g. the brick
* columns in the pit room, level 1) behind him.
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check Drutt for collision with another entity (in reverse order) at next depth level into
                                                           ; screen whose Interaction (11,7) Flag is set...
       joc  swap_drutts_depth_1        ; JR C,52341        ; ...and if no collision occurred, then skip ahead to #R52341
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  swap_drutts_depth_3        ; RET NC            ; ...then return
swap_drutts_depth_1:
       equ  $
       ab   one,@1(ix)                 ; INC (IX+1)        ; Increase Drutt's depth (i.e. move backward away from screen)
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease Drutt's top and bottom y-coordinates...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       jmp  swap_drutts_depth_3        ; RET               ; Return
* Drutt's depth is not 1
swap_drutts_depth_2:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's current depth is 1... (see trivia)
       cb   a,one                      ; CP 1              ; ...
       jeq  swap_drutts_depth_3        ; RET Z             ; ...then return
* The following collision check prevents Drutt from jumping forward a depth level while in behind an obstruction
* (e.g. Berk).
       bl   @chk_coll_next_depth       ; CALL 54764        ; Check Drutt for collision with another entity at next depth level out of screen whose
                                                           ; Interaction (11,6) Flag is set...
       jnc  swap_drutts_depth_3        ; RET NC            ; ...and if a collision occurred, then return
       sb   one,@1(ix)                 ; DEC (IX+1)        ; Decrease Drutt's depth (i.e. move forward towards screen)
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase Drutt's top and bottom y-coordinates...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
swap_drutts_depth_3:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Increase Worm's Age and Set its Depth to Zero if it has Expired
*
* Used by the routines at #R52914 and #R52967. Input:  IX  Address of complex state data (current level) for Worm
increase_worms_age:
       .proc
       movb @worms_age,a               ; LD A,(52728)      ; Increase current Worm Age value...
       ab   one,a                      ; INC A             ; ...
       movb a,@worms_age                  ; LD (52728),A      ; ...
       movb a,tmp0                     ; BIT 7,A           ; If Worm Age is less than 128...
       andi tmp0,128*256               ;
       jeq  increase_worms_age_1       ; RET Z             ; ...then return
       movb @current_characters_room,a                  ; LD A,(34218)      ; If current character's room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is the same as the worm's...
       jeq  increase_worms_age_1       ; RET Z             ; ...then return
       sb   a,a                        ; XOR A             ; Set the worm's depth to zero...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...
       movb a,@worms_age               ; LD (52728),A      ; Reset Worm Age to zero
       .pop bc                         ; POP BC            ; Remove top value from stack (return address in calling routine)
increase_worms_age_1:
       .endproc                        ; RET               ; Return (to routine that called the calling routine)

*********************************************************************************
* Load A with Value Indicating Which Direction Room A Lies Relative to Room in State Data at IX
*
* Direction index value in A denotes which direction (left or right), e.g. Drutt, has to travel to reach the target
* room: Input:  A  Target room index (e.g. Berk's room or worm's room) IX  Address of complex state data (current
* level) for Drutt Output: A  Direction index
find_direction_to_room:
       .proc
       .push hl                        ; PUSH HL           ; Store HL
       .push ix                        ; PUSH IX           ; Store IX
       movb a,@e                       ; LD E,A            ; Load E with target room index
       movb *ix,a                      ; LD A,(IX+0)       ; Load D with Drutt's current room...
       movb a,d                        ; LD D,A            ; ...
       li   hl,pathfinding_data_table  ; LD HL,53159       ; Set first two bytes of header to 255 (Start Marker)...
       movb @bytes+255,*hl+            ; LD (HL),255       ; ...
                                       ; INC HL            ; ...
       movb @bytes+255,*hl+            ; LD (HL),255       ; ...
                                       ; INC HL            ; Set third byte of header to index of Drutt's current room...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; Advance HL to first byte of first entry
       bl   @get_left_room_index_1     ; CALL 54542        ; Load B with index of room to left of Drutt's current room...
       jeq  find_direction_to_room_1   ; JR Z,53228        ; ...and if there is no such room then skip ahead to #R53228
       movb @e,a                       ; LD A,E            ; If room to left of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb @bytes+2,a                 ; LD A,2            ; Load A with 2 ("go left")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to left is target room) then restore registers and return
       b    @find_direction_to_room_7                    ;
!
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to left of Drutt is to the left
find_direction_to_room_1:
       bl   @get_right_room_index_1    ; CALL 54508        ; Load B with index of room to right of Drutt's room...
       jeq  find_direction_to_room_2                     ; JR Z,53243        ; ...and if there is no such room then skip ahead to #R53243
       movb @e,a                       ; LD A,E            ; If room to right of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb one,a                      ; LD A,1            ; Load A with 1 ("go right")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to right is target room) then restore registers and return
       b    @find_direction_to_room_7                    ;
!
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to right of Drutt is to the right
* Now the Pathfinding Data Table has a header and zero, one or two records, depending upon the horizontal
* connectivity of Drutt's current room.
find_direction_to_room_2:
       li   ix,pathfinding_1st_entry   ; LD IX,53162       ; Load IX with address of first entry in Pathfinding Data Table
find_direction_to_room_3:
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load D with index of room from current entry in Pathfinding Data Table
       bl   @get_left_room_index_1     ; CALL 54542        ; Load B with index of room to left of room D...
       jeq  find_direction_to_room_4                     ; JR Z,53271        ; ...and if there is no such room then skip ahead to #R53271
       movb @e,a                       ; LD A,E            ; If room to left of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @find_direction_to_room_6                    ;
!
       bl   @find_pathfinding_entry    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  find_direction_to_room_4   ; JR Z,53271        ; ...then skip ahead to #R53271
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
find_direction_to_room_4:
       bl   @get_right_room_index_1    ; CALL 54508        ; Load B with index of room to right of room D...
       jeq  find_direction_to_room_5                     ; JR Z,53292        ; ...and if there is no such room then skip ahead to #R53292
       movb @e,a                       ; LD A,E            ; If room to right of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @find_direction_to_room_6                    ;
!
       bl   @find_pathfinding_entry    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  find_direction_to_room_5   ; JR Z,53292        ; ...then skip ahead to #R53292
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
find_direction_to_room_5:
       inct ix                         ; INC IX            ; Advance IX by two bytes to next entry in Pathfinding Data Table...
                                       ; INC IX            ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; If byte at this location is not 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jne  find_direction_to_room_3   ; JP NZ,53247       ; ...then loop back to #R53247
* At this point, the search has checked all rooms and not found the target room.
       sb   a,a                        ; XOR A             ; Set A to zero
                                       ; POP IX            ; Restore IX
                                       ; POP HL            ; Restore HL
       jmp  find_direction_to_room_7   ; RET               ; Return
* Load A with Direction Index in Pathfinding Data Table entry at Address in IX, Restore Registers and Return
*
* Used by the routine at #R53194. Input:  IX  Address of an entry in Pathfinding Data Table
find_direction_to_room_6:
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with direction index for entry at IX
* This entry point is used by the routine at #R53194.
find_direction_to_room_7:
       .pop ix                         ; POP IX            ; Restore IX
       .pop hl                         ; POP HL            ; Restore HL
       .endproc                        ; RET               ; Return

*********************************************************************************
* Add Entry to Pathfinding Data Table for Room B in Direction A
*
* B contains the room the pathfinding routine is currently looking at, and A contains a value that denotes which
* direction this room lies in relative to Drutt's current room. Input:  A  Direction index (1 or 2) B  Index of room
* being examined HL  Current address of end of Pathfinding Data Table
add_pathfinding_entry:
       movb a,*hl+                     ; LD (HL),A         ; Store direction index
                                       ; INC HL            ; Advance by one byte
       movb b,a                        ; LD A,B            ; Store index of room being examined...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; Advance by one byte
       movb @bytes+255,*hl             ; LD (HL),255       ; Store 255 (End Marker)
       rt                              ; RET               ; Return

*********************************************************************************
* Set Zero Flag if Room B Has an Entry in Pathfinding Data Table, Otherwise Reset
*
* Used by the routine at #R53194. Input:  HL  Address of end of Pathfinding Data Table B  Index of room to check
* table for Output: F  (Zero Flag) Set if room B is already stored in Pathfinding Data Table, reset otherwise
find_pathfinding_entry:
       .push hl                        ; PUSH HL           ; Store HL (address of end of Pathfinding Data Table)
find_pathfinding_entry_1:
       dec  hl                         ; DEC HL            ; Move HL back to previous entry's room index...
       movb *hl,a                      ; LD A,(HL)         ; ...load into A...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (Start Marker, so room B not found)...
       jeq  find_pathfinding_entry_2   ; JR Z,53330        ; ...then skip ahead to #R53330
       dec  hl                         ; DEC HL            ; Move HL back to entry's direction index
       cb   a,b                        ; CP B              ; If room to search for not the same as current entry's room...
       jne  find_pathfinding_entry_1   ; JR NZ,53318       ; ...then loop back to #R53318 to test next entry
* At this point, the room we're looking for (in B) is already stored in the Pathfinding Data Table and the Zero Flag
* is set.
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       cb   a,a                                            ; Set zero flag
       jmp  find_pathfinding_entry_3   ; RET               ; Return
find_pathfinding_entry_2:
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       sb   one,a                      ; DEC A             ; Reset Zero Flag
find_pathfinding_entry_3:
       rt                              ; RET               ; Return

*********************************************************************************
* Close the Trap Door
*
* Used by the routines at #R36966 and #R36984.
close_trap_door:
       .proc
close_trap_door_1:
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" to 1 (i.e. Trap Door Room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       sb   one,a                      ; DEC A             ; Decrease A to zero
       jmp  open_close_trap_door_end   ; JR 37009          ; Set room of "Open Trap Door" to 0

*********************************************************************************
* Open the Trap Door
*
* Used by the routine at #R36990.
open_trap_door:
       .proc
       sb   a,a                        ; XOR A             ; Set room of "Closed Trap Door" to 0 (i.e. remove from Trap Door Room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       ab   one,a                      ; INC A             ; Increase A to 1 (index of Trap Door Room)
* This entry point is used by the routine at #R36996.
open_close_trap_door_end:
       movb a,@_43437                  ; LD (43437),A      ; Set value in A as the current room of "Open Trap Door"...
       movb a,@_43450                  ; LD (43450),A      ; ...and marker (preventing Berk and Drutt passing door lid)
       .endproc                        ; RET               ; Return
