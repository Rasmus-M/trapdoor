*********************************************************************************
* Make Berk Drop the Entity He is Holding and Load IY with its Complex State Data Address
*
* Used by the routines at #R35735, #R36116, #R36390, #R36638, #R39151, #R39278, #R39776, #R48920 and #R53723. Input:
* IX  Address of complex state data (current level) for Berk Output: IY  Address of complex state data for entity
* dropped by Berk
drop_item:
       .proc
drop_item_0:
       movb @berk_entity_held,a        ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jeq  drop_item_5                ; RET Z             ; ...then return
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       movb a,@berk_entity_held        ; LD (34221),A      ; ...
       mov  @berk_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set this dropped entity's velocity factor to 2...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...reset its Is Being Carried Flag...
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; ...and set its Can Fall Flag
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is reset...
       andi tmp0,1*256                 ;
       jeq  drop_item_2                ; JR Z,36339        ; ...then skip ahead to #R36339
drop_item_1:
       ab   one,@7(iy)                 ; INC (IY+7)        ; Move dropped entity right one character...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...
       jmp  drop_item_4                ; JR 36351          ; Skip ahead to #R36351
drop_item_2:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is reset...
       andi tmp0,2*256                 ;
       jeq  drop_item_4                ; JR Z,36351        ; ...then skip ahead to #R36351
drop_item_3:
       sb   one,@7(iy)                 ; DEC (IY+7)        ; Move dropped entity left one character...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...
drop_item_4:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If entity at IY has the x-coordinate of its left side less than 100...
       cb   a,@bytes+100               ; CP 100            ; ...
       jl   drop_item_1                ; JR C,36331        ; ...then move right until left x-coordinate is 100
       movb @tmp_width_current_room,a  ; LD A,(34235)      ; Load A with width of current room (chars) + 99
       cb   a,@7(iy)                   ; CP (IY+7)         ; If entity at IY has the x-coordinate of its right side greater than the width of the current
                                                           ; room...
       jl   drop_item_3                ; JR C,36345        ; ...then move right until left x-coordinate is less than room width
drop_item_5:
       .ret                            ; RET               ; Return
*// drop_item

*********************************************************************************
* Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
*
* Used by the routines at #R36610, #R39584 and #R39760.
cycle_colors_and_refresh:
       .proc
       .push hl                        ; PUSH HL           ; Store HL
       bl   @cycle_attributes_short    ; CALL 53581        ; Cycle Attributes (Full-Screen) and Clear Display Buffers
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
       .endproc                        ; RET               ; Return

*********************************************************************************
* Change Entity's Room Up One if Appropriate
*
* Used by the routines at #R36542, #R48487 and #R55196. Input:  IX  Address of complex state data for an entity
change_room_up:
       .proc
       movb @bytes+99,a                ; LD A,99           ; If y-coordinate of top of entity is larger than 99 (i.e. top of entity is below top of
                                                           ; room)...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jl   change_room_up_4           ; RET C             ; ...then return
       .push hl                        ; PUSH HL           ; Store HL
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @vert_room_connect_map,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (lower room index) of first entry
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
change_room_up_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (lower room index) of current entry into A
       cb   a,@b255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  change_room_up_3                     ; JR Z,55512        ; ...then skip ahead to #R55512
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  change_room_up_2                     ; JR Z,55467        ; ...then skip ahead to #R55467
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  change_room_up_1                     ; JR 55451          ; Loop back to #R55451
change_room_up_2:
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (upper room index) of current entry into B
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       ab   @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Add 22 to y-coordinate of top of entity...
       ab   @bytes+22,a                ; ADD A,22          ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Add 22 to y-coordinate of bottom of entity...
       ab   @bytes+22,a                ; ADD A,22          ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
change_room_up_3:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .pop hl                         ; POP HL            ; Restore HL
change_room_up_4:
       .endproc                        ; RET               ; Return
*// change_room_up

*********************************************************************************
* Set Can Fall Flag and Set Initial Velocity Factor of 2 for Entity Defined at Address in IX
*
* Used by the routines at #R36638, #R39760, #R48417, #R51779, #R52098, #R52193 and #R52243. Input:  IX  Address of
* complex state data for an entity
prepare_falling:
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set entity's "Can Fall" flag
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set entity's initial velocity factor to 2
       rt                            ; RET               ; Return

*********************************************************************************
* Change Entity's Room Down One if Appropriate
*
* Used by the routines at #R55196 and #R55525. Input:  IX  Address of complex state data for an entity
change_room_down:
       .proc
       movb @bytes+122,a               ; LD A,122          ; If y-coordinate of bottom of entity is smaller than 122 (i.e. bottom of entity is above
                                                           ; bottom of room)...
       cb   a,@6(ix)                   ; CP (IX+6)         ; ...
       jhe  change_room_down_4         ; RET NC            ; ...then return
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @vert_room_connect_map,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
change_room_down_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (upper room index) of current entry into A
       cb   a,@b255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  change_room_down_3                     ; JR Z,55695        ; ...then skip ahead to #R55695
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  change_room_down_2                     ; JR Z,55647        ; ...then skip ahead to #R55647
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  change_room_down_1                     ; JR 55631          ; Loop back to #R55631
change_room_down_2:
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (lower room index) of current entry into B
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       ab   @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Subtract 20 from y-coordinate of top of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Subtract 20 from y-coordinate of bottom of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .ret                            ; RET               ; Return
change_room_down_3:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
change_room_down_4:
       .endproc                        ; RET               ; Return
*// change_room_down

*********************************************************************************
* Copy Start Addresses of Current Level's Data Blocks to 34236 and Clean Up Old Data
*
* Used by the routines at #R34438 and #R36753.
init_level_data:
       .proc
       bl   @copy_level_data                               ; Copy level data from ROM
       .push de                        ; PUSH DE           ; Store DE
       .push hl                        ; PUSH HL           ; Store HL
;       mov  @worm_state_addr,hl        ; LD HL,(34244)     ; Load HL with address of complex state data (current level) for worm
;       movb @zero,*hl               ; LD (HL),0         ; Set worm's current room to zero
       li   hl,level_data
                                       ; LD A,(34207)      ; Load current level into A

                                       ; LD HL,34281       ; Point HL at position 20 bytes before start of list of start addresses of level 1's data
                                                           ; blocks
       li   bc,20                      ; LD BC,20          ; Set data length to 20, as there are 10 data blocks per level (so 10 addresses)

                                       ; ADD HL,BC         ; Advance HL to start of data block address list for next level
                                       ; DEC A             ; Decrease level counter
                                       ; JR NZ,34880       ; Loop back if we have not reached data for required level
* At this point, HL points to the start of the list of start addresses of the current level's data blocks
       li   de,current_level_data      ; LD DE,34236       ; Copy this level's data block start addresses to #R34236...
       .ldir                           ; LDIR              ; ...
       li   bc,6                       ; LD B,9            ; Clear Store for Script Instruction Loop Data...
       li   hl,script_23_24_loop_count ; LD HL,34285       ; ...
init_level_data_2:
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       dec  bc                         ; DJNZ 34894        ; ...
       jne  init_level_data_2                     ;
       .pop hl                         ; POP HL            ; Restore HL
       .pop de                         ; POP DE            ; Restore DE
       .endproc                        ; RET               ; Return

*********************************************************************************
* Advance to Next Level and if Back to Level 1 then Exit Calling Routine and Make Berk Start Falling
*
* Used by the routine at #R36390.
next_level:
       .proc
                                       ; LD A,(34208)      ; Set Update Scores and Display Flag...
       socb @bits+5,@game_flags        ; SET 5,A           ; ...
                                       ; LD (34208),A      ; ...
       mov  @berk_interaction_state,iy ; LD IY,(34256)     ; Load IY with address of complex state data for Door just interacted with
       movb @9(iy),@current_level      ; LD A,(IY+9)       ; Load A with destination level from Door's state data...
                                       ; LD (34207),A      ; ...and set current level to this value
       bl   @init_level_data
       bl   @align_with_level_1_door
       cb   @current_level,one         ; CP 1              ; If destination level is not Level 1...
       jne  next_level_1               ; JR NZ,36725       ; ...then skip ahead to #R36725
* Destination level is Level 1 (i.e. Level 4 completed)
                                       ; CALL 36753        ; Load IX with address of Berk's complex state data and set his horizontal position to match
                                                           ; Level 1's entry door
       socb @bits+2,@10(ix)            ; SET 2,(IX+10)     ; Set "Back to Level 1" Flag
       movb @bytes+10,*ix              ; LD (IX+0),10      ; Set Berk's room to 10
       movb @bytes+103,@4(ix)          ; LD (IX+4),103     ; Set y-coordinate of Berk's top edge to 103
       movb @bytes+109,@6(ix)          ; LD (IX+6),109     ; Set y-coordinate of Berk's bottom edge to 109
       li   iy,bonis_state_data_1      ; LD IY,43606       ; Load IY with address of Boni's entry in Level 1's State Data for Complex Entities...
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       bl   @position_carried_item     ; CALL 48850        ; Have Berk hold Boni, and position him appropriately between Berk's hands
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       movb @bytes+10,*iy              ; LD (IY+0),10      ; Set Boni's room to 10
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       bl   @prepare_falling           ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
       bl   @lock_level_1_exit_door    ; CALL 36739        ; Lock Level 1's exit door and cycle attributes (full-screen)
       .ifne start_at_level,5
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       .endif
       li   hl,init_drutts_state_data_1 ; LD HL,36625       ; Overwrite Drutt's entry in Level 1's State Data for Complex Entities with data at #R36625...
       li   de,drutts_state_data_1     ; LD DE,43671       ; ...
       li   bc,13                      ; LD BC,13          ; ...
       .ldir                           ; LDIR              ; ...
       li   hl,berk_fall_script        ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script            ; JP 48098          ; ...and execute
* Destination level is not Level 1
next_level_1:
                                       ; CALL 36753        ; Set Berk's horizontal position to match Level 1's entry door
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt...
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       bl   @position_carried_item     ; CALL 48850        ; Have Berk hold Drutt, and position him appropriately between Berk's hands
       jmp  !
lock_level_1_exit_door:
       .proc
!      li   hl,game_flags              ; LD HL,34208       ; Reset Level Exit Door Unlocked Flag...
       szcb @bits+4,*hl                ; RES 4,(HL)        ; ...
       movb @bytes+5,a                 ; LD A,5            ; Set door colour to 5 (cyan, i.e. locked)...
       movb a,@_50711+1                ; LD (50712),A      ; ...
       bl   @cycle_colors_and_refresh  ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       .endproc                        ; RET               ; Return

*********************************************************************************
* Set Berk's Horizontal Position to Match Level 1's Entry Door
*
* Used by the routine at #R36638.
align_with_level_1_door:
       .proc
                                       ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       movb @bytes+33,a                ; LD A,33           ; Load IY with address of complex state data for first entity that has class of 33 (Entry
                                                           ; Door)...
       bl   @find_1st_entity_of_class                   ; CALL 54019        ; ...
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with start address of current level's complex state data for Berk
       movb @5(iy),a                   ; LD A,(IY+5)       ; Load A with x-coordinate of left of Entry Door...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@5(ix)                   ; LD (IX+5),A       ; Adjust Berk's horizontal position so that his left side is at coordinate in A...
       ab   @bytes+5,a                 ; ADD A,5           ; ...and his right side is 5 characters to the right of this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       .endproc                        ; RET               ; Return
*// align_with_level_1_door

*********************************************************************************
* Decrease Remaining Time for Current Power and if Zero, Exit Calling Routine and Run Script Data for Removal of
* Power
*
* Used by the routines at #R35689, #R36542 and #R48487.
dec_power_duration:
       .proc
       mov  @remaining_power_cycles,de ; LD DE,(34224)     ; Load remaining power time into DE
       swpb de                         ; Little endian
       movb @e,a                       ; LD A,E            ; Increase E (number of game-cycles power has been in use in current block)...
       ab   one,a                      ; INC A             ; ...
       movb a,@e                       ; LD E,A            ; ...
       cb   a,@bytes+15                ; CP 15             ; If 16 game-cycles of power use have not yet elapsed...
       jne  dec_power_duration_1       ; JR NZ,48402       ; ...then skip ahead to #R48402
       movb @zero,@e                ; LD E,0            ; Reset number of game-cycles power has been in use to zero...
       sb   one,d                      ; DEC D             ; ...and decrease remaining number of 16-game-cycles
dec_power_duration_1:
       swpb de                         ; Big endian
       mov  de,@remaining_power_cycles ; LD (34224),DE     ; Store updated remaining power time...
       jne  dec_power_duration_2       ; RET NZ            ; ...and return if this is not zero
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @remove_current_power      ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original position
       li   hl,_35275                  ; LD HL,35275       ; Point HL at script data for Berk's power expiring...
       b    @execute_script             ; JP 48098          ; ...and execute
dec_power_duration_2:
       .endproc
*// dec_power_duration

*********************************************************************************
* Remove Berk's Current Power and Reset Sweet / Mushroom / Edible Eyes / Sausage to its Original Position
*
* Used by the routines at #R36390, #R36471, #R39151 and #R48388.
remove_current_power:
       .proc
       movb @berks_current_power,a     ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  remove_current_power_3     ; RET Z             ; ...then return
       .push ix                        ; PUSH IX           ; Store IX
       cb   a,@bytes+6                 ; CP 6              ; If Berk's current power is not 6 (flying, level 3, 2)...
       jne  remove_current_power_1     ; JR NZ,48445       ; ...then skip ahead to #R48445
       movb @bytes+13,a                ; LD A,13           ; Reset complex state data for Red Coloured Creature to that stored in Initial-State Table...
       bl   @reset_1st_entity_of_class ; CALL 53987        ; ...
       movb @bytes+14,a                ; LD A,14           ; Reset complex state data for Yellow Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @reset_1st_entity_of_class ; CALL 53987        ; ...
       movb @bytes+15,a                ; LD A,15           ; Reset complex state data for White Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @reset_1st_entity_of_class ; CALL 53987        ; ...
       jmp  remove_current_power_2     ; JR 48474          ; Skip ahead to #R48474
remove_current_power_1:
       cb   a,@bytes+10                ; CP 10             ; If Berk's current power is not 10 (floating)...
       jne  remove_current_power_2     ; JR NZ,48474       ; ...then skip ahead to #R48474
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       szcb @bits+7,@9(ix)             ; RES 7,(IX+9)      ; Reset Berk's Moving Upwards Flag
       movb @bytes+192,@11(ix)         ; LD (IX+11),192    ; Reset Berk's Walking Right, Walking Left, Unused (11,2), Unused (11,3), Impassable Leftwards
                                                           ; and Impassable Rightwards flags and set his Interaction (11,6) and Interaction (11,7) flags
       szcb @bits+7,@8(ix)             ; RES 7,(IX+8)      ; Reset bit 7 of Berk's class value (change from 159 to 31)
       sb   one,@6(ix)                 ; DEC (IX+6)        ; Decrease Berk's bottom y-coordinate by two...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @prepare_falling           ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
remove_current_power_2:
       movb @berks_current_power,a     ; LD A,(34220)      ; Reset complex state data for entity responsible for Berk's current power to that stored in
                                                           ; Initial-State Table...
       bl   @reset_1st_entity_of_class ; CALL 53987        ; ...
       sb   a,a                        ; XOR A             ; Clear Berk's current power...
       movb a,@berks_current_power     ; LD (34220),A      ; ...
       .pop ix                         ; POP IX            ; Restore IX
remove_current_power_3:
       .endproc                        ; RET               ; Return
*// remove_current_power

*********************************************************************************
* Set "Berk Has Been Killed" Flag
*
* Used by the routines at #R36116, #R36390, #R37085, #R37639, #R38074, #R38219, #R38540, #R38592, #R39934, #R41498,
* #R41633, #R41961, #R42064, #R42266 and #R42486.
set_berk_killed:
       movb @game_flags,a              ; LD A,(34208)      ; Set "Berk Has Been Killed" Flag...
       .ifeq berk_cant_die,0
       socb @bits+2,a                  ; SET 2,A           ; ...
       .endif
       movb a,@game_flags              ; LD (34208),A      ; ...
       rt                              ; RET               ; Return
*// set_bert_killed:

*********************************************************************************
* Advance DE by 2xA Bytes and Load WORD at this Location into DE
*
* Used by the routines at #R49010, #R51779 and #R53723. Input:  A  Index DE  Base address Output: DE  WORD value at
* DE (input) + 2 x A (input)
load_table_addr:
                                       ; PUSH HL           ; Store HL
       ab   a,a                        ; ADD A,A           ; Load HL with double index...
       clr  tmp0
       movb a,@r0lb                    ; LD L,A            ; ...
                                       ; LD H,0            ; ...
       a    de,tmp0                    ; ADD HL,DE         ; Add HL to DE as offset, in HL
       mov  *tmp0,de                   ; LD E,(HL)         ; Load address at HL into DE...
                                       ; INC HL            ; ...
                                       ; LD D,(HL)         ; ...
                                       ; POP HL            ; Restore HL
       rt                              ; RET               ; Return
*// load_table_addr

*********************************************************************************
* Paint Red Areas Outside Current Character's Room if IX Points to Current Character's Complex State Data
*
* Used by the routines at #R54383, #R54419, #R55433 and #R55616. Input:  IX  Address of complex state data for an
* entity
paint_red_areas_char:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; Set Zero Flag if Drutt Mode Flag is reset...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       movb @8(ix),a                   ; LD A,(IX+8)       ; Load Entity Class Value of entity at IX into A
       mov  tmp0,tmp0
       jne  paint_red_areas_char_1     ; JR NZ,54471       ; If Zero Flag is reset (i.e. Drutt Mode) then skip ahead to #R54471
       cb   a,@bytes+31                ; CP 31             ; If Entity Class is 31 (i.e. Berk)...
       jeq  paint_red_areas_char_2     ; JR Z,54474        ; ...then paint red areas outside accessible areas of current character's current room and
                                                           ; return
       jmp  paint_red_areas_char_3     ; RET               ; Return
paint_red_areas_char_1:
       cb   a,@bytes+18                ; CP 18             ; If Entity Class is not 18 (i.e. Drutt)...
       jne  paint_red_areas_char_3     ; RET NZ            ; ...then return
paint_red_areas_char_2:
       .push hl                        ; PUSH HL           ; Store HL
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
paint_red_areas_char_3:
       .endproc                        ; RET               ; Return
*// paint_red_areas_char

*********************************************************************************
* Paint Red Areas Outside Accessible Areas of Current Character's Current Room
*
* Used by the routines at #R34438, #R34916, #R36616, #R48791, #R53723 and #R54456.
paint_red_areas:
       .proc
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .push ix                        ; PUSH IX           ; Store IX
       bl    @clear_display_buffers    ; CALL 53635        ; Clear Display Buffers 1 & 2
                                       ; EXX               ; Switch registers
       li   hl_,display_buffer_1       ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de_,display_buffer_2       ; LD DE,63424       ; Point DE at Display Buffer 2
                                       ; EXX               ; Switch registers
       movb @tmp_room_dim_data+1,@l    ; LD HL,(34231)     ; For current character's current room, set H = room's right edge position and L = room's left
       movb @tmp_room_dim_data+2,h                         ; edge position (chars)
       movb @tmp_room_dim_data+3,@e    ; LD DE,(34233)     ; For current character's current room, set D = room's bottom edge position and E = room's top
       movb @tmp_room_dim_data+4,d                         ; edge position (chars)
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       sb   b,b                        ; LD B,0            ; Set initial y-coordinate (characters) to zero
paint_red_areas_1:
       movb b,a                        ; LD A,B            ; Load A with current y-coordinate
       cb   a,@e                       ; CP E              ; If y-coordinate of top of room is greater than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb d,a                        ; LD A,D            ; Load A with y-coordinate of bottom of room
       cb   a,b                        ; CP B              ; If y-coordinate of bottom of room is less than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb @zero,@c                ; LD C,0            ; Set initial x-coordinate to zero
paint_red_areas_2:
       movb @c,a                       ; LD A,C            ; Load A with current x-coordinate
       cb   a,@l                       ; CP L              ; If x-coordinate of left of room is greater than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
       movb h,a                        ; LD A,H            ; Load A with x-coordinate of right of room
       cb   a,@c                       ; CP C              ; If x-coordinate of right of room is less than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
                                       ; EXX               ; Switch registers
       ai   hl_,3                      ; CALL 53977        ; Advance pointers in Display Buffers and Attribute File address to next character
       ai   de_,3
       inc  ix
       jmp  paint_red_areas_4          ; JR 53943          ; Skip ahead to #R53943
* Current x-coordinate, C, is outside range of x-coordinates spanned by room
paint_red_areas_3:
       bl   @paint_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
paint_red_areas_4:
       ab   one,@c                     ; INC C             ; Advance C by one (move right one character)
       movb @c,tmp0                    ; BIT 5,C           ; If bit 5 is not set (x-coordinate has not reached 32)...
       andi tmp0,32*256                ;
       jeq  paint_red_areas_2          ; JR Z,53926        ; ...then loop back to #R53926
       jmp  paint_red_areas_7          ; JR 53959          ; Skip ahead to #R53959
* Current y-coordinate, B, is outside range of y-coordinates spanned by room
paint_red_areas_5:
       .push bc                        ; PUSH BC           ; Store BC (B = current y-coordinate, C = current x-coordinate)
       movb @bytes+32,b                ; LD B,32           ; Load counter with 32 (as there are 32 characters per row)
paint_red_areas_6:
       bl   @paint_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
       sb   one,b                      ; DJNZ 53953        ; Loop back to #R53953 for next character block
       jne  paint_red_areas_6                     ;
       .pop bc                         ; POP BC            ; Restore BC (B = current y-coordinate, C = current x-coordinate)
paint_red_areas_7:
       ab   one,b                      ; INC B             ; Increase current y-coordinate by one
       movb b,a                        ; LD A,B            ; If y-coordinate has not reached 22...
       cb   a,@bytes+22                ; CP 22             ; ...
       jne  paint_red_areas_1          ; JR NZ,53916       ; ...then loop back to #R53916
       .pop ix                         ; POP IX            ; Restore IX
       .endproc                        ; RET               ; Return
*// paint_red_areas

*********************************************************************************
* Print Red Cell to Current Attribute File Position (Outside Play Area) and Mark as Unused in Display Buffers
*
* Used by the routine at #R53887. Input:  IX  Address of start of Attribute File (22528) HL'  Current position in
* display buffer 1 (at #R61312) DE'  Current position in display buffer 2 (at #R63424)
paint_red_cell:
       .proc
;       movb @bytes+18,*ix              ; LD (IX+0),18      ; Set attribute to red INK, red PAPER
       li   a,18*256
       mov  ix,tmp1
       bl   @draw_attribute
                                       ; EXX               ; Switch registers
       movb @b255,a               ; LD A,255          ; Load 255 into current positions in Display Buffers 1 and 2...
       movb a,*hl_+                    ; LD (HL),A         ; ...
       movb a,*de_+                    ; LD (DE),A         ; ...
* This entry point is used by the routine at #R53887.
       inct hl_                        ; INC HL            ; Advance display buffer 1 pointer by three bytes to next entry...
                                       ; INC HL            ; ...
                                       ; INC HL            ; ...
       inct de_                        ; INC DE            ; Advance display buffer 2 pointer by three bytes to next entry...
                                       ; INC DE            ; ...
                                       ; INC DE            ; ...
                                       ; EXX               ; Switch registers
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return
*// paint_red_cell

*********************************************************************************
* Reset Complex State Data for First Entity of Class A to that Stored in Initial-State Table at 59821
*
* Used by the routines at #R37639 and #R48417. Input:  A  Entity class value IX  (Entry at #R53994 only) Address of
* complex state data for an entity
reset_1st_entity_of_class:
       .proc
       bl   @find_1st_entity_of_class                      ; CALL 54019        ; Load IX with address of complex state data for first entry in current level that has class
                                                           ; A...
       mov iy,ix                       ; PUSH IY           ; ..
                                       ; POP IX            ; ...
       jmp  reset_1st_entity_of_class_1
* This entry point is used by the routine at #R42064.
reset_1st_entity_of_class_0:
       .proc
reset_1st_entity_of_class_1:
       li   iy,initial_entity_states   ; LD IY,59821       ; Point IY at start of Table of Initial-State Data for Complex Entities
       bl   @find_1st_entity_of_class_0                   ; CALL 54023        ; Advance IY to first entry in copied complex state data that has class A
       .push ix                        ; PUSH IX           ; Store IX (address of entry in complex state data to overwrite)
       movb @e,b                       ; LD B,E            ; Load B with 13 (DE set to 13 in routine at #R54019)
reset_1st_entity_of_class_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Overwrite IX data entry with IY data...
       movb a,*ix+                     ; LD (IX+0),A       ; ...
                                       ; INC IX            ; ...
       inc  iy                         ; INC IY            ; ...
       sb   one,b                      ; DJNZ 54004        ; ...
       jne  reset_1st_entity_of_class_2                     ;
       .pop ix                         ; POP IX            ; Restore IX (address of entry in complex state data just overwritten)
       .endproc                        ; RET               ; Return
*// reset_1st_entity_of_class

*********************************************************************************
* Point IY at First Entry in Current Level's Complex State Data that has Class A
*
* Used by the routines at #R36753 and #R53987. Input:  A  Value of an entity class Output: IY  Address of complex
* state data for first entity of class A
find_1st_entity_of_class:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
* This entry point is used by the routine at #R53987.
find_1st_entity_of_class_0:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
find_1st_entity_of_class_1:
       cb   a,@8(iy)                   ; CP (IY+8)         ; If current IY entity has class A...
       jeq  find_1st_entity_of_class_2 ; RET Z             ; ...then return
       a    de,iy                      ; ADD IY,DE         ; Advance to entry for next entity
       jmp  find_1st_entity_of_class_1 ; JR 54026          ; Loop back to #R54026
find_1st_entity_of_class_2:
       rt
*// find_1st_entity_of_class

*********************************************************************************
* Load A with a Pseudo-Random Number Between 0 and the Higher of 2 and A (Input)
*
* This routine uses a linear congruential generator to generate a new pseudo-random number based upon a seed value.
* The seed value is stored at #R54219, is initially set to the value in the least significant byte of the system
* variable FRAMES, and subsequently set to the previously generated pseudo-random number. On entering this routine,
* the A register holds the range for the random number (e.g. 5 means this routine will generate a random number in
* the range 0-4 inclusive). A range of less than 2 is not allowed, so if A is less than this then it will be set to
* 2. Input:  A  Range Output: A  Generated random number
rnd_no:
       .proc
       cb   a,@bytes+2                 ; CP 2              ; If range is less than 2...
       jhe  rnd_no_1                   ; JP NC,54229       ; ...then set range to 2...
       movb @bytes+2,a                 ; LD A,2            ; ...
rnd_no_1:
       bl   @randl
;       movb a,@rnd_range               ; LD (54221),A      ; Store range at #R54211
;       .push hl                        ; PUSH HL           ; Store HL
;       .push de                        ; PUSH DE           ; Store DE
;       .push bc                        ; PUSH BC           ; Store BC
;       mov  @rnd_seed,de               ; LD DE,(54219)     ; Load DE with seed
;       movb @e,h                       ; LD H,E            ; Load least significant byte of random seed into H
;       movb @bytes+253,@l              ; LD L,253          ; Set L to 253
;       movb d,a                        ; LD A,D            ; Load most significant byte (MSB) of random seed into A
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (256 * seed + 253)
;                                       ; OR A              ; Reset carry flag
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @zero,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @zero,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (254 * seed + 253)
;       movb a,@e                       ; LD E,A            ; Calculate (AHL mod 65,537)...
;       movb @zero,d                 ; LD D,0            ; ...loading result into HL...
;       s    de,hl                      ; SBC HL,DE         ; ...
;       joc  !                          ; JP NC,54261       ; ...and if this is negative...
;       b    @rnd_no_2                  ;
;!
;       inc  hl                         ; INC HL            ; ...then add one (as zero in HL can represent both zero and 65,536)
;rnd_no_2:
;       mov  hl,@rnd_seed               ; LD (54219),HL     ; Store HL (new seed) at #R54219
;* At this point, HL contains a new pseudo-random 16-bit number
;       .push hl                        ; PUSH HL           ; Copy 16-bit pseudo-random number from HL into DE...
;       .pop de                         ; POP DE            ; ...
;       movb @rnd_range,a               ; LD A,(54221)      ; Load A with range as stored previously
;       sb   one,a                      ; DEC A             ; Decrease range by 1 to get maximum value as we want the output to range from 0 to (A-1)...
;       movb a,b                        ; LD B,A            ; ...and load into B (loop counter)
;* In the following loop we are obtaining the number of times that 65,536 goes into RANGE x DE. In other words,
;* (RANGE x DE) is divided by 65,536 and the integer part of the result is loaded into A. A is therefore limited to
;* values between zero, and the value A had on entering this routine minus one, inclusive.
;       sb   a,a                        ; XOR A             ; Set A to zero
;rnd_no_3:
;       a    de,hl                      ; ADD HL,DE         ; Add DE to HL
;       joc  !                          ; JP NC,54277       ; If DE has not crossed the 65,535 - 0 boundary then skip ahead to #R54277
;       b    @rnd_no_4                  ;
;!
;       ab   one,a                      ; INC A             ; Increase A (count of number of times DE rolls over from 65,535 to 0)
;rnd_no_4:
;       sb   one,b                      ; DJNZ 54272        ; Decrease B and loop back to #R54272
;       jne  rnd_no_3                   ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop de                         ; POP DE            ; Restore DE
;       .pop hl                         ; POP HL            ; Restore HL
       .endproc                         ; RET               ; Return
*// rnd_no

*********************************************************************************
* Move Entity at IX into New Room (Left or Right) if it is at the Edge of its Current Room
*
* Used by the routines at #R35735 and #R55041. Input:  IX  Address of complex state data for an entity
move_into_new_room:
       .proc
       movb @tmp_width_current_room,a  ; LD A,(34235)      ; Load A with width of current room (chars) + 97...
       sb   one,a                      ; DEC A             ; ...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of left side (+100) of entity is greater than this...
       jl   move_into_new_room_1       ; JR C,54306        ; ...then skip ahead to #R54306
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of right side (+100) of entity is not less than 102...
       cb   a,@bytes+102               ; CP 102            ; ...
       jhe  move_into_new_room_2       ; RET NC            ; ...then return
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       jmp  move_into_new_room_2       ; RET               ; Return
move_into_new_room_1:
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
move_into_new_room_2:
       .endproc                        ; RET               ; Return
*// move_into_new_room

*********************************************************************************
* Move Entity at IX into Room to the Right, If Appropriate
*
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading side (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading side crosses the boundary.
* This routine (along with its counterpart at #R54348) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the right, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_right_room:
       .proc
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load C with width of entity's current room (chars) + 99...
       movb a,@c                       ; LD C,A            ; ...
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       jeq  move_into_right_room_1     ; JR Z,54329        ; ...then skip ahead to #R54329
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of Drutt's left edge
       jmp  move_into_right_room_2     ; JR 54332          ; Skip ahead to #R54332
move_into_right_room_1:
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right edge
move_into_right_room_2:
       cb   a,@c                       ; CP C              ; If x-coordinate of room's right edge is greater than x-coordinate in A...
       jl   move_into_right_room_3     ; RET C             ; ...then return
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       jeq  move_into_right_room_4     ; JR Z,54381        ; If there is no room to the right, then jump to #R54381
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
       bl   @chk_coll_right            ; CALL 54569        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  move_into_right_room_4     ; JR NC,54381       ; ...and if a collision occurred, then jump to #R54381
move_into_right_room_3:
       b    @return_with_carry         ; RET               ; Return
move_into_right_room_4:
       sb   a,a
       b    @return_without_carry
*// move_into_right_room

*********************************************************************************
* Move Entity at IX into Room to the Left, If Appropriate
*
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading edge (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading edge crosses the boundary.
* This routine (along with its counterpart at #R54313) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the left, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_left_room:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       jeq  move_into_left_room_1      ; JR Z,54363        ; ...then skip ahead to #R54363
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Drutt's right edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
       jmp  move_into_left_room_2      ; JR 54369          ; Skip ahead to #R54369
move_into_left_room_1:
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Berk's left edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
move_into_left_room_2:
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       jeq  move_into_left_room_4      ; JR Z,54381        ; If there is no room to the left, then jump to #R54381
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       bl    @chk_coll_left            ; CALL 54666        ; Set Carry Flag if entity at IX has not collided with another impassable / pushable entity
       jnc   move_into_left_room_4                         ; immediately to the left, reset otherwise
move_into_left_room_3:
       bl   @return_with_carry         ; RET               ; Return
move_into_left_room_4:
       sb   a,a                        ; XOR A             ; Set A to zero
       bl   @return_without_carry      ; RET               ; Return
*// move_into_left_room

*********************************************************************************
* Move Entity at IX into Room to Right of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
*
* Used by the routines at #R48593, #R54283 and #R54313. Input:  IX  Address of complex state data for an entity
do_move_into_right_room:
       .proc
       bl   @move_to_left_of_right_room                    ; CALL 54398        ; Set character's position to be left-hand side of new room to right
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;
       jne  do_move_into_right_room_1  ; RET NZ            ; ...then return
       bl   @move_carried_to_right                   ; CALL 48727        ; If entity is Berk then move carried entity to Berk's right as he faces right
do_move_into_right_room_1:
       .endproc                        ; RET               ; Return
*// do_move_into_right_room

*********************************************************************************
* Set Entity's Position to be Left-Hand Side of New Room to Right
*
* Used by the routine at #R54383. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
move_to_left_of_right_room:
       .proc
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load D with i.e. x-coordinate of right edge of room (width of current room (chars) + 99)
                                                           ; minus x-coordinate of right-edge of current character...
       sb   @7(ix),a                   ; SUB (IX+7)        ; ...(i.e. [negative] distance by which entity's right edge is to the right of right edge of
                                                           ; room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @bytes+99,a                ; LD A,99           ; Load A with x-coordinate of left edge of current (new) room
       sb   d,a                        ; SUB D             ; Subtract D (negative)...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as new x-coordinate of entity's right edge
       sb   @e,a                       ; SUB E             ; Subtract (width - 1) of entity...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set this as x-coordinate of entity's left edge
       .endproc                        ; RET               ; Return
*// move_to_left_of_right_room

*********************************************************************************
* Move Entity at IX into Room to Left of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
*
* Used by the routines at #R48641, #R54283 and #R54348.
do_move_into_left_room:
       .proc
       bl   @move_to_right_of_left_room                   ; CALL 54434        ; Set entity's position to be right-hand side of new room to left
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;
       jne  do_move_into_left_room_1   ; RET NZ            ; ...then return
       bl   @move_carried_to_left      ; CALL 48738        ; If entity is Berk then move carried entity to Berk's left as he faces left
do_move_into_left_room_1:
       .endproc                        ; RET               ; Return
*// do_move_into_left_room

*********************************************************************************
* Set Entity's Position to be Right-Hand Side of New Room to Left
*
* Used by the routine at #R54419. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
move_to_right_of_left_room:
       .proc
       movb @bytes+100,a               ; LD A,100          ; Load D with x-coordinate of left edge of room minus x-coordinate of left edge of current
                                                           ; entity...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...(i.e. distance by which entity's left edge is to the left of left edge of room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load A with width of current (new) room (chars) + 99
       sb   d,a                        ; SUB D             ; Subtract D...
       ab   one,a                      ; INC A             ; ...and add one to get x-coordinate of entity's left edge in new room
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set entity's left edge to this position
       ab   @e,a                       ; ADD A,E           ; Add (width - 1) of entity...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set this as x-coordinate of entity's right edge
       .endproc                        ; RET               ; Return
*// move_to_right_of_left_room

*********************************************************************************
* Set Room of Entity at IX to B, Store Room Size Data for New Room and Load E with Entity's Width Minus One
*
* Used by the routines at #R54398, #R54434, #R55433 and #R55616. Input:  B  Destination room index IX  Address of
* complex state data for an entity Output: E  Entity's width, minus one (characters)
set_room_of_entity:
       .proc
       movb b,a                        ; LD A,B            ; Set entity's current room to be destination room...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       .push hl                        ; PUSH HL           ; Store HL
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for entity's current room
       .pop de                         ; POP DE            ; Restore DE
       .pop hl                         ; POP HL            ; Restore HL
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of entity's right...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...subtract x-coordinate of entity's left...
       movb a,@e                       ; LD E,A            ; ...and load result (entity's width minus one) into E
       .endproc                        ; RET               ; Return
*// set_room_of_entity

*********************************************************************************
* Load B with Index of Room to Right of an Entity's Current Room
*
* Used by the routines at #R48593, #R52193, #R54283 and #R54313. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54512 only) An entry in a room connectivity table D  (entry at #R54508 and #R54512 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the right, reset otherwise
get_right_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_right_room_index_1:
       mov  @horz_room_connect_map,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
* This entry point is used by the routine at #R54499.
get_right_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (left room index) of current entry into A
       cb   a,@b255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_right_room_index_3     ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  _54527                     ; JR NZ,54527       ; ...then skip ahead to #R54527
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (right room index) of current entry into B
       cb   a,@b255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_right_room_index_3     ; RET               ; Return
_54527:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_right_room_index_2                         ; JR 54512          ; Loop back to #R54512
get_right_room_index_3:
       rt
*// get_right_room_index

*********************************************************************************
* Load B with Index of Room to Left of an Entity's Current Room
*
* Used by the routines at #R48641, #R52098, #R54283 and #R54348. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54546 only) An entry in a room connectivity table D  (entry at #R54542 and #R54546 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the left, reset otherwise
get_left_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_left_room_index_1:
       mov  @horz_room_connect_map,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
       movb @b255,b                                   ; Init result to not found
* This entry point is used by the routine at #R54533.
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (right room index) of first entry
get_left_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (right room index) of current entry into A
       cb   a,@b255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_left_room_index_4      ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  get_left_room_index_3      ; JR NZ,54563       ; ...then skip ahead to #R54563
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (left room index) of current entry into B
       cb   a,@b255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_left_room_index_4      ; RET               ; Return
get_left_room_index_3:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_left_room_index_2                          ; JR 54548          ; Loop back to #R54548
get_left_room_index_4:
       rt
*// get_left_room_index

*********************************************************************************
* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Right
*
* Used by the routines at #R36116, #R52148, #R52193, #R52889, #R52914, #R54313 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_right:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_right_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@b255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_right_2           ; JR NZ,54585       ; ...then skip ahead to #R54585
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_right_2:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;
       jne  chk_coll_right_4           ; JP NZ,54662       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_right_4           ; JR Z,54662        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_right_3           ; JR NZ,54620       ; ...then skip over depth check to #R54620
                                       ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   @1(iy),@1(ix)              ; CP (IX+1)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
chk_coll_right_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Rightwards" Flag reset...
       andi a,32*256                   ; AND 32            ; ...
       jeq  chk_coll_right_4           ; JP Z,54662        ; ...then advance IY to next entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity at IX...
       ab   one,a                      ; INC A             ; ...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is not immediately to the left of the left side of the entity at IY...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_right_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_right_1           ; JR 54576          ; Loop back to #R54576
*// chk_coll_right

*********************************************************************************
* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Left
*
* Used by the routines at #R36116, #R52053, #R52098, #R52870, #R52914, #R54348 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_left:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_left_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@b255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_left_2            ; JR NZ,54682       ; ...then skip ahead to #R54682
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_left_2:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;
       jne  chk_coll_left_4            ; JP NZ,54760       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_left_3            ; JR NZ,54718       ; ...then skip over depth check to #R54620
                                       ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   @1(iy),@1(ix)              ; CP (IX+1)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
chk_coll_left_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Leftwards" Flag reset...
       andi a,16*256                   ; AND 16            ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       movb @5(ix),a                   ; LD A,(IX+5)       ; If the left side of entity at IX...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...is not immediately to the right of the right side of the entity at IY...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_left_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_left_1            ; JR 54673          ; Loop back to #R54673
*// chk_coll_left

*********************************************************************************
* Check Entity at IX for Collision With Another Entity at Next Depth Level Out Of Screen Whose Interaction (11,6)
* Flag is Set
*
* Used by the routines at #R37639 and #R52315. Input:  IX  Address of complex state data for an entity Output: F
* Carry Flag set if no entity found, reset otherwise A  Class of entity, if found, otherwise 255 IY  Address of
* complex state data for colliding entity
chk_coll_next_depth:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level out of screen)
       jmp  chk_coll_same_depth_1      ; JR 54770          ; Jump to collision detection routine

* Check Entity at IX for Collision With Another Entity at Same Depth Whose Interaction (11,6) Flag is Set
*
* Used by the routines at #R36036, #R36542, #R37085, #R38074, #R38219, #R38540, #R38592, #R41498, #R41633, #R41961,
* #R42064, #R42266, #R42486, #R48487, #R51779, #R53083, #R55196 and #R55525. Input:  IX  Address of complex state
* data for an entity C  (Entry at #R54770 only) Depth offset Output: F  Carry Flag set if no entity found, reset
* otherwise A  Class of entity, if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_same_depth:
       movb @zero,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
* This entry point is used by the routine at #R54764.
chk_coll_same_depth_1:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
chk_coll_same_depth_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@b255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_same_depth_3      ; JR NZ,54786       ; ...then skip ahead to #R54786
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return
chk_coll_same_depth_3:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_same_depth_6      ; JR NZ,54874       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;
       jne  chk_coll_same_depth_6      ; JP NZ,54874       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_same_depth_6      ; JR Z,54874        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_same_depth_4      ; JR NZ,54822       ; ...then skip over depth check to #R54822
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       ab   @c,a                       ; ADD A,C           ; ...plus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_same_depth_6      ; JR NZ,54874       ; ...then advance IY to next entity
chk_coll_same_depth_4:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,6) Flag reset...
       andi a,64*256                   ; AND 64            ; ...
       jeq  chk_coll_same_depth_6      ; JP Z,54874        ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   @7(ix),@5(iy)              ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   @7(iy),@5(ix)              ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
* This entry point is used by the routines at #R55196 and #R55525.
chk_coll_same_depth_5:
       li   de,13                      ; LD DE,13          ; Load DE with 13, as entries in complex state data are 13 bytes wide
chk_coll_same_depth_6:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_same_depth_2      ; JR 54777          ; Loop back to #R54777
*// chk_coll_same_depth

*********************************************************************************
* Check Entity at IX for Collision With Another Entity (Only those Defined Before, and in Reverse Order) at Same
* Depth Level Whose Interaction (11,7) Flag is Set
*
* Used by the routine at #R52315. Input:  IX  Address of complex state data for an entity Output: F  Carry Flag set
* if no entity found, reset otherwise A  Class of entity, if found, otherwise 254 IY  Address of complex state data
* for colliding entity
chk_coll_same_depth_rev:
       movb @zero,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
       mov  ix,iy                      ; PUSH IX           ; Load IY with address in IX...
                                       ; POP IY            ; ...
       li   de,-13                     ; LD DE,65523       ; Load DE with -13
       jmp  chk_coll_next_depth_rev_3  ; JP 54987          ; Move IY back to previous entity in complex state data and jump into collision check routine
*// chk_coll_same_depth_rev

*********************************************************************************
* Check Entity at IX for Collision With Another Entity (in Reverse Order) at Next Depth Level Into Screen Whose
* Interaction (11,7) Flag is Set
*
* The address stored at #R34246 is the address of complex state data for the entity to start with when doing
* collision checks in reverse order. On levels 2, 3 and 4, the value stored here is the address of the complex state
* data of the last entity, which means that on these levels, all entities are checked. On Level 1, however, the
* value stored is the address of the complex state data of the sixth-last entity. The remaining five entities after
* this address on Level 1 are the three spiders, their webs and their arches. This means that on Level 1, these
* spiders, webs and arches are excluded from certain collision checks. Input:  IX  Address of complex state data for
* an entity C  (Entry at #R54899 only) Depth offset Output: F  Carry Flag set if no entity found, reset otherwise A
* Class of entity, if found, otherwise 254 IY  Address of complex state data for colliding entity
chk_coll_next_depth_rev:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level into screen)
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (as entries in complex state data are 13 bytes wide)
       mov  @addr_rev_col_check,iy     ; LD IY,(34246)     ; Load IY with current level's start address for reverse-order collision checks
chk_coll_next_depth_rev_1:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;
       jne  chk_coll_next_depth_rev_3  ; JP NZ,54987       ; ...then move IY back to previous entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_next_depth_rev_3  ; JR Z,54987        ; ...then move IY back to previous entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_next_depth_rev_2  ; JR NZ,54935       ; ...then skip over depth check to #R54935
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       sb   @c,a                       ; SUB C             ; ...minus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
chk_coll_next_depth_rev_2:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,7) Flag reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  chk_coll_next_depth_rev_3  ; JP Z,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   @7(ix),@5(iy)              ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   @7(iy),@5(ix)              ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (?)
* This entry point is used by the routine at #R54878.
chk_coll_next_depth_rev_3:
       movb @-1(iy),a                  ; LD A,(IY-1)       ; If byte before current IY position is 254 (i.e. end marker for simple state data)...
       cb   a,@b254               ; CP 254            ; ...
       jeq  chk_coll_next_depth_rev_4  ; JP Z,55000        ; ...then skip ahead to #R55000
       a    de,iy                      ; ADD IY,DE         ; Move IY back 13 bytes (i.e. to start of previous entry)
       jmp  chk_coll_next_depth_rev_1  ; JP 54899          ; Jump to #R54899
chk_coll_next_depth_rev_4:
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return
*// chk_coll_next_depth_rev

*********************************************************************************
* Set Character Swap Pending Flag
*
* Used by the routine at #R55041.
set_swap_pending_flag:
       movb @game_flags,a              ; LD A,(34208)      ; Set Character Swap Pending Flag...
       socb @bits+6,a                  ; SET 6,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       rt                              ; RET               ; Return
*// set_swap_pending_flag

*********************************************************************************
* If Current Character is in Same Room as Target Entity at IX then Set Pending Sound to A
*
* If the requested sound has a lower index than the sound already pending then the requested sound overrides the
* pending sound (i.e. lower index has higher priority). Input:  A  Index of requested sound IX  Address of complex
* state data for target entity
request_entity_sound:
       .proc
       .push af                        ; PUSH AF           ; Store AF (A = index of requested sound)
       movb @current_characters_room,a ; LD A,(34218)      ; If current character's current room is the same as current room of target entity...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  request_entity_sound_1     ; JR Z,59612        ; ...then skip ahead to #R59612
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       .endproc                        ; RET               ; Return
request_entity_sound_1:
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       jmp  !
* At this point, A will hold the index of a requested sound, and RAM address #R34273 will contain the index of a
* pending sound. If the index of the requested sound is lower than the index of the pending sound, then the pending
* sound's index at #R34273 will be overwritten by the index of the requested sound in A. Sounds with lower indices
* therefore take priority over sounds with higher indices. This entry point is used by the routines at #R46284,
* #R55196 and #R59722.
request_sound_pri:
       .proc
!      socb a,a                        ; OR A              ; If index of requested sound is zero...
       jeq  request_sound_pri_2        ; RET Z             ; ...then return
       .push de                        ; PUSH DE           ; Store DE
       movb a,@e                       ; LD E,A            ; Load E with index of requested sound
       movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero (i.e. no sound pending)...
       jeq  request_sound_pri_1        ; JR Z,59628        ; ...then skip ahead to #R59628
       cb   a,@e                       ; CP E              ; If index of requested sound is less than or equal to index of pending sound...
       jhe  request_sound_pri_1        ; JR NC,59628       ; ...then skip ahead to #R59628
       .pop de                         ; POP DE            ; Restore DE
       jmp  request_sound_pri_2        ; RET               ; Return
request_sound_pri_1:
       movb @e,a                       ; LD A,E            ; Set requested sound to be new pending sound...
       movb a,@idx_pending_sound       ; LD (34273),A      ; ...
       .pop de                         ; POP DE            ; Restore DE
request_sound_pri_2:
       .endproc                        ; RET               ; Return

* Set Sound of Index A as Pending if Appropriate, then Play and Clear Pending Sound
*
* The sound with index A will become the pending sound if the currently pending sound index is either zero, or of
* higher index than A (i.e. lower priority). Input:  A  Sound index L  Undefined, pseudo-random value
request_sound:
       .proc
       bl   @request_sound_pri         ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
       jmp  !
* This entry point is used by the routine at #R34438.
play_sound:
       .proc
!      movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero...
       jeq  play_sound_1               ; RET Z             ; ...then return
;       sb   one,a                      ; DEC A             ; Decrease A to give zero-based sound index
;       .push ix                        ; PUSH IX           ; Store IX
;       li   ix,sound_table+1           ; LD IX,59635       ; Point IX at second byte of first entry in Sound Parameters Table
;       a    a,a                        ; ADD A,A           ; Multiply sound index by eight...
;       a    a,a                        ; ADD A,A           ; ...as sound data entries in table at #R59634 are eight bytes wide...
;       a    a,a                        ; ADD A,A           ; ...
;       movb a,@c                       ; LD C,A            ; ...and load into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,ix                      ; ADD IX,BC         ; Add BC to IX as offset to point to sound data for pending sound
;       movb b,a                        ; LD A,B            ; Set index of pending sound to zero...
;       movb a,@_34273                  ; LD (34273),A      ; ...
;       movb *ix,@c                     ; LD C,(IX+0)       ; Load outer repeat count into C
;_59752:
;       movb @1(ix),b                   ; LD B,(IX+1)       ; Load inner repeat count into B
;       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load delay constant E into E
;       movb @3(ix),d                   ; LD D,(IX+3)       ; Load delay constant D into D
;       movb @6(ix),h                   ; LD H,(IX+6)       ; Load most significant byte of pseudo-random address into H
;_59764:
;       .push bc                        ; PUSH BC           ; Store BC (B = inner repeat count, C = outer repeat count)
;       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
;       socb @bits+4,a                  ; SET 4,A           ; Set Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb d,b                        ; LD B,D            ; Apply delay based upon delay constant D...
;_59773:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59773        ; ...
;       jne  _59773                     ;
;       movb h,tmp0                     ; BIT 7,H           ; If No Pause Flag is set...
;       andi tmp0,128*256               ;
;       jne  _59794                     ; JR NZ,59794       ; ...then skip ahead to #R59794
;       movb *hl,b                      ; LD B,(HL)         ; Load B with value from pseudo-random address
;       inc  hl                         ; INC HL            ; Advance HL
;_59782:
;       movb *ix,tmp0                   ; BIT 0,(IX+0)      ; Do nothing (pause) for period B...
;       andi tmp0,1*256                 ;
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59782        ; ...
;       jne  _59782                     ;
;_59794:
;       szcb @bits+4,a                  ; RES 4,A           ; Reset Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb @e,b                       ; LD B,E            ; Do nothing for E cycles...
;_59799:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59799        ; ...
;       jne  _59799                     ;
;       movb @4(ix),a                   ; LD A,(IX+4)       ; Adjust value of delay constant D...
;       a    d,a                        ; ADD A,D           ; ...
;       movb a,d                        ; LD D,A            ; ...
;       movb @5(ix),a                   ; LD A,(IX+5)       ; Adjust value of delay constant E...
;       a    @e,a                       ; ADD A,E           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       .pop bc                         ; POP BC            ; Restore BC (B = inner repeat count, C = outer repeat count)
;       sb   one,b                      ; DJNZ 59764        ; Loop back to #R59764
;       jne  _59764                     ;
;       sb   one,@c                     ; DEC C             ; Decrease outer repeat count
;       jne  _59752                     ; JR NZ,59752       ; If non-zero (i.e. more repeats to process) then loop back to #R59752
;       .pop ix                         ; POP IX            ; Restore IX
play_sound_1:
       .endproc                         ; RET               ; Return

*********************************************************************
*
* For routines that set or reset the carry flag on return
*
return_with_carry:
       .pop  r11
return_with_carry_1:
       seto tmp0
       inc  tmp0
       rt

return_without_carry:
       .pop  r11
return_without_carry_1:
       clr  tmp0
       inc  tmp0
       rt

