*********************************************************************************
* Through the Trapdoor
*
* Copyright (c) 1987 Don Priestley / Piranha / Alternative Software Ltd (Through the Trap Door)
*
* SkoolKit disassembly copyright (c) 2017 Philip M. Anderson
*
* TI-99/4A version by Rasmus Moustgaard April 2023
*********************************************************************************

**
* Set Up Random Seed and Disable Interrupts
*
       limi 0                          ; DI                ; Disable interrupts
       lwpi wrksp
       mov  @rndsd,@rnd_seed            ; LD A,(23672)      ; Store the least significant byte of the system variable FRAMES...
                                        ; LD (54219),A      ; ...at 54219 as the seed for the pseudo-random number generator
       li   one,>0100
       li   tmp0,>fffe
       mov  tmp0,@b255
       li   sp,stack                   ; LD SP,34426       ; Set Stack Pointer
       bl   @init_bits
       bl   @copy_to_pad
       bl   @mute_sound
       bl   @graphics_mode
       bl   @title_screen
       bl   @wait_release_and_keypress
       seto @graphics_bank_select
;      bl   @copy_initial_state_data   ; CALL 34695        ; Copy State Data for all resettable complex entities into Table of Initial-State Data
       clr  @graphic_set_index         ; graphic_set_index + display_buffer_flag

*********************************************************************************
* Display Main Menu and Handle Main Game Loop
main:
       movb one,@current_level         ; LD A,1            ; Set current level to 1...
                                       ; LD (34207),A      ; ...
       bl   @main_menu                 ; CALL 46830        ; Display and handle Main Menu
       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
       bl   @set_border_color          ; OUT (254),A       ; Set border colour
       bl   @init_level_data           ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @draw_timer_bar            ; CALL 47241        ; Reset Show Score Flag and draw timer figures bar
*      Debug: start at other level
       .ifne start_at_level,1
       li   a,(start_at_level-1)*256
       movb a,@current_level
       bl   @init_level_data
       .ifeq start_at_level,2
       li   tmp0,level_1_exit_door
       .endif
       .ifeq start_at_level,3
       li   tmp0,rev_col_check_addr_2
       .endif
       .ifeq start_at_level,4
       li   tmp0,state_data_complex_3
       .endif
       .ifeq start_at_level,5
       socb @bits+3,@flying_skeleton+9 ; Set Berk and Drutt through the trap door flag
       li   tmp0,level_4_door
       .endif
       mov  tmp0,@berk_interaction_state
       bl   @next_level
       .endif
*      Debug - end
* Start of main loop
main_loop:
       bl   @snd_player
       bl   @check_berk_killed         ; CALL 53723        ; If Berk has been killed then reset his state, flash screen and decrease time / lives
       bl   @update_berk_state         ; CALL 35689        ; Update state of Berk and store current position in script data
       bl   @update_drutt_worm_state   ; CALL 51739        ; Update states of Drutt and worm and store current positions in script data
       mov  @update_level_entities_addr,tmp0               ; Get routine to update entities
       bl   *tmp0                                          ; ...and call it
       cb   @current_level,one         ; LD A,(34207)      ; If current level is not Level 1...
                                       ; CP 1              ; ...
       jne  main_all_levels            ; JR NZ,34527       ; ...then skip ahead to #R34527
* Level 1
                                       ; CALL 36791        ; Update states of all Level 1 entities
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       movb @10(ix),tmp0               ; BIT 2,(IX+10)     ; If "Back to Level 1" Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  main_all_levels            ; JR Z,34557        ; ...then skip ahead to #R34557
* Back to Level 1 Flag is set
       movb @bonis_state_data_1+6,a    ; LD A,(43612)      ; If y-coordinate of Boni's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1+6,a   ; LD A,(43677)      ; If y-coordinate of Drutt's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1,a     ; LD A,(43671)      ; If Drutt's room is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @bytes+2,a                 ; LD A,2            ; Set depth of "Home Sweet Home" brickwork to 2...
       movb a,@state_data_simple_1+13  ; LD (43159),A      ; ...
       socb @bits+3,@10(ix)            ; SET 3,(IX+10)     ; Set "All Home" Flag
                                       ; JR 34557          ; Skip ahead to #R34557
                                       ; LD A,(34207)      ; If current level is not Level 2...
                                       ; CP 2              ; ...
                                       ; JR NZ,34537       ; ...then skip ahead to #R34537
* Level 2
                                       ; CALL 38009        ; Update states of all Level 2 entities
;main_check_level_3:
                                       ; LD A,(34207)      ; If current level is not Level 3...
                                       ; CP 3              ; ...
                                       ; JR NZ,34547       ; ...then skip ahead to #R34547
* Level 3
                                       ; CALL 39137        ; Update states of all Level 3 entities
;main_check_level_4:
                                       ; LD A,(34207)      ; If current level is not Level 4...
                                       ; CP 4              ; ...
                                       ; JR NZ,34557       ; ...then skip ahead to #R34557
* Level 4
                                       ; CALL 41211        ; Update states of all Level 4 entities
* All levels
main_all_levels:
       bl   @snd_player
       bl   @check_control_input       ; CALL 47893        ; Check for control input and store at #R34219
       bl   @check_quit
       bl   @snd_player
       bl   @move_falling_entities     ; CALL 55525        ; Move all falling entities down by distances appropriate to their current velocity factors
       bl   @swap_characters           ; CALL 34916        ; If Fire Pressed, or Character Swap Pending Flag set, then swap characters
       bl   @snd_player
       bl   @clear_display_buffer      ; CALL 53782        ; Set each value in Primary Display Buffer within play area to zero
       bl   @snd_player
       bl   @populate_display_buffer   ; CALL 45899        ; Populate Primary Display Buffer with layout data for current character's current room
       bl   @snd_player
       bl   @draw_display_buffer       ; CALL 54034        ; Draw contents of Primary Display Buffer to display
       bl   @snd_player                ; CALL 59725        ; Play and clear pending sound (index as stored at #R34273)
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
                                       ; OR A              ; If no time / lives are left...
       jeq  time_out                   ; JR Z,34645        ; ...then jump to #R34645
       movb @berks_state_data_1+10,a   ; LD A,(43603)      ; If "All Home" Flag is set...
       andi a,8*256                    ; BIT 3,A           ; ...
       jne  all_home                   ; JR NZ,34658       ; ...then skip ahead to #R34658
       bl   @update_timer              ; CALL 47363        ; Update eyes of a randomly selected timer figure, increase Timer Tick Counter and process
                                                           ; timer figure blinking
       bl   @snd_player
                                       ; LD HL,34208       ; If Update Scores and Display Flag is reset...
       abs  @game_flag_5               ; BIT 5,(HL)        ; ...
       jeq  skip_update_score          ; JR Z,34606        ; ...then skip ahead to #R34606
       clr  @game_flag_5               ; RES 5,(HL)        ; Reset Update Scores and Display Flag
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
       bl   @snd_player
skip_update_score:
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a     ; LD A,(34271)      ; Invert "Display Buffer 2 is Primary" Flag...
       xor  one,a                      ; XOR 1             ; ...
       movb a,@display_buffer_flag     ; LD (34271),A      ; ...
       jeq  skip_swap_buffers          ; JR Z,34623        ; If "Display Buffer 2 is Primary" Flag is reset then skip ahead to #R34623 (Display Buffer 1
                                                           ; is Primary, Display Buffer 2 is Secondary)
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
skip_swap_buffers:
       mov  hl,@prim_disp_buffer_addr  ; LD (34279),HL     ; Store address of Primary Display Buffer at #R34279
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       andi a,64*256                   ; BIT 6,A           ; If Restart hasn't been pressed...
       jne  restart                    ; JP Z,34466        ; ...then jump to #R34466 (start of main loop)
       jmp  main_loop                  ;
* Restart has been pressed
restart:
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound_and_play    ; CALL 59722        ; ...
       bl   @reset_game_data           ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
* No time/lives left
time_out:
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
       bl   @print_times_up            ; CALL 47185        ; Print "SORRY BERK,  BUT YOUR TIME IS UP" string
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound_and_play    ; CALL 59722        ; ...
       jmp  wait_key_and_restart       ; JR 34666          ; Skip ahead to #R34666
* "All Home" Flag is set
all_home:
       bl   @print_home_sweet_home     ; CALL 47213        ; Print "HOME SWEET HOME" string
       movb @bytes+3,a                 ; LD A,3            ; Set sound 3 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound_and_play    ; CALL 59722        ; ...
wait_key_and_restart:
       bl   @wait_release_and_keypress ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
       bl   @reset_game_data           ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
*// main

*********************************************************************************
* Pause
*
* Used by the routine at #R53649. Input:  B  Repeat count for outer loop C  Additional repeat count for inner loop
;pause:
;       .push bc                        ; PUSH BC           ; Store BC
;       movb @bytes+10,b                ; LD B,10           ; Set B to 10
;pause_1:
;       dec  bc                         ; DEC BC            ; Decrease BC
;       movb b,a                        ; LD A,B            ; If BC is not zero...
;       socb @c,a                       ; OR C              ; ...
;       jne  pause_1                    ; JR NZ,34678       ; ...then loop back to #R34678
;       .pop bc                         ; POP BC            ; Restore BC
;       sb   one,b                      ; DJNZ 34675        ; Loop back for next pass
;       jne  pause                      ;
;       .ret                            ; RET               ; Return
;*// pause

*********************************************************************************
* Display and Handle Main Menu
*
* Used by the routine at #R34438.
main_menu:
       .proc
       movb one,a                      ; LD A,1            ; Load A with 1 (blue)
       movb a,@border_color            ; LD (34217),A      ; Store at #R34217 and...
       bl   @set_border_color          ; OUT (254),A       ; ...set border to this value (blue)
       movb @bytes+9,a                 ; LD A,9            ; Fill top 22 rows of Attribute File with blue PAPER & blue INK...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @print_title               ; CALL 47140        ; Print "THROUGH the TRAPDOOR" string
       bl   @print_score_strings       ; CALL 47628        ; Print SCORE / TOTAL / HI-SC string in current character's colours
       li   ix,main_menu_addrs         ; LD IX,46690       ; Point IX at Table of Attribute File Addresses for Main Menu Strings
       li   iy,main_menu_strings       ; LD IY,46710       ; Point IY at start of Table of Main Menu Strings
       movb @bytes+112,a               ; LD A,112          ; Load A with 112 (black INK on yellow PAPER)
       movb a,@print_attr              ; LD (34269),A      ; Store at #R34269
       movb @bytes+10,b                ; LD B,10           ; Load B with 10 as there are 10 strings to print (loop counter)
main_menu_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of strings to print)
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address at which to print text into HL...
                                       ; LD H,(IX+1)       ; ...
       movb @bytes+12,b                ; LD B,12           ; Load B with 12 as there are 12 characters to print (loop counter)
main_menu_2:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining characters to print)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load E with text character to print
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  iy                         ; INC IY            ; Advance IY to next character in text to print
       inc  hl                         ; INC HL            ; Advance to next Attribute File location
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining characters to print)
       sb   one,b                      ; DJNZ 46872        ; Loop back for next character
       jne  main_menu_2                ;
       inct ix                         ; INC IX            ; Advance IX to next entry in list of Attribute File addresses to print to...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of strings to print)
       sb   one,b                      ; DJNZ 46863        ; Loop back for next string
       jne  main_menu_1                ;
;       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
* This entry point is used by the routine at #R46968.
;main_menu_3:
       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
;       cb   a,@bytes+83               ; CP 83             ; If pressed key was not 83 (S)...
;       jne  main_menu_4               ; JR NZ,46915       ; ...then skip ahead to #R46915
                                       ; LD A,2            ; Set current border colour to red...
       movb @bytes+2,@border_color     ; LD (34217),A      ; ...
;       bl   @set_border_color          ; OUT (254),A       ; ...
       .endproc                        ; RET               ; Return
;main_menu_4:
;       cb   a,@bytes+74                ; CP 74             ; If pressed key was not 74 (J)...
;       jne  _46968                     ; JR NZ,46968       ; ...then jump to #R46968 (if "K" pressed then redefine controls)
;       movb @joystick_mode_flag,a      ; LD A,(34298)      ; If we are in Joystick Mode...
;       socb a,a                        ; OR A              ; ...
;       jne  main_menu_5                ; JR NZ,46937       ; ...then skip ahead to #R46937
;       bl   @check_for_joystick        ; CALL 47043        ; If Kempston Interface not present, or Kempston Joystick moved / fire pressed...
;       joc  main_menu_3                ; JR C,46900        ; ...then jump to #R46900
;       movb one,a                      ; LD A,1            ; Set Joystick Mode to On...
;       movb a,@joystick_mode_flag      ; LD (34298),A      ; ...(see trivia)
;       jmp  main_menu_6                ; JR 46938          ; Skip ahead to #R46938
;main_menu_5:
;       sb   one,a                      ; DEC A             ; Set Joystick Mode to Off...
;main_menu_6:
;       movb a,@joystick_mode_flag      ; LD (34298),A      ; ...
;       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
;       jmp  main_menu_3                ; JR 46900          ; Loop back to #R46900

* Draw Joystick "J" (Main Menu) in Colour Depending Upon Joystick Mode
*
* Used by the routine at #R46830.
;draw_joystick_j:
;       .proc
;       movb @joystick_mode_flag,a      ; LD A,(34298)      ; If Joystick Mode Flag is set...
;                                       ; OR A              ; ...
;       jne  draw_joystick_j_1          ; JR NZ,46956       ; ...then skip ahead to #R46956
;       movb @bytes+112,a               ; LD A,112          ; Load A with attribute value for black INK, yellow PAPER, BRIGHT
;       jmp  draw_joystick_j_2          ; JR 46958          ; Skip ahead to #R46958
;draw_joystick_j_1:
;       movb @bytes+114,a               ; LD A,114          ; Load A with attribute value for red INK, yellow PAPER, BRIGHT
;draw_joystick_j_2:
;       movb @bytes+74,@e               ; LD E,74           ; Load E with 74 (index for character "J")
;       li   ix,main_menu_addrs_kempston ; LD IX,46694       ; Point IX at entry for "J +KEMPSTON " in table of Attribute File addresses at which to print
;                                                           ; menu strings
;       bl   @set_and_print_dbl_height  ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;       .endproc                        ; RET               ; Return

;* If "K" Pressed then Redefine Controls
;*
;* Used by the routine at #R46830. Input:  A  ASCII code of pressed key
;_46968:
;       cb   a,@bytes+75                ; CP 75             ; If pressed key was not 75 (K)...
;       jne  main_menu_3                ; JR NZ,46900       ; ...then jump to Main Menu handling routine at #R46900
;       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at start of Table of Current Keyboard Controls
;_46977:
;       movb @bytes+63,*hl              ; LD (HL),63        ; Set current entry in table to 63 (ASCII code for "?")
;       inc  hl                         ; INC HL            ; Advance HL to next entry
;       sb   one,b                      ; DJNZ 46977        ; Decrease remaining number of controls to change and loop back to #R46977 if not zero
;       jne  _46977                     ;
;       movb @bytes+112,a               ; LD A,112          ; Load A with the attribute value for black INK, yellow PAPER, BRIGHT
;       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
;       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
;       li   ix,main_menu_addrs_dirs    ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
;                                                           ; print for main menu
;       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
;_46997:
;       .push bc                        ; PUSH BC           ; Store BC (remaining number of controls to define)
;       movb @bytes+198,a               ; LD A,198          ; Load A with 198 (yellow INK, black PAPER, BRIGHT, FLASH)
;       movb @bytes+32,@e               ; LD E,32           ; Load E with 32 (" ")
;       bl  @set_and_print_dbl_height   ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;_47005:
;       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
;       bl   @is_direction_key          ; CALL 47060        ; If key pressed matches a direction, or the Berk / Drutt key...
;       jeq  _47005                     ; JR Z,47005        ; ...then loop back to #R47005
;       movb a,@e                       ; LD E,A            ; Load keycode of pressed control into E...
;       movb @e,*iy+                    ; LD (IY+0),E       ; ...and store in Table of Current Keyboard Controls
;                                       ; INC IY            ; Advance IY to next control
;       movb @bytes+113,a               ; LD A,113          ; Load A with 113 (blue INK, yellow PAPER, BRIGHT)
;       bl @set_and_print_dbl_height    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;       inct ix                         ; INC IX            ; Advance IX to next entry in table of Attribute File addresses...
;                                       ; INC IX            ; ...
;       .pop bc                         ; POP BC            ; Restore BC (remaining number of controls to define)
;       sb   one,b                      ; DJNZ 46997        ; Decrease remaining number of controls to define and loop back to #R46997 if not zero
;       jne  _46997                     ;
;       sb   a,a                        ; XOR A             ; Switch Joystick Mode to Off...
;       movb a,@joystick_mode_flag      ; LD (34298),A      ; ...
;       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
;       bl @print_keyboard_controls     ; CALL 47084        ; Print keyboard controls on main menu
;       b    @main_menu_3               ; JP 46900          ; Jump to Main Menu handling routine at #R46900

* Set Carry Flag if Kempston Interface not Present, or Kempston Joystick Moved / Fire Pressed
*
* Used by the routine at #R46830. Output: F  Carry Flag set if Kempston Interface not present, Kempston Joystick
* moved or fire pressed, reset otherwise
;check_for_joystick:
;       .proc
;       sb   b,b                        ; LD B,0            ; Set B to zero (to repeat check loop 256 times)
;_47045:
;       ; IN A,(31)                     ; IN A,(31)         ; Read value from Port 31 into A (Kempston Interface)
;       socb a,a                        ; OR A              ; If retrieved value is not zero (i.e. Kempston Interface not present, or Kempston Joystick not
;                                                           ; centred / fire button pressed)...
;       jne  _47053                     ; JR NZ,47053       ; ...then skip ahead to #R47053
;       sb   one,b                      ; DJNZ 47045        ; Decrease B (loop counter) and loop back to #R47045 to check Kempston status again if counter
;       jne  _47045                     ;
;                                                           ; not zero
;       .ret                            ; RET               ; Return
;_47053:
;       movb @bytes+6,a                 ; LD A,6            ; Set sound 6 as pending if appropriate, then play and clear pending sound...
;       bl   @request_sound             ; CALL 59722        ; ...
;       ; SCF                           ; SCF               ; Set Carry Flag
;       .ret                            ; RET               ; Return
;       b    @return_without_carry

*********************************************************************************
* Set Zero Flag if Key Whose Index is in A Matches a Direction, or the Berk / Drutt Key
*
* Used by the routine at #R46968. Input:  A  Index of pressed key Output: F  Zero Flag set if input key index
* matches an entry in table at #R46683, reset otherwise HL  Address of matching entry in table at #R46683 (if match
* found)
;is_direction_key:
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
;       movb @bytes+5,b                 ; LD B,5            ; Load B with 5 (as we are checking the first five defined keys, see bugs)
;is_direction_key_1:
;       cb   a,*hl                      ; CP (HL)           ; If character code at current HL position matches the key we are checking...
;       jeq  is_direction_key_2         ; RET Z             ; ...then return with Zero Flag set
;       inc  hl                         ; INC HL            ; Advance HL to next character in keyboard controls table
;       sb   one,b                      ; DJNZ 47065        ; Loop back to #R47065 to check next control
;       jne  is_direction_key_1                     ;
;is_direction_key_2:
;       rt                              ; RET               ; Return
*// is_direction_key

*********************************************************************************
* Set Attribute and Location and Print Double-Height Character in E
*
* Used by the routines at #R46946 and #R46968. Input:  A  Attribute for character to print E  Character to print IX
* Points to memory location holding Attribute File address at which to print character
;set_and_print_dbl_height:
;       .proc
;       movb a,@print_attr              ; LD (34269),A      ; Set text printing attribute to value in A
;       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address to print character to into HL...
;                                       ; LD H,(IX+1)       ; ...
;       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
;       .endproc                        ; RET               ; Return
*// set_and_print_dbl_height

*********************************************************************************
* Print Keyboard Controls on Main Menu
*
* Used by the routines at #R46830 and #R46968. Input:  A  Attribute for printing text
print_keyboard_controls:
       .proc
       movb a,@print_attr              ; LD (34269),A      ; Set attribute for printing text
       li   ix,main_menu_dir_addrs    ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
                                                           ; print
       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7, as there are 7 keyboard controls (loop counter)
_47097:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining control keys)
       mov  *ix+,hl                    ; LD L,(IX+0)       ; Load HL with Attribute File address at which to print character...
                                       ; LD H,(IX+1)       ; ...
       movb *iy+,@e                    ; LD E,(IY+0)       ; Load E with character to print (current keyboard control)
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IY            ; Advance IY to next keyboard control
                                       ; INC IX            ; Advance IX to next entry in list of Attribute File addresses...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining control keys)
       sb   one,b                      ; DJNZ 47097        ; Loop back to #R47097 for next keyboard control
       jne  _47097                     ;
       .endproc                        ; RET               ; Return
*// print_keyboard_controls

*********************************************************************************
* Print "THROUGH the TRAPDOOR" String
*
* Used by the routine at #R46830.
print_title:
       .proc
       movb @bytes+20,b                ; LD B,20           ; Load B with 20 (length of string to print)
       li   hl,22566                   ; LD HL,22566       ; Point HL at position to start printing text in Attribute File
       movb @bytes+79,a                ; LD A,79           ; Load A with 79, for blue PAPER, white INK, BRIGHT
       li   ix,title_text              ; LD IX,47120       ; Point IX to text to print
       jmp  print_text                 ; JR 47224          ; Print the text and return
*// print_title

*********************************************************************************
* Print "SORRY BERK,  BUT YOUR TIME IS UP" String
*
* Used by the routine at #R34438.
print_times_up:
       .proc
       movb @bytes+32,b                ; LD B,32           ; Load B with 32 (length of string to print)
       movb @bytes+199,a               ; LD A,199          ; Load A with 199, for black PAPER, white INK, BRIGHT, FLASH
       li   ix,sorry_berk_text         ; LD IX,47153       ; Point IX to text to print
       li   hl,23232                   ; LD HL,23232       ; Point HL at position at which to start printing text in Attribute File (start of second-last
                                                           ; row)
       jmp  print_text                 ; JR 47224          ; Print the text and return
*// print_times_up

*********************************************************************************
* Print "HOME SWEET HOME" String
*
* Used by the routine at #R34438.
print_home_sweet_home:
       .proc
       movb @bytes+15,b                ; LD B,15           ; Set string length to 15
       movb @bytes+68,a                ; LD A,68           ; Set attribute to green INK on black PAPER, BRIGHT
       li   ix,home_sweet_home_text                  ; LD IX,47198       ; Point IX at "HOME SWEET HOME" text
       li   hl,22792                   ; LD HL,22792       ; Point HL at Attribute File address at which to print text
*// print_home_sweet_home:

*********************************************************************************
* This entry point is used by the routines at #R47140 and #R47185.
print_text:
       movb a,@print_attr              ; LD (34269),A      ; Store attribute at #R34269
print_text_1:
       .push bc                        ; PUSH BC           ; Store BC (B=remaining length of text)
       movb *ix+,@e                    ; LD E,(IX+0)       ; Load character of text to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IX            ; Advance IX to next text character to print
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address at which to print
       .pop bc                         ; POP BC            ; Restore BC (B = remaining length of text)
       sb   one,b                      ; DJNZ 47227        ; Decrease remaining length of text by one and repeat loop for next character
       jne  print_text_1               ;
       .endproc                        ; RET               ; Return
*// print_text

*********************************************************************************
* Copy State Data for all Resettable Complex Entities into Table of Initial-State Data for Complex Entities
* 
* Used by the routine at #R34438.
;copy_initial_state_data:
;       .proc
;       li   iy,level_data_table        ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
;       li   tmp0,initial_entity_states ; LD DE,59821       ; Point DE at start of Table of Initial-State Data for Complex Entities
;       bl   @vwad
;       li   bc,4                       ; LD B,4            ; Set B to 4 (as there are 4 levels)
;copy_initial_state_data_1:
;       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
;       mov  *iy+,ix
;       mov  @2(ix),ix                  ; LD L,(IY+0)       ; Load start address of current level's complex state data into HL...
;                                       ; LD H,(IY+1)       ; ...
;                                       ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
;                                       ; INC IY            ; ...
;                                       ; PUSH HL           ; Transfer start address of current level's complex state data into IX...
;                                       ; POP IX            ; ...
;copy_initial_state_data_2:
;                                       ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
;       cb   *ix,@b255             ; CP 255            ; ...
;       jeq  copy_initial_state_data_4  ; JR Z,34747        ; ...then skip ahead to #R34747
;       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
;       andi a,128*256                  ; AND 128           ; ...
;       jeq  copy_initial_state_data_3  ; JR Z,34740        ; ...then advance IX by 13 bytes to next entry and loop back to #R34718
;       mov  ix,hl                      ; PUSH IX           ; Transfer start address of current entry in complex state data into HL...
;                                       ; POP HL            ; ...
;       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
;!      movb *hl+,@vdpwd                ; LDIR              ; Copy current entry in complex state data into Table of Initial-State Data for Complex
;       dec  bc                                             ; Entities at #R59821
;       jne  -!
;copy_initial_state_data_3:
;       ai   ix,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
;                                       ; ADD IX,BC         ; Advance IX to next entry in complex state data
;       jmp  copy_initial_state_data_2  ; JR 34718          ; Loop back to #R34718
;copy_initial_state_data_4:
;       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
;       dec  bc                         ; DJNZ 34704        ; Decrease B and loop back to #R34704 to process next level
;       jne  copy_initial_state_data_1  ;
;       .endproc                        ; RET               ; Return

*********************************************************************************
* Reset All Game Data in Preparation for New Game
* 
* Used by the routine at #R34438.
reset_game_data:
       .proc
;       li   iy,level_data_table        ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
;       li   tmp0,initial_entity_states ; LD HL,59821       ; Point HL at start of Table of Initial-State Data for Complex Entities
;       bl   @vrad
;       li   bc,4                       ; LD B,4            ; Set B to 4 (as there are 4 levels)
;reset_game_data_1:
;       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
;       mov  *iy+,ix
;       mov  @2(ix),ix                  ; LD E,(IY+0)       ; Load start address of current level's complex state data into DE...
;                                       ; LD D,(IY+1)       ; ...
;                                       ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
;                                       ; INC IY            ; ...
;                                       ; PUSH DE           ; Transfer start address of current level's complex state data into IX...
;                                       ; POP IX            ; ...
;reset_game_data_2:
;                                       ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
;       cb   *ix,@b255             ; CP 255            ; ...
;       jeq  reset_game_data_4          ; JR Z,34803        ; ...then skip ahead to #R34803
;       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
;       andi a,128*256                  ; AND 128           ; ...
;       jeq  reset_game_data_3          ; JR Z,34796        ; ...then advance IX by 13 bytes to next entry and loop back to #R34774
;       mov  ix,de                      ; PUSH IX           ; Transfer start address of current entry in complex state data into DE...
;                                       ; POP DE            ; ...
;       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
;!      movb @vdprd,*de+                ; LDIR              ; Copy current entry in Table of Initial-State Data for Complex Entities at #R59821 into
;       dec  bc                                             ; complex state data
;       jne  -!
;reset_game_data_3:
;       ai   ix,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
;                                       ; ADD IX,BC         ; Advance IX to next entry in complex state data
;       jmp  reset_game_data_2          ; JR 34774          ; Loop back to #R34774
;reset_game_data_4:
;       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
;       dec  bc                         ; DJNZ 34760        ; Decrease B and loop back to #R34760 to process next level
;       jne  reset_game_data_1          ;
                                       ; LD HL,34298       ; Point HL at Joystick Mode Flag
                                       ; LD DE,34207       ; Point DE at store for current level number
       sb   a,a                        ; XOR A             ; Set A to zero and reset Carry Flag
                                       ; SBC HL,DE         ; Subtract DE from HL to leave HL = 91
       li   bc,clear_data_end-clear_data_start ; LD B,L            ; Load B with 91
       li   hl,clear_data_start        ; LD HL,34207       ; Point HL at store for current level number...
reset_game_data_5:
       movb a,*hl+                     ; LD (HL),A         ; ...and set 91 bytes from here onwards to zero...
                                       ; INC HL            ; ...
       dec  bc                         ; DJNZ 34819        ; ...
       jne  reset_game_data_5          ;
       movb @bytes+16,@time_left       ; LD A,16           ; Set time / lives to 16...
                                       ; LD (34210),A      ; ...
       movb one,@current_level         ; LD A,1            ; Set current level to Level 1...
                                       ; LD (34207),A      ; ...
       bl   @reset_skeleton_and_bat    ; CALL 36778        ; Initialise script data positions for Flying Skeleton Creature and Bat (Level 1)
       bl   @reset_apebeasts           ; CALL 38468        ; Reset current positions in apebeasts' script data to initial values
       bl   @reset_skeleton            ; CALL 41354        ; Reset Skeleton to initial state
       bl   @reset_drutt               ; CALL 51732        ; Reset Drutt to initial state
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" and impassable marker to 1 (i.e. starting room)...
       movb a,@closed_trap_door        ; LD (43188),A      ; ...
       movb a,@marker                  ; LD (43450),A      ; ...
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of current character to 1 (blue, Berk)
       sb   one,a                      ; DEC A             ; Set room of "Open Trap Door" and "Home Sweet Home" brickwork to 0...
       movb a,@opened_trap_door        ; LD (43437),A      ; ...i.e. remove from game...
       movb a,@home_sweet_home+1       ; LD (43159),A      ; ...
       .endproc                        ; RET               ; Return
*// reset_game_data

*********************************************************************************
* Initialise Script Data Positions for Flying Skeleton Creature and Bat (Level 1)
*
* Used by the routine at #R34751.
reset_skeleton_and_bat:
       li   hl,boni_kidnap_script      ; LD HL,36803       ; Load HL with start address of script data for Boni's kidnap...
       mov  hl,@boni_kidnap_script_pos ; LD (36801),HL     ; ...and store this as the current script data position at #R36801
       li   hl,bat_script              ; LD HL,37018       ; Load HL with start address of script data for Bat (not attacking)...
       mov  hl,@bat_script_pos         ; LD (37016),HL     ; ...and store this as the current script data position at #R37016
       rt                              ; RET               ; Return
*// reset_skeleton_and_bat

*********************************************************************************
* Reset Current Positions in Apebeasts' Script Data to Initial Values
*
* Used by the routine at #R34751.
reset_apebeasts:
       li   de,apebeasts_script_data_pos ; LD DE,38424       ; Point DE at Table of Current Positions in Apebeasts' Script Data
       li   hl,apebeasts_script_data_init ; LD HL,38416       ; Point HL at Table of Initial Positions in Apebeasts' Script Data
       li   bc,8                       ; LD BC,8           ; Load BC with 8 (as there are eight bytes to copy)
       .ldir                           ; LDIR              ; Overwrite addresses in Table of Current Positions with those from Table of Initial Positions
       rt                              ; RET               ; Return
*// reset_apebeasts

*********************************************************************************
* Reset Skeleton to Initial State
*
* Used by the routine at #R34751.
reset_skeleton:
       li   hl,skeleton_idling_script  ; LD HL,41232       ; Set current position in Skeleton's script data...
       mov  hl,@skeleton_script_pos    ; LD (41230),HL     ; ...to #R41232 (Skeleton Idling)
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       li   bc,6                       ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
reset_skeleton_1:
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
                                       ; LD H,(IX+1)       ; ...
       movb @bytes+7,*hl               ; LD (HL),7         ; Set the attribute value to 7 (white)
       inct ix                         ; INC IX            ; Advance IX to next address...
                                       ; INC IX            ; ...
       dec  bc                         ; DJNZ 41366        ; Decrease remaining number of blocks to modify and loop back to #R41366 if not zero
       jne  reset_skeleton_1           ;
       rt                              ; RET               ; Return
*// reset_skeleton

*********************************************************************************
* Reset Drutt to Initial State
*
* Used by the routine at #R34751.
reset_drutt:
       li   hl,drutt_facing_out_script ; LD HL,51524       ; Set current position in Drutt's script data...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...to #R51524 (Drutt facing out of screen)
       rt                              ; RET               ; Return
*// reset_drutt

*********************************************************************************
* If Fire Pressed, or Character Swap Pending Flag Set, then Swap Characters
* 
* Used by the routine at #R34438.
swap_characters:
       .proc
                                       ; LD HL,34208       ; If Character Swap Pending Flag is reset...
       abs  @game_flag_6               ; BIT 6,(HL)        ; ...
       jeq  swap_characters_1          ; JR Z,34927        ; ...then skip ahead to #R34927
       clr  @game_flag_6               ; RES 6,(HL)        ; Reset Character Swap Pending Flag
       jmp  swap_characters_4          ; JR 34944          ; Skip ahead to #R34944
swap_characters_1:
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 4,A           ; If fire was pressed...
       andi tmp0,16*256                ;                   
       jne  swap_characters_3          ; JR NZ,34940       ; ...then skip ahead to #R34940
       clr  @game_flag_1               ; RES 1,(HL)        ; Reset Characters Already Swapped Flag
swap_characters_2:
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .endproc                        ; RET               ; Return
* [Fire pressed]
swap_characters_3:
       abs  @game_flag_1               ; BIT 1,(HL)        ; If Characters Already Swapped Flag set (i.e. FIRE hasn't been released since last swap)...
       jne  swap_characters_2          ; JR NZ,34936       ; ...then jump back to #R34936
swap_characters_4:
       seto @game_flag_1               ; SET 1,(HL)        ; Set Characters Already Swapped Flag
                                       ; LD A,(HL)         ; Load Game Flags into A
       abs  @game_flag_0               ; TODO
       dec  @game_flag_0               ; XOR 1             ; Flip bit 7 (Berk / Drutt flag)...
                                       ; LD (HL),A         ; ...
                                       ; BIT 0,(HL)        ; If current character is now Berk (0)...
                                       ;
       jeq  swap_characters_5          ; JR Z,34958        ; ...then jump ahead to #R34958
       movb @bytes+6,a                 ; LD A,6            ; Load A with 6 (attribute for Drutt's timer indicator figures)
       jmp  swap_characters_6          ; JR 34960          ; Skip ahead to #R34960
swap_characters_5:
       movb one,a                      ; LD A,1            ; Load A with 1 (attribute for Berk's timer indicator figures)
swap_characters_6:
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of timer indicator figures to value in A
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
                                       ; LD HL,34208       ; If Show Score Flag is set...
       abs  @game_flag_7               ; BIT 7,(HL)        ; ...
       jeq  !                          ; JP NZ,47628       ; ...then print SCORE / TOTAL / HI-SC string in current character's colours and return
       b    @print_score_strings_0     ;
!
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, draw timer figures bar and return
*// swap_characters

*********************************************************************************
* Populate Primary Display Buffer with Layout Data for Current Character's Current Room
* 
* Used by the routine at #R34438.
populate_display_buffer:
       .proc
       ; LD HL,(34279)                 ; Modify instruction at #R46045 with address of Primary Display Buffer..
                                       ; LD (46046),HL     ; ...
       movb @tmp_room_dim_data,@c      ; LD A,(34230)      ; Load C with depth of current character's current room...
                                       ; LD C,A            ; ...
       movb @current_chars_room,b      ; LD A,(34218)      ; Load B with index of current character's current room...
                                       ; LD B,A            ; ...
                                       ; LD D,0            ; Load D with zero
* Start drawing simple entities
populate_display_buffer_1:
       mov  @current_level_data,ix     ; LD IX,(34236)     ; Load IX with start address of current level's simple state data
       li   de,6                       ; LD E,6            ; Load DE with 6 (as simple state data entries are 6 bytes wide)
populate_display_buffer_2:
       movb *ix,a                      ; LD A,(IX+0)       ; Load first byte of current simple state data entry into A
       cb   a,@b255                    ; CP 255            ; If this is 255 (end marker for complex state data)...
       jeq  populate_display_buffer_5  ; JR Z,45961        ; ...then skip ahead to #R45961
       cb   a,@b254                    ; CP 254            ; If it is not 254 (end marker for level's simple state data)...
       jne  populate_display_buffer_3  ; JR NZ,45939       ; ...then skip ahead to #R45939
* At this point, we have passed the end marker for the simple state data block and are now at the start of the
* complex state data block whose entries are 13 bytes wide.
       li   de,13                      ; LD E,13           ; Load DE with 13
       inc  ix                         ; INC IX            ; Advance IX to start of complex state data block
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with entity's room index
* At this point, A holds the index of the room to which the simple or complex entity belongs
populate_display_buffer_3:
       cb   a,b                        ; CP B              ; If entity's room is not the same as the current character's current room...
       jne  populate_display_buffer_4  ; JR NZ,45957       ; ...then skip ahead to #R45957
       movb @c,a                       ; LD A,C            ; If entity's depth is not the same as current depth in C...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  populate_display_buffer_4  ; JR NZ,45957       ; ...then skip ahead to #R45957
       .push bc                        ; EXX               ; Switch registers
       .push de
       .push ix                        ; PUSH IX           ; Store IX (pointer to current entry in simple/complex state data)
       bl   @draw_entity               ; CALL 45965        ; Load Primary Display Buffer with graphic layout data for current entity
       .pop ix                         ; POP IX            ; Restore IX (pointer to current entry in simple/complex state data)
       .pop de                         ; EXX               ; Switch registers
       .pop bc
populate_display_buffer_4:
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next entity's state data
       jmp  populate_display_buffer_2  ; JR 45921          ; Loop back to #R45921
populate_display_buffer_5:
       bl   @snd_player
       sb   one,@c                     ; DEC C             ; Decrease current depth (i.e. closer to screen)
       jne  populate_display_buffer_1  ; JR NZ,45915       ; If depth is not zero (i.e. still depth levels to process) then loop back to #R45915
       .endproc                        ; RET               ; Return

*********************************************************************************
* Populate Primary Display Buffer with Graphic Layout Data for Entity Whose Simple / Complex State Data is at
* Address in IX
* 
* Used by the routine at #R45899. Input:  IX  Address of complex state data for an entity IX  (Entry at #R45999,
* #R46001 or #R46003 only) Address of graphic layout data to draw B  (Entry at #R45999, #R46001 or #R46003 only) 0
* if current position in Display Buffer needs to be recalculated. 1 otherwise.
draw_entity:
       .proc
       inct ix
       movb *ix+,d                     ; LD E,(IX+2)       ; Load DE with address of graphic layout data for entity...
       swpb de
       movb *ix+,d                     ; LD D,(IX+3)       ; ...
       movb @tmp_room_dim_data+3,h     ; LD A,(34233)      ; Load A with y-coordinate of top edge of current character's current room...
       ab   *ix+,h                     ; ADD A,(IX+4)      ; ...add y-coordinate of graphic element to draw as offset...
       sb   @bytes+100,h               ; SUB 100           ; ...subtract 100...
                                       ; LD L,A             ; ...and load into L
       swpb hl
       movb @tmp_room_dim_data+1,h     ; LD A,(34231)      ; Load A with x-coordinate of left edge of current character's current room...
       ab   *ix+,h                     ; ADD A,(IX+5)      ; ...add x-coordinate of graphic element to draw as offset...
       sb   @bytes+100,h               ; SUB 100           ; ...subtract 100...
                                       ; LD H,A            ; ...and load into H
       swpb hl                         ; Big endian
       mov  hl,@draw_coordinates       ; LD (34281),HL     ; Store x- and y-coordinates at #R34281
       swpb hl                         ; Little endian
       mov  de,ix                      ; PUSH DE           ; Transfer address of graphic layout data in simple/complex state data from DE...
                                       ; POP IX            ; ...into IX
       sb   b,b                        ; LD B,0            ; Reset Do Not Recalculate Display Buffer Address Flag, as address not yet calculated
       jmp  execute_gfx_script         ; JR 46003          ; Jump to #R46003 (read / process data at address in IX)
* This entry point is used by the routines at #R46427, #R46442, #R46460 and #R46599.
inct_execute_gfx_script:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46284, #R46295 and #R46306.
inc_execute_gfx_script:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46317, #R46347, #R46363, #R46460, #R46481, #R46495, #R46611,
* #R46628, #R46647 and #R46664.
execute_gfx_script:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of graphic layout data entry is at least 236...
       cb   a,@bytes+236               ; CP 236            ; ...i.e. IX points to an instruction...
       jl   draw_graphics              ; JP NC,46218       ; ...then jump to appropriate graphic layout routine
       b    @jump_to_graphics_routine                    ;
* For recursive call
process_data_in_ix_call:
       .proc
       jmp  execute_gfx_script
*// draw_entity

*********************************************************************************
* At this point, the graphic layout data pointed to by IX is graphical data, not an instruction. We only draw the
* graphics if they lie within the display area (i.e. have x- and y-coordinates less than 32 and 24 respectively, see
* trivia).
draw_graphics:
                                       ; LD A,H            ; If x-coordinate of graphic to draw is 32 or more...
       cb   h,@bytes+32                ; CP 32             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
                                       ; LD A,L            ; If y-coordinate of graphic to draw is 24 or more...
       cb   @l,@bytes+22               ; CP 24             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
       .push hl                        ; PUSH HL           ; Store HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
       sb   one,b                      ; DEC B             ; Decrease value of Don't Recalculate Display Buffer Address Flag
       jeq  draw_graphics_1            ; JP Z,46051        ; If B is zero (i.e. we don't need to recalculate current position in display buffer), then
                                       ;                   ; skip ahead to #R46051
* If B was 1, then we need to load DE with the address of the current position in the Primary Display Buffer.
*      hl=000hhhhh000lllll
*      x=h=000hhhhh
*      y=l=000lllll
*      wanted=0000lllllhhhhh00
       swpb hl                         ; 000lllll000hhhhh
       mov  hl,de                      ; 000lllll000hhhhh
       sla  de,3                       ; lllll000hhhhh000
       movb h,d                        ; 000lllllhhhhh000
       srl  de,1                       ; 0000lllllhhhhh00
       swpb hl                         ; 000hhhhh000lllll
;       movb h,a                        ; LD A,H            ; Load C with three times entity's x-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   h,a                        ; ADD A,H           ; ...
;       movb a,@c                       ; LD C,A            ; ...
;       movb @l,a                       ; LD A,L            ; Load DE with double entity's y-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       sb   d,d                        ; LD D,0            ; ...
;       movb d,b                        ; LD B,D            ; Set B to zero (BC now holds three times x-coordinate)
;       li   hl,multiples_of_96         ; LD HL,46170       ; Point HL at start of Table of Multiples of 96
;       a    de,hl                      ; ADD HL,DE         ; Add double y-coordinate as offset
;       mov  *hl,de                     ; LD E,(HL)         ; Load DE with corresponding multiple of 96...
;                                       ; INC HL            ; ...
;                                       ; LD D,(HL)         ; ...
* The operand of the instruction at #R46045 represents the address of the Primary Display Buffer. This is modified
* by the instruction at #R45902.
       a    @prim_disp_buffer_addr,de
;       li   hl,0                       ; LD HL,0           ; Load HL with start address of Primary Display Buffer
;       a    de,hl                      ; ADD HL,DE         ; Move HL to position in Primary Display Buffer corresponding to x- and y-coordinates of
;                                                           ; entity...
;       a    bc,hl                      ; ADD HL,BC         ; ...
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now points to position in Primary Display Buffer for current entity) and HL
draw_graphics_1:
       movb *de,a                      ; LD A,(DE)         ; Load A with Graphic Set Index plus one from this entry in Primary Display Buffer...
                                       ; INC A             ; ...and if value is now zero (i.e. old value was 255 corresponding to a block outside
                                                           ; dimensions of room)...
       jlt  draw_graphics_8            ; JP Z,46150        ; ...then skip ahead to #R46150
       movb @graphic_set_index,*de+    ; LD A,(34268)      ; Load current Graphic Set Index into this location in Primary Display Buffer...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to Graphic Index in current character block's entry in Primary Display Buffer
       movb *ix+,*de+                  ; LD A,(IX+0)       ; Load Graphic Index into current Display Buffer location...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to next byte in current character block's display buffer entry (Attribute)
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_2            ; JR NZ,46077       ; ...then skip ahead to #R46077
* Current Attribute is zero (i.e. not set) so DE points to attribute data
                                       ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)...
       movb *ix+,a                     ; LD A,(IX+0)       ; ...and load into A
* At this point, A holds an attribute value either from the graphic layout data, or the Current Attribute as stored
* at #R34270. This attribute is to be applied to the current display buffer location. IX (current position in
* graphic layout data) is pointing to either the graphic index (if the Current Attribute at #R34270 is set) or the
* attribute data (if the Current Attribute is not set). In either case, IX+1 is the address of the Cursor Shift
* byte. Bit 7 of the Cursor Shift byte is the Override Attribute Flag.
draw_graphics_2:
       movb *ix,tmp0                   ; BIT 7,(IX+1)      ; If bit 7 (Override Attribute Flag) is set...
                                       ;
       jlt  draw_graphics_4            ; JP NZ,46111       ; ...then skip ahead to #R46111
* Override Attribute Flag reset
       movb a,tmp0                     ; LD L,A            ; Load L with attribute value
       czc  @paper_bits,a
                                       ; AND 56            ; Check PAPER bits
                                       ; LD A,L            ; Restore attribute value to A
       jne  draw_graphics_4            ; JP NZ,46111       ; If PAPER is not zero (i.e. black) then skip ahead to #R46111
* The instructions between #R46091 and #R46110 (inclusive) are executed only when the PAPER component of the
* attribute in A (and L) is black. If the Preserve INK Flag is reset in the attribute value loaded (at #R46098) from
* the Display Buffer, then the instruction at #R46107 will leave the reset (i.e. black) PAPER bits in A. If the
* Preserve INK Flag is set, then the instructions between #R46104 and #R46106 (inclusive) will shift the bits used
* for INK into the PAPER positions and this PAPER colour (originally INK colour) will be preserved when the
* instruction at #R46107 is executed.
       andi a,192*256                  ; AND 192           ; Reset all bits except Preserve INK and Mirror flags
       movb a,b                        ; LD B,A            ; Load B with Preserve INK and Mirror flags
                                       ; LD A,L            ; Restore attribute value to A
       andi tmp0,63*256                ; AND 63            ; Reset bits Preserve INK and Mirror flags
                                       ; LD C,A            ; Load C with INK and PAPER bits of attribute value
       movb *de,a                      ; LD A,(DE)         ; Load value currently in Display Buffer into A...
       czc  @preserve_ink_flag,a       ; BIT 6,A           ; ...and if Preserve INK Flag is reset...
                                       ;
       jeq  draw_graphics_3            ; JP Z,46107        ; ...then skip ahead to #R46107
* Preserve INK Flag set in Display Buffer
       sla  a,3                        ; ADD A,A           ; Shift INK bits into PAPER bits...
                                       ; ADD A,A           ; ...
                                       ; ADD A,A           ; ...
draw_graphics_3:
       andi a,56*256                   ; AND 56            ; Reset all except PAPER bits
       socb b,a                        ; OR B              ; (Re)set Preserve INK and Mirror flags as stored in B previously
       socb tmp0,a                     ; OR C              ; Set INK bits as stored in C previously (PAPER was black)
draw_graphics_4:
       movb a,*de                      ; LD (DE),A         ; Load attribute in A into Display Buffer
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
* Read Cursor Shift byte. Bits 0-6 of this byte control where the cursor to write to Primary Display Buffer is moved
* to after writing the current character block. A value of 33 advances the cursor right by one character. A value,
* n, less than 33 moves the cursor down a character row, and left by 33-(n+1) characters. A value greater than 33
* moves the cursor right by (n+1)-33 characters. Bit 7 is the Override Attribute Flag.
       movb *ix,a                      ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       cb   a,@b255                    ; CP 255            ; ...and if this is 255 (End Marker)...
       jne  draw_graphics_4a           ; JP Z,46418        ; ...then jump to #R46418 (load HL with stored coordinates from #R34281 and return from
       dec  ix
       b    @graphics_routine_255                          ; drawing)
draw_graphics_4a:
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33, and if remaining value is 0 (i.e. original value was 33)...
       jeq  draw_graphics_7            ; JP Z,46140        ; ...then skip ahead to #R46140...
draw_graphics_5:
       cb   tmp0,@bytes+33
       jhe  draw_graphics_6            ; JP NC,46132       ; ...else, if value was greater than 33 then skip ahead to #R46132
* Cursor Shift byte was less than 33 (move the cursor down a character row, and left by 33-(n+1) characters)
       ab   one,@l                     ; INC L             ; Increase y-coordinate
draw_graphics_6:
       ab   one,a                      ; INC A             ; Increase A (x-coordinate offset) and add to x-coordinate...
       ab   h,a                        ; ADD A,H           ; ...
       movb a,h                        ; LD H,A            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address as change in coordinates is non-trivial
       jmp  inc_execute_gfx_script     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* Cursor Shift byte was 33 (move the cursor right by one character)
draw_graphics_7:
       inct de                         ; INC DE            ; Advance pointer to start of next entry in Primary Display Buffer
       ab   one,h                      ; INC H             ; Increase x-coordinate by one
                                       ; JP Z,46135        ; If x-coordinate is zero then jump back to #R46135 (see trivia)
       movb one,b                      ; LD B,1            ; Prepare to skip over recalculation of Display Buffer address as we moved right one character
       jmp  inc_execute_gfx_script     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* First byte in Primary Display Buffer entry for current position is 255 (i.e. outside dimensions of room)
draw_graphics_8:
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
draw_graphics_9:
       inc  ix
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_10           ; JP NZ,46160       ; ...then skip ahead to #R46160
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)
draw_graphics_10:
       movb *ix,a                      ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0                     ; required
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33...
       jmp  draw_graphics_5            ; JP 46128          ; ...and jump back to #R46128 to update current drawing position
*// draw_graphics

*********************************************************************************
* Reset Show Score Flag and Draw Timer Figures Bar
* 
* Used by the routines at #R34438, #R34916 and #R47468.
draw_timer_bar:
       .proc
draw_timer_bar_0:
                                       ; LD A,(34208)      ; Reset Show Score Flag...
       clr  @game_flag_7               ; RES 7,A           ; ...
                                       ; LD (34208),A      ; ...
       li   ix,zx_attributes+(22*32)   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
                                       ; OR A              ; ...and if zero...
       jeq  draw_timer_bar_2           ; JR Z,47267        ; ...then skip ahead 47267
       movb a,b                        ; LD B,A            ; Load number of lives into B
draw_timer_bar_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of open eyes to draw)
       bl   @draw_open_eyes            ; CALL 47315        ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of open eyes to draw)
       sb   one,b                      ; DJNZ 47260        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47260 if not
       jne  draw_timer_bar_1           ;                   ; zero          
                                                           
draw_timer_bar_2:
       movb @time_left,@e              ; LD A,(34210)      ; Load remaining time / lives into E...
                                       ; LD E,A            ; ...
       movb @bytes+16,a                ; LD A,16           ; Load A with number of lives lost by subtracting E from 16...
       sb   @e,a                       ; SUB E             ; ...
       jeq  draw_timer_bar_4           ; JR Z,47284        ; If zero, then skip ahead to #R47284
       movb a,b                        ; LD B,A            ; Load number of lost lives into B as counter for loop
draw_timer_bar_3:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of closed eyes to draw)
       bl   @draw_closed_eyes         ; CALL 47302         ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of closed eyes to draw)
       sb   one,b                      ; DJNZ 47277        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47277 if not
       jne  draw_timer_bar_3           ;                   ; zero
                                                           
draw_timer_bar_4:
       movb @bytes+27,@c               ; LD C,27           ; Set graphic index to 27 (timer figures' bodies)
       movb @current_character_attr,a  ; LD A,(34226)      ; Load attribute of current character into A
       movb @bytes+16,b                ; LD B,16           ; Load B with 16 (as 16 timer figures' bodies to draw)
draw_timer_bar_5:
       .push bc                        ; PUSH BC           ; Store B (remaining number of timer figure bodies to draw)
       bl   @draw_timer_part          ; CALL 47333         ; Draw left half of timer figure's body and invert mirror flag on attribute
       bl   @draw_timer_part          ; CALL 47333         ; Draw right half of timer figure's body
       .pop bc                         ; POP BC            ; Restore B (remaining number of timer figure bodies to draw)
       sb   one,b                      ; DJNZ 47291        ; Decrease B and loop back to #R47291
       jne  draw_timer_bar_5           ;                   
       .endproc                        ; RET               ; Return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Closed) at Attribute File Address IX and Advance IX
* by Two Bytes
* 
* Used by the routines at #R47241 and #R47363. Input:  IX  Pointer to a location in Attribute File
draw_closed_eyes:
       .proc
       bl   @ret_if_show_score_flag    ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47305
       movb @current_character_attr,a  ; LD A,(34226)      ; Load A with the attribute of the current character
       movb @bytes+28,@c               ; LD C,28           ; Load C with 28 (graphic index of timer figures' closed eyes)
       bl   @draw_timer_part           ; CALL 47333        ; Draw the left (closed) eye at Attribute File address in IX and advance IX by one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw the right (closed) eye at Attribute File address in IX, advance IX by one byte and
                                                           ; return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Open, Random Frame) at Attribute File Address IX and
* Advance IX by Two Bytes
* 
* Used by the routines at #R47241, #R47363 and #R47431. Input:  IX  Attribute File address at which to draw pair of
* eyes Output: IX  Attribute File address two bytes on from initial IX
draw_open_eyes:
       .proc
draw_open_eyes_0:
       bl  @ret_if_show_score_flag     ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47318
       bl  @draw_eye                   ; CALL 47323        ; Draw Timer Figure's left eye (random frame) at Attribute File address in IX and advance IX by
                                                           ; one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw Timer Figure's right eye (same frame as above), advance IX by one byte then return

* Draw a Timer Figure's Eye (Random Frame) at Attribute File Address in IX and Advance IX by One Byte
* 
* Used by the routine at #R47315. Input:  IX  (Entry at #R47323 and #R47333) Pointer to a location in Attribute File
* A  (Entry at #R47333 only) Attribute C  (Entry at #R47333 only) Graphic Index (e.g. 27 for timer figures' bodies)
* Output: A  Attribute (including inverted mirror flag) IX  Pointer to next location in Attribute File
draw_eye:
       .proc
       movb @bytes+5,a                 ; LD A,5            ; Load A with a random number, 0-4...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   @bytes+29,a                ; ADD A,29          ; Add 29 (as 29 is the index of the first of five eye direction graphics) in C...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+7,a                 ; LD A,7            ; Set attribute for timer indicator figures' eyes to white INK on black PAPER
       jmp  draw_timer_part_0

* This entry point is used by the routines at #R47241, #R47302 and #R47315.
draw_timer_part:
       .proc
draw_timer_part_0:
       movb @bytes+4,b                 ; LD B,4            ; Set Graphic Set Index to 4
       .push af                        ; PUSH AF           ; Store AF (A = attribute)
       .push bc                        ; PUSH BC           ; Store BC (B = graphic set index, C = graphic index)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
       .pop bc                         ; POP BC            ; Restore BC (B = graphic set index, C = graphic index)
       movb @c,a                       ; LD A,C            ; Load Graphic Index into A
       cb   a,@bytes+32                ; CP 32             ; If graphic index is less than 32 (i.e. we're not dealing with #32 - eyes looking right or #33
                                                           ; - eyes looking left and don't need to cancel inversion at 47350)...
       jl   draw_timer_part_1          ; JR C,47348        ; ...then skip ahead to #R47348
       xor  one,a                      ; XOR 1             ; Add or subtract 1 if Graphic Index is 32 or 33 respectively (Timer Figures' Eyes looking
                                                           ; right or left respectively) to cancel out inversion at 47350
draw_timer_part_1:
       movb a,@c                       ; LD C,A            ; Load Graphic Index into C
       .pop af                         ; POP AF            ; Restore AF (A = attribute)
       li   tmp0,128*256               ; XOR 128           ; Flip mirror flag to prepare to draw mirror image of just-drawn character block
       xor  tmp0,a                     ;                   
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return

* If Show Score Flag is Reset then Return to Calling Routine, else Return to Routine that Called Calling Routine
* 
* Used by the routines at #R47302 and #R47315.
ret_if_show_score_flag:
                                       ; LD A,(34208)      ; If Show Score Flag is reset...
       abs  @game_flag_7               ; BIT 7,A           ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;
!
                                       ; POP BC            ; Remove return address from stack...
       .endproc                        ; RET               ; ...and return to routine that called the calling routine

*// draw_timer_bar

*********************************************************************************
* Update Eyes of a Randomly Selected Timer Figure, Increase Timer Tick Counter and Process Timer Figure Blinking
* 
* Used by the routine at #R34438.
update_timer:
       .proc
       bl   @update_rnd_timer_figure   ; CALL 47431        ; Select a remaining Timer Figure at random and update its eyes to a random (open-eyed) frame
       bl   @reduce_remaining_time     ; CALL 47468        ; Increase Timer Tick Counter and reduce remaining time if Counter > 767
       movb @blink_duration_counter,a  ; LD A,(34227)      ; If Blink Duration Counter is zero...
                                       ; OR A              ; ...
       jeq  update_timer_1             ; JR Z,47388        ; ...then skip ahead to #R47388
       sb   one,a                      ; DEC A             ; Decrease Blink Duration Counter by one...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
                                       ; OR A              ; If decreased Blink Duration Counter is not zero...
       jne  update_timer_2             ; RET NZ            ; ...then return
       mov  @blinking_eye_attr_addr,ix ; LD IX,(34264)     ; Restore Attribute File address of eyes of currently blinking timer figure into IX
       jmp  draw_open_eyes_0           ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
* Make a randomly chosen timer figure blink
update_timer_1:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 0-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (9 in 10 chance)...
       jne  update_timer_2             ; RET NZ            ; ...then return
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
       cb   a,@bytes+2                 ; CP 2              ; If less than two time / lives remain...
       jl   update_timer_2             ; RET C             ; ...then return
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(x-1) (where x is remaining time / lives)
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. point to a random "awake" timer figure)
       mov  ix,@blinking_eye_attr_addr ; LD (34264),IX     ; Store Attribute File address of eyes of currently blinking timer figure at 34264
       bl   @draw_closed_eyes          ; CALL 47302        ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address IX and advance IX by two bytes
       movb @bytes+10,a                ; LD A,10           ; Set Blink Duration Counter to a random number, 1-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
update_timer_2:
       .endproc                        ; RET               ; Return
*// update_timer

*********************************************************************************
* Select a Remaining Timer Figure at Random and Update its Eyes to a Random (Open-Eyed) Frame
* 
* Used by the routine at #R47363.
update_rnd_timer_figure:
       .proc
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
       socb a,a                        ; OR A              ; ...and if none remain...
       jeq  update_rnd_timer_figure_1  ; RET Z             ; ...then return
       movb a,@e                       ; LD E,A            ; Load remaining time / lives into E
       movb @bytes+18,a                ; LD A,18           ; Load A with 18 minus remaining time / lives (i.e. number in range 2 to 18)...
       sb   @e,a                       ; SUB E             ; ...
* As the value of x (Remaining Time / Lives) decreases, the probability that a randomly generated number between 0
* and (18-x) is 2 or more increases. This probability is used to ensure that the rate at which each timer figure is
* updated remains roughly constant.
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(17 minus remaining time / lives)
       cb   a,@bytes+2                 ; CP 2              ; If generated number is 2 or more...
       jhe  update_rnd_timer_figure_1  ; RET NC            ; ...then return
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @e,a                       ; LD A,E            ; Load remaining time / lives into A
* If remaining time / lives is one, then there is only one Timer Figure to update
       cb   a,one                      ; CP 1              ; If this is 1...
       jeq  draw_open_eyes_0           ; JP Z,47315        ; ...then jump to #R47315 (If Show Score Flag reset then draw pair of Timer Figure eyes and
                                       ;                   ; return)

* Otherwise, randomly select one of the remaining Timer Figures to update
       bl   @rnd_no                    ; CALL 54222        ; Load A with random number between 0 and (x-1) where x is remaining time / lives
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. advance IX to point to left eye of randomly chosen Timer Figure)
       b    @draw_open_eyes_0          ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
update_rnd_timer_figure_1:
       .endproc
*// update_rnd_timer_figure

*********************************************************************************
* Increase Timer Tick Counter and Reduce Remaining Time if Counter > 767
* 
* Used by the routine at #R47363.
reduce_remaining_time:
       .proc
       mov  @timer_tick,hl             ; LD HL,(34211)     ; Increase Timer Tick Counter by one...
       inc  hl                         ; INC HL            ; ...
       mov  hl,@timer_tick             ; LD (34211),HL     ; ...
       ci   hl,768                     ; LD A,H            ; If Timer Tick Counter is less than 768 (i.e. 3 x 256)...
                                       ; CP 3              ; ...
       jl   reduce_remaining_time_2    ; RET C             ; ...then return
       clr  @timer_tick                ; LD HL,0           ; Reset Timer Tick Counter to zero...
                                       ; LD (34211),HL     ; ...
       jmp  !
* This entry point is used by the routine at #R53723.
reduce_remaining_time_1:
       .proc
!      movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,47241        ; ...then reset Show Score Flag, draw timer figures bar and return
       b    @draw_timer_bar_0          ;
!
       sb   one,a                      ; DEC A             ; Decrease current time / lives by one...
       movb a,@time_left               ; LD (34210),A      ; ...
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, and draw timer figures bar and return
reduce_remaining_time_2:
       .endproc
*// reduce_remaining_time

*********************************************************************************
* Update Scores and Display
* 
* Used by the routine at #R34438.
update_and_print_score:
       .proc
                                       ; LD HL,34208       ; Set Show Score Flag...
       seto @game_flag_7               ; SET 7,(HL)        ; ...
       clr  hl                         ; LD HL,0           ; Set HL to zero
       movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jeq  update_and_print_score_2  ; JR Z,47526         ; ...then skip ahead to #R47526
       movb a,b                        ; LD B,A            ; Load HL with 1000 x current remaining time / lives...
       li   de,1000                    ; LD DE,1000        ; ...
update_and_print_score_1:
       a    de,hl                      ; ADD HL,DE         ; ...
       sb   one,b                      ; DJNZ 47517        ; ...
       jne  update_and_print_score_1                       ;                   
       mov  @timer_tick,de             ; LD DE,(34211)     ; Subtract value of Timer Tick Counter (i.e. Score Penalty) from current level's score...
       s    de,hl                      ; SBC HL,DE         ; ...
update_and_print_score_2:
       mov  hl,@score_level            ; LD (34213),HL     ; Set score for current level
       mov  @score_total,de            ; LD DE,(34215)     ; Load DE with current total score
       a    de,hl                      ; ADD HL,DE         ; Add score for current level to total score...
       mov  hl,@score_total            ; LD (34215),HL     ; ...and store
       mov  @high_score,de             ; LD DE,(34299)     ; Load current high score into DE
       s    de,hl                      ; SBC HL,DE         ; Subtract high score from current total score...
       jlt  update_and_print_score_3   ; JR C,47551        ; ...and if this is less than zero (i.e. high score is higher than current total score) then
                                                           ; skip ahead to #R47551
       mov  @score_total,hl            ; LD HL,(34215)     ; Load current total score into HL...
       mov  hl,@high_score             ; LD (34299),HL     ; ...and store as new high score
update_and_print_score_3:
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       movb a,@time_left               ; LD (34210),A      ; ...
       li   iy,score_text+7            ; LD IY,47596       ; Point IY at "numeric (score)" part of string at 47589
       mov  @score_level,hl            ; LD HL,(34213)     ; Load HL with current score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+20           ; LD IY,47609       ; Point IY at "numeric (total)" part of string at 47589
       mov  @score_total,hl            ; LD HL,(34215)     ; Load HL with current total score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+33           ; LD IY,47622       ; Point IY at "numeric (high score)" part of string at 47589
       mov  @high_score,hl             ; LD HL,(34299)     ; Load HL with current high score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       jmp  print_score_strings_0      ; JP 47628          ; Print SCORE / TOTAL / HI-SC string in current character's colours and return
*// update_and_print_score

*********************************************************************************
* Print Score / Total / High Score String in Current Character's Colours
* 
* Used by the routines at #R34916, #R46830 and #R47499.
print_score_strings:
       .proc
print_score_strings_0
       li   iy,score_text              ; LD IY,47589       ; Point IY at SCORE / TOTAL / HI-SC text
       li   hl,23232                   ; LD HL,23232       ; Set Attribute File address at which to print text to start of second-last character row
print_score_strings_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load a character from the string into A
       cb   a,@bytes+36                ; CP 36             ; If the character is 36 (end marker)...
       jeq  print_score_strings_6      ; RET Z             ; ...then return
       cb   a,@bytes+42                ; CP 42             ; If character is not 42 ("set attribute to current character's colours" marker)...
       jne  print_score_strings_3      ; JR NZ,47660       ; ...then skip ahead to #R47660
       movb @current_character_attr,a  ; LD A,(34226)      ; Load current character's attribute into A (blue for Berk, yellow for Drutt)
       cb   a,one                      ; CP 1              ; If blue (Berk)...
       jeq  print_score_strings_2      ; JR Z,47656        ; ...then skip ahead to #R47656
       movb @bytes+112,a               ; LD A,112          ; Load A with value for black INK, yellow PAPER, BRIGHT (Drutt's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_2:
       movb @bytes+79,a                ; LD A,79           ; Load A with value for white INK, blue PAPER, BRIGHT (Berk's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_3:
       cb   a,@bytes+35                ; CP 35             ; If character is not 35 ("set attribute to standard" marker)...
       jne  print_score_strings_5      ; JR NZ,47673       ; ...then skip ahead to #R47673
       movb @bytes+71,a                ; LD A,71           ; Load A with value for white INK, black PAPER, BRIGHT
print_score_strings_4:
       movb a,@print_attr              ; LD (34269),A      ; Store this value as the attribute to print text
       inc  iy                         ; INC IY            ; Advance IY to next character in string to print
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_5:
       movb a,@e                       ; LD E,A            ; Load character to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address
       inc  iy                         ; INC IY            ; Advance IY to next character to process
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_6
       .endproc
*// print_score_strings

*********************************************************************************
* Print a Double-Height Text Character
* 
* Used by the routines at #R46830, #R47071, #R47084, #R47213 and #R47628. Input:  HL  Attribute File address at
* which to print character E  Character to print
print_dbl_height:
       .proc
       li   bc,32                      ; LD BC,32          ; Load BC with 32 (width of a row in Attribute File)
       .push hl                        ; PUSH HL           ; Store HL (Attribute File address at which to print character)
       sb   d,d                        ; LD D,0            ; Set D to zero
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now Attribute File address at which to print character) and HL (now H = 0, L =
                                                           ; character to print)
       sla  hl,3                       ; ADD HL,HL         ; Multiply index of character to print by eight in HL, as each character's graphic data is
                                                           ; eight bytes long...
                                       ; ADD HL,HL         ; ...
                                       ; ADD HL,HL         ; ...
       li   de,font-(32*8)             ; LD DE,15360       ; Add eight times character index to 15360 in HL, to point to graphic of character in ROM...
       a    de,hl                      ; ADD HL,DE         ; ...
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to graphic of character in ROM) and HL (now 15360)
       .pop hl                         ; POP HL            ; Restore HL (Attribute File address at which to print character)
       bl   @print_half_dbl_height     ; CALL 47709        ; Print top half of a double-height text character
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL to advance down a character row
       bl   @print_half_dbl_height     ; CALL 47709        ; Print bottom half of a double-height text character
                                       ; AND A             ; Reset Carry Flag
       s    bc,hl                      ; SBC HL,BC         ; Subtract 32 from HL to restore to value it had upon starting this routine
       .endproc                        ; RET               ; Return
*// print_dbl_height

*********************************************************************************
* Print Half of a Double-Height Text Character
* 
* The most significant byte of the Attribute File address starts off as 88 for the top third of the screen. In the
* middle third it becomes 89 and in the lower third it reaches 90. The most significant byte of the Display File
* address (for the top pixel row of each character row) is 64 in the top third, 72 in the middle third and 80 in the
* lower third. Generally speaking, therefore, the most significant byte in the Display File address increases by
* eight for every increase of one in the attribute address most significant byte, so multiplying the latter by eight
* (giving 192, 200 or 208, values roll over 255-0 boundary with excess truncated) would put it on the same scale as
* the former (64, 72 or 80). Input:  DE  15360 + 8 x character index [+4 for second run-through] (i.e. points to ROM
* graphic data for the character of interest) HL  Attribute File address at which to print character
print_half_dbl_height:
       .proc
       mov  hl,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
       movb *de,*tmp2                  ; de must be advanced
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
*      Draw attribute
       movb @print_attr,a
       mov  hl,tmp1
       bl   @draw_attribute
;       .push hl                        ; PUSH HL           ; Store HL
;       .push bc                        ; PUSH BC           ; Store BC
;       movb @print_attr,a              ; LD A,(34269)      ; Load stored attribute into A
;       movb a,*hl                      ; LD (HL),A         ; Write this to Attribute File
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       a    a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       a    a,a                        ; ADD A,A           ; ...
;       a    a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File
;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (loop counter)
;_47724:
;       movb *de,a                      ; LD A,(DE)         ; Load a byte from the graphic data into C...
;       movb a,@c                       ; LD C,A            ; ...
;       ; SRL C                         ; SRL C             ; Shift bitmap data left one pixel in C
;       socb @c,a                       ; OR C              ; Merge this into bitmap data already in A to give a "bold" typeface appearance
;       andi a,127*256                  ; AND 127           ; Drop the leftmost bit to prevent one character touching the next (space between letters)
;       movb a,*hl                      ; LD (HL),A         ; Load the bitmap data into two consecutive rows to provide double-height (2 chars) text...
;       ab   one,h                      ; INC H             ; ...
;       movb a,*hl                      ; LD (HL),A         ; ...
;       ab   one,h                      ; INC H             ; ...
;       inc  de                         ; INC DE            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 47724        ; Repeat for next row of graphic data
;       jne  _47724                     ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop hl                         ; POP HL            ; Restore HL
        .endproc                        ; RET               ; Return
*// print_half_dbl_height

*********************************************************************************
* Convert Number in HL to String at IY
* 
* Used by the routine at #R47499. Input:  HL  A number to convert to string IY  A location in memory to store a
* number converted to a string
num_to_str:
       .proc
       li   de,10000                   ; LD DE,10000       ; Convert the ten thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,1000                    ; LD DE,1000        ; Convert the thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,100                     ; LD DE,100         ; Convert the hundreds to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,10                      ; LD DE,10          ; Convert the tens to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       movb @l,a                       ; LD A,L            ; Load remainder (units) into L
       ab   @bytes+48,a                ; ADD A,48          ; Add as offset to 48 (ASCII code for "0")
       movb a,*iy                      ; LD (IY+0),A       ; Load ASCII character code into units position in string
       .endproc                        ; RET               ; Return
*// num_to_str

*********************************************************************************
* Convert a Digit of Numeric Data to its String Equivalent
* 
* Used by the routine at #R47741. Input:  DE  Current power of ten HL  A number to convert to string IY  A location
* in memory to store a current digit converted to a string
digit_to_str:
       movb @bytes+47,*iy              ; LD (IY+0),47      ; Set character in string to "/" (character immediately before "0")
                                       ; AND A             ; Reset Carry Flag
digit_to_str_1:
       ab   one,*iy                    ; INC (IY+0)        ; Advance character at current string position to next numeric character up
       s    de,hl                      ; SBC HL,DE         ; Subtract current power of ten from number to convert
       jgt  digit_to_str_1             ; JR NC,47777       ; If number to convert has not dropped below 0 (i.e. we have not yet subtracted too many of the
       jeq  digit_to_str_1                                 ; current power of ten) then loop back to #R47777
       a    de,hl                      ; ADD HL,DE         ; We have subtracted one too many of the current power of ten, so add it back to make the
                                                           ; remainder positive
       inc  iy                         ; INC IY            ; Advance to next character in the string as we are finished dealing with the current power of
                                                           ; ten
       rt                              ; RET               ; Return
*// digit_to_str

*********************************************************************************
* Read Keyboard and Load Pressed Key Character into A
* 
* Used by the routines at #R47893 and #R47942. Output: A  Index of the key that was pressed
; read_keyboard:
;       .exx                            ; EXX               ; Swap registers
;       li   bc,65278                   ; LD BC,65278       ; Load B and C with 254
;       li   hl,ret_val_keyboard        ; LD HL,47853       ; Point HL at list of return values
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard) [IN 65278 reads the half row CAPS SHIFT to V]
;       socb @bits+0,a                  ; SET 0,A           ; Set bit 0 of A (i.e. clear pressing of CAPS SHIFT)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       li   de,5                       ; LD DE,5           ; Advance HL by five characters in list of return values string...
;       a    de,hl                      ; ADD HL,DE         ; ...
;       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 as there are 6 keyboard half-rows to test (loop counter)
;_47811:
;       sra  b,1                        ; RLC B             ; With each loop, change BC from 65278 -> 65022 -> 64510 -> 63486 -> 61438 -> 57342 -> 49150
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       inc  hl                         ; INC HL            ; Advance HL by five characters in list of return values string...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       sb   one,@e                     ; DEC E             ; Decrease number of remaining keyboard half-rows to check
;       jne  _47811                     ; JR NZ,47811       ; If there are any more half rows to check then loop back to #R47811
;       sra  b,1                        ; RLC B             ; Set BC to 32766 for final keyboard half-row
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
;       socb @bits+1,a                  ; SET 1,A           ; Set bit 1 of A (i.e. clear pressing of SYMBOL SHIFT)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       .exx                            ; EXX               ; Swap registers
;       .ret                            ; RET               ; Return [no key pressed]
;_47843:
;       srl  a,1                        ; SRL A             ; Shift bits right
;       mov  af,tmp0
;       andi tmp0,>0080
;       jne  _47850                     ; JR C,47850        ; If carry flag is set, then this is the key that was pressed, so skip ahead to #R47850
;       inc  hl                         ; INC HL            ; Advance HL to check next character
;       jmp  _47843                     ; JR 47843          ; Loop back to #R47843
;_47850:
;       movb *hl,a                      ; LD A,(HL)         ; Load current character in list of return values string into A as this is the key that was
;                                                           ; pressed
;       .exx                            ; EXX               ; Swap registers

*********************************************************************************
* Check for Control Key Press and Store at 34219
* 
* Used by the routine at #R34438.
check_control_input:
       .proc
       sb   a,a                        ; XOR A             ; Clear previously stored control input...
       movb @joystick_mode_flag,tmp0
       jeq  check_control_input_5
*      Read joystick
       li   r12,>0024                  ; CRU address of the column decoder
       li   tmp0,>0600
       ldcr tmp0,3                     ; Select column
       li   r12,>0006
       stcr tmp0,8
       inv  tmp0
*      Right
       coc  @bit2,tmp0
       jne  check_control_input_1
       socb @bits+0,a                  ; Right
check_control_input_1:
*      Left
       coc  @bit1,tmp0
       jne  check_control_input_2
       socb @bits+1,a                  ; Left
check_control_input_2:
*      Down
       coc  @bit3,tmp0
       jne  check_control_input_3
       socb @bits+2,a                  ; Forward
check_control_input_3:
*      Up
       coc  @bit4,tmp0
       jne  check_control_input_4
       socb @bits+3,a                  ; Back
check_control_input_4:
*      Fire
       coc  @bit0,tmp0
       jne  check_control_input_10
       socb @bits+4,a                  ; Change
*      Read keyboard
check_control_input_5:
       li   r0,KEY_D
       bl   @check_key
       jeq  check_control_input_6
       socb @bits+0,a
check_control_input_6:
       li   r0,KEY_S
       bl   @check_key
       jeq  check_control_input_7
       socb @bits+1,a
check_control_input_7:
       li   r0,KEY_X
       bl   @check_key
       jeq  check_control_input_8
       socb @bits+2,a
check_control_input_8:
       li   r0,KEY_E
       bl   @check_key
       jeq  check_control_input_9
       socb @bits+3,a
check_control_input_9:
       li   r0,KEY_C
       bl   @check_key
       jeq  check_control_input_10
       socb @bits+4,a
*      Shared
check_control_input_10:
       li   r0,KEY_P
       bl   @check_key
       jeq  check_control_input_11
       bl   @release_keypress
       bl   @wait_keypress
check_control_input_11:
       li   r0,KEY_R
       bl   @check_key
       jeq  check_control_input_12
       socb @bits+6,a
check_control_input_12:
;       movb a,@control_input           ; LD (34219),A      ; ...
;       .call @_47788                   ; CALL 47788        ; Read keyboard and load character of pressed key into A
;       socb a,a                        ; OR A              ; If no key was pressed...
;       jeq  _47930                     ; JR Z,47930        ; ...then read joystick input and return
;       movb one,@e                     ; LD E,1            ; Set least significant bit of E as we are testing the first keyboard control first
;       movb @bytes+7,b                 ; LD B,7            ; Set B to 7 as there are 7 keyboard controls to check (loop counter)
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
;_47910:
;       cb   a,*hl                      ; CP (HL)           ; If pressed key is the same as the current keyboard control...
;       jeq  _47921                     ; JR Z,47921        ; ...then skip ahead to #R47921
;       inc  hl                         ; INC HL            ; Advance HL to next keyboard control
;       ; SLA E                         ; SLA E             ; Shift E left
;       sb   one,b                      ; DJNZ 47910        ; Loop back to #R47910 for next keyboard control
;       jne  _47910                     ;
;       sb   a,a                        ; XOR A             ; Set A to zero
;       jmp  _47926                     ; JR 47926          ; Skip ahead to #R47926
;_47921:
;       movb @e,a                       ; LD A,E            ; Load input bitmap into A (bit that is set represents the control that has been pressed)
;       movb a,tmp0                     ; BIT 5,A           ; If bit 5 is set (i.e. Berk / Drutt key has been pressed)...
;       andi tmp0,32*256                ;
;       jne  _47942                     ; JR NZ,47942       ; ...then jump to #R47942 (Wait for current key to be released and another to be pressed,
;                                                           ; storing in A) and return
;* This entry point is used by the routine at #R47930.
;_47926:
       movb a,@control_input           ; LD (34219),A      ; Store control input at #R34219
       .endproc                        ; RET               ; Return

* If Joystick Mode is On, then Read Joystick Input
* 
* Used by the routine at #R47893.
;_47930:
;       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode is Off...
;       socb a,a                        ; OR A              ; ...
;       jne  !                          ; RET Z             ; ...then return
;       .ret                            ;
;!
;       ; IN A,(31)                     ; IN A,(31)         ; Read state of Kempston joystick into A
;       andi a,31*256                   ; AND 31            ; If joystick input is non-zero...
;       jne  _47926                     ; JR NZ,47926       ; ...then jump to #R47926
;       .ret                            ; RET               ; Return

*// check_control_input

*********************************************************************************
* Wait for Current Key to Be Released and Another to Be Pressed, Storing in A
* 
* Used by the routines at #R34438, #R47893 and #R47955.
wait_release_and_keypress:
       .proc
       bl   @release_keypress          ; CALL 47788        ; Read keyboard and load character of pressed key into A
                                       ; OR A              ; If a key is pressed...
                                       ; JR NZ,47942       ; ...then loop back to #R47942
       bl   @wait_keypress             ; CALL 47788        ; Read keyboard and load character of pressed key into A
                                       ; OR A              ; If a key is not pressed...
                                       ; JR Z,47948        ; ...then loop back to #R47948
       .endproc                        ; RET               ; Return
*// wait_release_and_keypress

*********************************************************************************
* Wait for release keypress
*
release_keypress:
       .proc
release_keypress_1:
       bl   @snd_player
       li   r0,KEY_S
       bl   @check_key
       jne  release_keypress_1
       li   r0,JOY_FI
       bl   @check_key
       jne  release_keypress_1
       .endproc
*// release_keypress

*********************************************************************************
* Wait for Key-Press, Store Pressed Key Code in A and Play Main Menu Sound
* 
* Used by the routines at #R46830 and #R46968. Output: A  code of pressed key
wait_keypress:
       .proc
wait_keypress_1:
       bl   @snd_player
       bl   @check_quit
       li   r0,KEY_S
       bl   @check_key
       jne  wait_keypress_2
       li   r0,KEY_SP
       bl   @check_key
       jeq  wait_keypress_3
wait_keypress_2:
       movb @zero,@joystick_mode_flag
       jmp  wait_keypress_4
wait_keypress_3:
       li   r0,JOY_FI
       bl   @check_key
       jeq  wait_keypress_1
       movb one,@joystick_mode_flag
;       .call @_47942                   ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
;       .push af                        ; PUSH AF           ; Store AF (A = last pressed key)
       movb @bytes+2,a                 ; LD A,2            ; Set sound 2 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound             ; CALL 59722        ; ...
;       .pop af                        ; POP AF            ; Restore AF (A = last pressed key)
wait_keypress_4:
       .endproc                        ; RET               ; Return
*// wait_keypress

*********************************************************************************
* Cycle Attributes (Long, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R53723.
cycle_attributes_long:
       .proc
       movb @bytes+21,b                ; LD B,21           ; Set repeat counter to 21
       jmp  cycle_attributes           ; JR 53583          ; Flash screen when Berk is "killed"
*// cycle_attributes_long

*********************************************************************************
* Cycle Attributes (Short, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R36616.
cycle_attributes_short:
       .proc
       movb @bytes+7,b                 ; LD B,7            ; Set repeat counter to 7
       jmp  cycle_attributes
*// cycle_attributes_short

*********************************************************************************
* This entry point is used by the routine at #R53577.
cycle_attributes:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of iterations required)
       li   hl,ti_attributes           ; LD HL,22528       ; Point HL at start of Attribute File
       li   bc,704                     ; LD BC,704         ; Set BC to 704 (i.e. gap between start of Attribute File and start of second-last row (timer
                                                           ; figures))
cycle_attributes_1:
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jeq  cycle_attributes_2         ; JR Z,53602        ; If value is zero (black INK) then skip ahead to #R53602
       ab   one,a                      ; INC A             ; Increase INK value to next colour
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jne  cycle_attributes_2         ; JR NZ,53602       ; If value is not zero (black INK) then skip ahead to #R53602
       movb one,a                      ; LD A,1            ; INK value was zero, so set now to blue INK
cycle_attributes_2:
       movb a,@e                       ; LD E,A            ; Load new INK value into E
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jeq  cycle_attributes_3         ; JR Z,53616        ; If black PAPER, then skip ahead to #R53616
       ab   @bytes+8,a                 ; ADD A,8           ; Increase to next PAPER colour
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jne  cycle_attributes_3         ; JR NZ,53616       ; If PAPER component is not black then skip ahead to #R53616
       movb @bytes+8,a                 ; LD A,8            ; PAPER value was zero, so set now to blue PAPER
cycle_attributes_3:
       socb @e,a                       ; OR E              ; Add INK component back in
       socb @bytes+64,a                ; OR 64             ; Set BRIGHT flag
       mov  hl,tmp1
       ai   tmp1,zx_attributes-ti_attributes
       bl   @draw_attribute            ; LD (HL),A         ; Paint new attribute back to current position in Attribute File
       andi a,16*256                   ; AND 16            ; Set / reset speaker bit
       socb @bytes+2,a                 ; OR 2              ; Set RED bit to maintain red border
       bl   @set_border_color          ; OUT (254),A       ; Set border and set / reset speaker state
       inc  hl                         ; INC HL            ; Advance to next byte of Attribute File
       dec  bc                         ; DEC BC            ; Decrease remaining number of character blocks to process
       movb b,a                        ; LD A,B            ; If number of remaining character blocks is not zero...
       socb @c,a                       ; OR C              ; ...
       jne  cycle_attributes_1         ; JR NZ,53590       ; ...then loop back to #R53590
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of iterations required)
       sb   one,b                      ; DJNZ 53583        ; Loop back for next iteration
       jne  cycle_attributes           ;
       jmp  clear_display_buffers_0
*// cycle_attributes

*********************************************************************************
* This entry point is used by the routine at #R53887.
clear_display_buffers:
       .proc
clear_display_buffers_0:
       li   hl,display_buffer_1        ; LD HL,61312       ; Clear Display Buffers 1 and 2...
       li   bc,32*22*4*2               ; LD BC,4224        ; ...
clear_display_buffers_1:
       clr  *hl+                       ; LD (HL),0         ; ...
                                       ; LD D,H            ; ...
                                       ; LD E,L            ; ...
       dect bc                         ; INC DE            ; ...
       jne  clear_display_buffers_1    ; LDIR              ; ...
       .endproc                        ; RET               ; Return

*********************************************************************************
* Fill Top 22 Rows of Attribute File with Attribute Value in A
* 
* Used by the routines at #R46830 and #R53723. Input:  A  Attribute
fill_screen:
       .proc
*      TI attributes
       li   tmp0,ti_attributes
       li   tmp2,22*32
fill_screen_1:
       movb a,*tmp0+
       dec  tmp2
       jne  fill_screen_1
*      ZX attributes
       bl   @ti_color
       mov  tmp0,r1
       li   r0,color_table
       li   r2,22*256
       bl   @vsmw
;       li   hl,22528                   ; LD HL,22528       ; Point HL at start of Attribute File
;       movb @l,@e                      ; LD E,L            ; Point DE one byte after this...
;       movb h,d                        ; LD D,H            ; ...
;       inc  de                         ; INC DE            ; ...
;       li   bc,703                     ; LD BC,703         ; Set counter to 703, as we are filling 704 characters (32*22)
;       movb a,*hl                      ; LD (HL),A         ; Set first byte to A...
;       .ldir                           ; LDIR              ; ...and repeat for remaining 703 bytes
;       movb @bytes+3,b                 ; LD B,3            ; Pause for three iterations...
;       .call @pause                    ; CALL 34675        ; ...
       .endproc                         ; RET               ; Return
*// fill_screen

*********************************************************************************
* If Berk Has Been Killed then Reset his Position and State, Flash Screen and Decrease Time / Lives
* 
* Used by the routine at #R34438.
check_berk_killed:
       .proc
                                       ; LD HL,34208       ; Point HL at Game Flags
       clr  @game_flag_3               ; RES 3,(HL)        ; Reset "Reset Spiders to Initial State" Flag
       abs  @game_flag_2               ; BIT 2,(HL)        ; If "Berk Has Been Killed" Flag is not set...
       jeq  check_berk_killed_1        ; RET Z             ; ...then return
       clr  @game_flag_2               ; RES 2,(HL)        ; Reset "Berk Has Been Killed" Flag
       seto @game_flag_3               ; SET 3,(HL)        ; Set "Reset Spiders to Initial State" Flag
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   de,berk_reset_table-2      ; LD DE,53674       ; Point DE at location two bytes (1 WORD) before start of Table of Addresses of Berk Reset Data
       movb @current_level,a           ; LD A,(34207)      ; Load current level number into A
       bl   @load_table_addr           ; CALL 53814        ; Load DE with that level's address (from table at #R53676) for complex state data to revert
                                                           ; Berk to after he is killed
       .ex_de_hl                       ; EX DE,HL          ; Swap HL (now address of complex state data to revert to) and DE
       mov  @berk_state_addr,de        ; LD DE,(34240)     ; Load DE with address of current level's complex state data for Berk
       li   bc,13                      ; LD BC,13          ; Overwrite Berk's current complex state data...
       .ldir                           ; LDIR              ; ...with reset data from table at #R53684 for current level
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       mov  hl,@berk_script_pos        ; LD (35687),HL     ; ...and store at #R35687 (as current position in Berk's script data)
       bl   @cycle_attributes_long     ; CALL 53577        ; Cycle attributes (long, full-screen) and clear display buffers
       movb @bytes+127,a               ; LD A,127          ; Fill top 22 rows of Attribute File with white PAPER and white INK, BRIGHT...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @reduce_remaining_time_1   ; CALL 47485        ; Decrease current time / lives by one if greater than zero and redraw Timer Figures
check_berk_killed_1:
       .endproc                        ; RET               ; Return
*// check_berk_killed

*********************************************************************************
* Set Each Value in Primary Display Buffer Within Play Area to Zero
* 
* Used by the routine at #R34438.
clear_display_buffer:
       .proc
       mov  @prim_disp_buffer_addr,hl  ; LD HL,(34279)     ; Load HL with start address of Primary Display Buffer
       li   bc,32*22                   ; LD BC,704         ; Set BC to 704, as there are 704 entries in a Display Buffer
       li   de,4                       ; LD DE,3           ; Load DE with 3 as each entry in the Display Buffer is three bytes wide

       bl   @clear_display_buffer_pad
       .endproc                        ; RET               ; Return
clear_display_buffer_start:
       equ $
clear_display_buffer_1:
       movb *hl,a                      ; LD A,(HL)         ; Read first byte in Display Buffer...
                                       ; INC A             ; ...and add one
       jlt  clear_display_buffer_2    ; JP Z,53806        ; If value is now zero (i.e. was previously 255 and therefore outside normal play area), then
                                                           ; skip ahead to #R53806
                                       ; XOR A             ; Set all values in current entry to zero...
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
                                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       dec  bc
       jne  clear_display_buffer_1
       jmp  clear_display_buffer_3
clear_display_buffer_2:
       a    de,hl
       dec  bc                         ; DEC BC            ; Decrease remaining number of entries to process
                                       ; LD A,B            ; If remaining number of entries is not zero...
                                       ; OR C              ; ...
       jne  clear_display_buffer_1     ; JP NZ,53791       ; ...then loop back to #R53791
clear_display_buffer_3:
       rt
clear_display_buffer_end:
       equ $
*// clear_display_buffer

*********************************************************************************
* Copy Room Dimension Data Entry for Current Character / Entity's Current Room to Temporary Store Location (34230)
* 
* Used by the routines at #R34916 and #R53887. Input:  IX  (Entry at #R53848 only) Address of complex state data for
* an entity
copy_room_dim_data_to_tmp:
                                       ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       abs  @game_flag_0               ; BIT 0,A           ; ...
       jeq  copy_room_dim_data_to_tmp_1 ; JR Z,53838        ; ...then skip ahead to #R53838
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       jmp  copy_room_dim_data_to_tmp_2 ; JR 53842          ; Skip ahead to #R53842
copy_room_dim_data_to_tmp_1:
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
copy_room_dim_data_to_tmp_2:
       movb *ix,@current_chars_room ; LD A,(IX+0)       ; Store current character's current room at 34218...
                                       ; LD (34218),A      ; ...
* This entry point is used by the routines at #R35689, #R37062, #R39278, #R51739, #R52837, #R53083, #R54480 and
* #R55525.
copy_room_dim_data_to_tmp_3:
       movb *ix,a                      ; LD A,(IX+0)       ; Load entity's current room into A
       sb   one,a                      ; DEC A             ; Subtract 1...
       movb a,@e                       ; LD E,A            ; ...and multiply by 5...
       ab   a,a                        ; ADD A,A           ; ...
       ab   a,a                        ; ADD A,A           ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@c                       ; LD C,A            ; Load into BC...
       sb   b,b                        ; LD B,0            ; ...
       mov  @room_dim_data,hl          ; LD HL,(34248)     ; Load start address of current level's room dimension data into HL...
       a    bc,hl                      ; ADD HL,BC         ; ...and add BC as offset
       mov  hl,@room_dim_data_addr     ; LD (34262),HL     ; Store HL at #R34262
       movb @bytes+5,@c                ; LD C,5            ; Set BC to 5 (as entries are 5 bytes wide)
       li   de,tmp_room_dim_data       ; LD DE,34230       ; Copy data entry in room dimension data for entity's current room to #R34230...
       .ldir                           ; LDIR              ; ...
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room into E...
       movb a,@e                       ; LD E,A            ; ...
       movb @tmp_room_dim_data+2,a     ; LD A,(34232)      ; Subtract position (chars) of right side of current room in A...
       sb   @e,a                       ; SUB E             ; ...
       ab   @bytes+100,a               ; ADD A,100         ; ...and add 100
       movb a,@tmp_width_current_room  ; LD (34235),A      ; Store value (width of current room + 99) at #R34235
       rt                              ; RET               ; Return
*// copy_room_dim_data_to_tmp

*********************************************************************************
* Draw Contents of Primary Display Buffer to Display
* 
* If either the graphic index, or the graphic set index for the current entry in the Primary Display Buffer is zero,
* then only the attribute from that entry is rendered; the currently displayed bitmap data (from the previous frame)
* is preserved.
draw_display_buffer:
       .proc
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a     ; LD A,(34271)      ; If "Display Buffer 2 is Primary" Flag is reset...
                                       ; OR A              ; ...i.e. Display Buffer 1 is Primary...
       jeq  draw_display_buffer_1      ; JP Z,54052        ; ...then skip ahead to #R54052
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
draw_display_buffer_1:
       mov de,iy                       ; PUSH DE           ; Copy address of Secondary Display Buffer into IY...
                                       ; POP IY            ; ...
       li   bc_,6*32
       bl   @draw_display_buffer_pad
       bl   @snd_player
       li   bc_,6*32
       bl   @draw_display_buffer_pad
       bl   @snd_player
       li   bc_,6*32
       bl   @draw_display_buffer_pad
       bl   @snd_player
       li   bc_,4*32
       bl   @draw_display_buffer_pad
       .endproc

draw_display_buffer_start:
       .proc
draw_display_buffer_2:
       mov  *hl+,bc                    ; LD A,(HL)         ; Read Graphic Set Index from Primary Display Buffer into A
                                       ; INC HL            ; Advance HL to next byte (Graphic Index) in Primary Display Buffer
                                       ; OR A              ; If Graphic Set Index is zero...
       jeq  draw_display_buffer_8      ; JP Z,54130        ; ...then skip ahead to #R54130
                                       ; CP 255            ; If Graphic Set Index is 255 (character block outside room's dimensions)...
       jlt  draw_display_buffer_6      ; JP Z,54140        ; ...then skip ahead to #R54140
                                       ; LD B,A            ; Transfer Graphic Set Index into B
                                       ; LD E,0            ; Set E to zero

       mov  *iy+,de                    ; CP (IY+0)         ; If Graphic Set Index in Primary Display Buffer entry is different to Graphic Set Index in
                                                           ; Secondary Display Buffer entry...
                                       ; JP NZ,54076       ; ...then skip ahead to #R54076
                                       ; INC E             ; Increase E
                                       ; LD A,(HL)         ; Load Graphic Index from Primary Display Buffer
                                       ; OR A              ; If Graphic Index is zero...
                                       ; JP Z,54130        ; ...then skip ahead to #R54130
                                       ; LD C,A            ; Transfer Graphic Index into C
                                       ; CP (IY+1)         ; If Graphic Index in Primary Display Buffer is different to Graphic Index in Secondary Display
                                                           ; Buffer...
                                       ; JP NZ,54089       ; ...then skip ahead to #R54089
                                       ; INC E             ; Increase E
draw_display_buffer_4:
                                       ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Read attribute from Primary Display Buffer
       cb   a,*iy                      ; CP (IY+2)         ; If attribute in Display Buffer entry A is different to attribute in Secondary Display Buffer
                                                           ; entry...
       jne  draw_display_buffer_5      ; JP NZ,54102       ; ...then skip ahead to #R54102
       c    bc,de                      ; BIT 1,E           ; If E is 2 (i.e. both Graphic Set Index and Graphic Index are the same)...
                                       ;
       jeq  draw_display_buffer_6      ; JP NZ,54107       ; ...then skip ahead to #R54107, over drawing instructions (no need to redraw what is already
                                                           ; there)
draw_display_buffer_5:
                                       ; PUSH HL           ; Store HL (pointer to current position in Primary Display Buffer)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
                                       ; POP HL            ; Restore HL (pointer to current position in Primary Display Buffer)
draw_display_buffer_6:
       inct hl                         ; INC HL            ; Advance HL to next byte in Primary Display Buffer (start of next entry)
       inct iy                         ; ADD IY,DE         ; ...
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
                                       ; PUSH IX           ; Copy current Attribute File address from IX to DE...
                                       ; POP DE            ; ...
                                       ; LD A,E            ; If current Attribute File address is not at the start of the seventh row of a third of the
                                                           ; display (i.e. row 7, 15 or 23)...
                                       ; CP 192            ; ...
                                       ; JR NZ,54122       ; ...then skip ahead to #R54122
                                       ; LD A,D            ; If current Attribute File address is 23232 (256*90 + 192, i.e. at start of second last
                                                           ; display character row)...
       dec  bc_                        ; CP 90             ; ...
       jne  draw_display_buffer_2      ; RET Z             ; ...then return, as only timer figures appear in last two rows
                                       ; LD DE,3           ; Advance current position in Secondary Display Buffer by 3 bytes...
       jmp  draw_display_buffer_10     ; JP 54055          ; Loop back to #R54055
draw_display_buffer_8:
                                       ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Load attribute into A
       socb @bits+6,a                  ; SET 6,A           ; Set BRIGHT flag
       mov  ix,tmp1                    ; LD (IX+0),A       ; Place attribute at current position in Attribute File
       bl   @draw_attribute
       jmp  draw_display_buffer_6      ; JP 54107          ; Loop back to #R54107
;draw_display_buffer_9:
;       inct hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
;       jmp  draw_display_buffer_6      ; JP 54107          ; Loop back to #R54107
draw_display_buffer_10:
       .endproc
draw_display_buffer_end:
       equ  $

*// draw_display_buffer

*********************************************************************************
* Draw a Graphic Character Block to Display
* 
* This routine uses the same technique as seen in the routine at #R47709 to convert from an Attribute File address
* to a Display File address. See the notes in #R47709 for more details. Input:  A  Attribute value (bit 7 is
* "mirror" flag, rather than FLASH) B  Graphic set index C  Graphic index IX  Address in Attribute File
draw_character_block:
       .proc
*      VDP address
       mov  ix,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
*      Graphics address
       mov  bc,tmp1
       srl  tmp1,8
       sla  tmp1,1
       mov  @graphic_sets_table(tmp1),tmp1
       mov  bc,tmp0
       andi tmp0,>00ff
       sla  tmp0,3
       a    tmp1,tmp0
*      Draw mirrored?
       socb @bits+6,a                  ; SET 6,A           ; Set Bright Flag
       jlt  draw_character_block_1
*      Draw normal block
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       jmp  draw_character_block_3
*      Draw mirrored
draw_character_block_1:
       clr  tmp1
       li   bc,8
draw_character_block_2:
       movb *tmp0+,@r1lb
       movb @byte_mirror_table(tmp1),*tmp2
       movb *tmp0+,@r1lb
       movb @byte_mirror_table(tmp1),*tmp2
       dect bc
       jne  draw_character_block_2
*      Draw attribute
draw_character_block_3:
       mov  ix,tmp1
       bl   @draw_attribute
;       movb a,*ix                      ; LD (IX+0),A       ; Load attribute value into current Attribute File address
;       sb   a,a                        ; XOR A             ; Load graphic set index into HL..
;       movb b,@l                       ; LD L,B            ; ...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Double (as start address entries in table at #R27000 are two bytes wide)...
;       li   de,graphic_sets_table      ; LD DE,27000       ; ...and add as offset to #R27000 (in HL)...
;       a    de,hl                      ; ADD HL,DE         ; ...
;       movb *hl,@e                     ; LD E,(HL)         ; Load start address for this graphic set into DE...
;       inc  hl                         ; INC HL            ; ...
;       movb *hl,d                      ; LD D,(HL)         ; ...
;       movb @c,@l                      ; LD L,C            ; Load graphic index into HL...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Multiply by eight, as graphic blocks are eight bytes long...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    de,hl                      ; ADD HL,DE         ; Add to address of start of this graphic set as an offset in HL
;       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to required graphic data) and HL (now address of start of graphic set
;                                                           ; from table at #R27000)
;       .push ix                        ; PUSH IX           ; Switch Attribute File address into HL...
;       .pop hl                         ; POP HL            ; ...
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       ab   a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now Display File address) and HL (now pointer to graphic data)
;       movb *ix,tmp0                   ; BIT 7,(IX+0)      ; If mirror flag is set for Attribute File at current location...
;       andi tmp0,128*256               ;
;       jeq  !                          ; JP NZ,54194       ; ...then skip to #R54194 to draw mirrored version
;       b    @draw_mirrored_block       ;
;!
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54187:
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       movb a,*de                      ; LD (DE),A         ; ...and load into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 54187        ; Loop back for next row of pixels
;       jne  _54187                     ;
       .endproc                         ; RET               ; Return
*// draw_character_block

*********************************************************************************
* Draw Mirrored Graphic Character Block to Display File
* 
* Used by the routine at #R54144. Input:  HL  Address of bitmap data to draw IX  Address in Attribute File
;draw_mirrored_block:
;       szcb @bits+7,*ix                ; RES 7,(IX+0)      ; Reset Bit 7 (Mirror Flag, shared with FLASH flag so would cause graphic to flash)
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54200:
;       .push bc                        ; PUSH BC           ; Store BC (B = current counter value)
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       .push hl                        ; PUSH HL           ; Store HL (pointer to graphic data)
;       li   hl,byte_mirror_table       ; LD HL,27030       ; Point HL at mirror graphic lookup table
;       movb a,@c                       ; LD C,A            ; Load graphic "value" into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,hl                      ; ADD HL,BC         ; ...and add to HL as offset
;       movb *hl,a                      ; LD A,(HL)         ; Read byte at this location (mirror image of graphic data read by instruction at 54201)
;       .pop hl                         ; POP HL            ; Restore HL (pointer to graphic data)
;       movb a,*de                      ; LD (DE),A         ; Load (mirrored) graphic data into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       .pop bc                         ; POP BC            ; Restore BC (B = current counter value)
;       sb   one,b                      ; DJNZ 54200        ; Loop back for next row of pixels
;       jne  _54200                     ;
;       rt                               ; RET               ; Return

*********************************************************************************
* Move All Falling Entities Down by Distances Appropriate to their Current Velocity Factors
* 
* If an entity's "velocity factor" is equal to its height in characters plus 3 (a proxy for its mass), then it has
* reached its terminal velocity.
move_falling_entities:
       .proc
       mov  @cmplx_state_data_addr,ix  ; LD IX,(34238)     ; Load IX with start address of current level's complex state data
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
move_falling_entities_1:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of entry is 255 (i.e. End Marker)...
       cb   a,@b255               ; CP 255            ; ...
       jeq  move_falling_entities_9    ; RET Z             ; ...then return
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If current entity's "Can Fall" flag is reset...
       andi tmp0,64*256                ;                   
       jeq  move_falling_entities_5    ; JR Z,55592        ; ...then skip ahead to #R55592 (advance to next entity)
* Current entity's "Can Fall" Flag is set
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for current entity's current room
       .pop de                         ; POP DE            ; Restore DE
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height (of entity defined by entry) + 3...
       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
       ab   @bytes+4,a                 ; ADD A,4           ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load B with velocity factor...
       movb a,b                        ; LD B,A            ; ...
       cb   a,@c                       ; CP C              ; If C is less than or equal to this (i.e. "terminal velocity" reached)...
       jhe  move_falling_entities_2    ; JR NC,55569       ; ...then skip ahead to #R55569
       ab   one,a                      ; INC A             ; Increase velocity factor by one and store for next pass (i.e. acceleration)...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...
move_falling_entities_2:
       srl  b,1                        ; SRL B             ; Divide current (i.e. not increased) velocity factor by 2
move_falling_entities_3:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If sum of y-coordinate of entity's bottom and entity's depth is 122...
       ab   @1(ix),a                   ; ADD A,(IX+1)      ; ...(i.e. entity is at ground-level)...
       cb   a,@bytes+122               ; CP 122            ; ...
       jeq  move_falling_entities_6    ; JR Z,55596        ; ...then skip ahead to #R55596
move_falling_entities_4:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       bl   @change_room_down          ; CALL 55616        ; Change entity's room down one if appropriate
       sb   one,b                      ; DJNZ 55571        ; Decrease B (current velocity factor, i.e. remaining number of characters to drop entity) and
       jne  move_falling_entities_3                     ;
                                                           ; if non-zero, loop back to #R55571
move_falling_entities_5:
       a    de,ix                      ; ADD IX,DE         ; Advance IX by 13 bytes to next entry
       jmp  move_falling_entities_1    ; JR 55532          ; Loop back to #R55532
* Entity's position is such that sum of y-coordinate of bottom + depth = 122 (i.e. at ground-level)
move_falling_entities_6:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
move_falling_entities_7:
       joc  move_falling_entities_8    ; JR C,55610        ; ...and if no collision occurred, then skip ahead to #R55610
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  move_falling_entities_4    ; JR Z,55581        ; ...then jump to #R55581 (entity may fall down into next room)
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that character did collide with
       bl   @chk_coll_same_depth_5     ; CALL 54871    ; Resume checking entity for collision with another entity at same depth whose Interaction
                                       ; (11,6) Flag is set...
       jmp  move_falling_entities_7    ; JR 55599          ; ...
* Entity has landed (i.e. is at ground-level and has not collided with a marker of class 129)
move_falling_entities_8:
       szcb @bits+6,@10(ix)            ; RES 6,(IX+10)     ; Reset entity's "Can Fall" flag as entity has landed
       jmp  move_falling_entities_5    ; JR 55592          ; Loop back for next entity
move_falling_entities_9:
       .endproc
*// move_falling_entities

*********************************************************************************
* Update State of Berk and Store Current Position in Script Data
*
* Used by the routine at #R34438.
update_berk_state:
       .proc
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       bl   @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Berk's current room
       movb @9(ix),tmp0                ; BIT 5,(IX+9)      ; If Berk's "Do Not Update State" Flag is set...
       andi tmp0,32*256                ;
       jne  update_berk_state_1        ; RET NZ            ; ...then return
       mov  @berk_script_pos,hl        ; LD HL,(35687)     ; Load current position in Berk's script data from #R35687 into HL...
       mov  hl,@current_script_addr    ; ...and store at #R34277 as position in script currently running
       bl  @update_berk_state_2        ; CALL 35735        ; Update state of Berk depending upon currently selected character, control input and currently
                                                           ; active power
       mov  @current_script_addr,@berk_script_pos ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
                                       ; LD (35687),HL     ; ...at #R35687 as current position in Berk's script data
                                       ; If Berk's current power is not invisibility (level 3)...
       cb   @berks_current_power,@bytes+11 ; CP 11             ; ...
       jne  update_berk_state_1        ; RET NZ            ; ...then return
* Current power is invisibility (Level 3)
       li   bc,_50800                  ; LD BC,50800       ; Load BC with address of blank graphic layout data...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as Berk's current graphic layout data address...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       bl   @dec_power_duration        ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
update_berk_state_1:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Update State of Berk Depending Upon Currently Selected Character, Control Input and Currently Active Power
*
* Used by the routine at #R35689. Input:  IX  Address of complex state data (current level) for Berk
update_berk_state_2:
       .proc
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If Berk's Moving Upwards Flag (floating power) is set...
       andi tmp0,128*256               ;
       jeq  !                          ; JP NZ,36542       ; ...then jump to #R36542 (update state of Berk,  floating power active)
       b    @update_berk_floating_power                    ;
!
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
                                       ; LD A,(34208)      ; If Drutt Mode Flag is set...
       abs  @game_flag_0               ; BIT 0,A           ; ...
       jeq  !                          ; JP NZ,35577       ; ...then jump to #R35577 (change direction Berk is facing depending upon relative position of
       b    @face_towards_drutt                            ; Drutt)
!
* Drutt Mode Flag is reset (i.e. Berk Mode)
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1*256                 ;
       jeq  !                          ; JP NZ,36214       ; ...then skip ahead to #R36214 (move Berk right if appropriate)
       b    @attempt_to_move_right                    ;
!
       movb a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2*256                 ;
       jeq  !                          ; JP NZ,36137       ; ...then skip ahead to #R36137 (move Berk left if appropriate)
       b    @attempt_to_move_left                    ;
!
       bl   @move_into_new_room        ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4*256                 ;
       jeq  !                          ; JP NZ,36036       ; ...then skip ahead to #R36036 (update state of Berk, forward pressed)
       b    @update_berk_state_16                    ;
!
       movb a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8*256                 ;
       jne  update_berk_state_7        ; JP NZ,35827       ; ...then skip ahead to #R35827
* At this point, no control has been pressed. This entry point is used by the routines at #R35577, #R36036 and
* #R36116.
update_berk_state_3:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is not flying...
       andi tmp0,64*256                ;
       jeq  update_berk_state_4        ; JR Z,35802        ; ...then skip ahead to #R35802
* Berk is flying
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset Berk's Is Flying Flag
       li   hl,berk_fall_script        ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script            ; JP 48098          ; ...and execute
* No control pressed and Berk not flying
update_berk_state_4:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;
       jeq  update_berk_state_6        ; JR Z,35821        ; ...then skip ahead to #R35821
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is set
       movb @11(ix),tmp0               ; BIT 3,(IX+11)     ; If Berk's Unused (11,3) Flag is reset...
       andi tmp0,8*256                 ;
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
* No control pressed, Berk not flying, Berk's Facing Into Screen and Unused (11,3) flags are set This entry point is
* used by the routine at #R35577.
update_berk_state_5:
       equ  $
       li   hl,_35113                  ; LD HL,35113       ; Point HL at script data for Berk facing into screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is reset This entry point is used by the
* routine at #R35577.
update_berk_state_6:
       li   hl,_35081                  ; LD HL,35081       ; Point HL at script data for Berk facing out of screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* Back Pressed
update_berk_state_7:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       bl   @eat                       ; CALL 36008        ; If Berk is holding an edible entity them make him eat it, process appropriate script data
                                                           ; and return to calling routine
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Temporarily decrease y-coordinate of Berk's top edge
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                       ; into screen whose Interaction (11,7) Flag is set
       stst tmp0                       ; PUSH AF           ; Store AF
       ab   one,@4(ix)                 ; INC (IX+4)        ; Restore y-coordinate of Berk's top edge
       andi tmp0,>1000                 ; POP AF            ; Restore AF
       jne  update_berk_state_12       ; JR C,35953        ; If no collision occurred, then skip ahead to #R35953
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  update_berk_state_8        ; JR NZ,35870       ; ...then skip ahead #R35870
* Collision with door
       bl    @move_berk_closer         ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; Store address of complex state data for door at #R34256
       li   hl,_35017                  ; LD HL,35017       ; Point HL at script data for Berk interacting with a door behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
update_berk_state_8:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  update_berk_state_11       ; JR NC,35924       ; ...then skip ahead to #R35924
* Collision with entity that can be picked up
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is already carrying something...
       andi tmp0,16*256                ;
       jne  update_berk_state_12       ; JP NZ,35953       ; ...then skip ahead to #R35953
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with entity then move him closer and exit this routine
* Berk is now horizontally aligned with entity pointed to by IY
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; Store address of complex state data for entity at #R34256
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Berk's bottom edge...
       sb   one,b                      ; DEC B             ; ...minus 1 (to take into account different depth)
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of entity's bottom edge...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...and if this is less than the y-coordinate of Berk's top edge...
       jl   update_berk_state_10       ; JR C,35918        ; ...then skip ahead to #R35918
* Entity is not above Berk
       cb   a,b                        ; CP B              ; If entity's bottom edge is level with Berk's (taking into account different depth)...
       jeq  update_berk_state_9        ; JR Z,35912        ; ...then skip ahead to #R35912
* Entity is above floor and below Berk's top edge
       li   hl,_35163                  ; LD HL,35163       ; Point HL at script data for Berk picking up an entity that is above floor and below Berk's
                                                           ; top edge and behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Entity is on floor behind Berk
update_berk_state_9:
       li   hl,_35135                  ; LD HL,35135       ; Point HL at script data for Berk picking up an entity on floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Entity is above Berk
update_berk_state_10:
       li   hl,_35149                  ; LD HL,35149       ; Point HL at script data for Berk picking up an entity above and behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something that can't be picked up
update_berk_state_11:
       cb   a,@bytes+32                ; CP 32             ; If collision was not with entity of class 32 (coloured creatures' slots, Level 3)...
       jne  update_berk_state_12       ; JR NZ,35953       ; ...then skip ahead to #R35953
* Collision with a coloured creature slot
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;
       jeq  update_berk_state_12       ; JR Z,35953        ; ...then skip ahead to #R35953
* Berk is carrying something
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with coloured creature slot then move him closer and
                                                           ; exit this routine
* Berk is now horizontally aligned with coloured creature slot and carrying something
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       movb @4(iy),a                   ; LD A,(IY+4)       ; Load A with y-coordinate of top edge of coloured creature slot... (see trivia)
       sb   one,a                      ; DEC A             ; ...minus 1...
       movb a,@berk_coloured_creature  ; LD (34222),A      ; ...and store at #R34222
       li   hl,_35235                  ; LD HL,35235       ; Point HL at script data for Berk putting an entity down above floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision, collision with non-interactive entity or interaction conditions not met
update_berk_state_12:
       movb @berks_current_power,a     ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  update_berk_state_13       ; JR Z,35969        ; ...then skip ahead to #R35969
       cb   a,@bytes+4                 ; CP 4              ; If Berk's current power is 1-3 (jumping)...
       jl   update_berk_state_15       ; JP C,35995        ; ...then skip ahead to #R35995
       cb   a,@bytes+9                 ; CP 9              ; If Berk's current power is 4-8 (flying)...
       jl   update_berk_state_14       ; JP C,35985        ; ...then skip ahead to #R35985
* Berk has neither jumping nor flying power
update_berk_state_13:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen
       b    @update_berk_state_3                           ; as appropriate)
!

* Berk is carrying something
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       li   hl,_35219                  ; LD HL,35219       ; Point HL at script data for Berk putting an entity down on floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk's current power is flying
update_berk_state_14:
       socb @bits+6,@9(ix)             ; SET 6,(IX+9)      ; Set Berk's Is Flying Flag
       li   hl,_35417                  ; LD HL,35417       ; Point HL at script data for Berk starting to fly...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk's current power is jumping
update_berk_state_15:
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @bytes+129,@12(ix)         ; LD (IX+12),129    ; Set Berk's Is Jumping Flag and set initial jump velocity to 1
       li   hl,_35441                  ; LD HL,35441       ; Point HL at script data for Berk starting to jump straight up...
       b    @execute_script            ; JP 48098          ; ...and execute

* Update State of Berk (Forward Pressed)
*
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
update_berk_state_16:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;
       jeq  update_berk_state_17       ; JP Z,36049        ; ...then skip ahead to #R36049
* Berk's Facing Into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk's Facing Into Screen Flag is reset
update_berk_state_17:
       li   de,0                       ; LD DE,0           ; Clear pointer to complex state data for entity involved in last collision check...
       mov  de,@coll_entity_addr       ; LD (34258),DE     ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  update_berk_state_19       ; JR C,36103        ; ...and if no collision occurred, then skip ahead to #R36103
* Collision occurred
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  update_berk_state_18       ; JR NZ,36078       ; ...then skip ahead to #R36078
* Collision with door
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; Store address of door's complex state data at #R34256
       li   hl,_35045                  ; LD HL,35045       ; Point HL at script data for Berk interacting with a door in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
update_berk_state_18:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is set...
       andi tmp0,16*256                ;
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; JP NC,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
* At this point, Berk is not carrying anything, and the entity he is colliding with is one which can be picked up
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with entity at IY then move him closer and exit this
                                                           ; routine
* Berk is now horizontally aligned with entity pointed to by IY
       mov  iy,@berk_interaction_state ; LD (34256),IY     ; Store address of entity's complex state data at #R34256
       li   hl,_35187                  ; LD HL,35187       ; Point HL at script data for Berk picking up an entity on floor in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision occurred
update_berk_state_19:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3       ;
!
                                                           ; appropriate)
* Berk is carrying something
       li   hl,_35205                  ; LD HL,35205       ; Point HL at script data for Berk putting an entity down on floor in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
*// update_berk_state - cont

*********************************************************************************
* Make Berk Eat the Entity He is Holding, if Edible, and Exit Calling Routine
*
* Used by the routine at #R35735.
eat:
       .proc
       movb @berk_entity_held,a        ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jeq  eat_1                      ; RET Z             ; ...then return
       cb   a,@bytes+12                ; CP 12             ; If class value of entity held by Berk is greater than 12...
       jhe  eat_1                      ; RET NC            ; ...then return
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @move_carried_to_front     ; CALL 48710         ; Move carried entity in front of Berk as he faces out of screen
       mov  @berk_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move entity up one character to level of Berk's mouth...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       li   hl,_35493                  ; LD HL,35493       ; Point HL at script data for Berk eating an entity...
       b    @execute_script            ; JP 48098          ; ...and execute
eat_1:
       .endproc
*// eat

*********************************************************************************
* If Berk is Not Horizontally Aligned with Entity at IY then Move Berk Closer and Exit Calling Routine
*
* Used by the routines at #R35735 and #R36036. Input:  IX  Address of complex state data (current level) for Berk IY
* Address of complex state data for entity with which Berk has collided
move_berk_closer:
       .proc
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of entity at IY, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; ...divide value by 2...
       sb   @bytes+2,a                 ; SUB 2             ; ...and subtract 2
       ab   @5(iy),a                   ; ADD A,(IY+5)      ; Add result to x-coordinate of entity's left edge
* At this point, A holds the x-coordinate of the middle of the entity at IY, minus two
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate in A is the same as Berk's left side x-coordinate...
       jeq  move_berk_closer_1         ; RET Z             ; ...then return
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       cb   a,@5(ix)
       jl   attempt_to_move_left       ; JP NC,36214       ; If x-coordinate in A is the less than Berk's left side x-coordinate then skip ahead to
       jh  attempt_to_move_right       ;                   ; #R36214
move_berk_closer_1:
       .endproc                        ;

* This entry point is used by the routine at #R35735. Attempt to move Berk left
attempt_to_move_left:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;
       jne  attempt_to_move_left_4     ; JR NZ,36200       ; ...then skip ahead to #R36200
* Attempt to move Berk left (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  attempt_to_move_left_2     ; JR NC,36171       ; ...and if a collision occurred, then skip ahead to #R36171
* No collision
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk into room to the left, if appropriate...
       joc  attempt_to_move_left_1     ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @update_berk_state_3       ;                   ; him (turn to) face out of screen as appropriate)
attempt_to_move_left_1:
       equ  $
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is already set...
       andi tmp0,2*256                 ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       li   hl,_35263                  ; LD HL,35263       ; Point HL at script data for Berk starting to walk left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision occurred with entity to the left
attempt_to_move_left_2:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  attempt_to_move_left_3     ; JR NZ,36184       ; ...then skip ahead to #R36184
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   hl,_35291                  ; LD HL,35291       ; Point HL at script data for Berk starting to fall to the left...
       b    @execute_script            ; JP 48098          ; ...and execute
attempt_to_move_left_3:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   attempt_to_move_left_1     ; JR C,36158        ; ...then jump back to #R36158
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  attempt_to_move_left_1     ; JR Z,36158        ; ...then jump back to #R36158
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @set_berk_killed           ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk left (flying)
attempt_to_move_left_4:
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* This entry point is used by the routine at #R35735. Attempt to move Berk right
attempt_to_move_right:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;
       jne  attempt_to_move_right_4    ; JP NZ,36282       ; ...then skip ahead to #R36282
* Attempt to move Berk right (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  attempt_to_move_right_2    ; JR NC,36249       ; ...and if a collision occurred, then skip ahead to #R36249
* No collision
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk into room to the right, if appropriate...
       joc  attempt_to_move_right_1    ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @update_berk_state_3                           ; him (turn to) face out of screen as appropriate)
attempt_to_move_right_1:
       equ  $
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is already set...
       andi tmp0,1*256                 ;
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       li   hl,_35251                  ; LD HL,35251       ; Point HL at script data for Berk starting to walk right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision occurred with entity to the right
attempt_to_move_right_2:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  attempt_to_move_right_3    ; JR NZ,36266       ; ...then skip ahead to #R36266
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       mov  @berk_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk (see trivia)
       li   hl,_35327                  ; LD HL,35327       ; Point HL at script data for Berk starting to fall to the right...
       b    @execute_script            ; JP 48098          ; ...and execute
attempt_to_move_right_3:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   attempt_to_move_right_1    ; JR C,36236        ; ...then jump back to #R36236
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  attempt_to_move_right_1    ; JR Z,36236        ; ...then jump back to #R36236
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @set_berk_killed           ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk right (flying)
attempt_to_move_right_4:
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
*// move_berk_closer

*********************************************************************************
* If Berk is Neither Facing into the Screen nor Walking then Exit Calling Routine and Have Berk Turn into Screen
*
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
turn_into_screen:
       .proc
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is set...
       andi tmp0,2*256                 ;
       jne  turn_into_screen_1         ; RET NZ            ; ...then return
       movb @11(ix),a                  ; LD A,(IX+11)      ; If either of Berk's Walking Left or Walking Right flags is set...
       andi a,3*256                    ; AND 3             ; ...
       jne  turn_into_screen_1         ; RET NZ            ; ...then return
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script            ; JP 48098          ; ...and execute
turn_into_screen_1:
       .endproc
*// turn_into_screen

*********************************************************************************
* Update State of Berk (Floating Power Active)
*
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
update_berk_floating_power:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jeq  _36558                     ; JR Z,36558        ; ...then skip ahead to #R36558
* No collision with entity of class 130
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move Berk up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @change_room_up            ; CALL 55433        ; Change Berk's room up one if appropriate
_36558:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is set...
       andi tmp0,2*256                 ;
       jne  _36587                     ; JR NZ,36587       ; ...then skip ahead to #R36587
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is set...
       andi tmp0,1*256                 ;
       jne  _36576                     ; JR NZ,36576       ; ...then skip ahead to #R36576
       bl    @dec_power_duration       ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
* Berk's Walking Right Flag is set (i.e. Drutt has pushed Berk right)
_36576:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk's left and right sides right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk at IX into room to the right, if appropriate
       jmp  _36596                     ; JR 36596          ; Skip ahead to #R36596
* Berk's Walking Left Flag is set (i.e. Drutt has pushed Berk left)
_36587:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk's left and right sides left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk at IX into room to the left, if appropriate
_36596:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining horizontal distance from Drutt's push...
       jeq  !                          ; JP NZ,48096       ; ...and if not zero then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       movb one,a                      ; LD A,1            ; Set remaining power duration to 1...
       movb a,@remaining_power_groups  ; LD (34225),A      ; ...
       b    @script_routine_10         ; JP 48212          ; Reset Berk's Walking Left and Walking Right flags, advance HL to next script instruction and
                                                           ; execute
*********************************************************************************
* Change Direction Berk is Facing Depending Upon Relative Position of Drutt
*
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
* Jump - not call
face_towards_drutt:
       movb @current_chars_room,a ; LD A,(34218)      ; If Drutt's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's current room...
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3       ;                   ; appropriate)
!
       movb @11(ix),a                  ; LD A,(IX+11)      ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags...
       andi a,240*256                  ; AND 240           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       movb @9(ix),@e                  ; LD E,(IX+9)       ; Load Berk's Flags into E
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of complex state data (current level) for Drutt
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with x-coordinate of Drutt's right side...
       ab   one,a                      ; INC A             ; ...and increase by one
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of Berk's left side is greater than this (i.e. Drutt is to the left of
                                                           ; Berk)...
       jl   face_towards_drutt_3       ; JR C,35653        ; ...then skip ahead to #R35653
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right side
       ab   one,a                      ; INC A             ; Increase A by one
       cb   a,@5(iy)                   ; CP (IY+5)         ; If x-coordinate of Drutt's left side is greater than this (i.e. Drutt is to the right of
                                                           ; Berk)...
       jl   face_towards_drutt_5       ; JR C,35670        ; ...then skip ahead to #R35670
* Drutt is between Berk's left and right sides
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Drutt's depth is 1...
       cb   a,one                      ; CP 1              ; ...
       jeq  face_towards_drutt_2       ; JP Z,35642        ; ...then skip ahead to #R35642
* Drutt is behind Berk
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,14*256                   ; AND 14            ; If Berk's Facing into Screen, Facing Left and Facing Right flags are all reset...
       jeq  face_towards_drutt_1       ; JP Z,35636        ; ...then skip ahead to #R35636
* Drutt is behind Berk and at least one of Berk's Facing into Screen, Facing Left and Facing Right flags is set
       b    @update_berk_state_5       ; JP 35815          ; Point HL at script data for Berk facing into screen, ready to respond to control input and
                                                           ; execute
* Drutt is behind Berk and Berk's Facing into Screen, Facing Left and Facing Right flags are all reset
face_towards_drutt_1:
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt is in front of Berk
face_towards_drutt_2:
       movb @e,tmp0                    ; BIT 1,E           ; If Berk's Facing into Screen Flag is reset...
       andi tmp0,2*256                 ;
       jne  !                          ; JP Z,35821        ; ...then point HL at script data for Berk facing out of screen, ready to respond to control
       b    @update_berk_state_6       ;                   ; input and execute
!

* Drutt is in front of Berk and Berk's Facing into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt is to the left of Berk
face_towards_drutt_3:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,6*256                    ; AND 6             ; If either of Berk's Facing into Screen or Facing Left flags are set...
       jne  face_towards_drutt_4       ; JR NZ,35664       ; ...then skip ahead to #R35664
* Drutt is to the left of Berk, and Berk's Facing into Screen and Facing Left flags are both reset
       li   hl,_34977                  ; LD HL,34977       ; Point HL at script data for Berk turning to face left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt is to the left of Berk and either of Berk's Facing into Screen or Facing Left flags are set
face_towards_drutt_4:
       li   hl,_34985                  ; LD HL,34985       ; Point HL at script data for Berk facing left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt is to the right of Berk
face_towards_drutt_5:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,10*256                   ; AND 10            ; If either of Berk's Facing into Screen or Facing Right flags are set...
       jne  face_towards_drutt_6       ; JR NZ,35681       ; ...then skip ahead to #R35681
* Drutt is to the right of Berk, and Berk's Facing into Screen and Facing Right flags are both reset
       li   hl,_34997                  ; LD HL,34997       ; Point HL at script data for Berk turning to face right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Drutt is to the right of Berk and either of Berk's Facing into Screen or Facing Right flags are set
face_towards_drutt_6:
       li   hl,_35005                  ; LD HL,35005       ; Point HL at script data for Berk facing right...
       b    @execute_script            ; JP 48098          ; ...and execute
*// change_berk_direction

*********************************************************************************
* Update States of Drutt and Worm and Store Current Positions in Script Data
*
* Used by the routine at #R34438.
update_drutt_worm_state:
       .proc
       bl   @update_worm_state         ; CALL 52837        ; Update state of Worm and store current position in script data
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Drutt's current room
       mov  @drutts_script_pos,hl      ; LD HL,(51518)     ; Load current position in Drutt's script data from #R51518 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_drutt_state        ; CALL 51765        ; Update state of Drutt
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...at #R51518 as current position in Drutt's script data
       .endproc                        ; RET               ; Return
*// update_drutt_worm_state

*********************************************************************************
* Update State of Drutt
*
* If Drutt is being carried or falling, then he should be prevented from doing anything. This is accomplished by
* constantly resetting his current script data position to be #R51520. This does nothing except redraw Drutt. Input:
* IX  Address of complex state data (current level) for Drutt Output: HL  Address of next script instruction to
* execute
update_drutt_state:
       .proc
       movb @10(ix),a                  ; LD A,(IX+10)      ; If both Drutt's Being Carried and Can Fall flags are reset...
       andi a,96*256                   ; AND 96            ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;
!
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @execute_script            ; JP 48098          ; ...and execute
*// update_drutt_state

*********************************************************************************
* Update State of Worm and Store Current Position in Script Data
*
* Used by the routine at #R51739.
update_worm_state:
       .proc
       mov  @worm_state_addr,ix        ; LD IX,(34244)     ; Load IX with address of current level's complex state data for worm
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       mov  @worms_script_data_pos,hl  ; LD HL,(52726)     ; Load current position in worm's script data from #R52726 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_worm_state_1       ; CALL 52860        ; Update state of worm
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@worms_script_data_pos  ; LD (52726),HL     ; ...at #R52726 as current position in worm's script data
       .endproc                        ; RET               ; Return

*********************************************************************************
* Update State of Worm
*
* Used by the routine at #R52837. Input:  IX  Address of complex state data (current level) for Worm
update_worm_state_1:
       .proc
       movb @1(ix),a                   ; LD A,(IX+1)       ; If worm's depth is zero (i.e. not currently active)...
                                       ; OR A              ; ...
       jeq  spawn_new_worm             ; JP Z,53083        ; ...then attempt to spawn a new worm...
       b    @inct_execute_script       ; JP 48096          ; ...otherwise advance HL to next script instruction and execute

*********************************************************************************
* Attempt to Spawn a New Worm
*
* Used by the routine at #R52860. Input:  IX  Address of complex state data (current level) for Worm
spawn_new_worm:
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If random number is not zero (59 in 60 chance)...
       jne  spawn_new_worm_4           ; RET NZ            ; ...then return
       movb @current_chars_room,a ; LD A,(34218)      ; Set worm's current room to same as current character's...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       movb @tmp_width_current_room,a  ; LD A,(34235)      ; Load A with width of current room (chars) + 99...
       sb   @bytes+100,a               ; SUB 100           ; ...and subtract 100 to get x-coordinate (zero-based) of right side of the room
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random x-coordinate within current room
       ab   @bytes+100,a               ; ADD A,100         ; Add 100 to restore coordinate system
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set this as the worm's left x-coordinate
       ab   @bytes+2,a                 ; ADD A,2           ; Add two to this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as the worm's right x-coordinate
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 1-2...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and assign the worm this depth
       movb @bytes+124,a               ; LD A,124          ; Load A with 124 (y-coordinate of character row below bottom of room)
       sb   @1(ix),a                   ; SUB (IX+1)        ; Subtract worm's depth value to get its bottom y-coordinate...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and assign
       .push af                        ; PUSH AF           ; Store AF (A = bottom y-coordinate of worm)
       movb @bytes+121,@4(ix)          ; LD (IX+4),121     ; Set worm's top y-coordinate to 121
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
       jnc  spawn_new_worm_1                               ; Flag is set
       .pop bc
       jmp  spawn_new_worm_2
spawn_new_worm_1:
       .pop bc                         ; POP BC            ; Store AF (B = bottom y-coordinate of worm)
       jmp  spawn_new_worm_3           ; JR NC,53154       ; If a collision occurred then set worm's depth to zero and return
spawn_new_worm_2:
       movb b,@4(ix)                   ; LD (IX+4),B       ; Set worm's top y-coordinate to same as its bottom y-coordinate
       li   hl,_52735                  ; LD HL,52735       ; Point HL at script data for worm rising from floor...
       b    @execute_script            ; JP 48098          ; ...and execute
spawn_new_worm_3:
       movb @zero,@1(ix)            ; LD (IX+1),0       ; Set worm's depth to zero
spawn_new_worm_4:
       .endproc                        ; RET               ; Return
*// spawn_new_worm

*********************************************************************************
*
* Display title screen
*
title_screen:
       .proc
*      Set all colors to black on white
       li   a,>7800
       bl   @fill_screen
*      Draw patterns
       seto @title_bank_select
       li   hl,>6000+bank_offset
       clr  ix
title_screen_1:
       clr  iy
title_screen_2:
       li   de,pattern_table
       a    ix,de
       a    iy,de
       li   bc,8*32
title_screen_3:
       mov  de,tmp0
       bl   @vwad
       movb *hl+,@vdpwd
       ai   de,8
       bl   @alternate_border_color
       dec  bc
       jne  title_screen_3
       inc  iy
       ci   iy,8
       jne  title_screen_2
       ai   ix,8*32*8
       ci   ix,3*8*32*8
       jne  title_screen_1
*      Draw attributes
       li   de,zx_attributes
       li   bc,768
title_screen_4:
       movb *hl+,a
       mov  de,tmp1
       seto @graphics_bank_select
       bl   @draw_attribute
       seto @title_bank_select
       inc  de
       bl   @alternate_border_color
       dec  bc
       jne  title_screen_4
*      Black border
       clr  af
       bl   @set_border_color
       .endproc
*// title_screen

*********************************************************************************
*
* Switch between blue and yellow border
*
alternate_border_color:
       .proc
       movb @border_color,a
       cb   a,@bytes+9
       jne  alternate_border_color_1
       movb @bytes+14,a
       jmp  alternate_border_color_2
alternate_border_color_1:
       movb @bytes+9,a
alternate_border_color_2:
       movb a,@border_color
       bl   @set_border_color
       .endproc
*// alternate_border_color
