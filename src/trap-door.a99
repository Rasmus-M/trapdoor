* Table of Graphic Sets' Start Addresses
* 
* These addresses represent the location that would be occupied by the zeroth eight-byte graphic in each graphic
* set. However as zero is not an allowed value for a graphic index, the actual start of the graphic data for each
* set is eight bytes further on than the address given here. For example, Graphic Set 03 has a start address here of
* 27278, however the UDG with an index of 1 (which is the true start of the graphic data for Set 03) is at #R27286.
* The address given here (#R27278) is actually an address in the previous data block at #R27030.
_27000:
       data 0                                                        ; Graphic Set 0 (unused)
       data 3850                                                     ; Graphic Set 1 (uses ROM data)
       data _32334                                                   ; Graphic Set 2
       data _27278                                                   ; Graphic Set 3
       data _28070                                                   ; Graphic Set 4
       data _27782                                                   ; Graphic Set 5
       data _28838                                                   ; Graphic Set 6
       data _28366                                                   ; Graphic Set 7
       data _29718                                                   ; Graphic Set 8
       data _29350                                                   ; Graphic Set 9
       data _29990                                                   ; Graphic Set 10
       data _30662                                                   ; Graphic Set 11
       data _31246                                                   ; Graphic Set 12

* Unused
       byte 0,0,0,0

* Bitmap Data Mirror Image Lookup Table
* 
* A byte of graphic data (e.g. 1, with set pixel at right of character block) is the lookup index, and the retrieved
* value is the mirror image (e.g. 128, with set pixel at left of character block)
_27030:
       byte 0,128,64,192,32,160,96,224
       byte 16,144,80,208,48,176,112,240
       byte 8,136,72,200,40,168,104,232
       byte 24,152,88,216,56,184,120,248
       byte 4,132,68,196,36,164,100,228
       byte 20,148,84,212,52,180,116,244
       byte 12,140,76,204,44,172,108,236
       byte 28,156,92,220,60,188,124,252
       byte 2,130,66,194,34,162,98,226
       byte 18,146,82,210,50,178,114,242
       byte 10,138,74,202,42,170,106,234
       byte 26,154,90,218,58,186,122,250
       byte 6,134,70,198,38,166,102,230
       byte 22,150,86,214,54,182,118,246
       byte 14,142,78,206,46,174,110,238
       byte 30,158,94,222,62,190,126,254
       byte 1,129,65,193,33,161,97,225
       byte 17,145,81,209,49,177,113,241
       byte 9,137,73,201,41,169,105,233
       byte 25,153,89,217,57,185,121,249
       byte 5,133,69,197,37,165,101,229
       byte 21,149,85,213,53,181,117,245
       byte 13,141,77,205,45,173,109,237
       byte 29,157,93,221,61,189,125,253
       byte 3,131,67,195,35,163,99,227
       byte 19,147,83,211,51,179,115,243
       byte 11,139,75,203,43,171,107,235
       byte 27,155,91,219,59,187,123,251
       byte 7,135,71,199,39,167,103,231
       byte 23,151,87,215,55,183,119,247
       byte 15,143,79,207,47,175,111,239
_27278:
       byte 31,159,95,223,63,191,127,255

* Graphics Set 03
_27286:
       byte 0,0,0,24,24,0,0,0                                        ; (01)
       byte 0,0,60,36,36,60,0,0                                      ; (02)
       byte 0,126,66,66,66,66,126,0                                  ; (03)
       byte 255,129,129,129,129,129,129,255                          ; (04)
       byte 0,0,0,24,24,0,0,0                                        ; (05)
       byte 0,0,60,36,36,60,0,0                                      ; (06)
       byte 0,126,66,66,66,66,126,0                                  ; (07)
       byte 255,129,129,129,129,129,129,255                          ; (08)
       byte 188,102,147,196,41,54,44,244                             ; (09)
       byte 0,0,128,192,96,48,144,182                                ; (10)
       byte 1,2,6,5,8,19,28,7                                        ; (11)
       byte 108,51,91,13,166,82,42,188                               ; (12)
       byte 55,120,48,224,192,0,0,0                                  ; (13)
       byte 218,53,27,15,6,0,0,0                                     ; (14)
       byte 109,152,180,97,202,149,168,123                           ; (15)
       byte 0,128,192,96,48,144,112,192                              ; (16)
       byte 57,78,83,131,168,134,206,127                             ; (17)
       byte 184,240,96,128,192,64,192,128                            ; (18)
       byte 43,30,13,1,3,2,2,1                                       ; (19)
       byte 60,102,215,129,43,77,175,252                             ; (20)
       byte 0,63,68,43,84,65,110,63                                  ; (21)
       byte 0,63,71,80,71,122,97,63                                  ; (22)
       byte 0,190,65,130,113,101,163,254                             ; (23)
       byte 0,246,73,193,119,137,69,254                              ; (24)
       byte 0,62,75,115,69,75,91,71                                  ; (25)
       byte 0,62,81,89,81,79,107,81                                  ; (26)
       byte 89,67,85,107,85,123,95,62                                ; (27)
       byte 85,99,73,87,81,99,111,62                                 ; (28)
       byte 0,119,200,192,225,127,156,13                             ; (29)
       byte 0,222,35,1,77,254,0,49                                   ; (30)
       byte 140,45,14,142,6,135,64,63                                ; (31)
       byte 32,37,33,101,72,197,11,182                               ; (32)
       byte 240,31,50,14,1,16,56,128                                 ; (33)
       byte 126,131,68,44,184,35,96,208                              ; (34)
       byte 206,33,144,12,0,192,0,0                                  ; (35)
       byte 238,3,102,13,8,88,36,100                                 ; (36)
       byte 223,32,192,3,0,28,0,0                                    ; (37)
       byte 184,69,2,148,12,10,16,16                                 ; (38)
       byte 223,32,0,0,28,112,0,0                                    ; (39)
       byte 124,133,67,34,86,5,12,24                                 ; (40)
       byte 239,56,128,3,0,8,48,32                                   ; (41)
       byte 239,17,131,2,130,70,5,12                                 ; (42)
       byte 62,225,2,0,0,14,0,0                                      ; (43)
       byte 254,2,3,2,26,6,5,14                                      ; (44)
       byte 255,128,255,192,255,128,255,255                          ; (45)
       byte 255,126,129,189,165,126,255,255                          ; (46)
       byte 255,0,255,0,255,0,255,255                                ; (47)
       byte 255,125,192,125,253,64,253,255                           ; (48)
       byte 31,31,31,31,31,31,31,31                                  ; (49)
       byte 0,128,128,192,96,176,144,0                               ; (50)
       byte 31,159,159,159,223,223,223,255                           ; (51)
       byte 124,131,4,2,0,36,24,0                                    ; (52)
       byte 224,31,1,5,3,194,34,66                                   ; (53)
       byte 247,28,8,0,16,128,64,0                                   ; (54)
       byte 252,2,1,1,65,33,65,131                                   ; (55)
       byte 0,0,0,0,0,0,14,27                                        ; (56)
       byte 109,82,164,130,168,153,230,66                            ; (57)
       byte 220,38,82,66,42,118,238,140                              ; (58)
       byte 0,0,0,0,0,0,192,160                                      ; (59)
       byte 0,0,3,6,12,24,18,217                                     ; (60)
       byte 115,205,147,71,9,153,120,95                              ; (61)
       byte 68,72,99,92,107,162,170,159                              ; (62)
_27782:
       byte 85,181,157,109,173,187,250,241                           ; (63)

* Graphics Set 05
       byte 55,120,48,224,192,0,3,12                                 ; (01)
       byte 64,64,64,32,63,224,32,32                                 ; (02)
       byte 1,2,2,4,4,252,10,17                                      ; (03)
       byte 184,240,96,128,192,65,194,244                            ; (04)
       byte 144,97,102,152,152,22,33,66                              ; (05)
       byte 127,144,16,16,31,113,145,146                             ; (06)
       byte 224,56,68,67,224,19,12,20                                ; (07)
       byte 193,38,24,104,132,130,66,65                              ; (08)
       byte 15,4,4,4,4,4,4,4                                         ; (09)
       byte 194,122,135,129,129,129,142,112                          ; (10)
       byte 74,45,218,63,246,169,72,136                              ; (11)
       byte 100,132,127,132,8,176,65,50                              ; (12)
       byte 64,63,225,66,132,132,8,8                                 ; (13)
       byte 190,192,0,0,0,0,0,0                                      ; (14)
       byte 5,6,25,97,16,8,8,4                                       ; (15)
       byte 129,2,4,8,151,96,64,128                                  ; (16)
       byte 116,11,8,8,232,23,8,8                                    ; (17)
       byte 12,247,1,0,0,192,63,0                                    ; (18)
       byte 16,32,160,64,48,12,242,1                                 ; (19)
       byte 3,2,4,8,16,32,64,0                                       ; (20)
       byte 64,48,12,2,0,0,0,0                                       ; (21)
       byte 0,0,0,0,1,3,6,12                                         ; (22)
       byte 60,126,255,255,255,255,255,90                            ; (23)
       byte 0,0,0,15,31,25,25,14                                     ; (24)
       byte 126,255,153,195,189,255,195,126                          ; (25)
       byte 102,102,66,66,36,0,0,0                                   ; (26)
       byte 102,102,195,129,129,66,0,0                               ; (27)
       byte 0,0,0,15,31,27,31,14                                     ; (28)
       byte 24,144,144,200,76,102,50,29                              ; (29)
       byte 16,8,16,8,16,8,16,8                                      ; (30)
       byte 16,16,8,8,16,16,8,8                                      ; (31)
       byte 1,2,2,4,4,8,8,48                                         ; (32)
       byte 16,8,8,4,4,2,3,1                                         ; (33)
       byte 7,28,16,24,12,6,3,1                                      ; (34)
       byte 90,255,255,255,255,126,126,60                            ; (35)
_28070:
       byte 7,15,15,6,0,0,0,0                                        ; (36)

* Graphics Set 04
       byte 7,31,63,121,113,225,193,193                              ; (01)
       byte 224,248,252,62,30,15,7,7                                 ; (02)
       byte 195,194,230,252,124,126,63,31                            ; (03)
       byte 135,135,207,127,126,254,252,248                          ; (04)
       byte 31,31,31,27,53,46,110,110                                ; (05)
       byte 240,240,240,176,88,232,236,236                           ; (06)
       byte 32,0,64,110,110,85,59,31                                 ; (07)
       byte 8,0,4,236,236,84,184,240                                 ; (08)
       byte 0,0,0,7,31,63,121,113                                    ; (09)
       byte 0,0,0,224,248,252,62,30                                  ; (10)
       byte 225,193,193,195,194,230,252,124                          ; (11)
       byte 15,7,7,135,135,207,127,126                               ; (12)
       byte 126,63,31,31,31,31,27,53                                 ; (13)
       byte 254,252,248,240,240,240,176,88                           ; (14)
       byte 46,110,110,17,110,85,59,31                               ; (15)
       byte 232,236,236,16,236,84,184,240                            ; (16)
       byte 15,159,95,255,127,223,159,15                             ; (17)
       byte 240,249,250,255,247,234,27,241                           ; (18)
       byte 195,219,219,255,255,255,0,0                              ; (19)
       byte 28,62,119,227,227,247,62,28                              ; (20)
       byte 0,0,0,0,3,4,4,4                                          ; (21)
       byte 2,2,2,2,2,3,0,0                                          ; (22)
       byte 0,0,0,24,24,0,0,0                                        ; (23)
       byte 0,0,60,36,36,60,0,0                                      ; (24)
       byte 0,126,66,66,66,66,126,0                                  ; (25)
       byte 255,129,129,129,129,129,129,255                          ; (26)
       byte 15,63,125,91,23,7,62,126                                 ; (27)
       byte 0,60,126,126,126,126,63,3                                ; (28)
       byte 0,60,126,102,102,126,63,3                                ; (29)
       byte 0,60,102,102,126,126,63,3                                ; (30)
       byte 0,60,126,126,102,102,63,3                                ; (31)
       byte 0,60,126,114,114,126,63,3                                ; (32)
       byte 0,60,126,78,78,126,63,3                                  ; (33)
       byte 3,15,27,62,109,127,187,254                               ; (34)
       byte 224,240,236,236,244,170,247,189                          ; (35)
       byte 182,211,73,3,5,3,3,7                                     ; (36)
_28366:
       byte 127,170,194,224,144,64,224,240                           ; (37)

* Graphics Set 07
       byte 0,0,0,0,231,189,189,255                                  ; (01)
       byte 0,0,0,0,0,231,231,231                                    ; (02)
       byte 126,60,126,189,60,60,60,60                               ; (03)
       byte 60,60,60,60,60,126,126,126                               ; (04)
       byte 0,0,0,7,11,11,7,0                                        ; (05)
       byte 0,0,0,0,240,248,252,60                                   ; (06)
       byte 0,0,30,39,39,39,39,30                                    ; (07)
       byte 56,56,56,56,60,31,15,3                                   ; (08)
       byte 0,0,0,0,0,128,224,240                                    ; (09)
       byte 0,0,0,0,191,255,255,240                                  ; (10)
       byte 126,255,255,247,231,231,231,195                          ; (11)
       byte 0,0,0,0,0,0,0,0                                          ; (12)
       byte 0,0,0,0,0,0,0,0                                          ; (13)
       byte 0,0,0,0,0,0,0,0                                          ; (14)
       byte 0,0,0,0,0,0,0,0                                          ; (15)
       byte 0,0,0,0,0,0,0,0                                          ; (16)
       byte 0,0,0,0,0,0,0,0                                          ; (17)
       byte 0,0,0,0,0,0,0,0                                          ; (18)
       byte 0,0,0,0,0,0,0,0                                          ; (19)
       byte 0,0,0,0,0,0,0,0                                          ; (20)
       byte 0,0,0,0,0,0,0,0                                          ; (21)
       byte 0,0,0,0,0,0,0,0                                          ; (22)
       byte 0,0,0,0,0,0,0,0                                          ; (23)
       byte 0,0,0,0,0,0,0,0                                          ; (24)
       byte 0,0,0,0,0,0,0,0                                          ; (25)
       byte 0,0,0,0,0,0,0,0                                          ; (26)
       byte 0,0,0,0,0,0,0,0                                          ; (27)
       byte 0,0,0,0,0,0,0,0                                          ; (28)
       byte 0,0,0,0,0,0,0,0                                          ; (29)
       byte 0,0,0,0,0,0,0,0                                          ; (30)
       byte 0,0,0,0,0,0,0,0                                          ; (31)
       byte 0,0,0,0,0,0,0,0                                          ; (32)
       byte 0,0,0,0,0,0,0,0                                          ; (33)
       byte 102,255,153,153,255,102,0,0                              ; (34)
       byte 0,0,0,231,231,60,60,255                                  ; (35)
       byte 0,0,0,231,231,255,255,255                                ; (36)
       byte 0,0,0,0,1,3,3,1                                          ; (37)
       byte 1,3,7,15,15,15,15,7                                      ; (38)
       byte 0,0,0,24,60,60,24,0                                      ; (39)
       byte 0,0,0,0,2,126,112,0                                      ; (40)
       byte 0,0,0,0,64,126,14,0                                      ; (41)
       byte 0,0,129,195,255,126,60,0                                 ; (42)
       byte 0,0,0,0,0,0,126,24                                       ; (43)
       byte 0,0,0,0,0,126,126,24                                     ; (44)
       byte 11,29,23,21,23,27,11,57                                  ; (45)
       byte 7,3,6,12,8,14,2,14                                       ; (46)
       byte 255,126,0,0,0,0,0,0                                      ; (47)
       byte 0,0,0,60,126,114,114,126                                 ; (48)
       byte 255,252,251,247,237,219,250,251                          ; (49)
       byte 128,192,96,96,96,96,192,0                                ; (50)
       byte 0,0,0,0,0,3,2,3                                          ; (51)
       byte 219,24,48,96,192,128,0,0                                 ; (52)
       byte 219,24,15,1,3,126,64,64                                  ; (53)
       byte 219,24,15,0,0,0,0,0                                      ; (54)
       byte 0,0,128,128,128,192,0,0                                  ; (55)
       byte 255,189,129,0,0,0,0,129                                  ; (56)
       byte 129,195,66,66,195,129,0,0                                ; (57)
       byte 7,1,1,3,3,3,3,1                                          ; (58)
_28838:
       byte 24,24,56,240,240,224,192,128                             ; (59)

* Graphics Set 06
       byte 241,28,15,34,29,18,13,18                                 ; (01)
       byte 13,3,7,12,17,8,9,48                                      ; (02)
       byte 1,0,1,1,2,4,0,0                                          ; (03)
       byte 0,112,15,0,0,0,3,28                                      ; (04)
       byte 0,0,128,96,16,8,232,20                                   ; (05)
       byte 32,64,64,0,0,1,2,4                                       ; (06)
       byte 12,4,5,58,194,2,2,2                                      ; (07)
       byte 1,13,16,32,16,0,0,0                                      ; (08)
       byte 0,0,0,0,7,10,52,73                                       ; (09)
       byte 0,128,64,64,128,192,96,48                                ; (10)
       byte 0,1,2,4,8,8,16,16                                        ; (11)
       byte 145,17,33,33,64,64,64,64                                 ; (12)
       byte 24,12,4,5,130,0,0,0                                      ; (13)
       byte 1,60,239,34,29,18,13,18                                  ; (14)
       byte 0,0,0,0,2,4,2,1                                          ; (15)
       byte 0,0,3,14,56,96,192,128                                   ; (16)
       byte 6,10,10,18,18,36,36,36                                   ; (17)
       byte 0,192,32,16,12,2,0,0                                     ; (18)
       byte 68,66,66,65,64,32,0,0                                    ; (19)
       byte 32,32,64,64,32,0,0,0                                     ; (20)
       byte 1,3,15,63,255,63,15,1                                    ; (21)
       byte 255,104,107,107,9,107,104,255                            ; (22)
       byte 255,177,182,182,177,183,151,255                          ; (23)
       byte 240,216,220,220,220,252,216,240                          ; (24)
       byte 16,24,12,4,12,12,24,24                                   ; (25)
       byte 56,48,112,112,120,252,222,223                            ; (26)
       byte 223,207,199,193,193,225,243,255                          ; (27)
       byte 127,127,63,191,159,207,239,236                           ; (28)
       byte 241,227,231,231,207,223,223,255                          ; (29)
       byte 63,7,3,3,1,1,1,1                                         ; (30)
       byte 243,70,62,124,102,66,66,4                                ; (31)
       byte 0,0,0,0,1,99,78,123                                      ; (32)
       byte 6,27,55,239,159,127,255,255                              ; (33)
       byte 0,0,0,1,1,2,5,11                                         ; (34)
       byte 55,111,223,175,111,238,108,100                           ; (35)
       byte 11,27,55,47,111,95,95,223                                ; (36)
       byte 116,116,124,114,96,32,160,160                            ; (37)
       byte 191,191,176,160,160,192,104,56                           ; (38)
       byte 208,239,60,0,0,0,0,0                                     ; (39)
       byte 0,0,0,0,2,2,6,6                                          ; (40)
       byte 0,0,0,0,0,192,128,192                                    ; (41)
       byte 0,0,1,15,63,96,64,96                                     ; (42)
       byte 0,31,245,95,255,255,31,7                                 ; (43)
       byte 31,245,94,251,247,238,222,190                            ; (44)
       byte 252,87,122,127,127,255,255,255                           ; (45)
       byte 0,240,158,235,252,255,255,255                            ; (46)
       byte 7,3,2,3,2,4,0,0                                          ; (47)
       byte 190,126,255,31,3,1,1,0                                   ; (48)
       byte 255,255,127,127,127,127,191,191                          ; (49)
       byte 183,97,32,0,0,0,0,0                                      ; (50)
       byte 255,255,127,127,127,127,255,255                          ; (51)
       byte 254,139,196,67,1,0,0,0                                   ; (52)
       byte 0,128,240,28,231,249,254,127                             ; (53)
       byte 0,0,0,0,0,128,224,56                                     ; (54)
       byte 127,127,252,243,207,63,255,255                           ; (55)
       byte 230,131,120,246,247,247,239,239                          ; (56)
       byte 224,160,128,224,112,184,220,238                          ; (57)
       byte 23,47,48,32,0,0,0,0                                      ; (58)
       byte 255,255,127,15,3,3,1,1                                   ; (59)
       byte 239,223,223,223,223,223,223,223                          ; (60)
       byte 247,251,253,253,255,255,255,255                          ; (61)
       byte 191,191,191,191,191,191,191,160                          ; (62)
       byte 63,31,31,31,31,31,31,31                                  ; (63)
_29350:
       byte 31,31,63,63,63,127,127,127                               ; (64)

* Graphics Set 09
       byte 1,7,15,15,31,31,31,31                                    ; (01)
       byte 240,248,252,252,252,254,254,191                          ; (02)
       byte 15,15,7,7,3,3,15,14                                      ; (03)
       byte 191,191,207,231,231,199,6,14                             ; (04)
       byte 28,56,127,127,112,0,0,0                                  ; (05)
       byte 14,6,7,231,227,0,0,0                                     ; (06)
       byte 0,15,31,63,127,127,127,255                               ; (07)
       byte 0,224,240,248,252,124,126,127                            ; (08)
       byte 0,0,1,3,7,7,7,14                                         ; (09)
       byte 254,253,240,240,240,224,0,0                              ; (10)
       byte 223,223,47,15,15,30,28,14                                ; (11)
       byte 0,0,0,224,224,0,0,0                                      ; (12)
       byte 224,241,255,251,251,247,247,206                          ; (13)
       byte 3,3,2,7,15,30,28,28                                      ; (14)
       byte 188,112,240,115,63,28,0,0                                ; (15)
       byte 3,14,56,63,126,124,254,255                               ; (16)
       byte 255,255,252,240,240,112,120,126                          ; (17)
       byte 192,224,32,0,16,16,48,112                                ; (18)
       byte 63,31,15,224,160,0,0,0                                   ; (19)
       byte 14,31,25,57,126,192,0,0                                  ; (20)  (see bugs)
       byte 14,25,25,31,126,192,0,0                                  ; (21)  (see bugs)
       byte 255,153,0,102,102,0,153,255                              ; (22)
       byte 255,153,0,51,51,0,153,255                                ; (23)
       byte 255,153,0,204,204,0,153,255                              ; (24)
       byte 153,102,102,0,0,153,255,255                              ; (25)
       byte 255,187,17,187,255,129,126,255                           ; (26)
       byte 7,3,1,1,0,0,0,0                                          ; (27)
       byte 129,255,255,255,255,255,255,255                          ; (28)
       byte 1,1,3,7,15,31,63,127                                     ; (29)
       byte 127,255,255,255,255,255,255,127                          ; (30)
       byte 240,224,128,0,0,0,0,0                                    ; (31)
       byte 6,7,3,3,0,0,0,0                                          ; (32)
       byte 3,7,15,15,15,15,7,7                                      ; (33)
       byte 255,255,255,60,153,195,255,255                           ; (34)
       byte 64,63,127,223,183,175,47,15                              ; (35)
       byte 255,60,219,102,165,165,165,129                           ; (36)
       byte 255,255,255,255,129,60,255,255                           ; (37)
       byte 63,15,3,1,3,7,31,127                                     ; (38)
       byte 1,3,7,15,15,15,7,1                                       ; (39)
       byte 0,0,1,7,15,31,31,63                                      ; (40)
       byte 0,126,255,255,255,255,255,255                            ; (41)
       byte 63,127,127,127,127,127,127,63                            ; (42)
       byte 60,126,255,255,255,255,126,60                            ; (43)
       byte 255,15,3,3,3,7,31,127                                    ; (44)
       byte 63,31,31,15,7,1,0,0                                      ; (45)
_29718:
       byte 255,255,255,255,255,255,126,0                            ; (46)

* Graphics Set 08
       byte 60,126,243,225,225,243,126,60                            ; (01)
       byte 60,126,255,231,195,195,102,60                            ; (02)
       byte 60,126,207,135,135,207,126,60                            ; (03)
       byte 60,102,195,195,231,255,126,60                            ; (04)
       byte 60,102,195,195,231,255,126,60                            ; (05)
       byte 60,126,207,135,135,207,126,60                            ; (06)
       byte 60,126,255,231,195,195,102,60                            ; (07)
       byte 60,126,243,225,225,243,126,60                            ; (08)
       byte 255,255,255,255,253,189,136,0                            ; (09)
       byte 255,255,255,239,143,159,135,2                            ; (10)
       byte 255,126,68,64,0,0,0,0                                    ; (11)
       byte 255,127,127,63,63,25,0,0                                 ; (12)
       byte 255,255,255,255,223,15,7,0                               ; (13)
       byte 255,255,255,255,255,247,199,1                            ; (14)
       byte 1,3,27,31,63,63,127,63                                   ; (15)
       byte 127,127,63,31,31,63,63,127                               ; (16)
       byte 127,127,63,31,7,3,3,1                                    ; (17)
       byte 5,31,31,63,127,127,127,63                                ; (18)
       byte 31,15,47,127,127,127,63,63                               ; (19)
       byte 63,31,15,31,31,15,3,1                                    ; (20)
       byte 3,7,31,63,31,7,15,3                                      ; (21)
       byte 1,3,135,215,255,255,127,126                              ; (22)
       byte 126,126,126,126,60,60,126,126                            ; (23)
       byte 126,126,124,124,124,124,60,56                            ; (24)
       byte 56,56,56,56,56,48,48,48                                  ; (25)
       byte 48,48,16,16,16,16,16,0                                   ; (26)
       byte 255,255,255,255,255,223,141,1                            ; (27)
       byte 255,255,255,255,235,107,200,128                          ; (28)
       byte 255,255,255,255,231,207,23,7                             ; (29)
       byte 255,255,255,227,197,225,225,129                          ; (30)
       byte 255,255,255,243,227,231,227,128                          ; (31)
       byte 255,255,255,255,239,231,131,1                            ; (32)
       byte 255,254,254,254,252,252,156,24                           ; (33)
_29990:
       byte 3,15,15,7,7,1,1,0                                        ; (34)

* Graphics Set 10
       byte 0,0,0,31,31,24,24,24                                     ; (01)
       byte 0,0,0,248,248,24,24,24                                   ; (02)
       byte 24,24,24,31,31,0,0,0                                     ; (03)
       byte 24,24,24,248,248,0,0,0                                   ; (04)
       byte 24,24,24,248,248,0,0,0                                   ; (05)
       byte 24,24,24,31,31,0,0,0                                     ; (06)
       byte 0,0,0,248,248,24,24,24                                   ; (07)
       byte 0,0,0,31,31,24,24,24                                     ; (08)
       byte 84,84,76,174,170,170,178,180                             ; (09)
       byte 180,52,44,76,74,82,82,82                                 ; (10)
       byte 84,84,148,164,84,82,146,74                               ; (11)
       byte 82,82,84,20,34,34,18,18                                  ; (12)
       byte 17,17,17,17,18,34,33,33                                  ; (13)
       byte 33,34,34,18,20,20,20,20                                  ; (14)
       byte 18,36,36,36,34,2,2,4                                     ; (15)
       byte 4,4,4,4,0,0,0,0                                          ; (16)
       byte 82,74,74,42,52,82,82,82                                  ; (17)
       byte 146,164,148,84,84,82,82,74                               ; (18)
       byte 74,42,41,41,69,41,42,42                                  ; (19)
       byte 74,74,82,82,146,84,76,76                                 ; (20)
       byte 44,44,50,50,42,42,74,66                                  ; (21)
       byte 68,68,66,66,34,66,66,66                                  ; (22)
       byte 66,68,68,68,68,36,36,36                                  ; (23)
       byte 34,34,34,36,36,32,32,32                                  ; (24)
       byte 56,199,128,140,147,80,83,82                              ; (25)
       byte 224,30,2,226,18,210,84,84                                ; (26)
       byte 16,239,128,60,195,224,31,240                             ; (27)
       byte 198,17,238,0,239,16,195,60                               ; (28)
       byte 7,248,2,125,128,30,225,57                                ; (29)
       byte 3,63,199,31,255,7,255,3                                  ; (30)
       byte 231,248,255,198,249,240,251,252                          ; (31)
       byte 60,60,96,60,60,96,60,60                                  ; (32)
       byte 96,60,60,96,60,60,96,60                                  ; (33)
       byte 60,96,60,60,96,60,60,96                                  ; (34)
       byte 60,60,64,189,189,96,254,255                              ; (35)
       byte 0,1,1,3,7,30,61,123                                      ; (36)
       byte 192,224,224,254,124,49,135,255                           ; (37)
       byte 126,126,84,255,255,255,255,255                           ; (38)
       byte 251,251,251,113,17,113,49,17                             ; (39)
       byte 255,252,240,224,192,192,192,224                          ; (40)
       byte 255,126,0,0,0,0,0,0                                      ; (41)
       byte 11,3,3,1,0,0,0,0                                         ; (42)
       byte 224,224,224,192,32,96,48,8                               ; (43)
       byte 0,0,0,0,0,0,5,27                                         ; (44)
       byte 0,3,7,7,3,1,1,0                                          ; (45)
       byte 115,231,223,190,190,190,159,231                          ; (46)
       byte 231,153,0,0,0,0,0,129                                    ; (47)
       byte 251,125,125,125,57,4,12,4                                ; (48)
       byte 195,231,231,231,195,36,102,36                            ; (49)
       byte 255,126,96,189,189,96,60,60                              ; (50)
       byte 60,126,255,255,255,126,60,24                             ; (51)
       byte 0,6,9,9,15,15,6,0                                        ; (52)
       byte 60,126,255,255,255,219,231,126                           ; (53)
       byte 126,124,252,248,248,252,124,126                          ; (54)
       byte 62,31,95,207,239,254,254,124                             ; (55)
       byte 0,0,0,0,35,31,23,27                                      ; (56)
       byte 36,24,24,255,189,189,219,153                             ; (57)
       byte 29,30,15,15,7,3,1,0                                      ; (58)
       byte 0,129,195,129,129,129,129,66                             ; (59)
       byte 0,0,0,7,127,47,55,26                                     ; (60)
       byte 66,36,195,129,129,0,0,24                                 ; (61)
       byte 30,31,27,23,31,49,32,0                                   ; (62)
       byte 36,219,255,255,219,189,90,90                             ; (63)
       byte 0,0,8,7,1,0,0,0                                          ; (64)
       byte 6,27,251,247,237,125,70,4                                ; (65)
       byte 36,24,255,255,219,188,90,153                             ; (66)
       byte 219,189,219,219,90,60,24,36                              ; (67)
       byte 36,36,102,102,102,231,231,195                            ; (68)
       byte 1,7,3,0,0,0,0,0                                          ; (69)
       byte 126,62,63,31,31,63,62,126                                ; (70)
       byte 124,248,250,243,247,127,127,62                           ; (71)
       byte 255,255,170,85,170,85,170,0                              ; (72)
       byte 234,212,234,212,234,212,234,212                          ; (73)
       byte 0,0,0,0,24,60,118,235                                    ; (74)
       byte 1,3,7,14,29,58,117,234                                   ; (75)
       byte 213,170,84,168,80,160,64,128                             ; (76)
       byte 129,195,102,24,24,36,0,0                                 ; (77)
       byte 0,0,36,24,24,102,195,129                                 ; (78)
       byte 0,0,0,1,3,0,0,0                                          ; (79)
       byte 0,0,36,255,24,36,0,0                                     ; (80)
       byte 60,126,231,195,219,251,122,24                            ; (81)
       byte 15,31,31,31,31,31,63,63                                  ; (82)
       byte 63,63,63,63,127,127,127,127                              ; (83)
_30662:
       byte 127,127,255,255,255,255,255,127                          ; (84)

* Graphics Set 11
       byte 7,31,63,113,96,224,224,241                               ; (01)
       byte 241,224,224,96,113,63,31,7                               ; (02)
       byte 7,31,63,127,127,255,255,255                              ; (03)
       byte 255,255,255,127,127,63,31,7                              ; (04)
       byte 1,1,3,7,31,32,31,255                                     ; (05)
       byte 254,248,243,231,143,63,127,127                           ; (06)
       byte 7,31,63,125,124,254,248,8                                ; (07)
       byte 224,240,248,252,252,126,126,63                           ; (08)
       byte 9,51,55,119,115,121,255,255                              ; (09)
       byte 0,0,0,0,0,15,63,255                                      ; (10)
       byte 63,63,63,31,31,31,31,31                                  ; (11)
       byte 3,31,127,127,135,51,123,255                              ; (12)
       byte 0,17,99,195,135,199,71,71                                ; (13)
       byte 0,128,192,192,224,224,224,224                            ; (14)
       byte 160,168,168,168,168,104,72,72                            ; (15)
       byte 7,31,63,127,127,127,255,255                              ; (16)
       byte 0,112,88,207,12,8,120,216                                ; (17)
       byte 71,199,135,135,3,3,7,15                                  ; (18)
       byte 224,224,224,224,192,193,129,3                            ; (19)
       byte 72,216,152,152,152,152,56,56                             ; (20)
       byte 1,1,1,1,3,7,31,255                                       ; (21)
       byte 28,17,27,62,32,51,30,0                                   ; (22)
       byte 136,140,7,15,24,48,96,64                                 ; (23)
       byte 31,120,224,0,0,7,28,48                                   ; (24)
       byte 255,127,15,0,14,155,241,32                               ; (25)
       byte 254,252,240,2,12,27,241,2                                ; (26)
       byte 2,6,12,8,8,12,7,0                                        ; (27)
       byte 120,248,240,112,0,62,225,0                               ; (28)
       byte 15,7,3,3,1,1,1,0                                         ; (29)
       byte 0,0,1,3,2,3,1,0                                          ; (30)
       byte 64,225,231,60,1,1,131,194                                ; (31)
       byte 224,128,4,3,240,48,31,25                                 ; (32)
       byte 32,96,192,8,8,24,48,224                                  ; (33)
       byte 0,0,28,62,127,127,255,255                                ; (34)
       byte 255,255,255,255,135,3,1,0                                ; (35)
       byte 0,0,0,0,0,112,248,248                                    ; (36)
       byte 251,125,29,61,123,119,51,1                               ; (37)
       byte 99,48,16,48,57,31,0,0                                    ; (38)
       byte 144,16,48,96,192,0,0,0                                   ; (39)
       byte 255,252,240,224,192,128,128,128                          ; (40)
       byte 255,127,127,127,63,63,31,31                              ; (41)
       byte 248,248,248,248,240,240,112,0                            ; (42)
       byte 255,127,63,63,63,63,63,127                               ; (43)
       byte 57,127,127,127,127,63,63,63                              ; (44)
       byte 254,248,224,224,224,192,224,224                          ; (45)
       byte 224,224,224,192,192,192,192,128                          ; (46)
       byte 63,127,254,253,251,99,3,3                                ; (47)
       byte 255,15,247,251,253,252,252,252                           ; (48)
       byte 192,224,224,224,192,0,0,0                                ; (49)
       byte 29,62,127,255,255,255,255,127                            ; (50)
       byte 251,247,15,255,255,255,255,255                           ; (51)
       byte 128,224,240,240,248,248,248,252                          ; (52)
       byte 63,31,3,3,7,30,28,0                                      ; (53)
       byte 255,255,255,255,7,3,3,1                                  ; (54)
       byte 252,254,254,255,255,255,255,255                          ; (55)
       byte 0,0,0,0,192,224,240,252                                  ; (56)
       byte 62,62,62,126,127,127,127,255                             ; (57)
       byte 255,127,63,31,15,7,3,1                                   ; (58)
       byte 224,248,255,255,255,255,255,255                          ; (59)
       byte 255,255,127,62,0,0,0,0                                   ; (60)
       byte 0,192,255,255,255,255,255,255                            ; (61)
       byte 255,63,95,111,55,56,48,64                                ; (62)
       byte 255,255,255,255,255,255,127,1                            ; (63)
       byte 15,31,255,255,255,255,255,255                            ; (64)
       byte 252,253,253,249,251,243,247,247                          ; (65)
       byte 255,255,255,255,255,143,7,1                              ; (66)
       byte 63,127,254,193,184,127,255,255                           ; (67)
       byte 247,7,247,239,31,255,255,255                             ; (68)
       byte 252,252,240,224,192,192,192,192                          ; (69)
       byte 255,62,30,30,28,28,56,224                                ; (70)
       byte 255,255,127,31,7,3,0,0                                   ; (71)
       byte 255,255,255,255,255,254,0,0                              ; (72)
_31246:
       byte 224,224,224,224,192,0,0,0                                ; (73)

* Graphics Set 12
       byte 1,130,69,170,85,186,125,254                              ; (001)
       byte 170,85,43,23,15,23,43,85                                 ; (002)
       byte 127,190,93,170,85,162,65,128                             ; (003)
       byte 170,212,232,240,232,212,170,85                           ; (004)
       byte 170,85,43,23,15,23,43,85                                 ; (005)
       byte 127,190,93,170,85,162,65,128                             ; (006)
       byte 170,212,232,240,232,212,170,85                           ; (007)
       byte 1,130,69,170,85,186,125,254                              ; (008)
       byte 0,63,106,64,96,64,96,63                                  ; (009)
       byte 0,255,170,0,0,0,0,255                                    ; (010)
       byte 0,252,170,2,2,2,2,252                                    ; (011)
       byte 15,1,0,0,0,0,0,0                                         ; (012)
       byte 240,128,0,0,0,0,0,0                                      ; (013)
       byte 255,255,126,0,0,0,0,0                                    ; (014)
       byte 255,255,255,126,0,0,0,0                                  ; (015)
       byte 255,255,255,255,126,60,0,0                               ; (016)
       byte 255,255,126,60,60,126,126,126                            ; (017)
       byte 126,60,0,0,0,0,0,0                                       ; (018)
       byte 255,255,60,24,60,126,255,255                             ; (019)
       byte 255,255,126,60,0,0,0,0                                   ; (020)
       byte 255,255,60,24,24,24,24,24                                ; (021)
       byte 60,126,255,255,255,255,126,60                            ; (022)
       byte 112,248,252,255,127,127,63,15                            ; (023)
       byte 1,1,1,3,3,7,31,255                                       ; (024)
       byte 6,15,30,62,62,124,248,240                                ; (025)
       byte 0,0,192,240,120,28,4,4                                   ; (026)
       byte 0,0,0,0,0,1,3,63                                         ; (027)
       byte 3,7,15,31,63,255,255,255                                 ; (028)
       byte 195,129,0,6,6,0,129,195                                  ; (029)
       byte 224,192,128,128,128,128,128,128                          ; (030)
       byte 255,255,255,255,255,255,248,224                          ; (031)
       byte 128,128,128,192,192,224,224,224                          ; (032)
       byte 255,63,1,0,0,0,0,0                                       ; (033)
       byte 224,240,248,252,124,63,31,0                              ; (034)
       byte 0,128,192,192,224,240,248,254                            ; (035)
       byte 255,255,255,124,1,255,255,254                            ; (036)
       byte 255,129,63,126,254,240,192,0                             ; (037)
       byte 0,255,0,0,0,0,0,0                                        ; (038)
       byte 120,128,124,0,0,0,0,0                                    ; (039)
       byte 120,128,112,0,0,0,0,0                                    ; (040)
       byte 31,31,31,31,31,63,63,63                                  ; (041)
       byte 63,63,63,127,127,127,127,127                             ; (042)
       byte 255,255,129,129,0,0,24,60                                ; (043)
       byte 127,127,63,63,63,31,31,15                                ; (044)
       byte 60,24,66,60,0,0,0,0                                      ; (045)
       byte 127,255,224,238,223,219,31,14                            ; (046)
       byte 255,255,255,126,126,126,0,0                              ; (047)
       byte 0,0,0,0,0,0,112,254                                      ; (048)
       byte 1,1,3,3,7,7,15,15                                        ; (049)
       byte 192,248,255,255,255,255,255,255                          ; (050)
       byte 0,0,0,192,192,128,128,128                                ; (051)
       byte 31,31,63,63,127,127,127,127                              ; (052)
       byte 128,128,128,0,0,0,0,0                                    ; (053)
       byte 127,127,127,127,63,63,31,15                              ; (054)
       byte 254,254,254,254,252,252,248,240                          ; (055)
       byte 1,1,3,15,31,63,127,127                                   ; (056)
       byte 99,65,65,193,193,193,193,227                             ; (057)
       byte 127,63,159,135,192,224,248,255                           ; (058)
       byte 2,6,12,28,28,60,62,127                                   ; (059)
       byte 127,255,255,255,255,255,255,127                          ; (060)
       byte 129,255,255,255,255,255,255,255                          ; (061)
       byte 127,127,63,31,15,3,0,0                                   ; (062)
       byte 255,255,255,255,255,255,31,0                             ; (063)
       byte 0,0,3,15,31,63,127,127                                   ; (064)
       byte 0,31,255,255,255,255,255,255                             ; (065)
       byte 127,255,255,255,255,255,255,127                          ; (066)
       byte 255,255,255,255,255,255,255,129                          ; (067)
       byte 127,62,60,28,28,12,6,2                                   ; (068)
       byte 127,63,63,63,63,63,63,127                                ; (069)
       byte 127,127,127,127,63,31,15,15                              ; (070)
       byte 15,15,15,15,7,3,1,1                                      ; (071)
       byte 127,63,31,31,31,31,63,63                                 ; (072)
       byte 63,63,63,63,63,31,31,31                                  ; (073)
       byte 31,31,7,3,1,1,0,0                                        ; (074)
       byte 0,15,31,63,127,127,255,255                               ; (075)
       byte 0,192,248,252,254,254,255,255                            ; (076)
       byte 255,255,255,207,135,7,7,7                                ; (077)
       byte 255,255,255,255,255,255,254,254                          ; (078)
       byte 76,127,127,255,255,171,86,214                            ; (079)
       byte 126,126,240,128,112,118,206,221                          ; (080)
       byte 192,23,215,223,255,126,0,0                               ; (081)
       byte 192,1,23,215,239,188,248,96                              ; (082)
       byte 155,134,141,131,31,47,118,116                            ; (083)
       byte 0,128,192,192,224,224,96,192                             ; (084)
       byte 0,0,0,0,0,8,52,244                                       ; (085)
       byte 0,0,1,1,1,1,1,3                                          ; (086)
       byte 243,239,222,185,135,190,125,3                            ; (087)
       byte 247,119,120,248,176,96,216,184                           ; (088)
       byte 236,140,12,12,12,24,24,20                                ; (089)
       byte 32,254,35,1,1,35,254,32                                  ; (090)
       byte 0,0,0,255,255,0,0,0                                      ; (091)
       byte 0,12,114,255,188,94,47,24                                ; (092)
       byte 0,0,0,255,192,191,255,193                                ; (093)
       byte 3,7,6,222,22,234,240,254                                 ; (094)
       byte 127,124,1,255,126,0,195,126                              ; (095)
       byte 112,224,208,239,111,192,192,64                           ; (096)
       byte 56,60,84,167,175,168,80,0                                ; (097)
       byte 0,1,3,6,12,24,24,49                                      ; (098)
       byte 243,143,62,113,71,190,125,3                              ; (099)
       byte 247,119,120,248,176,97,219,187                           ; (100)
       byte 0,224,126,7,124,224,0,0                                  ; (101)
       byte 0,0,195,127,254,0,0,0                                    ; (102)
       byte 0,1,252,253,14,3,0,0                                     ; (103)
       byte 113,224,193,65,0,193,0,0                                 ; (104)
       byte 254,252,1,255,126,0,195,126                              ; (105)
       byte 118,238,210,227,111,196,200,64                           ; (106)
       byte 1,14,31,127,255,255,121,22                               ; (107)
       byte 0,0,0,0,0,31,95,68                                       ; (108)
       byte 0,0,3,15,254,248,128,0                                   ; (109)
       byte 60,252,248,132,12,12,12,14                               ; (110)
       byte 0,0,0,0,0,0,0,0                                          ; (111)
       byte 0,0,0,0,0,0,0,0                                          ; (112)
       byte 47,15,6,14,12,28,58,118                                  ; (113)
       byte 0,1,3,3,7,14,94,70                                       ; (114)
       byte 230,198,134,131,3,3,3,5                                  ; (115)
       byte 40,60,60,24,24,24,24,24                                  ; (116)
       byte 4,3,1,0,0,0,0,0                                          ; (117)
       byte 128,128,128,192,192,192,224,96                           ; (118)
       byte 24,48,48,48,48,48,48,48                                  ; (119)
       byte 96,96,96,96,96,96,96,96                                  ; (120)
       byte 0,0,11,53,246,0,0,0                                      ; (121)
       byte 80,232,120,184,24,0,0,0                                  ; (122)
       byte 6,6,6,7,3,3,3,5                                          ; (123)
       byte 0,0,0,0,1,7,30,248                                       ; (124)
       byte 22,56,125,225,195,131,3,1                                ; (125)
       byte 0,0,0,0,0,128,128,128                                    ; (126)
       byte 2,2,1,1,1,1,1,1                                          ; (127)
       byte 240,160,64,128,0,128,192,192                             ; (128)
       byte 1,1,0,0,0,0,0,0                                          ; (129)
       byte 192,192,192,192,224,160,64,184                           ; (130)
       byte 192,192,192,192,224,96,96,96                             ; (131)
       byte 252,30,7,1,0,0,0,0                                       ; (132)
       byte 0,0,128,224,120,31,3,0                                   ; (133)
       byte 0,0,0,0,0,176,240,160                                    ; (134)
       byte 0,0,1,11,0,0,0,0                                         ; (135)
_32334:
       byte 192,192,128,128,0,0,0,0                                  ; (136)

* Graphics Set 02
       byte 60,126,251,241,241,251,126,60                            ; (001)
       byte 60,126,255,249,241,243,126,60                            ; (002)
       byte 60,126,243,241,249,255,126,60                            ; (003)
       byte 0,0,0,0,0,1,3,3                                          ; (004)
       byte 0,1,7,15,31,63,127,255                                   ; (005)
       byte 1,1,3,7,7,15,31,31                                       ; (006)
       byte 31,63,63,127,127,127,127,255                             ; (007)
       byte 0,128,192,224,240,3,255,255                              ; (008)
       byte 7,15,31,63,126,252,248,255                               ; (009)
       byte 240,248,248,240,0,6,14,30                                ; (010)
       byte 255,63,159,199,241,252,255,255                           ; (011)
       byte 255,255,255,255,255,255,127,63                           ; (012)
       byte 255,255,255,255,254,255,255,255                          ; (013)
       byte 254,252,240,196,28,252,252,248                           ; (014)
       byte 159,207,231,241,252,255,255,255                          ; (015)
       byte 255,252,255,255,127,0,0,0                                ; (016)
       byte 0,112,240,224,192,0,0,0                                  ; (017)
       byte 127,63,159,207,231,243,249,253                           ; (018)
       byte 152,204,224,255,255,255,255,255                          ; (019)
       byte 3,31,127,255,255,254,254,255                             ; (020)
       byte 192,248,252,252,252,0,0,0                                ; (021)
       byte 255,255,127,127,127,63,191,191                           ; (022)
       byte 255,255,255,255,252,255,239,231                          ; (023)
       byte 252,254,252,248,0,240,240,240                            ; (024)
       byte 159,223,207,224,255,255,254,254                          ; (025)
       byte 224,255,255,126,0,0,0,0                                  ; (026)
       byte 255,255,255,255,255,127,127,127                          ; (027)
       byte 255,248,224,192,192,128,128,128                          ; (028)
       byte 255,63,31,15,15,7,7,7                                    ; (029)
       byte 255,255,255,254,254,254,254,254                          ; (030)
       byte 63,63,31,15,7,3,1,0                                      ; (031)
       byte 128,128,128,128,128,192,224,240                          ; (032)
       byte 7,15,15,31,31,63,127,255                                 ; (033)
       byte 252,252,248,248,224,224,128,0                            ; (034)
       byte 0,63,127,127,0,0,0,0                                     ; (035)
       byte 0,255,255,255,0,0,0,0                                    ; (036)
       byte 192,224,224,224,0,0,0,0                                  ; (037)
       byte 255,255,255,254,252,252,248,248                          ; (038)
       byte 240,128,0,0,0,0,0,0                                      ; (039)
       byte 128,224,224,224,224,224,192,128                          ; (040)
       byte 63,63,31,15,7,3,9,12                                     ; (041)
       byte 240,240,240,240,240,240,248,252                          ; (042)
       byte 255,254,252,248,240,224,192,128                          ; (043)
       byte 0,192,224,224,0,0,0,0                                    ; (044)
       byte 255,255,252,249,243,231,207,159                          ; (045)
       byte 255,0,127,255,255,255,255,255                            ; (046)
       byte 0,0,128,128,192,192,224,240                              ; (047)
       byte 63,63,31,79,231,243,249,252                              ; (048)
       byte 255,255,255,255,255,255,255,31                           ; (049)
       byte 191,63,127,127,127,127,127,255                           ; (050)
       byte 255,255,255,255,252,240,192,0                            ; (051)
       byte 240,224,192,128,0,0,0,0                                  ; (052)
       byte 7,7,7,3,0,0,0,0                                          ; (053)
       byte 255,255,255,255,0,0,0,0                                  ; (054)
       byte 192,255,255,255,0,0,0,0                                  ; (055)
       byte 1,7,15,15,15,15,7,1                                      ; (056)
       byte 127,127,63,191,159,223,207,231                           ; (057)
       byte 248,131,127,255,255,255,255,255                          ; (058)
       byte 0,224,248,248,252,252,252,252                            ; (059)
       byte 247,115,0,0,0,0,0,0                                      ; (060)
       byte 255,255,63,0,0,0,0,0                                     ; (061)
       byte 127,127,127,255,0,0,0,0                                  ; (062)
       byte 252,252,252,192,0,0,0,0                                  ; (063)
       byte 127,127,127,127,127,127,63,63                            ; (064)
       byte 63,31,7,0,0,0,0,0                                        ; (065)
       byte 255,255,192,158,63,127,127,127                           ; (066)
       byte 255,255,3,121,252,254,254,255                            ; (067)
       byte 255,255,254,254,254,126,124,124                          ; (068)
       byte 112,112,112,240,192,192,128,0                            ; (069)
       byte 127,127,63,63,0,0,0,0                                    ; (070)
       byte 254,254,252,252,0,0,0,0                                  ; (071)
       byte 120,224,128,0,0,0,0,0                                    ; (072)
       byte 255,255,65,28,127,255,255,255                            ; (073)
       byte 255,255,129,60,254,254,254,254                           ; (074)
       byte 255,254,252,253,249,243,231,207                          ; (075)
       byte 112,120,252,252,248,248,224,0                            ; (076)
       byte 255,255,255,127,0,0,0,0                                  ; (077)
       byte 254,252,253,249,0,0,0,0                                  ; (078)
       byte 255,254,254,248,128,0,0,0                                ; (079)
       byte 255,255,224,192,128,128,0,0                              ; (080)
       byte 255,255,127,63,31,31,15,15                               ; (081)
       byte 255,255,255,127,127,127,63,63                            ; (082)
       byte 7,7,7,7,7,7,7,15                                         ; (083)
       byte 255,255,255,255,255,255,254,248                          ; (084)
       byte 252,249,243,231,207,159,63,255                           ; (085)
       byte 31,15,7,3,0,0,0,0                                        ; (086)
       byte 240,240,240,224,0,0,0,0                                  ; (087)
       byte 3,127,127,127,0,0,0,0                                    ; (088)
       byte 252,254,254,255,255,255,255,255                          ; (089)
       byte 60,126,231,195,195,231,126,60                            ; (090)
       byte 60,126,207,135,135,207,126,60                            ; (091)
       byte 60,126,243,225,225,243,126,60                            ; (092)
       byte 60,126,255,255,255,255,126,60                            ; (093)
       byte 255,255,255,243,248,255,255,255                          ; (094)
       byte 255,255,255,207,15,31,255,255                            ; (095)
       byte 255,255,255,243,240,248,255,255                          ; (096)
       byte 255,255,255,207,31,255,255,255                           ; (097)
       byte 255,254,252,252,252,252,254,255                          ; (098)
       byte 255,127,63,63,63,63,127,255                              ; (099)
       byte 0,1,3,3,15,31,127,255                                    ; (100)
       byte 0,0,0,0,1,3,7,15                                         ; (101)
       byte 1,7,127,255,255,255,255,255                              ; (102)
       byte 255,254,252,253,249,249,249,249                          ; (103)
       byte 15,15,15,12,12,6,2,0                                     ; (104)
       byte 255,255,0,0,0,0,0,0                                      ; (105)
       byte 253,252,252,252,254,254,254,158                          ; (106)
       byte 239,207,207,111,47,15,7,3                                ; (107)
       byte 30,30,30,30,140,193,223,223                              ; (108)
       byte 96,240,240,248,248,248,120,126                           ; (109)
       byte 124,255,255,63,3,15,63,127                               ; (110)
       byte 127,255,255,255,255,255,255,255                          ; (111)
       byte 1,131,135,199,255,255,255,255                            ; (112)
       byte 252,241,3,7,15,63,62,28                                  ; (113)
       byte 255,255,255,255,255,0,0,0                                ; (114)
       byte 252,253,243,231,143,31,31,31                             ; (115)
       byte 0,0,0,0,0,0,7,7                                          ; (116)
       byte 0,0,0,0,0,15,255,255                                     ; (117)
       byte 1,3,7,31,255,255,255,255                                 ; (118)
       byte 255,254,252,249,243,231,207,159                          ; (119)
       byte 7,3,5,15,15,15,0,0                                       ; (120)
       byte 255,255,85,239,188,120,48,0                              ; (121)
       byte 255,255,95,15,7,3,1,0                                    ; (122)
       byte 191,191,191,159,207,239,239,111                          ; (123)
       byte 254,254,254,254,254,252,253,249                          ; (124)
       byte 255,255,255,255,255,255,254,240                          ; (125)
       byte 251,243,231,207,128,128,0,0                              ; (126)
       byte 251,251,243,247,247,231,239,239                          ; (127)
       byte 207,223,159,191,191,63,127,127                           ; (128)
       byte 127,127,127,127,127,127,127,127                          ; (129)
       byte 56,124,126,254,254,254,254,254                           ; (130)
       byte 254,126,126,63,63,31,15,3                                ; (131)
       byte 255,255,127,127,127,63,191,191                           ; (132)
       byte 63,31,31,15,7,1,0,0                                      ; (133)
       byte 7,3,0,0,0,0,0,0                                          ; (134)
       byte 1,15,63,127,255,255,240,231                              ; (135)
       byte 60,126,255,231,195,195,102,60                            ; (136)
       byte 14,31,63,63,63,63,63,31                                  ; (137)
       byte 15,159,254,253,248,195,255,255                           ; (138)
       byte 31,15,15,7,7,3,3,0                                       ; (139)
       byte 62,192,252,254,126,158,236,193                           ; (140)
       byte 15,255,255,255,255,255,255,255                           ; (141)
       byte 248,244,246,230,238,206,223,31                           ; (142)
       byte 0,0,0,31,255,255,240,231                                 ; (143)
       byte 3,31,255,255,255,255,255,255                             ; (144)
       byte 0,3,15,31,31,63,127,255                                  ; (145)
       byte 1,3,7,15,15,15,31,31                                     ; (146)
       byte 31,15,15,39,55,115,123,120                               ; (147)
       byte 15,255,255,255,0,0,0,0                                   ; (148)
       byte 96,240,240,224,224,0,224,224                             ; (149)
       byte 29,29,61,59,59,119,127,127                               ; (150)
       byte 224,224,224,192,192,192,224,240                          ; (151)
       byte 127,127,63,31,31,15,7,7                                  ; (152)
       byte 195,129,0,126,255,255,255,255                            ; (153)
       byte 3,3,3,1,1,1,3,3                                          ; (154)
       byte 1,1,5,11,27,55,103,239                                   ; (155)
       byte 1,7,31,63,127,255,255,255                                ; (156)
       byte 191,159,223,207,231,240,252,248                          ; (157)
       byte 1,7,15,31,31,63,63,127                                   ; (158)
       byte 255,255,127,63,0,0,0,0                                   ; (159)
       byte 240,224,192,128,0,0,0,0                                  ; (160)
       byte 0,0,0,0,0,120,252,254                                    ; (161)
       byte 1,1,0,0,1,3,7,15                                         ; (162)
       byte 240,135,63,127,255,255,255,255                           ; (163)
       byte 0,0,0,1,3,7,15,30                                        ; (164)
       byte 31,95,191,63,127,127,127,127                             ; (165)
       byte 62,62,62,30,30,14,6,0                                    ; (166)
       byte 239,207,223,223,159,191,191,63                           ; (167)
       byte 127,126,126,62,62,30,6,0                                 ; (168)
       byte 127,127,255,255,255,255,255,255                          ; (169)
       byte 0,0,1,3,7,7,14,13                                        ; (170)
       byte 255,255,255,255,255,255,240,231                          ; (171)
       byte 0,0,0,0,0,1,3,7                                          ; (172)
       byte 0,0,3,31,127,255,255,255                                 ; (173)
       byte 15,127,253,251,243,231,239,207                           ; (174)
       byte 248,243,247,247,247,247,247,247                          ; (175)
       byte 15,15,31,63,63,127,127,127                               ; (176)
       byte 223,223,223,223,207,231,240,254                          ; (177)
       byte 231,143,63,255,255,254,252,0                             ; (178)
       byte 15,227,251,249,252,252,252,252                           ; (179)
       byte 255,252,248,192,0,0,0,0                                  ; (180)
       byte 0,0,0,0,0,0,0,0                                          ; (181)
       byte 31,31,15,0,0,0,0,0                                       ; (182)
       byte 15,255,255,255,255,255,255,255                           ; (183)
       byte 192,248,252,254,255,255,255,255                          ; (184)
       byte 60,126,255,231,231,255,126,60                            ; (185)
       byte 0,128,128,192,192,192,192,192                            ; (186)
       byte 192,192,192,192,192,128,128,0                            ; (187)
       byte 0,0,0,99,249,252,255,63                                  ; (188)
       byte 7,31,255,255,255,126,0,255                               ; (189)
       byte 248,252,254,159,63,127,255,255                           ; (190)
       byte 199,31,255,255,121,1,243,231                             ; (191)
       byte 255,255,255,255,255,254,254,254                          ; (192)
       byte 255,247,199,159,63,127,255,255                           ; (193)
       byte 207,223,223,222,192,255,255,255                          ; (194)
       byte 254,158,30,30,190,188,184,185                            ; (195)
       byte 255,255,255,255,255,0,63,63                              ; (196)
       byte 255,249,227,143,63,127,255,255                           ; (197)
       byte 224,225,241,251,255,255,255,255                          ; (198)
       byte 0,0,0,28,127,255,255,255                                 ; (199)
       byte 255,255,127,63,31,7,1,0                                  ; (200)
       byte 255,255,255,255,255,255,252,0                            ; (201)
       byte 254,253,249,243,199,159,63,31                            ; (202)
       byte 6,15,15,15,15,15,15,7                                    ; (203)
       byte 31,159,191,191,191,191,191,191                           ; (204)
       byte 7,3,3,3,3,1,1,0                                          ; (205)
       byte 191,223,223,207,231,251,248,240                          ; (206)
       byte 0,0,0,0,0,15,63,255                                      ; (207)
       byte 0,1,3,3,3,7,7,6                                          ; (208)
       byte 240,248,247,207,207,159,63,127                           ; (209)
       byte 0,0,0,0,1,63,255,252                                     ; (210)
       byte 0,0,0,0,225,255,127,0                                    ; (211)
       byte 12,9,3,15,255,255,255,31                                 ; (212)
       byte 255,255,255,255,255,247,231,131                          ; (213)
       byte 60,102,195,195,231,255,126,60                            ; (214)
       byte 60,126,255,231,195,195,102,60                            ; (215)
       byte 191,191,191,160,206,254,252,0                            ; (216)
       byte 0,0,0,0,0,224,240,247                                    ; (217)
       byte 0,0,0,0,0,15,31,63                                       ; (218)
       byte 127,127,255,255,0,192,248,252                            ; (219)
       byte 254,254,255,255,255,255,0,0                              ; (220)

* Unused
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0

* Jump to Start of Initialisation Code
* 
* Used by the routines at #R59543 and #R63000.
_34200:
       b    @_34428                    ; JP 34428          ; Jump to start of initialisation code

* Unused
       byte 190,133,173,233

* Index of Current Level
_34207:
       byte 1

* Game Flags
* 
* #TABLE(default,centre,:w)
* { =h Bit | =h Effect }
* { 0 | Drutt Mode Flag (Set = Drutt mode / Reset = Berk mode) }
* { 1 | Characters Already Swapped Flag }
* { 2 | "Berk Has Been Killed" Flag }
* { 3 | "Reset Spiders to Initial State" Flag }
* { 4 | Level Exit Door Unlocked Flag }
* { 5 | Update Scores and Display Flag (Reset = draw timer figures / Set = calculate/update scores and display) }
* { 6 | Character Swap Pending Flag }
* { 7 | Show Score Flag (Reset = draw Timer Figures / Set = Display Score / Hi Score) }
* TABLE#
_34208:
       byte 0

* Cannon's (Level 4) Ammunition Counter
* 
* Number of shots Cannon can fire before returning to its dormant state. Increases by 10 for each drip the Cannon
* catches.
_34209:
       byte 0

* Current Time / Lives
_34210:
       byte 16

* Score Data
_34211:
       data 0                                                        ; Timer Tick Counter / Score penalty (current level)
_34213:
       data 0                                                        ; Score (Current Level)
_34215:
       data 0                                                        ; Current Total Score

* Current Border Colour
_34217:
       byte 1

* Index of Current Character's Current Room
_34218:
       byte 0

* Control Input Bitmap
* 
* #TABLE(default,centre,:w)
* { =h Bit | =h Effect }
* { 0 | Right }
* { 1 | Left }
* { 2 | Forward (i.e. DOWN - makes Drutt swap depth levels) }
* { 3 | Back (i.e. UP - makes Drutt jump higher) }
* { 4 | Berk / Drutt }
* { 5 | Pause }
* { 6 | Restart }
* { 7 | Unused }
* TABLE#
_34219:
       byte 0

* Berk's Current Power
* 
* #TABLE(default,centre,:w)
* { =h Value | =h Effect }
* { 0 | None }
* { 1 | Jumping (Level 1) }
* { 2 | Jumping (Level 2) }
* { 3 | Jumping (Level 4) }
* { 4 | Flying (Level 1) }
* { 5 | Flying (Level 3, 1) }
* { 6 | Flying (Level 3, 2) }
* { 7 | Flying (Level 4, 1) }
* { 8 | Flying (Level 4, 2) }
* { 9 | Immunity to Bubo (Level 2) }
* { 10 | Floating (Level 3) }
* { 11 | Invisibility (Level 3) }
* TABLE#
_34220:
       byte 0

* Interaction Data for Berk
_34221:
       byte 0                                                        ; Class of entity currently held by Berk (e.g. Drutt = 18), or zero for none
_34222:
       byte 0                                                        ; y-coordinate minus one for top edge of coloured creature slot with which Berk is interacting
_34223:
       byte 0                                                        ; Number of times Berk has been killed by a spider on Level 1

* Remaining Duration of Berk's Current Power
* 
* For each game-cycle that a power is in use, the byte at #R34224 is increased. When this reaches 16, it is reset to
* zero and the value at #R34225 is decreased by one.
_34224:
       byte 0                                                        ; Number of elapsed game-cycles in current group of 16
_34225:
       byte 0                                                        ; Number of groups of 16 game-cycles remaining

* Attribute of Current Character
* 
* This is 1 (blue) for Berk, or 6 (yellow) for Drutt.
_34226:
       byte 1

* Timer Figure Blink Duration Counter
_34227:
       byte 0

* Data for Clawed Foot (Level 3)
* 
* Location #R34229 holds the index of the action performed by Clawed Foot after it picks Berk up. This value is
* incremented when the Clawed Foot reaches the top of its vertical range of travel while carrying Berk. If the
* incremented value exceeds six, then it is reset to one. After incrementing (and resetting if appropriate), the
* value is used to determine what the Clawed Foot does with Berk:
_34228:
       byte 0                                                        ; Time (cycles) until Clawed Foot (Level 3) attacks
_34229:
       byte 0                                                        ; Clawed Foot's Action Index

* Temporary Store for Room Dimension Data
* 
* Contains an entry from one of the room dimension data blocks (at #R43815, #R44436, #R45116 or #R45860) for the
* current room of interest (see also #R34262).
_34230:
       byte 0,0,0,0,0

* Temporary Store for Width of Entity's Current Room
* 
* This location holds the width of an entity's current room (in characters, plus + 99).
_34235:
       byte 0

* Table of Data Addresses (Current Level)
_34236:
       data 99                                                       ; State Data for Simple Entities
_34238:
       data 99                                                       ; State Data for Complex Entities
_34240:
       data 99                                                       ; Address of Berk's state data
_34242:
       data 99                                                       ; Address of Drutt's state data
_34244:
       data 99                                                       ; Address of worm's state data
_34246:
       data 99                                                       ; Start address for reverse-order collision checks
_34248:
       data 99                                                       ; Room Dimension Data
_34250:
       data 99                                                       ; Horizontal Room Connectivity Map
_34252:
       data 99                                                       ; Unused Data Block (09)
_34254:
       data 99                                                       ; Vertical Room Connectivity Map

* Miscellaneous Data 1
_34256:
       data 0                                                        ; Address of complex state data for entity Berk is interacting with
_34258:
       data 0                                                        ; Address of complex state data for entity involved in last collision check
_34260:
       data 0                                                        ; Address of complex state data for entity last held by Berk
_34262:
       data 0                                                        ; Pointer to entry in room dimension data for an entity's room (See also data in this entry
                                                                     ; copied to #R34230)
_34264:
       data 0                                                        ; Attribute File address of eyes of currently blinking timer figure
_34266:
       data 0                                                        ; Temporary store for script data to execute upon arrival on new level
_34268:
       byte 0                                                        ; Current Graphic Set Index
_34269:
       byte 0                                                        ; Attribute for text printing
_34270:
       byte 0                                                        ; Current Attribute
_34271:
       byte 0                                                        ; "Display Buffer 2 is Primary" Flag
_34272:
       byte 0                                                        ; Width of entity carried by Berk (characters), minus 1
_34273:
       byte 0                                                        ; Index of pending sound (used by playback routine at #R59722)
_34274:
       byte 0                                                        ; Store for current value of loop counter in graphic layout data processing (instructions 238
                                                                     ; and 239)
_34275:
       byte 0                                                        ; Store for current value of loop counter in graphic layout data processing (instructions 240
                                                                     ; and 241)

* Unused
       byte 0

* Position (Address) in Script Data Currently Running
_34277:
       data 0

* Data for Drawing to Display
_34279:
       data 0                                                        ; Start address of Primary Display Buffer
_34281:
       byte 0                                                        ; Base y-coordinate for graphic drawing
       byte 0                                                        ; Base x-coordinate for graphic drawing

* Unused
       byte 0,0

* Store for Script Instruction Loop Data
_34285:
       byte 0,0,1                                                    ; Repeat count and loop start address for script instructions 23 and 24
_34288:
       byte 0,0,1                                                    ; Repeat count and loop start address for script instructions 25 and 26
_34291:
       byte 0,0,1                                                    ; Repeat count and loop start address for script instructions 27 and 28

* Store for Graphic Layout Loop Data
_34294:
       data 0                                                        ; Store for address of start of current loop in graphic layout data processing (instructions
                                                                     ; 238 and 239)
_34296:
       data 0                                                        ; Store for address of start of current loop in graphic layout data processing (instructions
                                                                     ; 240 and 241)

* Joystick Mode Flag
* 
* #TABLE(default,centre,:w)
* { =h Value | =h Effect }
* { 0 | Joystick Mode off }
* { 1 | Joystick Mode on }
* TABLE#
_34298:
       byte 0

* Current High Score
_34299:
       data 999

* Table of Data Addresses (Level 1)
       data _43146                                                   ; State Data for Simple Entities (Level 1)
       data _43333                                                   ; State Data for Complex Entities (Level 1)
       data _43593                                                   ; Address of Berk's state data (Level 1)
       data _43671                                                   ; Address of Drutt's state data (Level 1)
       data _43684                                                   ; Address of worm's state data (Level 1)
       data _43736                                                   ; Start address for reverse-order collision checks (Level 1)
       data _43815                                                   ; Room Dimension Data (Level 1)
       data _43871                                                   ; Horizontal Room Connectivity Map (Level 1)
       data _43881                                                   ; Unused Data Block (09) (Level 1)
       data _43882                                                   ; Vertical Room Connectivity Map (Level 1)

* Table of Data Addresses (Level 2)
       data _43896                                                   ; State Data for Simple Entities (Level 2)
       data _43993                                                   ; State Data for Complex Entities (Level 2)
       data _44149                                                   ; Address of Berk's state data (Level 2)
       data _44396                                                   ; Address of Drutt's state data (Level 2)
       data _44409                                                   ; Address of Worm's state data (Level 2)
       data _44422                                                   ; Start address for reverse-order collision checks (Level 2)
       data _44436                                                   ; Room Dimension Data (Level 2)
       data _44472                                                   ; Horizontal Room Connectivity Map (Level 2)
       data _44482                                                   ; Unused Data Block (09) (Level 2)
       data _44483                                                   ; Vertical Room Connectivity Map (Level 2)

* Table of Data Addresses (Level 3)
       data _44487                                                   ; State Data for Simple Entities (Level 3)
       data _44608                                                   ; State Data for Complex Entities (Level 3)
       data _44855                                                   ; Address of Berk's state data (Level 3)
       data _44998                                                   ; Address of Drutt's state data (Level 3)
       data _45024                                                   ; Address of worm's state data (Level 3)
       data _45102                                                   ; Start address for reverse-order collision checks (Level 3)
       data _45116                                                   ; Room Dimension Data (Level 3)
       data _45152                                                   ; Horizontal Room Connectivity Map (Level 3)
       data _45164                                                   ; Unused Data Block (09) (Level 3)
       data _45165                                                   ; Vertical Room Connectivity Map (Level 3)

* Table of Data Addresses (Level 4)
       data _45171                                                   ; State Data for Simple Entities (Level 4)
       data _45274                                                   ; State Data for Complex Entities (Level 4)
       data _45391                                                   ; Address of Berk's state data (Level 4)
       data _45443                                                   ; Address of Drutt's state data (Level 4)
       data _45469                                                   ; Address of worm's state data (Level 4)
       data _45846                                                   ; Start address for reverse-order collision checks (Level 4)
       data _45860                                                   ; Room Dimension Data (Level 4)
       data _45886                                                   ; Horizontal Room Connectivity Map (Level 4)
       data _45894                                                   ; Unused Data Block (09) (Level 4)
       data _45895                                                   ; Vertical Room Connectivity Map (Level 4)

* Stack Space
       byte 78,79,87,32,73,83,32,84
       byte 72,69,32,87,73,78,84,69
       byte 82,32,79,70,32,79,85,82
       byte 32,68,73,83,67,79,78,84
       byte 69,78,84,32,77,65,68,69
       byte 32,71,76,79,82

* Unused
_34426:
       byte 0,0

* Set Up Random Seed and Disable Interrupts
* 
* Used by the routine at #R34200.
_34428:
       bl   @_59831                    ; CALL 59831        ; Do nothing (see trivia)
       movb @23672,a                   ; LD A,(23672)      ; Store the least significant byte of the system variable FRAMES...
       mov  a,@_54219                  ; LD (54219),A      ; ...at 54219 as the seed for the pseudo-random number generator
       limi 0                          ; DI                ; Disable interrupts

* Display Main Menu and Handle Main Game Loop
_34438:
       li   sp,_34426                  ; LD SP,34426       ; Set Stack Pointer
       bl   @_34695                    ; CALL 34695        ; Copy State Data for all resettable complex entities into Table of Initial-State Data
       movb one,a                      ; LD A,1            ; Set current level to 1...
       mov  a,@_34207                  ; LD (34207),A      ; ...
       bl   @_46830                    ; CALL 46830        ; Display and handle Main Menu
       movb @_34217,a                  ; LD A,(34217)      ; Load current border colour into A
       ; OUT (254),A                   ; OUT (254),A       ; Set border colour
       bl   @_34864                    ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @_47241                    ; CALL 47241        ; Reset Show Score Flag and draw timer figures bar
* Start of main loop
_34466:
       bl   @_53723                    ; CALL 53723        ; If Berk has been killed then reset his state, flash screen and decrease time / lives
       bl   @_35689                    ; CALL 35689        ; Update state of Berk and store current position in script data
       bl   @_51739                    ; CALL 51739        ; Update states of Drutt and worm and store current positions in script data
       movb @_34207,a                  ; LD A,(34207)      ; If current level is not Level 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _34527                     ; JR NZ,34527       ; ...then skip ahead to #R34527
* Level 1
       bl   @_36791                    ; CALL 36791        ; Update states of all Level 1 entities
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       mov  @10(ix),tmp0               ; BIT 2,(IX+10)     ; If "Back to Level 1" Flag is reset...
       andi tmp0,4                     ;                   
       jeq  _34557                     ; JR Z,34557        ; ...then skip ahead to #R34557
* Back to Level 1 Flag is set
       movb @_43606+6,a                ; LD A,(43612)      ; If y-coordinate of Boni's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  _34557                     ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @_43671+6,a                ; LD A,(43677)      ; If y-coordinate of Drutt's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  _34557                     ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @_43671,a                  ; LD A,(43671)      ; If Drutt's room is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _34557                     ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @bytes+2,a                 ; LD A,2            ; Set depth of "Home Sweet Home" brickwork to 2...
       mov  a,@_43146+13               ; LD (43159),A      ; ...
       socb @bits+3,@10(ix)            ; SET 3,(IX+10)     ; Set "All Home" Flag
       jmp  _34557                     ; JR 34557          ; Skip ahead to #R34557
_34527:
       movb @_34207,a                  ; LD A,(34207)      ; If current level is not Level 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  _34537                     ; JR NZ,34537       ; ...then skip ahead to #R34537
* Level 2
       bl   @_38009                    ; CALL 38009        ; Update states of all Level 2 entities
_34537:
       movb @_34207,a                  ; LD A,(34207)      ; If current level is not Level 3...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jne  _34547                     ; JR NZ,34547       ; ...then skip ahead to #R34547
* Level 3
       bl   @_39137                    ; CALL 39137        ; Update states of all Level 3 entities
_34547:
       movb @_34207,a                  ; LD A,(34207)      ; If current level is not Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jne  _34557                     ; JR NZ,34557       ; ...then skip ahead to #R34557
* Level 4
       bl   @_41211                    ; CALL 41211        ; Update states of all Level 4 entities
* All levels
_34557:
       bl   @_47893                    ; CALL 47893        ; Check for control input and store at #R34219
       bl   @_55525                    ; CALL 55525        ; Move all falling entities down by distances appropriate to their current velocity factors
       bl   @_34916                    ; CALL 34916        ; If Fire Pressed, or Character Swap Pending Flag set, then swap characters
       bl   @_53782                    ; CALL 53782        ; Set each value in Primary Display Buffer within play area to zero
       bl   @_45899                    ; CALL 45899        ; Populate Primary Display Buffer with layout data for current character's current room
       bl   @_54034                    ; CALL 54034        ; Draw contents of Primary Display Buffer to display
       bl   @_59725                    ; CALL 59725        ; Play and clear pending sound (index as stored at #R34273)
       movb @_34210,a                  ; LD A,(34210)      ; Load remaining time / lives into A
       socb a,a                        ; OR A              ; If no time / lives are left...
       jeq  _34645                     ; JR Z,34645        ; ...then jump to #R34645
       movb @_43593+10,a               ; LD A,(43603)      ; If "All Home" Flag is set...
       mov  a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8                     ;                   
       jne  _34658                     ; JR NZ,34658       ; ...then skip ahead to #R34658
       bl   @_47363                    ; CALL 47363        ; Update eyes of a randomly selected timer figure, increase Timer Tick Counter and process
                                                           ; timer figure blinking
       li   hl,_34208                  ; LD HL,34208       ; If Update Scores and Display Flag is reset...
       mov  *hl,tmp0                   ; BIT 5,(HL)        ; ...
       andi tmp0,32                    ;                   
       jeq  _34606                     ; JR Z,34606        ; ...then skip ahead to #R34606
       szcb @bits+5,*hl                ; RES 5,(HL)        ; Reset Update Scores and Display Flag
       bl   @_47499                    ; CALL 47499        ; Update scores and display
_34606:
       li   hl,_61312                  ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,_63424                  ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @_34271,a                  ; LD A,(34271)      ; Invert "Display Buffer 2 is Primary" Flag...
       xor  one,a                      ; XOR 1             ; ...
       mov  a,@_34271                  ; LD (34271),A      ; ...
       jeq  _34623                     ; JR Z,34623        ; If "Display Buffer 2 is Primary" Flag is reset then skip ahead to #R34623 (Display Buffer 1
                                                           ; is Primary, Display Buffer 2 is Secondary)
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
_34623:
       mov  hl,@_34279                 ; LD (34279),HL     ; Store address of Primary Display Buffer at #R34279
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 6,A           ; If Restart hasn't been pressed...
       andi tmp0,64                    ;                   
       jne  !                          ; JP Z,34466        ; ...then jump to #R34466 (start of main loop)
       b    @_34466                    ;                   
!
* Restart has been pressed
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
       bl   @_34751                    ; CALL 34751        ; Reset all game data in preparation for new game
       b    @_34438                    ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
* No time/lives left
_34645:
       bl   @_47499                    ; CALL 47499        ; Update scores and display
       bl   @_47185                    ; CALL 47185        ; Print "SORRY BERK,  BUT YOUR TIME IS UP" string
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
       jmp  _34666                     ; JR 34666          ; Skip ahead to #R34666
* "All Home" Flag is set
_34658:
       bl   @_47213                    ; CALL 47213        ; Print "HOME SWEET HOME" string
       movb @bytes+3,a                 ; LD A,3            ; Set sound 3 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
_34666:
       bl   @_47942                    ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
       bl   @_34751                    ; CALL 34751        ; Reset all game data in preparation for new game
       b    @_34438                    ; JP 34438          ; Jump back to #R34438 (return to Main Menu)

* Pause
* 
* Used by the routine at #R53649. Input:  B  Repeat count for outer loop C  Additional repeat count for inner loop
_34675:
       .push bc                        ; PUSH BC           ; Store BC
       movb @bytes+10,b                ; LD B,10           ; Set B to 10
_34678:
       dec  bc                         ; DEC BC            ; Decrease BC
       movb b,a                        ; LD A,B            ; If BC is not zero...
       socb @c,a                       ; OR C              ; ...
       jne  _34678                     ; JR NZ,34678       ; ...then loop back to #R34678
       .pop bc                         ; POP BC            ; Restore BC
       sb   one,b                      ; DJNZ 34675        ; Loop back for next pass
       jne  _34675                     ;                   
       rt                              ; RET               ; Return

* Table of Start Addresses of Levels' State Data for Complex Entities
_34687:
       data _43333                                                   ; Level 1
       data _43993                                                   ; Level 2
       data _44608                                                   ; Level 3
       data _45274                                                   ; Level 4

* Copy State Data for all Resettable Complex Entities into Table of Initial-State Data for Complex Entities
* 
* Used by the routine at #R34438.
_34695:
       li   iy,_34687                  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   de,_59821                  ; LD DE,59821       ; Point DE at start of Table of Initial-State Data for Complex Entities
       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (as there are 4 levels)
_34704:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       movb *iy,@l                     ; LD L,(IY+0)       ; Load start address of current level's complex state data into HL...
       movb @1(iy),h                   ; LD H,(IY+1)       ; ...
       inc  iy                         ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
       inc  iy                         ; INC IY            ; ...
       .push hl                        ; PUSH HL           ; Transfer start address of current level's complex state data into IX...
       .pop ix                         ; POP IX            ; ...
_34718:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  _34747                     ; JR Z,34747        ; ...then skip ahead to #R34747
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  _34740                     ; JR Z,34740        ; ...then advance IX by 13 bytes to next entry and loop back to #R34718
       .push ix                        ; PUSH IX           ; Transfer start address of current entry in complex state data into HL...
       .pop hl                         ; POP HL            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in complex state data into Table of Initial-State Data for Complex
                                                           ; Entities at #R59821
_34740:
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       a    bc,ix                      ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  _34718                     ; JR 34718          ; Loop back to #R34718
_34747:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       sb   one,b                      ; DJNZ 34704        ; Decrease B and loop back to #R34704 to process next level
       jne  _34704                     ;                   
       rt                              ; RET               ; Return

* Reset All Game Data in Preparation for New Game
* 
* Used by the routine at #R34438.
_34751:
       li   iy,_34687                  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   hl,_59821                  ; LD HL,59821       ; Point HL at start of Table of Initial-State Data for Complex Entities
       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (as there are 4 levels)
_34760:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load start address of current level's complex state data into DE...
       movb @1(iy),d                   ; LD D,(IY+1)       ; ...
       inc  iy                         ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
       inc  iy                         ; INC IY            ; ...
       .push de                        ; PUSH DE           ; Transfer start address of current level's complex state data into IX...
       .pop ix                         ; POP IX            ; ...
_34774:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  _34803                     ; JR Z,34803        ; ...then skip ahead to #R34803
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  _34796                     ; JR Z,34796        ; ...then advance IX by 13 bytes to next entry and loop back to #R34774
       .push ix                        ; PUSH IX           ; Transfer start address of current entry in complex state data into DE...
       .pop de                         ; POP DE            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in Table of Initial-State Data for Complex Entities at #R59821 into
                                                           ; complex state data
_34796:
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       a    bc,ix                      ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  _34774                     ; JR 34774          ; Loop back to #R34774
_34803:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       sb   one,b                      ; DJNZ 34760        ; Decrease B and loop back to #R34760 to process next level
       jne  _34760                     ;                   
       li   hl,_34298                  ; LD HL,34298       ; Point HL at Joystick Mode Flag
       li   de,_34207                  ; LD DE,34207       ; Point DE at store for current level number
       sb   a,a                        ; XOR A             ; Set A to zero and reset Carry Flag
       sb   de,hl                      ; SBC HL,DE         ; Subtract DE from HL to leave HL = 91
       movb @l,b                       ; LD B,L            ; Load B with 91
       li   hl,_34207                  ; LD HL,34207       ; Point HL at store for current level number...
_34819:
       movb a,*hl                      ; LD (HL),A         ; ...and set 91 bytes from here onwards to zero...
       inc  hl                         ; INC HL            ; ...
       sb   one,b                      ; DJNZ 34819        ; ...
       jne  _34819                     ;                   
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       mov  a,@_34210                  ; LD (34210),A      ; ...
       movb one,a                      ; LD A,1            ; Set current level to Level 1...
       mov  a,@_34207                  ; LD (34207),A      ; ...
       bl   @_36778                    ; CALL 36778        ; Initialise script data positions for Flying Skeleton Creature and Bat (Level 1)
       bl   @_38468                    ; CALL 38468        ; Reset current positions in apebeasts' script data to initial values
       bl   @_41354                    ; CALL 41354        ; Reset Skeleton to initial state
       bl   @_51732                    ; CALL 51732        ; Reset Drutt to initial state
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" and impassable marker to 1 (i.e. starting room)...
       mov  a,@_43188                  ; LD (43188),A      ; ...
       mov  a,@_43450                  ; LD (43450),A      ; ...
       mov  a,@_34226                  ; LD (34226),A      ; Set attribute of current character to 1 (blue, Berk)
       sb   one,a                      ; DEC A             ; Set room of "Open Trap Door" and "Home Sweet Home" brickwork to 0...
       mov  a,@_43437                  ; LD (43437),A      ; ...i.e. remove from game...
       mov  a,@_43146+13               ; LD (43159),A      ; ...
       rt                              ; RET               ; Return

* Copy Start Addresses of Current Level's Data Blocks to 34236 and Clean Up Old Data
* 
* Used by the routines at #R34438 and #R36753.
_34864:
       .push de                        ; PUSH DE           ; Store DE
       .push hl                        ; PUSH HL           ; Store HL
       mov  @_34244,hl                 ; LD HL,(34244)     ; Load HL with address of complex state data (current level) for worm
       movb @bytes+0,*hl               ; LD (HL),0         ; Set worm's current room to zero
       movb @_34207,a                  ; LD A,(34207)      ; Load current level into A
       li   hl,_34281                  ; LD HL,34281       ; Point HL at position 20 bytes before start of list of start addresses of level 1's data
                                                           ; blocks
       li   bc,20                      ; LD BC,20          ; Set data length to 20, as there are 10 data blocks per level (so 10 addresses)
_34880:
       a    bc,hl                      ; ADD HL,BC         ; Advance HL to start of data block address list for next level
       sb   one,a                      ; DEC A             ; Decrease level counter
       jne  _34880                     ; JR NZ,34880       ; Loop back if we have not reached data for required level
* At this point, HL points to the start of the list of start addresses of the current level's data blocks
       li   de,_34236                  ; LD DE,34236       ; Copy this level's data block start addresses to #R34236...
       .ldir                           ; LDIR              ; ...
       movb @bytes+9,b                 ; LD B,9            ; Clear Store for Script Instruction Loop Data...
       li   hl,_34285                  ; LD HL,34285       ; ...
_34894:
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; ...
       sb   one,b                      ; DJNZ 34894        ; ...
       jne  _34894                     ;                   
       .pop hl                         ; POP HL            ; Restore HL
       .pop de                         ; POP DE            ; Restore DE
       rt                              ; RET               ; Return

* Script Routine (48, 49) Return
* 
* This script routine terminates the script data currently under execution until the next game cycle.
_34901:
       rt                              ; RET               ; Return

* Unused routine
* 
* This routine floods the Attribute File with value 9 (Blue INK, Blue PAPER)
       li   hl,22528                   ; LD HL,22528       ; Set all Attribute File contents to blue INK, blue PAPER...
       li   de,22529                   ; LD DE,22529       ; ...
       movb @bytes+9,*hl               ; LD (HL),9         ; ...
       li   bc,767                     ; LD BC,767         ; ...
       .ldir                           ; LDIR              ; ...
       rt                              ; RET               ; Return

* If Fire Pressed, or Character Swap Pending Flag Set, then Swap Characters
* 
* Used by the routine at #R34438.
_34916:
       li   hl,_34208                  ; LD HL,34208       ; If Character Swap Pending Flag is reset...
       mov  *hl,tmp0                   ; BIT 6,(HL)        ; ...
       andi tmp0,64                    ;                   
       jeq  _34927                     ; JR Z,34927        ; ...then skip ahead to #R34927
       szcb @bits+6,*hl                ; RES 6,(HL)        ; Reset Character Swap Pending Flag
       jmp  _34944                     ; JR 34944          ; Skip ahead to #R34944
_34927:
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 4,A           ; If fire was pressed...
       andi tmp0,16                    ;                   
       jne  _34940                     ; JR NZ,34940       ; ...then skip ahead to #R34940
       szcb @bits+1,*hl                ; RES 1,(HL)        ; Reset Characters Already Swapped Flag
_34936:
       bl   @_53825                    ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       rt                              ; RET               ; Return
* [Fire pressed]
_34940:
       mov  *hl,tmp0                   ; BIT 1,(HL)        ; If Characters Already Swapped Flag set (i.e. FIRE hasn't been released since last swap)...
       andi tmp0,2                     ;                   
       jne  _34936                     ; JR NZ,34936       ; ...then jump back to #R34936
_34944:
       socb @bits+1,*hl                ; SET 1,(HL)        ; Set Characters Already Swapped Flag
       movb *hl,a                      ; LD A,(HL)         ; Load Game Flags into A
       xor  one,a                      ; XOR 1             ; Flip bit 7 (Berk / Drutt flag)...
       movb a,*hl                      ; LD (HL),A         ; ...
       mov  *hl,tmp0                   ; BIT 0,(HL)        ; If current character is now Berk (0)...
       andi tmp0,1                     ;                   
       jeq  _34958                     ; JR Z,34958        ; ...then jump ahead to #R34958
       movb @bytes+6,a                 ; LD A,6            ; Load A with 6 (attribute for Drutt's timer indicator figures)
       jmp  _34960                     ; JR 34960          ; Skip ahead to #R34960
_34958:
       movb one,a                      ; LD A,1            ; Load A with 1 (attribute for Berk's timer indicator figures)
_34960:
       mov  a,@_34226                  ; LD (34226),A      ; Set attribute of timer indicator figures to value in A
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       li   hl,_34208                  ; LD HL,34208       ; If Show Score Flag is set...
       mov  *hl,tmp0                   ; BIT 7,(HL)        ; ...
       andi tmp0,128                   ;                   
       jeq  !                          ; JP NZ,47628       ; ...then print SCORE / TOTAL / HI-SC string in current character's colours and return
       b    @_47628                    ;                   
!
       b    @_47241                    ; JP 47241          ; Reset Show Score Flag, draw timer figures bar and return

* Script Data Berk Turning to Face Left
_34977:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 19,0                                                     ; Move carried entity to Berk's left as he faces left
       byte _56248%256,_56248/256                                    ; #R56248 (Berk, stepping left, left foot out, arm and eye animated)
       byte _56257%256,_56257/256                                    ; #R56257 (Berk, stepping left, left foot out and forward, arm and eye animated)
* At this point, Berk has made the turn (i.e. already moved his feet)
_34985:
       byte 13,0                                                     ; Set Berk's Facing Left Flag, and reset his Facing Into Screen and Facing Right flags
       byte 19,0                                                     ; Move carried entity to Berk's left as he faces left
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte _56266%256,_56266/256                                    ; #R56266 (Berk, facing left, arm and eye animated)
       byte 1,0,_34985%256,_34985/256                                ; Jump back to #R34985

* Script Data Berk Turning to Face Right
_34997:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 20,0                                                     ; Move carried entity to Berk's right as he faces right
       byte _55710%256,_55710/256                                    ; #R55710 (Berk, stepping right, right foot out, arm and eye animated)
       byte _55698%256,_55698/256                                    ; #R55698 (Berk, stepping right, right foot out and forward, arm and eye animated)
* At this point, Berk has made the turn (i.e. already moved his feet)
_35005:
       byte 14,0                                                     ; Set Berk's Facing Right Flag, and reset his Facing Into Screen and Facing Left flags
       byte 20,0                                                     ; Move carried entity to Berk's right as he faces right
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte _55722%256,_55722/256                                    ; #R55722 (Berk, facing right, arm and eye animated)
       byte 1,0,_35005%256,_35005/256                                ; Jump back to #R35005

* Script Data Berk Interacting with a Door Behind Him
_35017:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 6,0                                                      ; Set Berk's Facing Into Screen Flag, and reset his Facing Left and Facing Right flags
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 22,0                                                     ; Move carried entity behind Berk as he faces into screen
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte 59,0                                                     ; Have Berk interact appropriately with a door behind him
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
       byte 23,0,5,0                                                 ; Start loop (1) for 5 iterations
       byte _57338%256,_57338/256                                    ; #R57338 (Berk facing into screen, arms out to the sides)
       byte 24,0                                                     ; End loop (1)
       byte 1,0,_35113%256,_35113/256                                ; Jump to #R35113 (Berk facing into screen, ready to respond to control input)

* Script Data Berk Interacting with a Door in Front of Him
_35045:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 7,0                                                      ; Reset Berk's Facing Into Screen, Facing Left and Facing Right flags
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 21,0                                                     ; Move carried entity in front of Berk as he faces out of screen
       byte _57058%256,_57058/256                                    ; #R57058 (Berk, facing out of screen, holding something, animated)
       byte _57058%256,_57058/256                                    ; #R57058 (Berk, facing out of screen, holding something, animated)
       byte 58,0                                                     ; Have Berk interact appropriately with a door in front of him
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
       byte 23,0,5,0                                                 ; Start loop (1) for 5 iterations
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte 24,0                                                     ; End loop (1)
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)

* Script Data Berk Turning (Facing into Screen to Facing Out of Screen)
_35073:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 20,0                                                     ; Move carried entity to Berk's right as he faces right
       byte _55698%256,_55698/256                                    ; #R55698 (Berk, stepping right, right foot out and forward, arm and eye animated)
       byte _55710%256,_55710/256                                    ; #R55710 (Berk, stepping right, right foot out, arm and eye animated)
* Berk facing out of screen, ready to respond to control input
_35081:
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte 7,0                                                      ; Reset Berk's Facing Into Screen, Facing Left and Facing Right flags
       byte 15,0,_35097%256,_35097/256                               ; If Berk is carrying something then jump to #R35097 (Berk facing out of screen, holding
                                                                     ; something)
* Berk holding nothing
_35091:
       byte _56804%256,_56804/256                                    ; #R56804 (Berk, facing out of screen, arms down at sides, animated)
       byte 1,0,_35091%256,_35091/256                                ; Jump to #R35091
* Berk holding something
_35097:
       byte 21,0                                                     ; Move carried entity in front of Berk as he faces out of screen
       byte _57058%256,_57058/256                                    ; #R57058 (Berk, facing out of screen, holding something, animated)
       byte 1,0,_35097%256,_35097/256                                ; Jump to #R35097

* Script Data Berk Turning (Facing Out of Screen to Facing into Screen)
_35105:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 19,0                                                     ; Move carried entity to Berk's left as he faces left
       byte _56248%256,_56248/256                                    ; #R56248 (Berk, stepping left, left foot out, arm and eye animated)
       byte _56257%256,_56257/256                                    ; #R56257 (Berk, stepping left, left foot out and forward, arm and eye animated)
* Berk facing into screen, ready to respond to control input
_35113:
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte 6,0                                                      ; Set Berk's Facing Into Screen Flag, and reset his Facing Left and Facing Right flags
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 15,0,_35173%256,_35173/256                               ; If Berk is carrying something then jump to #R35173 (Berk facing into screen, holding
                                                                     ; something)
* Berk holding nothing
       byte 23,0,8,0                                                 ; Start loop (1) for 8 iterations
       byte _57353%256,_57353/256                                    ; #R57353 (Berk, facing into screen, arms down)
       byte 24,0                                                     ; End loop (1)
       byte 1,0,_35073%256,_35073/256                                ; Jump to #R35073 (Berk turning from facing into screen to facing out of screen)

* Script Data Berk Picking Up an Entity on Floor Behind Him
_35135:
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _57338%256,_57338/256                                    ; #R57338 (Berk facing into screen, arms out to the sides)
       byte _58209%256,_58209/256                                    ; #R58209 (Berk facing into screen, bending down)
       byte 16,0                                                     ; Have Berk hold an entity, and position it appropriately between his hands
       byte 1,0,_35173%256,_35173/256                                ; Jump to #R35173 (Berk facing into screen, holding something)

* Script Data Berk Picking Up an Entity Above and Behind Him
_35149:
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _58278%256,_58278/256                                    ; #R58278 (Berk, facing into screen, stretching upwards)
       byte _58278%256,_58278/256                                    ; #R58278 (Berk, facing into screen, stretching upwards)
       byte 16,0                                                     ; Have Berk hold an entity, and position it appropriately between his hands
       byte 1,0,_35173%256,_35173/256                                ; Jump to #R35173 (Berk facing into screen, holding something)

* Script Data Berk Picking Up an Entity that is Above Floor and Below Berk's Top Edge and Behind Him
_35163:
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _57338%256,_57338/256                                    ; #R57338 (Berk facing into screen, arms out to the sides)
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte 16,0                                                     ; Have Berk hold an entity, and position it appropriately between his hands
_35173:
       byte 22,0                                                     ; Move carried entity behind Berk as he faces into screen
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte 1,0,_35073%256,_35073/256                                ; Jump to #R35073 (Berk turning from facing into screen to facing out of screen)

* Script Data Berk Picking Up an Entity on Floor in Front of Him
_35187:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte 16,0                                                     ; Have Berk hold an entity, and position it appropriately between his hands
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)

* Script Data Berk Putting an Entity Down on Floor in Front of Him
_35205:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 21,0                                                     ; Move carried entity in front of Berk as he faces out of screen
       byte 17,0                                                     ; Have Berk put down an entity in front of him, if appropriate
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)

* Script Data Berk Putting an Entity Down on Floor Behind Him
_35219:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 22,0                                                     ; Move carried entity behind Berk as he faces into screen
       byte 18,0                                                     ; Have Berk put down an entity behind him, if appropriate
       byte _58209%256,_58209/256                                    ; #R58209 (Berk facing into screen, bending down)
       byte _58209%256,_58209/256                                    ; #R58209 (Berk facing into screen, bending down)
       byte _57338%256,_57338/256                                    ; #R57338 (Berk facing into screen, arms out to the sides)
       byte 1,0,_35113%256,_35113/256                                ; Jump to #R35113 (Berk facing into screen, ready to respond to control input)

* Script Data Berk Putting an Entity Down Above Floor Behind Him
_35235:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 22,0                                                     ; Move carried entity behind Berk as he faces into screen
       byte _57428%256,_57428/256                                    ; #R57428 (Berk facing into screen, holding something)
       byte 18,0                                                     ; Have Berk put down an entity behind him, if appropriate
       byte _58278%256,_58278/256                                    ; #R58278 (Berk, facing into screen, stretching upwards)
       byte _58278%256,_58278/256                                    ; #R58278 (Berk, facing into screen, stretching upwards)
       byte 1,0,_35073%256,_35073/256                                ; Jump to #R35073 (Berk turning from facing into screen to facing out of screen)

* Script Data Berk Starting to Walk Right
_35251:
       byte 12,0                                                     ; Set Berk's Walking Right Flag
       byte 20,0                                                     ; Move carried entity to Berk's right as he faces right
_35255:
       byte _55734%256,_55734/256                                    ; #R55734 (Berk walking right, animated)
       byte 3,0                                                      ; Move Berk right one character
       byte 1,0,_35255%256,_35255/256                                ; Jump to #R35255

* Script Data Berk Starting to Walk Left
_35263:
       byte 11,0                                                     ; Set Berk's Walking Left Flag
       byte 19,0                                                     ; Move carried entity to Berk's left as he faces left
_35267:
       byte _56275%256,_56275/256                                    ; #R56275 (Berk walking left, animated)
       byte 2,0                                                      ; Move Berk left one character
       byte 1,0,_35267%256,_35267/256                                ; Jump back to #R35267

* Script Data Berk's Power Expiring
_35275:
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
       byte 1,0,_35359%256,_35359/256                                ; Jump to #R35359 (Berk starting to fall downwards)

* Script Data Berk Banging Head (While Jumping)
_35283:
       byte _59464%256,_59464/256                                    ; #R59464 (Berk, getting up / banging head, frame 2)
       byte _59464%256,_59464/256                                    ; #R59464 (Berk, getting up / banging head, frame 2)
       byte 1,0,_35359%256,_35359/256                                ; Jump to #R35359 (Berk starting to fall downwards)

* Script Data Berk Starting to Fall to the Left
_35291:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 23,0,3,0                                                 ; Start loop (1) for 3 iterations
       byte _56275%256,_56275/256                                    ; #R56275 (Berk walking left, animated)
       byte 2,0                                                      ; Move Berk left one character
       byte 24,0                                                     ; End loop (1)
* At this point, the fall is in progress
_35303:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _58853%256,_58853/256                                    ; #R58853 (Berk, facing left, falling, arms to sides)
       byte 2,0                                                      ; Move Berk left two characters...
       byte 2,0                                                      ; ...
       byte _58685%256,_58685/256                                    ; #R58685 (Berk, facing left, falling, arms forward)
       byte 2,0                                                      ; Move Berk left one character
       byte 35,0                                                     ; Move Berk down two characters...
       byte 35,0                                                     ; ...
       byte _59048%256,_59048/256                                    ; #R59048 (Berk being thrown left)
       byte 35,0                                                     ; Move Berk down one character
       byte 1,0,_35359%256,_35359/256                                ; Jump to #R35359 (Berk starting to fall downwards)

* Script Data Berk Starting to Fall to the Right
_35327:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 23,0,3,0                                                 ; Start loop (1) for 3 iterations
       byte _55734%256,_55734/256                                    ; #R55734 (Berk walking right, animated)
       byte 3,0                                                      ; Move Berk right one character
       byte 24,0                                                     ; End loop (1)
* At this point, the fall is in progress
_35339:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _58778%256,_58778/256                                    ; #R58778 (Berk, facing right, falling, arms to sides)
       byte 3,0                                                      ; Move Berk right two characters...
       byte 3,0                                                      ; ...
       byte _58592%256,_58592/256                                    ; #R58592 (Berk, facing right, falling, arms forward)
       byte 3,0                                                      ; Move Berk right one character
       byte 35,0                                                     ; Move Berk down two characters...
       byte 35,0                                                     ; ...
       byte _58928%256,_58928/256                                    ; #R58928 (Berk, being thrown right)
       byte 35,0                                                     ; Move Berk down one character
* This is the start of the script data that controls Berk's vertical falls, e.g. when flying power expires, after
* initial sideways fall down Trap Door, etc.
_35359:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 29,0                                                     ; Make Berk start falling, and drop his carried entity if appropriate
_35363:
       byte _59168%256,_59168/256                                    ; #R59168 (Floating / starting to fall, animated)
       byte 30,0                                                     ; Check Berk's fall velocity, and react to landing
_35367:
       byte _59239%256,_59239/256                                    ; #R59239 (Berk, falling downwards)
       byte 30,0                                                     ; Check Berk's fall velocity, and react to landing
* This is the start of the script data that controls Berk when he has landed from a fall. Initially he is lying on
* the floor stunned, and then he gets up.
_35371:
       byte _59311%256,_59311/256                                    ; #R59311 (Berk, lying on floor, animated)
       byte 4,0,5,0                                                  ; If current character and target entity are in the same room then set pending sound to 5
                                                                     ; (#R59666)
       byte _59380%256,_59380/256                                    ; #R59380 (Berk, getting up, frame 1, animated)
       byte 23,0,15,0                                                ; Start loop (1) for 15 iterations
       byte _59311%256,_59311/256                                    ; #R59311 (Berk, lying on floor, animated)
       byte 24,0                                                     ; End loop (1)
       byte 23,0,4,0                                                 ; Start loop (1) for 4 iterations
       byte _59380%256,_59380/256                                    ; #R59380 (Berk, getting up, frame 1, animated)
       byte 24,0                                                     ; End loop (1)
       byte 23,0,2,0                                                 ; Start loop (1) for 2 iterations
       byte _59311%256,_59311/256                                    ; #R59311 (Berk, lying on floor, animated)
       byte _59311%256,_59311/256                                    ; #R59311 (Berk, lying on floor, animated)
       byte _59380%256,_59380/256                                    ; #R59380 (Berk, getting up, frame 1, animated)
       byte _59464%256,_59464/256                                    ; #R59464 (Berk, getting up / banging head, frame 2)
       byte 24,0                                                     ; End loop (1)
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)

* Script Data Berk Starting to Fly Holding nothing
_35417:
       byte 21,0                                                     ; Move carried entity in front of Berk as he faces out of screen
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
       byte 15,0,_35433%256,_35433/256                               ; If Berk is carrying something then jump to #R35433
_35425:
       byte _56801%256,_56801/256                                    ; #R56801 (Berk with wings, animated)
       byte 32,0                                                     ; Update Berk's position and state (flying) depending upon control input
       byte 1,0,_35425%256,_35425/256                                ; Jump back to #R35425
* Holding something
_35433:
       byte _57055%256,_57055/256                                    ; #R57055 (Berk with wings and holding something, animated)
       byte 32,0                                                     ; Update Berk's position and state (flying) depending upon control input
       byte 1,0,_35433%256,_35433/256                                ; Jump back to #R35433

* Script Data Berk Jumping
* 
* Berk Starting to Jump Straight Up
_35441:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
_35447:
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
_35449:
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte 33,0                                                     ; Advance Berk's jump and select next phase if current phase complete
       byte 1,0,_35449%256,_35449/256                                ; Jump back to #R35449
* Berk Landing (After Jump)
_35457:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 10,0                                                     ; Reset Berk's Walking Left and Walking Right flags
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte _58119%256,_58119/256                                    ; #R58119 (Berk, facing out of screen, bending down)
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)
* Berk Jumping Left
_35469:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 11,0                                                     ; Set Berk's Walking Left Flag
       byte _56275%256,_56275/256                                    ; #R56275 (Berk walking left, animated)
       byte 33,0                                                     ; Advance Berk's jump and select next phase if current phase complete
       byte 1,0,_35469%256,_35469/256                                ; Jump to #R35469
* Berk Jumping Right
_35481:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 12,0                                                     ; Set Berk's Walking Right Flag
       byte _55734%256,_55734/256                                    ; #R55734 (Berk walking right, animated)
       byte 33,0                                                     ; Advance Berk's jump and select next phase if current phase complete
       byte 1,0,_35481%256,_35481/256                                ; Jump to #R35481

* Script Data Berk Eating an Entity
_35493:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 23,0,4,0                                                 ; Start loop (1) for 4 iterations
       byte _56743%256,_56743/256                                    ; #R56743 (Berk, arms raised, eating, animated)
       byte 24,0                                                     ; End loop (1)
       byte 56,0                                                     ; Give Berk power corresponding to entity eaten
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte _56731%256,_56731/256                                    ; #R56731 (Berk, facing out of screen, arms outstretched, animated)
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
       byte 1,0,_35081%256,_35081/256                                ; Jump to #R35081 (Berk facing out of screen, ready to respond to control input)

* Script Data Berk Gaining Floating Power
* 
* The current position in Berk's script data is set to #R35515 both when he gains the floating power (#R36536) and
* when the Clawed Foot on Level 3 grabs Berk (#R39391). In the former case, the script instruction at #R35515 will
* be executed however in the latter case that instruction will be skipped over. Therefore, when Berk is grabbed on
* Level 3, the cycle attributes effect does not occur.
_35515:
       byte 57,0                                                     ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                                     ; room
_35517:
       byte _59168%256,_59168/256                                    ; #R59168 (Floating / starting to fall, animated)
       byte 1,0,_35517%256,_35517/256                                ; Jump to #R35517

* Script Data Berk Being Thrown Left by Hatch (Level 3)
_35523:
       byte _59048%256,_59048/256                                    ; #R59048 (Berk being thrown left)
       byte 23,0,5,0                                                 ; Start loop (1) for 5 iterations
       byte _59048%256,_59048/256                                    ; #R59048 (Berk being thrown left)
       byte 2,0                                                      ; Move Berk left two characters...
       byte 2,0                                                      ; ...
       byte 62,0                                                     ; Move Berk into room to the left, if appropriate
       byte 34,0                                                     ; Move Berk up two characters...
       byte 34,0                                                     ; ...
       byte 24,0                                                     ; End loop (1)
       byte 23,0,4,0                                                 ; Start loop (1) for 4 iterations
       byte _59048%256,_59048/256                                    ; #R59048 (Berk being thrown left)
       byte 2,0                                                      ; Move Berk left two characters...
       byte 2,0                                                      ; ...
       byte 35,0                                                     ; Move Berk down two characters...
       byte 35,0                                                     ; ...
       byte 24,0                                                     ; End loop (1)
       byte 23,0,2,0                                                 ; Start loop (1) for 2 iterations
       byte _59168%256,_59168/256                                    ; #R59168 (Floating / starting to fall, animated)
       byte 2,0                                                      ; Move Berk left one character
       byte 35,0                                                     ; Move Berk down two characters...
       byte 35,0                                                     ; ...
       byte 24,0                                                     ; End loop (1)
       byte 1,0,_35371%256,_35371/256                                ; Jump to #R35371 (Berk lying on floor stunned and getting up)

* Change Direction Berk is Facing Depending Upon Relative Position of Drutt
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_35577:
       movb @_34218,a                  ; LD A,(34218)      ; If Drutt's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's current room...
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
       movb @11(ix),a                  ; LD A,(IX+11)      ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags...
       andi a,240*256                  ; AND 240           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       movb @9(ix),@e                  ; LD E,(IX+9)       ; Load Berk's Flags into E
       mov  @_34242,iy                 ; LD IY,(34242)     ; Load IY with address of complex state data (current level) for Drutt
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with x-coordinate of Drutt's right side...
       ab   one,a                      ; INC A             ; ...and increase by one
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of Berk's left side is greater than this (i.e. Drutt is to the left of
                                                           ; Berk)...
       jl   _35653                     ; JR C,35653        ; ...then skip ahead to #R35653
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right side
       ab   one,a                      ; INC A             ; Increase A by one
       cb   a,@5(iy)                   ; CP (IY+5)         ; If x-coordinate of Drutt's left side is greater than this (i.e. Drutt is to the right of
                                                           ; Berk)...
       jl   _35670                     ; JR C,35670        ; ...then skip ahead to #R35670
* Drutt is between Berk's left and right sides
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Drutt's depth is 1...
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; JP Z,35642        ; ...then skip ahead to #R35642
       b    @_35642                    ;                   
!
* Drutt is behind Berk
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,14*256                   ; AND 14            ; If Berk's Facing into Screen, Facing Left and Facing Right flags are all reset...
       jne  !                          ; JP Z,35636        ; ...then skip ahead to #R35636
       b    @_35636                    ;                   
!
* Drutt is behind Berk and at least one of Berk's Facing into Screen, Facing Left and Facing Right flags is set
       b    @_35815                    ; JP 35815          ; Point HL at script data for Berk facing into screen, ready to respond to control input and
                                                           ; execute
* Drutt is behind Berk and Berk's Facing into Screen, Facing Left and Facing Right flags are all reset
_35636:
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt is in front of Berk
_35642:
       mov  @e,tmp0                    ; BIT 1,E           ; If Berk's Facing into Screen Flag is reset...
       andi tmp0,2                     ;                   
       jne  !                          ; JP Z,35821        ; ...then point HL at script data for Berk facing out of screen, ready to respond to control
       b    @_35821                    ;                   
!
                                                           ; input and execute
* Drutt is in front of Berk and Berk's Facing into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk
_35653:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,6*256                    ; AND 6             ; If either of Berk's Facing into Screen or Facing Left flags are set...
       jne  _35664                     ; JR NZ,35664       ; ...then skip ahead to #R35664
* Drutt is to the left of Berk, and Berk's Facing into Screen and Facing Left flags are both reset
       li   hl,_34977                  ; LD HL,34977       ; Point HL at script data for Berk turning to face left...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk and either of Berk's Facing into Screen or Facing Left flags are set
_35664:
       li   hl,_34985                  ; LD HL,34985       ; Point HL at script data for Berk facing left...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk
_35670:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,10*256                   ; AND 10            ; If either of Berk's Facing into Screen or Facing Right flags are set...
       jne  _35681                     ; JR NZ,35681       ; ...then skip ahead to #R35681
* Drutt is to the right of Berk, and Berk's Facing into Screen and Facing Right flags are both reset
       li   hl,_34997                  ; LD HL,34997       ; Point HL at script data for Berk turning to face right...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk and either of Berk's Facing into Screen or Facing Right flags are set
_35681:
       li   hl,_35005                  ; LD HL,35005       ; Point HL at script data for Berk facing right...
       b    @_48098                    ; JP 48098          ; ...and execute

* Current Position in Berk's Script Data
_35687:
       data _35081                                                   ; Berk facing out of screen, ready to respond to control input

* Update State of Berk and Store Current Position in Script Data
* 
* Used by the routine at #R34438.
_35689:
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       bl   @_53848                    ; CALL 53848        ; Store room size data for Berk's current room
       mov  @9(ix),tmp0                ; BIT 5,(IX+9)      ; If Berk's "Do Not Update State" Flag is set...
       andi tmp0,32                    ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  @_35687,hl                 ; LD HL,(35687)     ; Load current position in Berk's script data from #R35687 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_35735                    ; CALL 35735        ; Update state of Berk depending upon currently selected character, control input and currently
                                                           ; active power
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_35687                 ; LD (35687),HL     ; ...at #R35687 as current position in Berk's script data
       movb @_34220,a                  ; LD A,(34220)      ; If Berk's current power is not invisibility (level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
* Current power is invisibility (Level 3)
       li   bc,_50800                  ; LD BC,50800       ; Load BC with address of blank graphic layout data...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as Berk's current graphic layout data address...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       bl   @_48388                    ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       rt                              ; RET               ; Return

* Update State of Berk Depending Upon Currently Selected Character, Control Input and Currently Active Power
* 
* Used by the routine at #R35689. Input:  IX  Address of complex state data (current level) for Berk
_35735:
       mov  @9(ix),tmp0                ; BIT 7,(IX+9)      ; If Berk's Moving Upwards Flag (floating power) is set...
       andi tmp0,128                   ;                   
       jeq  !                          ; JP NZ,36542       ; ...then jump to #R36542 (update state of Berk,  floating power active)
       b    @_36542                    ;                   
!
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is set...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,35577       ; ...then jump to #R35577 (change direction Berk is facing depending upon relative position of
       b    @_35577                    ;                   
!
                                                           ; Drutt)
* Drutt Mode Flag is reset (i.e. Berk Mode)
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,36214       ; ...then skip ahead to #R36214 (move Berk right if appropriate)
       b    @_36214                    ;                   
!
       mov  a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,36137       ; ...then skip ahead to #R36137 (move Berk left if appropriate)
       b    @_36137                    ;                   
!
       bl   @_54283                    ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4                     ;                   
       jeq  !                          ; JP NZ,36036       ; ...then skip ahead to #R36036 (update state of Berk, forward pressed)
       b    @_36036                    ;                   
!
       mov  a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8                     ;                   
       jeq  !                          ; JP NZ,35827       ; ...then skip ahead to #R35827
       b    @_35827                    ;                   
!
* At this point, no control has been pressed. This entry point is used by the routines at #R35577, #R36036 and
* #R36116.
_35786:
       equ  $
       mov  @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is not flying...
       andi tmp0,64                    ;                   
       jeq  _35802                     ; JR Z,35802        ; ...then skip ahead to #R35802
* Berk is flying
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset Berk's Is Flying Flag
       li   hl,_35359                  ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @_48098                    ; JP 48098          ; ...and execute
* No control pressed and Berk not flying
_35802:
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _35821                     ; JR Z,35821        ; ...then skip ahead to #R35821
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is set
       mov  @11(ix),tmp0               ; BIT 3,(IX+11)     ; If Berk's Unused (11,3) Flag is reset...
       andi tmp0,8                     ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
* No control pressed, Berk not flying, Berk's Facing Into Screen and Unused (11,3) flags are set This entry point is
* used by the routine at #R35577.
_35815:
       equ  $
       li   hl,_35113                  ; LD HL,35113       ; Point HL at script data for Berk facing into screen, ready to respond to control input...
       b    @_48098                    ; JP 48098          ; ...and execute
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is reset This entry point is used by the
* routine at #R35577.
_35821:
       li   hl,_35081                  ; LD HL,35081       ; Point HL at script data for Berk facing out of screen, ready to respond to control input...
       b    @_48098                    ; JP 48098          ; ...and execute
* Back Pressed
_35827:
       mov  @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64                    ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       bl   @_36008                    ; CALL 36008        ; If Berk is holding an edible entity them make him eat it, process appropriate script data
                                                           ; and return to calling routine
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Temporarily decrease y-coordinate of Berk's top edge
       bl   @_54890                    ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                                           ; into screen whose Interaction (11,7) Flag is set
       .push af                        ; PUSH AF           ; Store AF
       ab   one,@4(ix)                 ; INC (IX+4)        ; Restore y-coordinate of Berk's top edge
       .pop af                         ; POP AF            ; Restore AF
       joc  _35953                     ; JR C,35953        ; TODO: check code. If no collision occurred, then skip ahead to #R35953
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  _35870                     ; JR NZ,35870       ; ...then skip ahead #R35870
* Collision with door
       bl   @_36116                    ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       bl   @_36367                    ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@_34256                 ; LD (34256),IY     ; Store address of complex state data for door at #R34256
       li   hl,_35017                  ; LD HL,35017       ; Point HL at script data for Berk interacting with a door behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Collision with something other than door
_35870:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  _35924                     ; JR NC,35924       ; ...then skip ahead to #R35924
* Collision with entity that can be picked up
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is already carrying something...
       andi tmp0,16                    ;                   
       jeq  !                          ; JP NZ,35953       ; ...then skip ahead to #R35953
       b    @_35953                    ;                   
!
       bl   @_36116                    ; CALL 36116        ; If Berk is not horizontally aligned with entity then move him closer and exit this routine
* Berk is now horizontally aligned with entity pointed to by IY
       bl   @_36367                    ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@_34256                 ; LD (34256),IY     ; Store address of complex state data for entity at #R34256
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Berk's bottom edge...
       sb   one,b                      ; DEC B             ; ...minus 1 (to take into account different depth)
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of entity's bottom edge...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...and if this is less than the y-coordinate of Berk's top edge...
       jl   _35918                     ; JR C,35918        ; ...then skip ahead to #R35918
* Entity is not above Berk
       cb   a,b                        ; CP B              ; If entity's bottom edge is level with Berk's (taking into account different depth)...
       jeq  _35912                     ; JR Z,35912        ; ...then skip ahead to #R35912
* Entity is above floor and below Berk's top edge
       li   hl,_35163                  ; LD HL,35163       ; Point HL at script data for Berk picking up an entity that is above floor and below Berk's
                                                           ; top edge and behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Entity is on floor behind Berk
_35912:
       li   hl,_35135                  ; LD HL,35135       ; Point HL at script data for Berk picking up an entity on floor behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Entity is above Berk
_35918:
       li   hl,_35149                  ; LD HL,35149       ; Point HL at script data for Berk picking up an entity above and behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Collision with something that can't be picked up
_35924:
       cb   a,@bytes+32                ; CP 32             ; If collision was not with entity of class 32 (coloured creatures' slots, Level 3)...
       jne  _35953                     ; JR NZ,35953       ; ...then skip ahead to #R35953
* Collision with a coloured creature slot
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16                    ;                   
       jeq  _35953                     ; JR Z,35953        ; ...then skip ahead to #R35953
* Berk is carrying something
       bl   @_36116                    ; CALL 36116        ; If Berk is not horizontally aligned with coloured creature slot then move him closer and
                                                           ; exit this routine
* Berk is now horizontally aligned with coloured creature slot and carrying something
       bl   @_36367                    ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       movb @4(iy),a                   ; LD A,(IY+4)       ; Load A with y-coordinate of top edge of coloured creature slot... (see trivia)
       sb   one,a                      ; DEC A             ; ...minus 1...
       mov  a,@_34222                  ; LD (34222),A      ; ...and store at #R34222
       li   hl,_35235                  ; LD HL,35235       ; Point HL at script data for Berk putting an entity down above floor behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* No collision, collision with non-interactive entity or interaction conditions not met
_35953:
       movb @_34220,a                  ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  _35969                     ; JR Z,35969        ; ...then skip ahead to #R35969
       cb   a,@bytes+4                 ; CP 4              ; If Berk's current power is 1-3 (jumping)...
       jhe  !                          ; JP C,35995        ; ...then skip ahead to #R35995
       b    @_35995                    ;                   
!
       cb   a,@bytes+9                 ; CP 9              ; If Berk's current power is 4-8 (flying)...
       jhe  !                          ; JP C,35985        ; ...then skip ahead to #R35985
       b    @_35985                    ;                   
!
* Berk has neither jumping nor flying power
_35969:
       equ  $
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen
       b    @_35786                    ;                   
!
                                                           ; as appropriate)
* Berk is carrying something
       bl   @_36367                    ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       li   hl,_35219                  ; LD HL,35219       ; Point HL at script data for Berk putting an entity down on floor behind him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Berk's current power is flying
_35985:
       socb @bits+6,@9(ix)             ; SET 6,(IX+9)      ; Set Berk's Is Flying Flag
       li   hl,_35417                  ; LD HL,35417       ; Point HL at script data for Berk starting to fly...
       b    @_48098                    ; JP 48098          ; ...and execute
* Berk's current power is jumping
_35995:
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @bytes+129,@12(ix)         ; LD (IX+12),129    ; Set Berk's Is Jumping Flag and set initial jump velocity to 1
       li   hl,_35441                  ; LD HL,35441       ; Point HL at script data for Berk starting to jump straight up...
       b    @_48098                    ; JP 48098          ; ...and execute

* Make Berk Eat the Entity He is Holding, if Edible, and Exit Calling Routine
* 
* Used by the routine at #R35735.
_36008:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       cb   a,@bytes+12                ; CP 12             ; If class value of entity held by Berk is greater than 12...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @_48710                    ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move entity up one character to level of Berk's mouth...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       li   hl,_35493                  ; LD HL,35493       ; Point HL at script data for Berk eating an entity...
       b    @_48098                    ; JP 48098          ; ...and execute

* Update State of Berk (Forward Pressed)
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_36036:
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2                     ;                   
       jne  !                          ; JP Z,36049        ; ...then skip ahead to #R36049
       b    @_36049                    ;                   
!
* Berk's Facing Into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @_48098                    ; JP 48098          ; ...and execute
* Berk's Facing Into Screen Flag is reset
_36049:
       li   de,0                       ; LD DE,0           ; Clear pointer to complex state data for entity involved in last collision check...
       mov  de,@_34258                 ; LD (34258),DE     ; ...
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _36103                     ; JR C,36103        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R36103
* Collision occurred
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  _36078                     ; JR NZ,36078       ; ...then skip ahead to #R36078
* Collision with door
       bl   @_36116                    ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       mov  iy,@_34256                 ; LD (34256),IY     ; Store address of door's complex state data at #R34256
       li   hl,_35045                  ; LD HL,35045       ; Point HL at script data for Berk interacting with a door in front of him...
       b    @_48098                    ; JP 48098          ; ...and execute
* Collision with something other than door
_36078:
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is set...
       andi tmp0,16                    ;                   
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; JP NC,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
* At this point, Berk is not carrying anything, and the entity he is colliding with is one which can be picked up
       bl   @_36116                    ; CALL 36116        ; If Berk is not horizontally aligned with entity at IY then move him closer and exit this
                                                           ; routine
* Berk is now horizontally aligned with entity pointed to by IY
       mov  iy,@_34256                 ; LD (34256),IY     ; Store address of entity's complex state data at #R34256
       li   hl,_35187                  ; LD HL,35187       ; Point HL at script data for Berk picking up an entity on floor in front of him...
       b    @_48098                    ; JP 48098          ; ...and execute
* No collision occurred
_36103:
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
* Berk is carrying something
       li   hl,_35205                  ; LD HL,35205       ; Point HL at script data for Berk putting an entity down on floor in front of him...
       b    @_48098                    ; JP 48098          ; ...and execute

* If Berk is Not Horizontally Aligned with Entity at IY then Move Berk Closer and Exit Calling Routine
* 
* Used by the routines at #R35735 and #R36036. Input:  IX  Address of complex state data (current level) for Berk IY
* Address of complex state data for entity with which Berk has collided
_36116:
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of entity at IY, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; ...divide value by 2...
       sb   @bytes+2,a                 ; SUB 2             ; ...and subtract 2
       a    @5(iy),a                   ; ADD A,(IY+5)      ; Add result to x-coordinate of entity's left edge
* At this point, A holds the x-coordinate of the middle of the entity at IY, minus two
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate in A is the same as Berk's left side x-coordinate...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       joc  !                          ; JP NC,36214       ; TODO: check code. If x-coordinate in A is the less than Berk's left side x-coordinate then skip ahead to
       b    @_36214                    ;                   
!
                                                           ; #R36214
* This entry point is used by the routine at #R35735. Attempt to move Berk left
_36137:
       equ  $
       mov  @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64                    ;                   
       jne  _36200                     ; JR NZ,36200       ; ...then skip ahead to #R36200
* Attempt to move Berk left (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl   @_54666                    ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  _36171                     ; JR NC,36171       ; TODO: check code. ...and if a collision occurred, then skip ahead to #R36171
* No collision
       bl   @_54348                    ; CALL 54348        ; Move Berk into room to the left, if appropriate...
       joc  !                          ; JP NC,35786       ; TODO: check code. ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @_35786                    ;                   
!
                                                           ; him (turn to) face out of screen as appropriate)
_36158:
       equ  $
       mov  @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is already set...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       li   hl,_35263                  ; LD HL,35263       ; Point HL at script data for Berk starting to walk left...
       b    @_48098                    ; JP 48098          ; ...and execute
* Collision occurred with entity to the left
_36171:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  _36184                     ; JR NZ,36184       ; ...then skip ahead to #R36184
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   hl,_35291                  ; LD HL,35291       ; Point HL at script data for Berk starting to fall to the left...
       b    @_48098                    ; JP 48098          ; ...and execute
_36184:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   _36158                     ; JR C,36158        ; ...then jump back to #R36158
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _36158                     ; JR Z,36158        ; ...then jump back to #R36158
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk left (flying)
_36200:
       bl   @_54666                    ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  !                          ; JP C,48096        ; TODO: check code. ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @_48096                    ;                   
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* This entry point is used by the routine at #R35735. Attempt to move Berk right
_36214:
       mov  @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64                    ;                   
       jeq  !                          ; JP NZ,36282       ; ...then skip ahead to #R36282
       b    @_36282                    ;                   
!
* Attempt to move Berk right (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl   @_54569                    ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _36249                     ; JR NC,36249       ; TODO: check code. ...and if a collision occurred, then skip ahead to #R36249
* No collision
       bl   @_54313                    ; CALL 54313        ; Move Berk into room to the right, if appropriate...
       joc  !                          ; JP NC,35786       ; TODO: check code. ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @_35786                    ;                   
!
                                                           ; him (turn to) face out of screen as appropriate)
_36236:
       equ  $
       mov  @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is already set...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       li   hl,_35251                  ; LD HL,35251       ; Point HL at script data for Berk starting to walk right...
       b    @_48098                    ; JP 48098          ; ...and execute
* Collision occurred with entity to the right
_36249:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  _36266                     ; JR NZ,36266       ; ...then skip ahead to #R36266
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk (see trivia)
       li   hl,_35327                  ; LD HL,35327       ; Point HL at script data for Berk starting to fall to the right...
       b    @_48098                    ; JP 48098          ; ...and execute
_36266:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   _36236                     ; JR C,36236        ; ...then jump back to #R36236
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _36236                     ; JR Z,36236        ; ...then jump back to #R36236
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk right (flying)
_36282:
       bl   @_54569                    ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  !                          ; JP C,48096        ; TODO: check code. ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @_48096                    ;                   
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)

* Make Berk Drop the Entity He is Holding and Load IY with its Complex State Data Address
* 
* Used by the routines at #R35735, #R36116, #R36390, #R36638, #R39151, #R39278, #R39776, #R48920 and #R53723. Input:
* IX  Address of complex state data (current level) for Berk Output: IY  Address of complex state data for entity
* dropped by Berk
_36296:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       mov  a,@_34221                  ; LD (34221),A      ; ...
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set this dropped entity's velocity factor to 2...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...reset its Is Being Carried Flag...
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; ...and set its Can Fall Flag
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       mov  @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is reset...
       andi tmp0,1                     ;                   
       jeq  _36339                     ; JR Z,36339        ; ...then skip ahead to #R36339
_36331:
       ab   one,@7(iy)                 ; INC (IY+7)        ; Move dropped entity right one character...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...
       jmp  _36351                     ; JR 36351          ; Skip ahead to #R36351
_36339:
       mov  @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _36351                     ; JR Z,36351        ; ...then skip ahead to #R36351
_36345:
       sb   one,@7(iy)                 ; DEC (IY+7)        ; Move dropped entity left one character...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...
_36351:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If entity at IY has the x-coordinate of its left side less than 100...
       cb   a,@bytes+100               ; CP 100            ; ...
       jl   _36331                     ; JR C,36331        ; ...then move right until left x-coordinate is 100
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 99
       cb   a,@7(iy)                   ; CP (IY+7)         ; If entity at IY has the x-coordinate of its right side greater than the width of the current
                                                           ; room...
       jl   _36345                     ; JR C,36345        ; ...then move right until left x-coordinate is less than room width
       rt                              ; RET               ; Return

* If Berk is Neither Facing into the Screen nor Walking then Exit Calling Routine and Have Berk Turn into Screen
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_36367:
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is set...
       andi tmp0,2                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @11(ix),a                  ; LD A,(IX+11)      ; If either of Berk's Walking Left or Walking Right flags is set...
       andi a,3*256                    ; AND 3             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (59) Have Berk Interact Appropriately with a Door Behind Him Output: BC  Address of script data to
* execute upon arrival of new level
_36385:
       li   bc,_35113                  ; LD BC,35113       ; Load BC with address of script data for Berk facing into screen, ready to respond to control
                                                           ; input
       jmp  _36393                     ; JR 36393          ; Have Berk interact appropriately with a door

* Script Routine (58) Have Berk Interact Appropriately with a Door in Front of Him Input:  BC  (entry at #R36393
* only) Address of script data to execute upon arrival of new level
_36390:
       li   bc,_35081                  ; LD BC,35081       ; Load BC with address of script data for Berk facing out of screen, ready to respond to
                                                           ; control input
* This entry point is used by the routine at #R36385.
_36393:
       mov  bc,@_34266                 ; LD (34266),BC     ; Store script data address in BC at #R34266
       movb @_34208,a                  ; LD A,(34208)      ; Load E with Game Flags...
       movb a,@e                       ; LD E,A            ; ...
       movb @_34221,a                  ; LD A,(34221)      ; Load A with class of entity currently held by Berk...
       cb   a,@bytes+17                ; CP 17             ; ... and if this is not 17 (Key)...
       jne  _36429                     ; JR NZ,36429       ; ...then skip ahead to #R36429
* Berk is holding a key
       movb @bytes+7,a                 ; LD A,7            ; Set door colour to 7 (white, i.e. unlocked)...
       mov  a,@_50711+1                ; LD (50712),A      ; ...
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the key and load IY with its complex state data address
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set depth of key to 0 (i.e. out of display)
       socb @bits+4,@e                 ; SET 4,E           ; Set Level Exit Door Unlocked Flag...
       movb @e,a                       ; LD A,E            ; ...
       mov  a,@_34208                  ; LD (34208),A      ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
* Berk is not holding a key
_36429:
       mov  @e,tmp0                    ; BIT 4,E           ; If Level Exit Door Unlocked Flag is reset...
       andi tmp0,16                    ;                   
       jeq  _36462                     ; JR Z,36462        ; ...then skip ahead to #R36462
       movb a,d                        ; LD D,A            ; Load D with class of entity currently held by Berk
       movb @_34207,a                  ; LD A,(34207)      ; Set Zero Flag if current level is Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       movb d,a                        ; LD A,D            ; Load A with class of entity currently held by Berk
       jne  _36446                     ; JR NZ,36446       ; If Zero Flag is not set (i.e. we are not on Level 4) then skip ahead to #R36446
* Level 4
       cb   a,@bytes+19                ; CP 19             ; Set Zero Flag if class of entity currently held by Berk is 19 (Boni)
       jmp  _36448                     ; JR 36448          ; Skip ahead to #R36448
* Not Level 4
_36446:
       cb   a,@bytes+18                ; CP 18             ; Set Zero Flag if class of entity currently held by Berk is 18 (Drutt)
_36448:
       jne  _36462                     ; JR NZ,36462       ; If Zero Flag is not set (i.e. Berk is not holding Drutt on Levels 1-3 or Boni on Level 4)
                                                           ; then skip ahead to #R36462
* Berk is holding the correct character
       bl   @_48417                    ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       bl   @_36638                    ; CALL 36638        ; Advance to next level and if back to Level 1 then exit this routine and make Berk start
                                                           ; falling
* New level is not Level 1
       mov  @_34266,hl                 ; LD HL,(34266)     ; Load HL with script data address stored at #R34266...
       b    @_48098                    ; JP 48098          ; ...and execute
* Door is locked or Berk is not holding the correct character
_36462:
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (56) Give Berk Power Corresponding to Entity Eaten Input:  IX  Address of complex state data
* (current level) for Berk
_36471:
       bl   @_48417                    ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       movb @_34221,a                  ; LD A,(34221)      ; Set current power value to class of entity currently held by Berk...
       mov  a,@_34220                  ; LD (34220),A      ; ...
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. none)...
       mov  a,@_34221                  ; LD (34221),A      ; ...
       mov  a,@_34224                  ; LD (34224),A      ; Set number of elapsed game-cycles in current block to zero
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       movb a,@1(iy)                   ; LD (IY+1),A       ; ...and set its depth to zero (i.e. outside room)
       movb @10(iy),a                  ; LD A,(IY+10)      ; Initialise remaining duration of power to value encoded entity's complex state data (bits
                                                           ; 0-4)...
       andi a,31*256                   ; AND 31            ; ...
       mov  a,@_34225                  ; LD (34225),A      ; ...
       movb @_34220,a                  ; LD A,(34220)      ; If Berk's current power is not floating (Level 3)...
       cb   a,@bytes+10                ; CP 10             ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
* Power is floating
       movb @bytes+12,@12(ix)          ; LD (IX+12),12     ; Set distance Berk will be pushed by Drutt while floating to 12
       socb @bits+7,@9(ix)             ; SET 7,(IX+9)      ; Set Berk's Moving Upwards Flag
       movb @bytes+240,@11(ix)         ; LD (IX+11),240    ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags, and set his
                                                           ; Impassable Leftwards, Impassable Rightwards, Interaction (11,6) and Interaction (11,7) flags
       socb @bits+7,@8(ix)             ; SET 7,(IX+8)      ; Set bit 7 of Berk's class value (i.e. set "Spans Full Depth" Flag)
       ab   one,@6(ix)                 ; INC (IX+6)        ; Increase y-coordinate of Berk's bottom edge by two characters...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
_36536:
       li   hl,_35515                  ; LD HL,35515       ; Point HL at script data for Berk gaining floating power...
       b    @_48098                    ; JP 48098          ; ...and execute

* Update State of Berk (Floating Power Active)
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_36542:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jeq  _36558                     ; JR Z,36558        ; ...then skip ahead to #R36558
* No collision with entity of class 130
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move Berk up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @_55433                    ; CALL 55433        ; Change Berk's room up one if appropriate
_36558:
       mov  @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is set...
       andi tmp0,2                     ;                   
       jne  _36587                     ; JR NZ,36587       ; ...then skip ahead to #R36587
       mov  @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is set...
       andi tmp0,1                     ;                   
       jne  _36576                     ; JR NZ,36576       ; ...then skip ahead to #R36576
       bl   @_48388                    ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
* Berk's Walking Right Flag is set (i.e. Drutt has pushed Berk right)
_36576:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk's left and right sides right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @_54313                    ; CALL 54313        ; Move Berk at IX into room to the right, if appropriate
       jmp  _36596                     ; JR 36596          ; Skip ahead to #R36596
* Berk's Walking Left Flag is set (i.e. Drutt has pushed Berk left)
_36587:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk's left and right sides left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @_54348                    ; CALL 54348        ; Move Berk at IX into room to the left, if appropriate
_36596:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining horizontal distance from Drutt's push...
       jeq  !                          ; JP NZ,48096       ; ...and if not zero then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb one,a                      ; LD A,1            ; Set remaining power duration to 1...
       mov  a,@_34225                  ; LD (34225),A      ; ...
       b    @_48212                    ; JP 48212          ; Reset Berk's Walking Left and Walking Right flags, advance HL to next script instruction and
                                                           ; execute

* Script Routine (57) Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
_36610:
       bl   @_36616                    ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
* 
* Used by the routines at #R36610, #R39584 and #R39760.
_36616:
       .push hl                        ; PUSH HL           ; Store HL
       bl   @_53581                    ; CALL 53581        ; Cycle Attributes (Full-Screen) and Clear Display Buffers
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* State Data for Drutt Upon Returning to Level 1
* 
* After completing Level 4, the data here is written into Drutt's slot in Level 1's State Data for Complex Entities
* block (#R43333). This ensures that Drutt follows Berk and Boni through the final door.
_36625:
       byte 10,1,193,204,30,119,30,119,18,0,192,192,2

* Advance to Next Level and if Back to Level 1 then Exit Calling Routine and Make Berk Start Falling
* 
* Used by the routine at #R36390.
_36638:
       movb @_34208,a                  ; LD A,(34208)      ; Set Update Scores and Display Flag...
       socb @bits+5,a                  ; SET 5,A           ; ...
       mov  a,@_34208                  ; LD (34208),A      ; ...
       mov  @_34256,iy                 ; LD IY,(34256)     ; Load IY with address of complex state data for Door just interacted with
       movb @9(iy),a                   ; LD A,(IY+9)       ; Load A with destination level from Door's state data...
       mov  a,@_34207                  ; LD (34207),A      ; ...and set current level to this value
       cb   a,one                      ; CP 1              ; If destination level is not Level 1...
       jne  _36725                     ; JR NZ,36725       ; ...then skip ahead to #R36725
* Destination level is Level 1 (i.e. Level 4 completed)
       bl   @_36753                    ; CALL 36753        ; Load IX with address of Berk's complex state data and set his horizontal position to match
                                                           ; Level 1's entry door
       socb @bits+2,@10(ix)            ; SET 2,(IX+10)     ; Set "Back to Level 1" Flag
       movb @bytes+10,*ix              ; LD (IX+0),10      ; Set Berk's room to 10
       movb @bytes+103,@4(ix)          ; LD (IX+4),103     ; Set y-coordinate of Berk's top edge to 103
       movb @bytes+109,@6(ix)          ; LD (IX+6),109     ; Set y-coordinate of Berk's bottom edge to 109
       li   iy,_43606                  ; LD IY,43606       ; Load IY with address of Boni's entry in Level 1's State Data for Complex Entities...
       mov  iy,@_34256                 ; LD (34256),IY     ; ...and store at #R34256
       bl   @_48850                    ; CALL 48850        ; Have Berk hold Boni, and position him appropriately between Berk's hands
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       movb @bytes+10,*iy              ; LD (IY+0),10      ; Set Boni's room to 10
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       bl   @_55516                    ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
       bl   @_36739                    ; CALL 36739        ; Lock Level 1's exit door and cycle attributes (full-screen)
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_36625                  ; LD HL,36625       ; Overwrite Drutt's entry in Level 1's State Data for Complex Entities with data at #R36625...
       li   de,_43671                  ; LD DE,43671       ; ...
       li   bc,13                      ; LD BC,13          ; ...
       .ldir                           ; LDIR              ; ...
       li   hl,_35359                  ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @_48098                    ; JP 48098          ; ...and execute
* Destination level is not Level 1
_36725:
       bl   @_36753                    ; CALL 36753        ; Set Berk's horizontal position to match Level 1's entry door
       mov  @_34242,iy                 ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt...
       mov  iy,@_34256                 ; LD (34256),IY     ; ...and store at #R34256
       bl   @_48850                    ; CALL 48850        ; Have Berk hold Drutt, and position him appropriately between Berk's hands
_36739:
       li   hl,_34208                  ; LD HL,34208       ; Reset Level Exit Door Unlocked Flag...
       szcb @bits+4,*hl                ; RES 4,(HL)        ; ...
       movb @bytes+5,a                 ; LD A,5            ; Set door colour to 5 (cyan, i.e. locked)...
       mov  a,@_50711+1                ; LD (50712),A      ; ...
       bl   @_36616                    ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       rt                              ; RET               ; Return

* Set Berk's Horizontal Position to Match Level 1's Entry Door
* 
* Used by the routine at #R36638.
_36753:
       bl   @_34864                    ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       movb @bytes+33,a                ; LD A,33           ; Load IY with address of complex state data for first entity that has class of 33 (Entry
                                                           ; Door)...
       bl   @_54019                    ; CALL 54019        ; ...
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with start address of current level's complex state data for Berk
       movb @5(iy),a                   ; LD A,(IY+5)       ; Load A with x-coordinate of left of Entry Door...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@5(ix)                   ; LD (IX+5),A       ; Adjust Berk's horizontal position so that his left side is at coordinate in A...
       a    @bytes+5,a                 ; ADD A,5           ; ...and his right side is 5 characters to the right of this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       rt                              ; RET               ; Return

* Initialise Script Data Positions for Flying Skeleton Creature and Bat (Level 1)
* 
* Used by the routine at #R34751.
_36778:
       li   hl,_36803                  ; LD HL,36803       ; Load HL with start address of script data for Boni's kidnap...
       mov  hl,@_36801                 ; LD (36801),HL     ; ...and store this as the current script data position at #R36801
       li   hl,_37018                  ; LD HL,37018       ; Load HL with start address of script data for Bat (not attacking)...
       mov  hl,@_37016                 ; LD (37016),HL     ; ...and store this as the current script data position at #R37016
       rt                              ; RET               ; Return

* Update States of All Level 1 Entities
* 
* Used by the routine at #R34438.
_36791:
       bl   @_36887                    ; CALL 36887        ; Execute script data for Boni's kidnap and handle Trap Door opening and closing
       bl   @_37062                    ; CALL 37062        ; Update state of Bat (Level 1) and store current position in script data
       bl   @_37586                    ; CALL 37586        ; Update states of the Spiders (Level 1) and store current positions in script data
       rt                              ; RET               ; Return

* Current Position in Script Data for Boni's Kidnap
_36801:
       data _36803

* Script Data Boni's Kidnap
_36803:
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 25,0,6,0                                                 ; Start loop (2) for 6 iterations
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 26,0                                                     ; End loop (2)
       byte 39,0                                                     ; Open the Trap Door
       byte 25,0,10,0                                                ; Start loop (2) for 10 iterations
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 34,0                                                     ; Move creature up one character
       byte 26,0                                                     ; End loop (2)
       byte 25,0,10,0                                                ; Start loop (2) for 10 iterations
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 2,0                                                      ; Move creature left one character
       byte 26,0                                                     ; End loop (2)
       byte 25,0,10,0                                                ; Start loop (2) for 10 iterations
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 3,0                                                      ; Move creature right one character
       byte 26,0                                                     ; End loop (2)
       byte 25,0,4,0                                                 ; Start loop (2) for 4 iterations
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte _51314%256,_51314/256                                    ; #R51314 (Flying Skeleton Creature, animated)
       byte 34,0                                                     ; Move creature up one character
       byte 26,0                                                     ; End loop (2)
       byte 36,0                                                     ; Remove Boni from Level 1
       byte 25,0,16,0                                                ; Start loop (2) for 16 iterations
       byte _51286%256,_51286/256                                    ; #R51286 (Boni being kidnapped, shouting for help, animated)
       byte 26,0                                                     ; End loop (2)
       byte 25,0,12,0                                                ; Start loop (2) for 12 iterations
       byte _51308%256,_51308/256                                    ; #R51308 (Boni being kidnapped, mouth closed)
       byte 35,0                                                     ; Move creature down one character
       byte 26,0                                                     ; End loop (2)
       byte 38,0                                                     ; Close the Trap Door
       byte 37,0                                                     ; Remove Flying Skeleton Creature from Level 1

* Execute Script Data for Boni's Kidnap and Handle Trap Door Opening and Closing
* 
* Used by the routine at #R36791.
_36887:
       li   ix,_43619                  ; LD IX,43619       ; Load IX with address of complex state data for Flying Skeleton Creature
       movb @_43619+9,a                ; LD A,(43628)      ; If Berk and Drutt Through Trap Door Flag is set...
       mov  a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  a,tmp0                     ; BIT 2,A           ; If Trap Door Opened Flag is set...
       andi tmp0,4                     ;                   
       jne  _36966                     ; JR NZ,36966       ; ...then jump to #R36966 (close the Trap Door if Berk is not in room 1 and Drutt is in room 4)
       mov  a,tmp0                     ; BIT 1,A           ; If creature's Inactive Flag is set...
       andi tmp0,2                     ;                   
       jne  _36921                     ; JR NZ,36921       ; ...then jump to #R36921 (open the Trap Door if Berk is near the left side of the Trap Door
                                                           ; room)
       mov  @_36801,hl                 ; LD HL,(36801)     ; Load current position in script data for Boni's kidnap from #R36801 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_36947                    ; CALL 36947        ; Advance HL to next script instruction and start executing
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_36801                 ; LD (36801),HL     ; ...at #R36801 as current position in script data for Boni's kidnap
       rt                              ; RET               ; Return

* Open Trap Door if Berk is Near the Left Side of the Trap Door Room
* 
* Used by the routine at #R36887. Input:  IX  Address of complex state data for Flying Skeleton Creature (Level 1)
_36921:
       li   iy,_43593                  ; LD IY,43593       ; Load IY with address of complex state data for Berk (Level 1)
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of Berk's left side is 104 or greater...
       cb   a,@bytes+104               ; CP 104            ; ...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Trap Door Opened Flag
       sb   a,a                        ; XOR A             ; Set room of "Closed Trap Door" to 0 (i.e. remove from Trap Door Room)...
       mov  a,@_43188                  ; LD (43188),A      ; ...
       ab   one,a                      ; INC A             ; Increase A to 1 (index of Trap Door Room)...
       mov  a,@_43437                  ; LD (43437),A      ; ...and set this as the current room of "Open Trap Door"...
       mov  a,@_43450                  ; LD (43450),A      ; ...and marker (preventing Berk and Drutt passing door lid)
       rt                              ; RET               ; Return

* Advance HL to Next Script Instruction and Start Executing
* 
* Used by the routine at #R36887.
_36947:
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (36) Remove Boni from Level 1
_36950:
       sb   a,a                        ; XOR A             ; Set Boni's room (Level 1) to zero...
       mov  a,@_43606                  ; LD (43606),A      ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (37) Remove Flying Skeleton Creature from Level 1, and Terminate Script Processing Input:  IX
* Address of complex state data for an entity
_36957:
       sb   a,a                        ; XOR A             ; Set current room of Flying Skeleton Creature (Level 1) to zero...
       mov  a,@_43619                  ; LD (43619),A      ; ...
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Flying Skeleton Creature's Inactive Flag
       rt                              ; RET               ; Return (i.e. terminate further script processing)

* Close the Trap Door if Berk is Not in Room 1 and Drutt is in Room 4 (Level 1)
* 
* See bugs.
_36966:
       movb @_43593,a                  ; LD A,(43593)      ; If Berk's current room (Level 1) is 1 (i.e. Trap Door Room)...
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       movb @_43671,a                  ; LD A,(43671)      ; If Drutt's current room is not 4 (room at bottom of Trap Door Shaft)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       socb @bits+3,@9(ix)             ; SET 3,(IX+9)      ; Set Berk and Drutt Through Trap Door Flag
       jmp  _36996                     ; JR 36996          ; Close the Trap Door and return

* Script Routine (38) Close the Trap Door
_36984:
       bl   @_36996                    ; CALL 36996        ; Close the Trap Door
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (39) Open the Trap Door
_36990:
       bl   @_37004                    ; CALL 37004        ; Open the Trap Door
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Close the Trap Door
* 
* Used by the routines at #R36966 and #R36984.
_36996:
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" to 1 (i.e. Trap Door Room)...
       mov  a,@_43188                  ; LD (43188),A      ; ...
       sb   one,a                      ; DEC A             ; Decrease A to zero
       jmp  _37009                     ; JR 37009          ; Set room of "Open Trap Door" to 0

* Open the Trap Door
* 
* Used by the routine at #R36990.
_37004:
       sb   a,a                        ; XOR A             ; Set room of "Closed Trap Door" to 0 (i.e. remove from Trap Door Room)...
       mov  a,@_43188                  ; LD (43188),A      ; ...
       ab   one,a                      ; INC A             ; Increase A to 1 (index of Trap Door Room)
* This entry point is used by the routine at #R36996.
_37009:
       mov  a,@_43437                  ; LD (43437),A      ; Set value in A as the current room of "Open Trap Door"...
       mov  a,@_43450                  ; LD (43450),A      ; ...and marker (preventing Berk and Drutt passing door lid)
       rt                              ; RET               ; Return

* Current Position in Bat's Script Data
_37016:
       data _37018

* Script Data Bat (Level 1)
* 
* Stationary (off top of screen)
_37018:
       byte _37205%256,_37205/256                                    ; #R37205 (Flying, full wing flap)
       byte 1,0,_37018%256,_37018/256                                ; Jump to #R37018
* Attacking
_37024:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 27,0,8,0                                                 ; Start loop (3) for 8 iterations
       byte _37216%256,_37216/256                                    ; #R37216 (Flying, half wing flap)
       byte 35,0                                                     ; Move Bat down two characters...
       byte 35,0                                                     ; ...
       byte 28,0                                                     ; End loop (3)
       byte 27,0,8,0                                                 ; Start loop (3) for 8 iterations
       byte _37205%256,_37205/256                                    ; #R37205 (Flying, full wing flap)
       byte 28,0                                                     ; End loop (3)
       byte 27,0,17,0                                                ; Start loop (3) for 17 iterations
       byte _37205%256,_37205/256                                    ; #R37205 (Flying, full wing flap)
       byte 34,0                                                     ; Move Bat up one character
       byte 28,0                                                     ; End loop (3)
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte 1,0,_37018%256,_37018/256                                ; Jump to #R37018

* Update State of Bat (Level 1) and Store Current Position in Script Data
* 
* Used by the routine at #R36791.
_37062:
       li   ix,_43463                  ; LD IX,43463       ; Point IX at position data for Bat (Level 1)
       bl   @_53848                    ; CALL 53848        ; Store room size data for Bat's room
       mov  @_37016,hl                 ; LD HL,(37016)     ; Load current position in Bat's script data from #R37016 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_37085                    ; CALL 37085        ; Update state of Bat
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_37016                 ; LD (37016),HL     ; ...at #R37016 as current position in Bat's script data
       rt                              ; RET               ; Return

* Update State of Bat (Level 1)
* 
* Used by the routine at #R37062. Input:  IX  (always #R43463, entry in Level 1 complex state data for Bat) HL
* Current position in Bat's script data
_37085:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _37104                     ; JR C,37104        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R37104
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _37100                     ; JR NZ,37100       ; ...then skip ahead to #R37100
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_37100:
       cb   a,@bytes+18                ; CP 18             ; If collision was with entity of class 18 (Drutt)...
       jeq  _37111                     ; JR Z,37111        ; ...then skip ahead to #R37111
_37104:
       bl   @_54890                    ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                                           ; into screen whose Interaction (11,7) Flag is set...
       cb   a,@bytes+18                ; CP 18             ; ...and if collision was not with entity of class 18 (Drutt)...
       jne  _37128                     ; JR NZ,37128       ; ...then skip ahead to #R37128
_37111:
       mov  @10(iy),tmp0               ; BIT 6,(IY+10)     ; If Drutt's Can Fall Flag is set...
       andi tmp0,64                    ;                   
       jne  _37128                     ; JR NZ,37128       ; ...then skip ahead to #R37128
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set Drutt's Can Fall Flag
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set Drutt's Velocity Factor to 2
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_37128:
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Bat's Paralysed Flag is set...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is set...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jne  _37148                     ; JR NZ,37148       ; ...then skip ahead to #R37148
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       jmp  _37152                     ; JR 37152          ; Skip ahead to #R37152
_37148:
       mov  @_34242,iy                 ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt
* At this point, IY points to the complex state data entry for the current character.
_37152:
       movb *iy,a                      ; LD A,(IY+0)       ; If current character's current room is not the same as the Bat's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the current character's right side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the Bat's left side...
       jl   _37194                     ; JR C,37194        ; ...then skip ahead to #R37194
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the Bat's right side...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the current character's left side...
       jl   _37183                     ; JR C,37183        ; ...then skip ahead to #R37183
       li   hl,_37024                  ; LD HL,37024       ; Point HL at script data for Bat attacking...
       b    @_48098                    ; JP 48098          ; ...and execute
_37183:
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the x-coordinate of the Bat's right side is less than 130...
       cb   a,@bytes+130               ; CP 130            ; ...
       jhe  !                          ; JP C,48615        ; ...then move Bat right by one character
       b    @_48615                    ;                   
!
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_37194:
       movb @bytes+101,a               ; LD A,101          ; If the x-coordinate of the Bat's left side is greater than 101...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jhe  !                          ; JP C,48660        ; ...then move Bat left by one character
       b    @_48660                    ;                   
!
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Graphic Layout Data Bat (Level 1) Flying, full wing flap - 3 stages, i.e. hovering at floor-level / going up
_37205:
       byte 243,0,4                                                  ; Increase current state value n (initially 0), up to maximum of 4, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _37322%256,_37322/256                                    ; #R37322 (Bat, full, wings raised, eyes animated)
       byte _37425%256,_37425/256                                    ; #R37425 (Bat, full, wings level, eyes animated)
       byte _37507%256,_37507/256                                    ; #R37507 (Bat, full, wings down, eyes animated)
       byte _37425%256,_37425/256                                    ; #R37425 (Bat, full, wings level, eyes animated)
* Flying, half wing flap - 2 stages, i.e. going down
_37216:
       byte 243,0,2                                                  ; Increase current state value n (initially 0), up to maximum of 2, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _37322%256,_37322/256                                    ; #R37322 (Bat, full, wings raised, eyes animated)
       byte _37425%256,_37425/256                                    ; #R37425 (Bat, full, wings level, eyes animated)
* Head, body and claws only, eyes animated
_37223:
       byte 244,6                                                    ; Set current graphic set to 6
       byte 251,_37271%256,_37271/256                                ; Process graphic layout data at #R37271 and upon returning, move cursor to base coordinates
       byte 250,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively
       byte 25,4,33
       byte 25,132,31
       byte 26,4,33
       byte 26,132,31
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 28,68,161
       byte 28,196,159
       byte 29,124,161
       byte 29,252,158
       byte 31,4,33
       byte 30,4,33
       byte 30,132,33
       byte 31,132,33
       byte 255                                                      ; End Marker
* Eyes, animated
_37271:
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 243,0,5                                                  ; Increase current state value n (initially 0), up to maximum of 5, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _37287%256,_37287/256                                    ; #R37287 (Bat's eyes, white)
       byte _37294%256,_37294/256                                    ; #R37294 (Bat's eyes, yellow)
       byte _37301%256,_37301/256                                    ; #R37301 (Bat's eyes, cyan)
       byte _37308%256,_37308/256                                    ; #R37308 (Bat's eyes, magenta)
       byte _37315%256,_37315/256                                    ; #R37315 (Bat's eyes, red)
* Eyes, white
_37287:
       byte 27,124,33
       byte 27,252,33
       byte 255                                                      ; End Marker
* Eyes, yellow
_37294:
       byte 27,116,33
       byte 27,244,33
       byte 255                                                      ; End Marker
* Eyes, cyan
_37301:
       byte 27,108,33
       byte 27,236,33
       byte 255                                                      ; End Marker
* Eyes, magenta
_37308:
       byte 27,92,33
       byte 27,220,33
       byte 255                                                      ; End Marker
* Eyes, red
_37315:
       byte 27,84,33
       byte 27,212,33
       byte 255                                                      ; End Marker
* Full, wings raised, eyes animated
_37322:
       byte 254,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively and store as new
                                                                     ; base coordinates
       byte 251,_37223%256,_37223/256                                ; Process graphic layout data at #R37223 and upon returning, move cursor to base coordinates
       byte 250,255,253                                              ; Change cursor's x- and y-coordinates by -3 and -1 characters respectively
       byte 52,4,33
       byte 53,68,33
       byte 54,4,30
       byte 34,4,33
       byte 55,68,161
       byte 56,68,161
       byte 57,68,29
       byte 58,4,33
       byte 59,4,33
       byte 60,68,161
       byte 61,68,159
       byte 62,68,161
       byte 0,36,32
       byte 63,68,32
       byte 64,68,33
       byte 250,251,3                                                ; Change cursor's x- and y-coordinates by +3 and -5 characters respectively
       byte 54,132,33
       byte 53,196,33
       byte 52,132,29
       byte 57,132,33
       byte 56,196,161
       byte 55,196,161
       byte 34,132,29
       byte 61,196,161
       byte 60,196,161
       byte 59,132,33
       byte 58,132,29
       byte 0,36,33
       byte 62,196,159
       byte 63,196,32
       byte 64,196,33
       byte 255                                                      ; End Marker
* Full, wings level, eyes animated
_37425:
       byte 251,_37223%256,_37223/256                                ; Process graphic layout data at #R37223 and upon returning, move cursor to base coordinates
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 41,4,29
       byte 42,4,33
       byte 43,68,33
       byte 44,68,161
       byte 45,68,161
       byte 46,68,29
       byte 47,4,33
       byte 48,68,33
       byte 49,68,161
       byte 0,36,31
       byte 50,4,33
       byte 51,68,33
       byte 250,253,3                                                ; Change cursor's x- and y-coordinates by +3 and -3 characters respectively
       byte 41,132,31
       byte 46,196,33
       byte 45,196,161
       byte 44,196,161
       byte 43,196,33
       byte 42,132,28
       byte 0,36,33
       byte 49,196,161
       byte 48,196,33
       byte 47,132,29
       byte 51,196,33
       byte 50,132,33
       byte 255                                                      ; End Marker
* Full, wings down, eyes animated
_37507:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and store as new
                                                                     ; base coordinates
       byte 251,_37223%256,_37223/256                                ; Process graphic layout data at #R37223 and upon returning, move cursor to base coordinates
       byte 250,2,0                                                  ; Change cursor's x- and y-coordinates by 0 and +2 characters respectively
       byte 40,4,31
       byte 32,4,33
       byte 33,68,30
       byte 34,4,33
       byte 35,68,33
       byte 0,36,30
       byte 36,68,33
       byte 37,68,31
       byte 38,4,33
       byte 39,4,33
       byte 250,252,3                                                ; Change cursor's x- and y-coordinates by +3 and -4 characters respectively
       byte 40,132,32
       byte 33,196,33
       byte 32,132,31
       byte 0,36,33
       byte 35,196,161
       byte 34,132,31
       byte 37,132,33
       byte 36,196,31
       byte 39,132,33
       byte 38,132,33
       byte 255                                                      ; End Marker

* Table of Current Positions in Spiders' Script Data
_37580:
       data _37792                                                   ; Spider 1
       data _37792                                                   ; Spider 2
       data _37792                                                   ; Spider 3

* Update the States of the Spiders (Level 1) and Store Current Positions in Script Data
* 
* Used by the routine at #R36791.
_37586:
       li   ix,_43749                  ; LD IX,43749       ; Load IX with address of complex state data for Spider 1 (Level 1)
       li   iy,_37580                  ; LD IY,37580       ; Load IY with start address of Table of Current Positions in Spiders' Script Data
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 as there are 3 spiders
_37596:
       movb *iy,@l                     ; LD L,(IY+0)       ; Load HL with current position in script data for current spider...
       movb @1(iy),h                   ; LD H,(IY+1)       ; ...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .push ix                        ; PUSH IX           ; Store IX
       .push iy                        ; PUSH IY           ; Store IY
       .push bc                        ; PUSH BC           ; Store BC
       bl   @_37639                    ; CALL 37639        ; Update the state of the current spider (Level 1)
       .pop bc                         ; POP BC            ; Restore BC
       .pop iy                         ; POP IY            ; Restore IY
       .pop ix                         ; POP IX            ; Restore IX
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data for current spider) stored at #R34277...
       movb @l,*iy                     ; LD (IY+0),L       ; ...in table at #R37580 as current position in this spider's script data...
       movb h,@1(iy)                   ; LD (IY+1),H       ; ...
       inc  iy                         ; INC IY            ; Advance IY to next entry in table (i.e. position in next spider's script data)...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX by 13 bytes (i.e. to entry for next spider)...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 37596        ; Decrease B (remaining number of spiders to process) and loop back to #R37596
       jne  _37596                     ;                   
       rt                              ; RET               ; Return

* Update the State of a Spider (Level 1)
* 
* Used by the routine at #R37586. Input:  IX  Address of complex state data for a (Level 1) spider (#R43749, #R43762
* or #R43775)
_37639:
       movb @_34208,a                  ; LD A,(34208)      ; If "Reset Spiders to Initial State" Flag is reset...
       mov  a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8                     ;                   
       jeq  _37662                     ; JR Z,37662        ; ...then skip ahead to #R37662
       movb @bytes+27,a                ; LD A,27           ; Reset complex state data for right-hand spider to that stored in Initial-State Table...
       bl   @_53987                    ; CALL 53987        ; ...
       movb @bytes+28,a                ; LD A,28           ; Reset complex state data for middle spider to that stored in Initial-State Table...
       bl   @_53987                    ; CALL 53987        ; ...
       movb @bytes+29,a                ; LD A,29           ; Reset complex state data for left-hand spider to that stored in Initial-State Table...
       bl   @_53987                    ; CALL 53987        ; ...
       rt                              ; RET               ; Return
_37662:
       mov  a,tmp0                     ; BIT 2,A           ; If Berk Has Been Killed Flag is set...
       andi tmp0,4                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       bl   @_54764                    ; CALL 54764        ; Check entity at IX for collision with another entity at next depth level out of screen whose
                                                           ; Interaction (11,6) Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _37685                     ; JR NZ,37685       ; ...then skip ahead to #R37685
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       movb @_34223,a                  ; LD A,(34223)      ; Increase count of number of times a spider has killed Berk...
       ab   one,a                      ; INC A             ; ...
       mov  a,@_34223                  ; LD (34223),A      ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_37685:
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If spider's Must Process Current Script Data Flag is set...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If the spider and Berk are in different rooms...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with the x-coordinate of the spider's right side...
       a    @bytes+4,a                 ; ADD A,4           ; ...plus 4...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...and if the x-coordinate of Berk's left side is greater than this...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       li   hl,_37800                  ; LD HL,37800       ; Point HL at script data for spider moving down...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (41) Move Spider Up One Character and, if Home, Reset its Timer and Make it Wait Input:  IX Address
* of complex state data for an entity Output: HL  Address of next script instruction to execute
_37718:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of bottom of entity IX (spider) is not 106...
       cb   a,@bytes+106               ; CP 106            ; ...
       jeq  !                          ; JP NZ,48541       ; ...then move entity up one character and return
       b    @_48541                    ;                   
!
       movb @bytes+20,@c               ; LD C,20           ; Load C with 20
       movb @8(ix),a                   ; LD A,(IX+8)       ; If entity class is not 27 (right-most spider, Level 1)...
       cb   a,@bytes+27                ; CP 27             ; ...
       jne  _37744                     ; JR NZ,37744       ; ...then skip ahead to #R37744
* The following code affects the behaviour of the right-most spider depending upon how many times Berk has been
* killed by a spider. See (trivia) and (pokes).
       movb @_34223,a                  ; LD A,(34223)      ; Load number of times Berk has been killed by a spider into A...
       srl  a,1                        ; SRL A             ; ...and divide by four, discarding remainder...
       srl  a,1                        ; SRL A             ; ...
       a    @c,a                       ; ADD A,C           ; Add this value to C, in C...
       movb a,@c                       ; LD C,A            ; ...
_37744:
       movb @c,@12(ix)                 ; LD (IX+12),C      ; Load spider's timer with this value
       li   hl,_37792                  ; LD HL,37792       ; Point HL at script data for spider waiting...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (42) Decrease Remaining Time Until Spider Next Descends and if Zero, Start Descent Input:  IX
* Address of complex state data for an entity Output: HL  Address of next script instruction to execute
_37753:
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If spider's Must Process Current Script Data Flag is reset...
       andi tmp0,1                     ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If Spider's timer is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _37772                     ; JR Z,37772        ; ...then skip ahead to #R37772
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining time on spider's timer
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_37772:
       li   hl,_37800                  ; LD HL,37800       ; Point HL at script data for spider moving down...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (40) Move Spider Down One Character, and if at Bottom, Advance it to Bounce / Climb Up Mode Input:
* IX  Address of complex state data for an entity Output: HL  Address of next script instruction to execute
_37778:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If entity's bottom y-coordinate is less than 119...
       cb   a,@bytes+119               ; CP 119            ; ...
       jhe  !                          ; JP C,48567        ; ...then move entity down one character and process next script data
       b    @_48567                    ;                   
!
       li   hl,_37816                  ; LD HL,37816       ; Point HL at script data for bounce / climb up mode...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Data Spiders (Level 1)
* 
* Waiting
_37792:
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 42,0                                                     ; Decrease remaining time until spider next descends and if zero, start descent
       byte 1,0,_37792%256,_37792/256                                ; Jump to #R37792
* Moving down
_37800:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 4,0,7,0                                                  ; If current character and target entity are in the same room then set pending sound to 7
                                                                     ; (spider sound)
       byte 40,0                                                     ; Move spider down one character, and if at bottom, advance it to bounce / climb up mode
       byte 40,0                                                     ; Move spider down one character, and if at bottom, advance it to bounce / climb up mode
       byte 1,0,_37800%256,_37800/256                                ; Jump to #R37800
* Bounce / climb up mode
_37816:
       byte _37872%256,_37872/256                                    ; #R37872 (Spider, web trail stretched)
       byte 34,0                                                     ; Move Spider up one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 34,0                                                     ; Move Spider up one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 34,0                                                     ; Move Spider up one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 35,0                                                     ; Move Spider down one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 35,0                                                     ; Move Spider down one character
       byte _37872%256,_37872/256                                    ; #R37872 (Spider, web trail stretched)
       byte _37872%256,_37872/256                                    ; #R37872 (Spider, web trail stretched)
       byte 34,0                                                     ; Move Spider up one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte 35,0                                                     ; Move Spider down one character
       byte _37872%256,_37872/256                                    ; #R37872 (Spider, web trail stretched)
       byte _37872%256,_37872/256                                    ; #R37872 (Spider, web trail stretched)
       byte 34,0                                                     ; Move Spider up one character
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte _37888%256,_37888/256                                    ; #R37888 (Spider, web trail slack)
       byte _37950%256,_37950/256                                    ; #R37950 (Spider climbing up web trail)
_37864:
       byte _37950%256,_37950/256                                    ; #R37950 (Spider climbing up web trail)
       byte 41,0                                                     ; Move spider up one character and, if home, reset its timer and make it wait
       byte 1,0,_37864%256,_37864/256                                ; Jump to #R37864

* Graphic Layout Data Spiders (Level 1) Spider, web trail stretched
_37872:
       byte 244,5                                                    ; Set current graphic set to 5
       byte 237,7                                                    ; Set sound 7 (spider sound) as pending
       byte 250,246,1                                                ; Change cursor's x- and y-coordinates by +1 and -10 characters respectively
       byte 238,11                                                   ; Set Repeat Counter A to 11
_37881:
       byte 31,7,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R37881 if not zero
       byte 248,_37899%256,_37899/256                                ; Jump to #R37899 (spider, facing down)
* Spider, web trail slack
_37888:
       byte 244,5                                                    ; Set current graphic set to 5
       byte 250,246,1                                                ; Change cursor's x- and y-coordinates by +1 and -10 characters respectively
       byte 238,11                                                   ; Set Repeat Counter A to 11
_37895:
       byte 30,7,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R37895 if not zero
* Spider, facing down
_37899:
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters respectively
       byte 22,2,34
       byte 22,130,30
       byte 29,2,33
       byte 23,66,33
       byte 29,130,31
       byte 25,2,32
       byte 236,2,26,27                                              ; Modify following instruction to display graphic of random index, chosen from 26 and 27
       byte 26,7,33
       byte 250,255,254                                              ; Change cursor's x- and y-coordinates by -2 and -1 characters respectively
       byte 247,2                                                    ; Jump to one of the 2 addresses in the following list, chosen at random:
       byte _37936%256,_37936/256                                    ; #R37936 (Spider's eyes, large pupils)
       byte _37943%256,_37943/256                                    ; #R37943 (Spider's eyes, small pupils)
* Spider's eyes, large pupils
_37936:
       byte 24,7,34
       byte 24,135,33
       byte 255                                                      ; End Marker
* Spider's eyes, small pupils
_37943:
       byte 28,7,34
       byte 28,135,33
       byte 255                                                      ; End Marker
* Spider climbing up web trail
_37950:
       byte 244,5                                                    ; Set current graphic set to 5
       byte 250,246,1                                                ; Change cursor's x- and y-coordinates by +1 and -10 characters respectively
       byte 238,12                                                   ; Set Repeat Counter A to 12
_37957:
       byte 30,7,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R37957 if not zero
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 36,7,33
       byte 25,2,33
       byte 36,135,31
       byte 35,2,33
       byte 243,0,2                                                  ; Increase current state value n (initially 0), up to maximum of 2, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _37983%256,_37983/256                                    ; #R37983 (Spider's legs, left extended, right not, climbing up web trail)
       byte _37996%256,_37996/256                                    ; #R37996 (Spider's legs, right extended, left not, climbing up web trail)
* Spider's legs (left extended, right not), climbing up web trail
_37983:
       byte 250,253,254                                              ; Change cursor's x- and y-coordinates by -2 and -3 characters respectively
       byte 32,2,32
       byte 33,2,34
       byte 34,130,33
       byte 255                                                      ; End Marker
* Spider's legs (right extended, left not), climbing up web trail
_37996:
       byte 250,253,0                                                ; Change cursor's x- and y-coordinates by 0 and -3 characters respectively
       byte 32,130,30
       byte 34,2,34
       byte 33,130,33
       byte 255                                                      ; End Marker

* Update States of All Level 2 Entities
* 
* Used by the routine at #R34438.
_38009:
       bl   @_38592                    ; CALL 38592        ; Update states of stalactites (Level 2)
       bl   @_38480                    ; CALL 38480        ; Update states of apebeasts (Level 2) and store current positions in script data
       bl   @_38054                    ; CALL 38054        ; Update state of Bubo (Level 2) and store current position in script data
       bl   @_38219                    ; CALL 38219        ; Update state of Bubo's projectile
       rt                              ; RET               ; Return

* Current Position in Bubo's Script Data
_38022:
       data _38024

* Script Data Bubo
_38024:
       byte 9,0                                                      ; Reset Must Process Current Script Data Flag
       byte _38996%256,_38996/256                                    ; #R38996 (Bubo, normal, animated)
       byte 1,0,_38024%256,_38024/256                                ; Jump to #R38024
* Firing
_38032:
       byte 8,0                                                      ; Set Must Process Current Script Data Flag
       byte 25,0,4,0                                                 ; Start loop (2) for 4 iterations
       byte _39038%256,_39038/256                                    ; #R39038 (Bubo, pre/post firing)
       byte 26,0                                                     ; End loop (2)
       byte _39070%256,_39070/256                                    ; #R39070 (Bubo, squashed, firing)
       byte _39106%256,_39106/256                                    ; #R39106 (Bubo, squashed, firing, with explosion)
       byte 61,0                                                     ; Fire Bubo's projectile
       byte _39038%256,_39038/256                                    ; #R39038 (Bubo, pre/post firing)
       byte 1,0,_38024%256,_38024/256                                ; Jump to #R38024

* Update State of Bubo (Level 2) and Store Current Position in Script Data
* 
* Used by the routine at #R38009.
_38054:
       li   ix,_44227                  ; LD IX,44227       ; Load IX with address of complex state data for Bubo (Level 2)
       mov  @_38022,hl                 ; LD HL,(38022)     ; Load HL with current position in Bubo's script data from #R38022...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_38074                    ; CALL 38074        ; Update state of Bubo
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_38022                 ; LD (38022),HL     ; ...at #R38022 as current position in Bubo's script data
       rt                              ; RET               ; Return

* Update State of Bubo
* 
* Used by the routine at #R38054. Input:  IX  Address of complex state data for Bubo (Level 2)
_38074:
       mov  @9(ix),tmp0                ; BIT 3,(IX+9)      ; If Bubo's Harmless Flag is set...
       andi tmp0,8                     ;                   
       jne  _38101                     ; JR NZ,38101       ; ...then skip ahead to #R38101
       movb @_34220,a                  ; LD A,(34220)      ; If Berk's current power is not immunity to Bubo (Level 2)...
       cb   a,@bytes+9                 ; CP 9              ; ...
       jne  _38093                     ; JR NZ,38093       ; ...then skip ahead to #R38093
       socb @bits+3,@9(ix)             ; SET 3,(IX+9)      ; Set Bubo's Harmless Flag
       jmp  _38101                     ; JR 38101          ; Skip ahead to #R38101
_38093:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
_38101:
       equ  $
       li   iy,_44214                  ; LD IY,44214       ; Load IY with address of complex state data for Bubo's Projectile (Level 2)
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Bubo's Must Process Current Script Data Flag is set (Bubo firing)...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @9(iy),tmp0                ; BIT 1,(IY+9)      ; If Projectile's Fired Flag is set...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
_38119:
       equ  $
       mov  @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Bubo is not being carried...
       andi tmp0,32                    ;                   
       jeq  _38132                     ; JR Z,38132        ; ...then skip ahead to #R38132
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Bubo's Waiting to Fire Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
* The code block below is only entered if Bubo's Must Process Current Script Data Flag is reset (i.e. he is not
* firing), the Projectile's Fired Flag is reset and Bubo is not being carried.
_38132:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Bubo has a depth of 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Bubo's Waiting to Fire Flag is set, i.e. he has just been dropped...
       andi tmp0,4                     ;                   
       jne  _38155                     ; JR NZ,38155       ; ...then skip ahead to #R38155 (make Bubo fire)
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (59 in 60 chance)...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
_38155:
       equ  $
       szcb @bits+2,@9(ix)             ; RES 2,(IX+9)      ; Reset Bubo's Waiting to Fire Flag
       li   hl,_38032                  ; LD HL,38032       ; Point HL at script data for Bubo firing...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (61) Fire Bubo's Projectile
* 
* Note that Bubo normally can't fire when being carried (see instructions at #R38119), however if he starts to fire
* immediately before being picked up, then his Being Carried Flag will be set by the time execution reaches this
* routine. Input:  IX  Address of complex state data for Bubo (Level 2) IY  Address of complex state data for Bubo's
* projectile
_38165:
       socb @bits+1,@9(iy)             ; SET 1,(IY+9)      ; Set projectile's Fired Flag
       mov  @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Bubo is being carried...
       andi tmp0,32                    ;                   
       jne  _38181                     ; JR NZ,38181       ; ...then skip ahead to #R38181
       movb @bytes+251,@12(iy)         ; LD (IY+12),251    ; Set projectile's Velocity Factor to -5
       jmp  _38185                     ; JR 38185          ; Skip ahead to #R38185
_38181:
       movb @bytes+246,@12(iy)         ; LD (IY+12),246    ; Set projectile's Velocity Factor to -10
_38185:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set projectile's x-coordinate to one more than Bubo's...
       ab   one,a                      ; INC A             ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set projectile's y-coordinate to be three less than Bubo's...
       sb   @bytes+3,a                 ; SUB 3             ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Set projectile's room to be same as Bubo's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set projectile's depth to zero
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Update State of Bubo's Projectile
* 
* Used by the routine at #R38009.
_38219:
       li   ix,_44214                  ; LD IX,44214       ; Load IX with address of complex state data for Bubo's Projectile (Level 2)
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If projectile's Fired Flag is reset...
       andi tmp0,2                     ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       mov  @9(ix),tmp0                ; BIT 2,(IX+9)      ; If projectile's Has Hit Target Flag is reset...
       andi tmp0,4                     ;                   
       jeq  _38252                     ; JR Z,38252        ; ...then update position of projectile and knock key down if appropriate
       li   bc,_39131                  ; LD BC,39131       ; Point BC at graphic layout data for Bubo's Projectile...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as the Graphic Lookup Address for the projectile's complex state data
                                                           ; entry...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       movb @bytes+0,@9(ix)            ; LD (IX+9),0       ; Reset projectile's Has Hit Target Flag and Fired Flag
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set projectile's depth to zero
       rt                              ; RET               ; Return
_38252:
       li   iy,_44227                  ; LD IY,44227       ; Point IY at complex state data for Bubo (Level 2)
       movb @12(ix),a                  ; LD A,(IX+12)      ; If projectile's velocity factor is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _38267                     ; JR NZ,38267       ; ...then skip ahead to #R38267
       bl   @_38377                    ; CALL 38377        ; Start level 2 key falling if Bubo's projectile is in place below it
       jmp  _38361                     ; JR 38361          ; Jump to #R38361 (increase velocity and handle landing if appropriate)
_38267:
       mov  a,tmp0                     ; BIT 7,A           ; If bit 7 of projectile's velocity factor is set (i.e. negative, moving upwards)...
       andi tmp0,128                   ;                   
       jne  _38336                     ; JR NZ,38336       ; ...then skip ahead to #R38336
       cb   a,@bytes+6                 ; CP 6              ; If projectile's velocity factor is less than 6...
       jl   _38277                     ; JR C,38277        ; ...then skip ahead to #R38277
       movb @bytes+5,a                 ; LD A,5            ; Load A with 5 (terminal velocity)
_38277:
       movb a,b                        ; LD B,A            ; Load B with velocity value
_38278:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining velocity value)
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _38328                     ; JR C,38328        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R38328
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _38293                     ; JR NZ,38293       ; ...then skip ahead to #R38293
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       jmp  _38328                     ; JR 38328          ; Skip ahead to #R38328
_38293:
       cb   a,@bytes+25                ; CP 25             ; If collision was not with entity of class 25 (Green Apebeast, Level 2)...
       jne  _38328                     ; JR NZ,38328       ; ...then skip ahead to #R38328
       movb @_34218,a                  ; LD A,(34218)      ; Load A with current character's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...and if this is not the same as the projectile's room...
       jne  _38328                     ; JR NZ,38328       ; ...then skip ahead to #R38328
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set Ape Beast's depth to zero
       movb @bytes+0,@11(iy)           ; LD (IY+11),0      ; Reset Ape Beast's flags
       li   bc,_51483                  ; LD BC,51483       ; Point BC at graphic layout data for Explosion (Bubo's Projectile / Fallen Drips, Level 4)...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as the Graphic Lookup Address for the projectile's complex state data
                                                           ; entry...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set projectile's Has Hit Target Flag
       .pop bc                         ; POP BC            ; Restore BC (B = current velocity factor)
       rt                              ; RET               ; Return
_38328:
       bl   @_38756                    ; CALL 38756        ; Move projectile down one character
       .pop bc                         ; POP BC            ; Restore BC (B = current velocity factor)
       sb   one,b                      ; DJNZ 38278        ; Decrease remaining velocity value and loop back to #R38278 if not zero
       jne  _38278                     ;                   
       jmp  _38361                     ; JR 38361          ; Skip ahead to #R38361 (increase velocity and handle landing if appropriate)
* Projectile moving upwards
_38336:
       neg a                           ; NEG               ; Multiply projectile's velocity factor by -1
       cb   a,@bytes+6                 ; CP 6              ; If projectile's velocity factor is now less than 6...
       jl   _38344                     ; JR C,38344        ; ...then skip ahead to #R38344 (change projectile's y-coordinate based upon velocity)
       movb @bytes+5,a                 ; LD A,5            ; Load A with 5 (i.e. cap velocity magnitude at 5)
_38344:
       neg a                           ; NEG               ; Multiply value in A by -1...
       movb a,@e                       ; LD E,A            ; ...and load value (capped velocity) into E
       movb @4(ix),a                   ; LD A,(IX+4)       ; Decrease projectile's y-coordinate by value in E...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; ...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
_38361:
       movb @4(ix),a                   ; LD A,(IX+4)       ; If projectile's y-coordinate is at least 124...
       cb   a,@bytes+124               ; CP 124            ; ...
       jhe  _38372                     ; JR NC,38372       ; ...then skip ahead to #R38372 (reset projectile's Fired Flag and return)
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase projectile's velocity factor by one
       rt                              ; RET               ; Return
_38372:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset projectile's Fired Flag
       rt                              ; RET               ; Return

* Start Level 2 Key Falling if Bubo's Projectile is in Place Below it
* 
* Used by the routine at #R38219. Input:  IX  Address of complex state data for Bubo's projectile (Level 2)
_38377:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of projectile is not 1...
       cb   a,one                      ; CP 1              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If projectile's left-side has an x-coordinate less than 114...
       cb   a,@bytes+114               ; CP 114            ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       cb   a,@bytes+118               ; CP 118            ; If projectile's left-side has an x-coordinate of 118 or more...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       li   iy,_44240                  ; LD IY,44240       ; Load IY with address of complex state data for Key (Level 2)
       movb *iy,a                      ; LD A,(IY+0)       ; If key's room is not 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  @10(iy),tmp0               ; BIT 6,(IY+10)     ; If key's Is Falling Flag is set...
       andi tmp0,64                    ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set key's Is Falling Flag
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set key's velocity factor to 2
       rt                              ; RET               ; Return

* Table of Initial Positions in Apebeasts' Script Data
_38416:
       data _38432                                                   ; Apebeast 1 (Level 2)
       data _38450                                                   ; Apebeast 2 (Level 2)
       data _38432                                                   ; Apebeast 3 (Level 2)
       data _38450                                                   ; Apebeast 4 (Level 2)

* Table of Current Positions in Apebeasts' Script Data
_38424:
       data _38432                                                   ; Apebeast 1 (Level 2)
       data _38450                                                   ; Apebeast 2 (Level 2)
       data _38432                                                   ; Apebeast 3 (Level 2)
       data _38450                                                   ; Apebeast 4 (Level 2)

* Script Data Apebeast Walking Right
_38432:
       byte 12,0                                                     ; Set Apebeast's Walking Right Flag
       byte 60,0                                                     ; Check position of apebeast and turn if appropriate
       byte 3,0                                                      ; Move apebeast right one character
       byte _38822%256,_38822/256                                    ; #R38822 (Apebeast, walking right, frame 3)
       byte _38766%256,_38766/256                                    ; #R38766 (Apebeast, walking right, frame 1)
       byte _38794%256,_38794/256                                    ; #R38794 (Apebeast, walking right, frame 2)
       byte _38794%256,_38794/256                                    ; #R38794 (Apebeast, walking right, frame 2)
       byte 1,0,_38432%256,_38432/256                                ; Jump back to #R38432

* Script Data Apebeast Walking Left
_38450:
       byte 11,0                                                     ; Set Apebeast's Walking Left Flag
       byte 60,0                                                     ; Check position of apebeast and turn if appropriate
       byte 2,0                                                      ; Move apebeast left one character
       byte _38937%256,_38937/256                                    ; #R38937 (Apebeast, walking left, frame 3)
       byte _38881%256,_38881/256                                    ; #R38881 (Apebeast, walking left, frame 1)
       byte _38909%256,_38909/256                                    ; #R38909 (Apebeast, walking left, frame 2)
       byte _38909%256,_38909/256                                    ; #R38909 (Apebeast, walking left, frame 2)
       byte 1,0,_38450%256,_38450/256                                ; Jump back to #R38450

* Reset Current Positions in Apebeasts' Script Data to Initial Values
* 
* Used by the routine at #R34751.
_38468:
       li   de,_38424                  ; LD DE,38424       ; Point DE at Table of Current Positions in Apebeasts' Script Data
       li   hl,_38416                  ; LD HL,38416       ; Point HL at Table of Initial Positions in Apebeasts' Script Data
       li   bc,8                       ; LD BC,8           ; Load BC with 8 (as there are eight bytes to copy)
       .ldir                           ; LDIR              ; Overwrite addresses in Table of Current Positions with those from Table of Initial Positions
       rt                              ; RET               ; Return

* Update States of Apebeasts (Level 2) and Store Current Positions in Script Data
* 
* Used by the routine at #R38009.
_38480:
       li   ix,_44162                  ; LD IX,44162       ; Load IX with address of complex state data for Green Apebeast 1 (Level 2)
       li   iy,_38424                  ; LD IY,38424       ; Point IY at Table of Current Positions in Apebeasts' Script Data
_38488:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If depth of Apebeast is zero (i.e. Apebeast killed by Bubo)...
       socb a,a                        ; OR A              ; ...
       jeq  _38523                     ; JR Z,38523        ; ...then skip ahead to #R38523 (i.e. move onto next apebeast)
       movb *iy,@l                     ; LD L,(IY+0)       ; Load HL with current position in script data for current apebeast...
       movb @1(iy),h                   ; LD H,(IY+1)       ; ...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .push ix                        ; PUSH IX           ; Store IX
       .push iy                        ; PUSH IY           ; Store IY
       bl   @_38540                    ; CALL 38540        ; Update the state of the current apebeast
       .pop iy                         ; POP IY            ; Restore IY
       .pop ix                         ; POP IX            ; Restore IX
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data for current apebeast) stored at #R34277...
       movb @l,*iy                     ; LD (IY+0),L       ; ...in table at #R38424 as current position in this apebeast's script data...
       movb h,@1(iy)                   ; LD (IY+1),H       ; ...
_38523:
       inc  iy                         ; INC IY            ; Advance IY to next entry in table (i.e. position in next apebeast's script data)...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX by 13 bytes (i.e. to entry for next apebeast)...
       a    de,ix                      ; ADD IX,DE         ; ...
       movb @8(ix),a                   ; LD A,(IX+8)       ; If class of this next entry is 25 (i.e. Apebeast)...
       cb   a,@bytes+25                ; CP 25             ; ...
       jeq  _38488                     ; JR Z,38488        ; ...then loop back to #R38488
       rt                              ; RET               ; Return

* Update State of an Apebeast
* 
* Used by the routine at #R38480.
_38540:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       jnc  !                          ; JP C,48096        ; TODO: check code. ...and if no collision occurred, then jump to #R48096 (advance HL to next script instruction
       b    @_48096                    ;                   
!
                                                           ; and execute)
       cb   a,@bytes+31                ; CP 31             ; If collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (60) Check Position of Apebeast and Turn If Appropriate Input:  IX  Address of complex state data
* for an entity Output: HL  Address of next script instruction to execute
_38554:
       mov  @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Apebeast's Walking Right Flag is set...
       andi tmp0,1                     ;                   
       jne  _38575                     ; JR NZ,38575       ; ...then skip ahead to #R38575
* Apebeast walking left
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is less than x-coordinate of left edge of Apebeast...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       li   hl,_38432                  ; LD HL,38432       ; Point HL at script data for Apebeast walking right...
       b    @_48098                    ; JP 48098          ; ...and execute
* Apebeast walking right
_38575:
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       a    @bytes+13,a                ; ADD A,13          ; ...plus 13...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...is equal to or greater than x-coordinate of right edge of Apebeast...
       jl   !                          ; JP NC,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       li   hl,_38450                  ; LD HL,38450       ; Point HL at script data for Apebeast walking left...
       b    @_48098                    ; JP 48098          ; ...and execute

* Update States of Stalactites (Level 2)
* 
* Used by the routine at #R38009.
_38592:
       li   ix,_44305                  ; LD IX,44305       ; Load IX with address of complex state data for first of seven falling stalactites (Level 2)
_38596:
       movb @8(ix),a                   ; LD A,(IX+8)       ; If current entity class is not 34 (Stalactite, Level 2)...
       cb   a,@bytes+34                ; CP 34             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If velocity factor of stalactite is not zero (i.e. it is falling)...
       socb a,a                        ; OR A              ; ...
       jne  _38635                     ; JR NZ,38635       ; ...then skip ahead to #R38635
       movb @bytes+40,a                ; LD A,40           ; Load A with a random number, 0-39...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (39 in 40 chance)...
       jeq  !                          ; JP NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
       b    @_38748                    ;                   
!
       bl   @_38756                    ; CALL 38756        ; Move stalactite down one character and load A with new top y-coordinate
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load A with top y-coordinate of stalactite (see trivia)
       cb   a,@bytes+101               ; CP 101            ; If new top y-coordinate is not 101
       jeq  !                          ; JP NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
       b    @_38748                    ;                   
!
       movb one,@12(ix)                ; LD (IX+12),1      ; Set stalactite's velocity factor to 1
       b    @_38748                    ; JP 38748          ; Advance IX to next entry in complex state data and loop back to #R38596
_38635:
       cb   a,one                      ; CP 1              ; If velocity factor is not 1...
       jne  _38707                     ; JR NZ,38707       ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
       movb @5(ix),@e                  ; LD E,(IX+5)       ; Load E with x-coordinate of left of stalactite
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is not the same as the stalactite's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jne  _38679                     ; JR NZ,38679       ; ...then skip ahead to #R38679 to check Drutt's position
       movb @11(iy),a                  ; LD A,(IY+11)      ; If Berk's Walking Left Flag is set...
       mov  a,tmp0                     ; BIT 1,A           ; ...
       andi tmp0,2                     ;                   
       jne  _38673                     ; JR NZ,38673       ; ...then skip ahead to #R38673
       mov  a,tmp0                     ; BIT 0,A           ; If Berk's Walking Right Flag is not set...
       andi tmp0,1                     ;                   
       jeq  _38679                     ; JR Z,38679        ; ...then skip ahead to #R38679 to check Drutt's position
       movb @7(iy),a                   ; LD A,(IY+7)       ; If Berk's right-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@e                       ; CP E              ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
       jmp  _38679                     ; JR 38679          ; Skip ahead to #R38679 to check Drutt's position
_38673:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Berk's left-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@e                       ; CP E              ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
_38679:
       li   iy,_44396                  ; LD IY,44396       ; Load IY with address of complex state data for Drutt (Level 2)
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt's current room is not the same as the stalactite's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jne  _38699                     ; JR NZ,38699       ; ...then skip ahead to #R38699
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Drutt's left-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
_38699:
       movb @bytes+200,a               ; LD A,200          ; Load A with a random number, 0-199...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (199 in 200 chance)...
       jne  _38748                     ; JR NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
_38707:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _38718                     ; JR NZ,38718       ; ...then skip ahead to #R38718 (start stalactite falling)
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       rt                              ; RET               ; Return
_38718:
       movb @12(ix),b                  ; LD B,(IX+12)      ; Load B with stalactite's velocity factor...
_38721:
       bl   @_38756                    ; CALL 38756        ; ...and move stalactite down by this many characters...
       sb   one,b                      ; DJNZ 38721        ; ...
       jne  _38721                     ;                   
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase stalactite's velocity factor by one
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of top of stalactite is less than 150...
       cb   a,@bytes+150               ; CP 150            ; ...
       jl   _38748                     ; JR C,38748        ; ...then advance IX to next entry in complex state data and loop back to #R38596
       movb @bytes+98,@4(ix)           ; LD (IX+4),98      ; Move stalactite back to top of room...
       movb @bytes+100,@6(ix)          ; LD (IX+6),100     ; ...
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; ...and set its velocity factor to zero
_38748:
       li   bc,13                      ; LD BC,13          ; Advance IX by 13 bytes to move to next complex state data entry...
       a    bc,ix                      ; ADD IX,BC         ; ...
       b    @_38596                    ; JP 38596          ; ...and loop back to #R38596 for next entity

* Move Entity at IX Down One Character
* 
* Used by the routines at #R38219 and #R38592. Input:  IX  Address of complex state data for an entity Output: A New
* y-coordinate of entity's top
_38756:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase y-coordinates of top and bottom of entity by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load new y-coordinate of entity's top into A
       rt                              ; RET               ; Return

* Graphic Layout Data Green Apebeast (Level 2) Walking right (frame 1)
_38766:
       byte 250,255,2                                                ; Change cursor's x- and y-coordinates by +2 and -1 characters respectively
       byte 251,_38856%256,_38856/256                                ; Process graphic layout data at #R38856 and upon returning, move cursor to base coordinates
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 1,68,33
       byte 2,68,31
       byte 3,4,33
       byte 4,68,31
       byte 5,4,33
       byte 6,4,33
       byte 255                                                      ; End Marker
* Walking right (frame 2)
_38794:
       byte 250,254,2                                                ; Change cursor's x- and y-coordinates by +2 and -2 characters respectively
       byte 251,_38856%256,_38856/256                                ; Process graphic layout data at #R38856 and upon returning, move cursor to base coordinates
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 33,68,33
       byte 13,68,31
       byte 14,4,33
       byte 15,4,31
       byte 5,4,33
       byte 12,4,33
       byte 255                                                      ; End Marker
* Walking right (frame 3)
_38822:
       byte 250,255,2                                                ; Change cursor's x- and y-coordinates by +2 and -1 characters respectively
       byte 251,_38856%256,_38856/256                                ; Process graphic layout data at #R38856 and upon returning, move cursor to base coordinates
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 7,68,33
       byte 8,68,30
       byte 9,4,33
       byte 10,4,33
       byte 11,4,30
       byte 5,4,33
       byte 12,4,33
       byte 32,4,33
       byte 255                                                      ; End Marker
* Head (right-facing)
_38856:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 16,68,33
       byte 236,2,20,21                                              ; Modify following instruction to display graphic of random index, chosen from 20 and 21
       byte 20,7,31
       byte 17,4,33
       byte 18,7,31
       byte 19,4,33
       byte 31,4,33
       byte 255                                                      ; End Marker
* Walking left (frame 1)
_38881:
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 251,_38971%256,_38971/256                                ; Process graphic layout data at #R38971 and upon returning, move cursor to base coordinates
       byte 250,255,2                                                ; Change cursor's x- and y-coordinates by +2 and -1 characters respectively
       byte 2,132,33
       byte 1,132,31
       byte 4,132,33
       byte 3,132,31
       byte 6,132,33
       byte 5,132,33
       byte 255                                                      ; End Marker
* Walking left (frame 2)
_38909:
       byte 250,254,0                                                ; Change cursor's x- and y-coordinates by 0 and -2 characters respectively
       byte 251,_38971%256,_38971/256                                ; Process graphic layout data at #R38971 and upon returning, move cursor to base coordinates
       byte 250,255,2                                                ; Change cursor's x- and y-coordinates by +2 and -1 characters respectively
       byte 13,132,33
       byte 33,132,31
       byte 15,132,33
       byte 14,132,31
       byte 12,132,33
       byte 5,132,33
       byte 255                                                      ; End Marker
* Walking left (frame 3)
_38937:
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 251,_38971%256,_38971/256                                ; Process graphic layout data at #R38971 and upon returning, move cursor to base coordinates
       byte 250,255,2                                                ; Change cursor's x- and y-coordinates by +2 and -1 characters respectively
       byte 8,132,33
       byte 7,132,31
       byte 11,132,33
       byte 10,132,33
       byte 9,132,30
       byte 32,132,33
       byte 12,132,33
       byte 5,132,33
       byte 255                                                      ; End Marker
* Head (left-facing)
_38971:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 236,2,20,21                                              ; Modify following instruction to display graphic of random index, chosen from 20 and 21
       byte 20,135,33
       byte 16,132,31
       byte 18,135,33
       byte 17,132,31
       byte 31,132,33
       byte 19,132,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Bubo (Level 2) Normal, animated
_38996:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 27,6,33
       byte 28,70,33
       byte 27,134,30
       byte 29,6,33
       byte 245,2,10,3,22,23,24                                      ; Decrease timer value (initially 2) and if now zero then reset to 10 and
                                                                     ; load one of the 3 following values at random into the Graphic Index field
                                                                     ; of the following instruction
       byte 22,70,161
       byte 29,134,30
       byte 30,70,33
       byte 34,70,161
       byte 30,198,30
       byte 248,_39096%256,_39096/256                                ; Jump to #R39096 (Bubo's feet)
* Pre/post firing
_39038:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 250,254,1                                                ; Change cursor's x- and y-coordinates by +1 and -2 characters respectively
       byte 0,54,32
       byte 0,54,31
       byte 29,6,33
       byte 25,70,161
       byte 29,134,30
       byte 30,70,33
       byte 37,70,161
       byte 30,198,30
       byte 248,_39096%256,_39096/256                                ; Jump to #R39096 (Bubo's feet)
* Squashed, firing
_39070:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 44,6,33
       byte 0,54,33
       byte 44,134,29
       byte 39,6,33
       byte 0,54,33
       byte 26,70,161
       byte 0,54,33
       byte 39,134,29
* Feet
_39096:
       byte 35,70,161
       byte 36,70,161
       byte 35,198,33
       byte 255                                                      ; End Marker
* Squashed, firing, with explosion
_39106:
       byte 251,_39070%256,_39070/256                                ; Process graphic layout data at #R39070 and upon returning, move cursor to
                                                                     ; base coordinates
       byte 250,254,0                                                ; Change cursor's x- and y-coordinates by 0 and -2 characters respectively
       byte 40,71,33,41,71,33,40,199,30
       byte 42,71,33,43,120,33,42,199,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Bubo's Projectile (Level 2)
_39131:
       byte 244,9                                                    ; Set current graphic set to 9
       byte 43,71,33
       byte 255                                                      ; End Marker

* Update States of All Level 3 Entities
* 
* Used by the routine at #R34438.
_39137:
       bl   @_39776                    ; CALL 39776        ; Update state of Large Yellow Creature
       bl   @_39601                    ; CALL 39601        ; Update states of coloured creatures
       bl   @_39278                    ; CALL 39278        ; Update state of Clawed Foot
       bl   @_39151                    ; CALL 39151        ; Update state of Hatch
       rt                              ; RET               ; Return

* Hatch State Index (Level 3)
_39150:
       byte 0

* Update State of Hatch (Level 3)
* 
* Used by the routine at #R39137.
_39151:
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       li   hl,_39150                  ; LD HL,39150       ; If Hatch State Index is zero...
       movb *hl,a                      ; LD A,(HL)         ; ...
       socb a,a                        ; OR A              ; ...
       jeq  _39176                     ; JR Z,39176        ; ...then skip ahead to #R39176
* Hatch State Index is not zero
       ab   one,*hl                    ; INC (HL)          ; Increase Hatch State Index
       cb   a,@bytes+2                 ; CP 2              ; If Hatch State Index is 2 (Berk was thrown 1 cycle ago)...
       jeq  _39264                     ; JR Z,39264        ; ...then skip ahead to #R39264
       cb   a,@bytes+10                ; CP 10             ; If Hatch State Index is 10 (Berk was thrown 9 cycles ago)...
       jeq  _39259                     ; JR Z,39259        ; ...then skip ahead to #R39259
       cb   a,@bytes+11                ; CP 11             ; If Hatch State Index is 11 (Berk was thrown 10 cycles ago)...
       jeq  _39269                     ; JR Z,39269        ; ...then skip ahead to #R39269
       rt                              ; RET               ; Return
* Hatch State Index is zero
_39176:
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is not 4 (Hatch Room)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Berk's left edge is less than 109...
       cb   a,@bytes+109               ; CP 109            ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Berk's right edge is 120 or greater...
       cb   a,@bytes+120               ; CP 120            ; ...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
* At this point, Berk is standing on the hatch
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is holding the weight...
       cb   a,@bytes+12                ; CP 12             ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Increase Hatch State Index to 1
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @_34220,a                  ; LD A,(34220)      ; If Berk's current power is not invisibility (Level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jne  _39225                     ; JR NZ,39225       ; ...then skip ahead to #R39225
       bl   @_48417                    ; CALL 48417        ; Remove Berk's invisibility and reset corresponding edible eyes to their original position
_39225:
       movb @bytes+4,b                 ; LD B,4            ; Move Berk up four characters...
_39227:
       bl   @_39442                    ; CALL 39442        ; ...
       sb   one,b                      ; DJNZ 39227        ; ...
       jne  _39227                     ;                   
       movb @bytes+107,@5(ix)          ; LD (IX+5),107     ; Set x-coordinate of Berk's left edge to 107
       movb @bytes+112,@7(ix)          ; LD (IX+7),112     ; Set x-coordinate of Berk's right edge to 112
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Berk's Must Process Current Script Data Flag
       li   hl,_59048                  ; LD HL,59048       ; Set Berk's graphic layout data address to #R59048...
       movb @l,@2(ix)                  ; LD (IX+2),L       ; ...(Berk being thrown left)...
       movb h,@3(ix)                   ; LD (IX+3),H       ; ...
       li   hl,_35523                  ; LD HL,35523       ; Set current position in Berk's script data to #R35523...
       mov  hl,@_35687                 ; LD (35687),HL     ; (Berk being thrown left by Hatch)
* Hatch State Index is 10 (Berk was thrown 9 cycles ago)
_39259:
       li   hl,_41115                  ; LD HL,41115       ; Load HL with graphic layout data address of Hatch half open with Bat (Animated)
       jmp  _39274                     ; JR 39274          ; Skip ahead to #R39274 (set Hatch's GLD address to value in HL and return)
* Hatch State Index is 2 (Berk was thrown 1 cycle ago)
_39264:
       li   hl,_41099                  ; LD HL,41099       ; Load HL with graphic layout data address of Hatch fully open With Bat (Animated)
       jmp  _39274                     ; JR 39274          ; Skip ahead to #R39274 (set Hatch's GLD address to value in HL and return)
* Hatch State Index is 11 (Berk was thrown 10 cycles ago)
_39269:
       movb @bytes+0,*hl               ; LD (HL),0         ; Set Hatch State Index to zero
       li   hl,_41090                  ; LD HL,41090       ; Load HL with graphic layout data address of Hatch closed
_39274:
       mov  hl,@_44608+184             ; LD (44792),HL     ; Set Hatch's graphic layout data address to value in HL
       rt                              ; RET               ; Return

* Update State of Clawed Foot (Level 3)
* 
* Used by the routine at #R39137.
_39278:
       movb @_34228,a                  ; LD A,(34228)      ; If Clawed Foot's Attack Timer is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _39289                     ; JR Z,39289        ; ...then skip ahead to #R39289
       sb   one,a                      ; DEC A             ; Decrease Clawed Foot's Attack Timer...
       mov  a,@_34228                  ; LD (34228),A      ; ...
       rt                              ; RET               ; Return
* Clawed Foot is attacking
_39289:
       li   iy,_44881                  ; LD IY,44881       ; Load IY with address of complex state data for Clawed Foot (Level 3)
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       bl   @_53848                    ; CALL 53848        ; Store room size data for Berk's current room
       movb @_44881+9,a                ; LD A,(44890)      ; Load A with Clawed Foot's flags...
       socb a,a                        ; OR A              ; ...and if any are set...
       jne  _39337                     ; JR NZ,39337       ; ...then skip ahead to #R39337
* Clawed Foot attack not yet started
       movb *iy,a                      ; LD A,(IY+0)       ; If the Clawed Foot's room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's room...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @11(ix),a                  ; LD A,(IX+11)      ; If Berk's Walking Left Flag or Walking Right Flag is set...
       andi a,3*256                    ; AND 3             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set the Clawed Foot's left edge...
       ab   one,a                      ; INC A             ; ...to be one character to the right of Berk's left edge...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       a    @bytes+2,a                 ; ADD A,2           ; Set the Clawed Foot's right edge...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...to be two characters to the right of its left edge
       socb @bits+1,@9(iy)             ; SET 1,(IY+9)      ; Set Clawed Foot's Moving Down Flag
       jmp  _39341                     ; JR 39341          ; Skip ahead to #R39341
* Clawed Foot attack underway
_39337:
       mov  a,tmp0                     ; BIT 1,A           ; If Clawed Foot's Moving Down Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _39420                     ; JR Z,39420        ; ...then skip ahead to #R39420
_39341:
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as the Clawed Foot moves down three characters at time)
_39343:
       ab   one,@4(iy)                 ; INC (IY+4)        ; Advance Clawed Foot one character down...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of bottom edge of Clawed Foot is 115...
       cb   a,@bytes+115               ; CP 115            ; ...
       jeq  _39359                     ; JR Z,39359        ; ...then skip ahead to #R39359
       sb   one,b                      ; DJNZ 39343        ; Decrease remaining number of characters to move and loop back to #R39343 if not zero
       jne  _39343                     ;                   
       rt                              ; RET               ; Return
* Clawed Foot attempting to grab Berk
_39359:
       mov  @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64                    ;                   
       jne  _39386                     ; JR NZ,39386       ; ...then skip ahead to #R39386 (set Clawed Foot's Moving Up Flag and return)
       mov  @10(ix),tmp0               ; BIT 6,(IX+10)     ; If Berk is falling...
       andi tmp0,64                    ;                   
       jne  _39386                     ; JR NZ,39386       ; ...then skip ahead to #R39386 (set Clawed Foot's Moving Up Flag and return)
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Clawed Foot's left edge...
       sb   one,a                      ; DEC A             ; ...is one character to the right of Berk's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jeq  _39391                     ; JR Z,39391        ; ...then skip ahead to #R39391
       sb   one,a                      ; DEC A             ; If Clawed Foot's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is two characters to the right of Berk's left edge...
       jeq  _39391                     ; JR Z,39391        ; ...then skip ahead to #R39391
* Berk is flying or falling, or Clawed Foot has missed
_39386:
       movb @bytes+4,@9(iy)            ; LD (IY+9),4       ; Set Clawed Foot's Moving Up Flag
       rt                              ; RET               ; Return
* Make Clawed Foot grab Berk (Clawed Foot is one or two characters to the right of Berk's left edge)
_39391:
       li   bc,_35515                  ; LD BC,35515       ; Set current position in Berk's script data to...
       mov  bc,@_35687                 ; LD (35687),BC     ; ...Berk in floating position
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Berk's Must Process Current Script Data Flag
       movb @bytes+12,a                ; LD A,12           ; Set Clawed Foot's Moving Up Flag and Holding Berk Flag...
       movb a,@9(iy)                   ; LD (IY+9),A       ; ...
       li   bc,_40368                  ; LD BC,40368       ; Set Clawed Foot's graphic layout data address to point to #R40368 (Reaching, Closed)...
_39410:
       movb @c,@2(iy)                  ; LD (IY+2),C       ; ...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       rt                              ; RET               ; Return
* Check Clawed Foot's Moving Up Flag
_39420:
       mov  a,tmp0                     ; BIT 2,A           ; If Clawed Foot's Moving Up Flag is reset...
       andi tmp0,4                     ;                   
       jeq  _39532                     ; JR Z,39532        ; ...then skip ahead to #R39532
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move Clawed Foot up one character...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of bottom of Clawed Foot...
       cb   a,@bytes+95                ; CP 95             ; ...is 95...
       jeq  _39449                     ; JR Z,39449        ; ...then skip ahead to #R39449
       mov  @9(iy),tmp0                ; BIT 3,(IY+9)      ; If Clawed Foot's Holding Berk Flag is reset...
       andi tmp0,8                     ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
* This entry point is used by the routine at #R39151.
_39442:
       equ  $
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move entity at IX (Berk) up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       rt                              ; RET               ; Return
_39449:
       mov  @9(iy),tmp0                ; BIT 3,(IY+9)      ; If Clawed Foot's Holding Berk Flag is reset...
       andi tmp0,8                     ;                   
       jeq  _39527                     ; JR Z,39527        ; ...then skip ahead to #R39527 (Reset Clawed Foot to inactive state and return)
       movb @_34229,a                  ; LD A,(34229)      ; Increase Clawed Foot's Action Index...
       ab   one,a                      ; INC A             ; ...
_39459:
       mov  a,@_34229                  ; LD (34229),A      ; ...
       cb   a,@bytes+7                 ; CP 7              ; ...and if less than 7...
       jl   _39470                     ; JR C,39470        ; ...then skip ahead to #R39470
       movb one,a                      ; LD A,1            ; Set Clawed Foot's Action Index to 1...
       jmp  _39459                     ; JR 39459          ; ...and jump to #R39470 (via #R39459)
_39470:
       cb   a,@bytes+3                 ; CP 3              ; If Clawed Foot's Action Index is less than 3...
       jl   _39501                     ; JR C,39501        ; ...then skip ahead to #R39501 (i.e. make clawed foot release Berk, and return)
       cb   a,@bytes+5                 ; CP 5              ; If Clawed Foot's Action Index is less than 5...
       jl   _39482                     ; JR C,39482        ; ...then skip ahead to #R39482
       movb @bytes+112,@e              ; LD E,112          ; Load E with 112 (prepare to set Clawed Foot's destination x-coordinate)
       jmp  _39484                     ; JR 39484          ; Skip ahead to #R39484
_39482:
       movb @bytes+122,@e              ; LD E,122          ; Load E with 122 (prepare to set Clawed Foot's destination x-coordinate)
_39484:
       movb @e,@12(ix)                 ; LD (IX+12),E      ; Store destination x-coordinate in byte 12 of Berk's complex state data
       mov  a,tmp0                     ; BIT 0,A           ; If Clawed Foot's Action Index is even...
       andi tmp0,1                     ;                   
       jeq  _39496                     ; JR Z,39496        ; ...then skip ahead to #R39496
       movb @bytes+16,@9(iy)           ; LD (IY+9),16      ; Set Clawed Foot's Move Left Flag
       rt                              ; RET               ; Return
_39496:
       movb @bytes+32,@9(iy)           ; LD (IY+9),32      ; Set Clawed Foot's Move Right Flag
       rt                              ; RET               ; Return
* The instructions between #R39501 and #R39531 make the Clawed Foot release Berk.
_39501:
       movb @bytes+100,a               ; LD A,100          ; Set Clawed Foot's Attack Timer to 100...
       mov  a,@_34228                  ; LD (34228),A      ; ...i.e. Clawed Foot will attack again in 100 cycles
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set Berk's "Can Fall" flag
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set Berk's velocity factor to 2
       li   bc,_35359                  ; LD BC,35359       ; Set current position in Berk's script data to...
       mov  bc,@_35687                 ; LD (35687),BC     ; ...Berk starting to fall downwards
       li   bc,_40320                  ; LD BC,40320       ; Set Clawed Foot's graphic layout data address to point to #R40320 (Reaching, Open)...
       bl   @_39410                    ; CALL 39410        ; ...make Berk drop the entity he is holding and load IY with its complex state data address
* Reset Clawed Foot to inactive state
_39527:
       movb @bytes+0,@9(iy)            ; LD (IY+9),0       ; Reset Clawed Foot's Flags
_39531:
       rt                              ; RET               ; Return
* Check Clawed Foot's Moving Left Flag
_39532:
       mov  a,tmp0                     ; BIT 4,A           ; If Clawed Foot's Move Left Flag is reset...
       andi tmp0,16                    ;                   
       jeq  _39552                     ; JR Z,39552        ; ...then skip ahead to #R39552
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk one character left...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @_54348                    ; CALL 54348        ; Move Berk into room to the left, if appropriate
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is 5 (room to the left of the Coloured Creatures' Room)...
       cb   a,@bytes+5                 ; CP 5              ; ...then set Zero Flag
       jmp  _39569                     ; JR 39569          ; Skip ahead to #R39569
* Check Clawed Foot's Moving Right Flag
_39552:
       mov  a,tmp0                     ; BIT 5,A           ; If Clawed Foot's Move Right Flag is reset...
       andi tmp0,32                    ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk one character right...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @_54313                    ; CALL 54313        ; Move Berk into room to the right, if appropriate
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is 7 (room to the right of the Coloured Creatures' Room)...
       cb   a,@bytes+7                 ; CP 7              ; ...then set Zero Flag
_39569:
       jeq  !                          ; RET NZ            ; If Zero Flag is not set (i.e. Berk is not in Room 5 or Room 7) then return
       rt                              ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If the x-coordinate of Berk's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not the same as the Clawed Foot's destination x-coordinate...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       li   iy,_44881                  ; LD IY,44881       ; Load IY with address of complex state data for Clawed Foot (Level 3)
       b    @_39501                    ; JP 39501          ; Make Clawed Foot release Berk, and return

* Table of Coloured Creatures' Properties
* 
* This data is used to periodically change the identities of the three coloured creatures. Upon switching, a random
* number (i.e. a "Sequence ID") between 0 and 2 is generated. This Sequence ID is the index of the record, in the
* following table, whose data (entity class and graphic layout data address) will overwrite that of the first
* coloured creature at #R44894, as defined in the complex state data table. The second and third creatures' data
* will be likewise overwritten by the data from the following two records, respectively. As three records are always
* used, starting with the record whose index matches the generated Sequence ID, there will always be one red, one
* yellow and one white creature.
_39584:
       byte 13,62,157                                                ; Red Coloured Creature
       byte 14,77,157                                                ; Yellow Coloured Creature
       byte 15,92,157                                                ; White Coloured Creature
       byte 13,62,157                                                ; Red Coloured Creature
       byte 14,77,157                                                ; Yellow Coloured Creature

* Miscellaneous Data (Coloured Creatures)
_39599:
       byte 0                                                        ; Creatures' current Sequence ID
_39600:
       byte 0                                                        ; Cycles elapsed since last swap of creatures

* Update States of Coloured Creatures
* 
* Used by the routine at #R39137.
_39601:
       movb @_44894+9,a                ; LD A,(44903)      ; Load A with first coloured creature's flags
       mov  a,tmp0                     ; BIT 2,A           ; If Coloured Creatures' Reward Given Flag is set...
       andi tmp0,4                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  a,tmp0                     ; BIT 1,A           ; If All Coloured Creatures Home Flag is set...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,39760       ; ...then present reward for getting coloured creatures home, and return
       b    @_39760                    ;                   
!
       bl   @_39699                    ; CALL 39699        ; Count coloured creatures in slots and return if all are home
       movb @l,a                       ; LD A,L            ; If all three coloured creatures are in slots...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       movb @_34218,a                  ; LD A,(34218)      ; If current character's current room is not 6 (coloured creatures' room)...
       cb   a,@bytes+6                 ; CP 6              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       li   hl,_39600                  ; LD HL,39600       ; Increase cycles elapsed since last swap of creatures...
       ab   one,*hl                    ; INC (HL)          ; ...
       movb *hl,a                      ; LD A,(HL)         ; ...
       cb   a,@bytes+100               ; CP 100            ; ...and if less than 100...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       movb @bytes+0,*hl               ; LD (HL),0         ; Set cycles elapsed since last swap of creatures to zero
       bl   @_36616                    ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       li   hl,_39599                  ; LD HL,39599       ; Point HL at current Sequence ID
_39641:
       movb @bytes+3,a                 ; LD A,3            ; Load A with a random number, 0-2...
       bl   @_54222                    ; CALL 54222        ; ...
       cb   a,*hl                      ; CP (HL)           ; ...and if this is the same as the current Sequence ID...
       jeq  _39641                     ; JR Z,39641        ; ...then jump back to #R39641 to generate a new random number
       movb a,*hl                      ; LD (HL),A         ; Set new Sequence ID to generated number
       a    a,a                        ; ADD A,A           ; Load BC with three times Sequence ID...
       a    *hl,a                      ; ADD A,(HL)        ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+0,b                 ; LD B,0            ; ...
       li   iy,_39584                  ; LD IY,39584       ; Load IY with start address of Table of Coloured Creatures' Properties...
       a    bc,iy                      ; ADD IY,BC         ; ...and add three times Sequence ID to get address of first entry in new sequence
       li   ix,_44894                  ; LD IX,44894       ; Load IX with address of complex state data for first coloured creature (Level 3)
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as there are three coloured creatures)
_39667:
       movb *iy,a                      ; LD A,(IY+0)       ; Set class of current coloured creature...
       movb a,@8(ix)                   ; LD (IX+8),A       ; ...
       movb @1(iy),a                   ; LD A,(IY+1)       ; ...and address of graphic layout data...
       movb a,@2(ix)                   ; LD (IX+2),A       ; ...
       movb @2(iy),a                   ; LD A,(IY+2)       ; ...
       movb a,@3(ix)                   ; LD (IX+3),A       ; ...to values in current record in Table of Coloured Creatures' Properties
       inc  iy                         ; INC IY            ; Advance IY to next entry in properties table...
       inc  iy                         ; INC IY            ; ...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX to next coloured creature's properties...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 39667        ; Decrease remaining number of coloured creatures to update and loop back to #R39667 if not
       jne  _39667                     ;                   
                                                           ; zero
       rt                              ; RET               ; Return

* Count Coloured Creatures in Slots and Return if All Are Home
* 
* Used by the routine at #R39601. Output: H  Number of coloured creatures in correct slots L  Number of coloured
* creatures in slots
_39699:
       li   ix,_44894                  ; LD IX,44894       ; Load IX with address of complex state data for first coloured creature (Level 3)
       li   hl,0                       ; LD HL,0           ; Load HL with zero
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as there are 3 creatures)
_39708:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of bottom of current creature is not 114...
       cb   a,@bytes+114               ; CP 114            ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       ab   one,@l                     ; INC L             ; Increase L (number of creatures in slots)
       movb @8(ix),a                   ; LD A,(IX+8)       ; If current entity class is not 13 (Red Coloured Creature, Level 3)...
       cb   a,@bytes+13                ; CP 13             ; ...
       jne  _39726                     ; JR NZ,39726       ; ...then skip ahead to #R39726
       movb @bytes+108,a               ; LD A,108          ; Load A with 108 (x-coordinate of left-most slot)
       jmp  _39736                     ; JR 39736          ; Skip ahead to #R39736
_39726:
       cb   a,@bytes+14                ; CP 14             ; If current entity class is not 14 (Yellow Coloured Creature, Level 3)...
       jne  _39734                     ; JR NZ,39734       ; ...then skip ahead to #R39734
       movb @bytes+115,a               ; LD A,115          ; Load A with 115 (x-coordinate of middle slot)
       jmp  _39736                     ; JR 39736          ; Skip ahead to #R39736
_39734:
       movb @bytes+122,a               ; LD A,122          ; Load A with 122 (x-coordinate of right-most slot)
_39736:
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of slot in A is not the same as x-coordinate of current creature's left...
       jne  _39742                     ; JR NZ,39742       ; ...then skip ahead to #R39742
       ab   one,h                      ; INC H             ; Increase H (number of creatures at correct x-coordinate for their respective coloured slots)
_39742:
       li   de,13                      ; LD DE,13          ; Advance IX to next entity...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 39708        ; Loop back to #R39708 for next creature
       jne  _39708                     ;                   
       movb h,a                        ; LD A,H            ; If H is not 3 (i.e. at least one creature not at correct x-coordinates)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @bytes+2,a                 ; LD A,2            ; Set All Coloured Creatures Home Flag
       mov  a,@_44894+9                ; LD (44903),A      ; ...
       .pop bc                         ; POP BC            ; Return to routine that called the calling routine...
       rt                              ; RET               ; ...

* Present Reward for Getting Coloured Creatures Home
* 
* Used by the routine at #R39601.
_39760:
       bl   @_36616                    ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       li   ix,_44972                  ; LD IX,44972       ; Load IX with address of complex state data for edible eyes (normally hidden off-screen)...
       bl   @_55516                    ; CALL 55516        ; ...and set their "Can Fall" Flag and set initial velocity factor to 2
       movb @bytes+4,a                 ; LD A,4            ; Set Coloured Creatures' Reward Given Flag...
       mov  a,@_44894+9                ; LD (44903),A      ; ...
       rt                              ; RET               ; Return

* Update State of Large Yellow Creature (Level 3)
* 
* Used by the routine at #R39137.
_39776:
       li   iy,_44868                  ; LD IY,44868       ; Load IY with address of complex state data for Large Yellow Creature (Level 3)
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       li   hl,_44868+9                ; LD HL,44877       ; Load HL with address of Large Yellow Creature's flags...
       movb *hl,a                      ; LD A,(HL)         ; ...and load flags into A
       cb   a,@bytes+2                 ; CP 2              ; If creature is in "Rising From Floor" mode...
       jeq  _39831                     ; JR Z,39831        ; ...then skip ahead to #R39831
       cb   a,@bytes+4                 ; CP 4              ; If creature is in "Hunting" mode...
       jeq  _39845                     ; JR Z,39845        ; ...then skip ahead to #R39845
       cb   a,@bytes+8                 ; CP 8              ; If creature is in "Attacking" mode...
       jeq  _39918                     ; JR Z,39918        ; ...then skip ahead to #R39918
       cb   a,@bytes+16                ; CP 16             ; If creature is in "Just Attacked" mode...
       jne  !                          ; JP Z,39934        ; ...then set creature's mode to "Returning Home", set Berk's "Has Been Killed" Flag and return
       b    @_39934                    ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is not 3 (Yellow Creature's Room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
* "Returning Home" mode
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of creature's left side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is the same as that of Berk's left side...
       jeq  _39828                     ; JR Z,39828        ; ...then skip ahead to #R39828
       ab   one,a                      ; INC A             ; If x-coordinate of creature's left side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not one character to the right of Berk's left side...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
_39828:
       equ  $
       movb @bytes+2,a                 ; LD A,2            ; Set creature's mode to "Rising from Floor"...
       movb a,*hl                      ; LD (HL),A         ; ...
* "Rising from Floor" mode
_39831:
       bl   @_39971                    ; CALL 39971        ; Move creature such that its left edge is up to two characters closer to Berk's
       bl   @_39961                    ; CALL 39961        ; Move creature up by two characters
       movb @4(iy),a                   ; LD A,(IY+4)       ; If y-coordinate of creature's top...
       cb   a,@bytes+108               ; CP 108            ; ...is 108 or greater...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       movb @bytes+4,*hl               ; LD (HL),4         ; Set creature's mode to "Hunting"
* "Hunting" mode
_39845:
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is not 3 (Yellow Creature's Room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
       movb @_34220,a                  ; LD A,(34220)      ; If Berk's current power is invisibility (Level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jeq  _39909                     ; JR Z,39909        ; ...then skip ahead to #R39909 ("confused" mode)
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of Berk's top...
       cb   a,@bytes+103               ; CP 103            ; ...is less than 103...
       jl   _39909                     ; JR C,39909        ; ...then skip ahead to #R39909 ("confused" mode)
       bl   @_39971                    ; CALL 39971        ; Move creature such that its left edge is up to two characters closer to Berk's
       movb @4(iy),a                   ; LD A,(IY+4)       ; If creature's top...
       a    @bytes+4,a                 ; ADD A,4           ; ...is four characters above Berk's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jeq  _39890                     ; JR Z,39890        ; ...then skip ahead to #R39890 (set "Attacking" mode)
       jnc  _39961                     ; JR NC,39961       ; TODO: check code. If creature's top is less than 4 characters above Berk's top then move creature up by two
                                                           ; characters and return
       ab   one,a                      ; INC A             ; If creature's top is five characters above Berk's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jeq  _39890                     ; JR Z,39890        ; ...then skip ahead to #R39890 (set "Attacking" mode)
       joc  _39951                     ; JR C,39951        ; TODO: check code. If creature's top is more than five characters above Berk's top then move creature down two
                                                           ; characters and return
_39890:
       movb @bytes+8,*hl               ; LD (HL),8         ; Set creature's mode to "Attacking"
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set creature's depth to 1
       socb @bits+5,@9(ix)             ; SET 5,(IX+9)      ; Set Berk's "Do Not Update State" Flag
       li   bc,_40442                  ; LD BC,40442       ; Set graphic layout data address for creature to #R40442 (Large Yellow Creature with mouth
                                                           ; open)...
       bl   @_39944                    ; CALL 39944        ; ...
       b    @_36296                    ; JP 36296          ; Make Berk drop the entity he is holding, load IY with its complex state data address and
                                                           ; return
* "Confused" mode
_39909:
       li   bc,_40485                  ; LD BC,40485       ; Set graphic layout data address for creature to #R40485 (Large Yellow Creature, animated,
                                                           ; confused)...
       bl   @_39944                    ; CALL 39944        ; ...
       b    @_40008                    ; JP 40008          ; Move creature one step closer to x (left) = 113, y (top) > 111 if not already there, and
                                                           ; return
* "Attacking" mode
_39918:
       bl   @_39951                    ; CALL 39951        ; Move creature down two characters
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Berk's depth to zero
       movb @bytes+16,*hl              ; LD (HL),16        ; Set creature's mode to "Just Attacked"
       li   bc,_40451                  ; LD BC,40451       ; Set graphic layout data address for creature to #R40451 (Large Yellow Creature with mouth
                                                           ; closed)...
       b    @_39944                    ; JP 39944          ; ...and return

* Unused routine
       rt                              ; RET               ; Return

* Set Large Yellow Creature's Mode to "Returning Home", and Set Berk's "Has Been Killed" Flag
* 
* Used by the routine at #R39776.
_39934:
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       szcb @bits+5,@9(ix)             ; RES 5,(IX+9)      ; Reset Berk's "Do Not Update State" Flag
       movb @bytes+0,*hl               ; LD (HL),0         ; Set creature's mode to "Returning Home"
       rt                              ; RET               ; Return

* Set Graphic Layout Data Address for Entity at IY to BC
* 
* Used by the routine at #R39776. Input:  BC  Graphic layout data address IY  Address of complex state data for an
* entity
_39944:
       movb @c,@2(iy)                  ; LD (IY+2),C       ; Set graphic layout data address for entity to address in BC...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       rt                              ; RET               ; Return

* Move Entity at IY Down Two Characters
* 
* Used by the routine at #R39776. Input:  IY  Address of complex state data for an entity
_39951:
       bl   @_39954                    ; CALL 39954        ; Move entity at IY down one character
* This entry point is used by the routine at #R40008.
_39954:
       ab   one,@4(iy)                 ; INC (IY+4)        ; Increase y-coordinates of entity's top and bottom edges...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       rt                              ; RET               ; Return

* Move Entity at IY Up Two Characters
* 
* Used by the routine at #R39776. Input:  IY  Address of complex state data for an entity
_39961:
       bl   @_39964                    ; CALL 39964        ; Move entity at IY up one character
_39964:
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Decrease y-coordinates of entity's top and bottom edges...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       rt                              ; RET               ; Return

* Move Entity IY Such that its Left Edge is Up to Two Characters Closer to Entity IX's
* 
* Used by the routine at #R39776. Input:  IX  Address of complex state data for Entity A IY  Address of complex
* state data for Entity B
_39971:
       bl   @_39975                    ; CALL 39975        ; Move Entity B one character closer (horizontally) to Entity A...
       jne  !                          ; RET Z             ; ...and if left edges now both at same x-coordinate then return
       rt                              ;                   
!
* If entities' left edges are not at the same x-coordinate, then proceed into the code block below and move entity B
* by one additional character.
_39975:
       equ  $
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinates of both entities' left edges are the same...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       joc  _39991                     ; JR C,39991        ; TODO: check code. If Entity B's left edge is to the right of Entity A's then move Entity B left by one
                                                           ; character
       ab   one,@5(iy)                 ; INC (IY+5)        ; Move Entity B right by one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       rt                              ; RET               ; Return
_39991:
       sb   one,@5(iy)                 ; DEC (IY+5)        ; Move Entity B left by one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       rt                              ; RET               ; Return

* Set Large Yellow Creature's Mode to "Returning Home", Move One Step Closer to Home and Return
* 
* Used by the routine at #R39776. Input:  HL  Address of creature's flags IY  Address of complex state data for
* creature
_39998:
       movb @bytes+0,*hl               ; LD (HL),0         ; Set creature's mode to "Returning Home"
_40000:
       movb @bytes+2,@1(iy)            ; LD (IY+1),2       ; Set creature's depth to 2
       movb @bytes+122,a               ; LD A,122          ; Move creature one step closer to x (Left) = 113, y (Top) > 122...
       jmp  _40010                     ; JR 40010          ; ...and return

* Move Entity at IY One Step Closer to Home Position
* 
* This routine moves an entity (whose complex state data is pointed to by IY) one character left or right, if such a
* move would take the x-coordinate of that entity's left edge closer to a value of 113. The entity will also be
* moved down by one character if the y-coordinate of its top edge is less than or equal to 111 (or the input value
* in A if we are entering this routine via #R40010). Input:  A  (Entry at #R40010 only) Minimum allowed y-coordinate
* for entity's top edge IY  Address of complex state data for an entity
_40008:
       movb @bytes+111,a               ; LD A,111          ; Load A with 111 (minimum allowed y-coordinate)
* This entry point is used by the routine at #R39998.
_40010:
       cb   a,@4(iy)                   ; CP (IY+4)         ; If y-coordinate of entity's top edge is greater than value in A...
       jl   _40018                     ; JR C,40018        ; ...then skip ahead to #R40018
       bl   @_39954                    ; CALL 39954        ; Move entity at IY down one character
_40018:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of entity's left edge...
       cb   a,@bytes+113               ; CP 113            ; ...is 113...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       joc  _40033                     ; JR C,40033        ; TODO: check code. ...else if greater than 113 then skip ahead to #R40033
       sb   one,@5(iy)                 ; DEC (IY+5)        ; Move entity left one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       rt                              ; RET               ; Return
_40033:
       ab   one,@5(iy)                 ; INC (IY+5)        ; Move entity right one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       rt                              ; RET               ; Return

* Graphic Layout Data Architecture (Level 3) Vertical wall
_40040:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 238,3                                                    ; Set Repeat Counter A to 3
_40044:
       byte 251,_40052%256,_40052/256                                ; Process graphic layout data at #R40052 and upon returning, move cursor to base coordinates
       byte 254,8,0                                                  ; Change cursor's x- and y-coordinates by 0 and +8 characters respectively and store as new
                                                                     ; base coordinates
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R40044 if not zero
       byte 255                                                      ; End Marker
* Vertical wall section
_40052:
       byte 242,4                                                    ; Set current attribute to 4
       byte 17,160
       byte 18,160
       byte 19,160
       byte 20,160
       byte 9,160
       byte 10,160
       byte 11,160
       byte 12,160
       byte 18,160
       byte 255                                                      ; End Marker
* Door Archway
_40073:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 251,_40052%256,_40052/256                                ; Process graphic layout data at #R40052 and upon returning, move cursor to base coordinates
       byte 250,1,9                                                  ; Change cursor's x- and y-coordinates by +9 and +1 characters respectively
       byte 251,_40052%256,_40052/256                                ; Process graphic layout data at #R40052 and upon returning, move cursor to base coordinates
       byte 242,4                                                    ; Set current attribute to 4
       byte 25,33
       byte 28,33
       byte 27,33
       byte 29,33
       byte 28,33
       byte 29,33
       byte 27,33
       byte 28,33
       byte 27,33
       byte 26,33
       byte 255                                                      ; End Marker
* Platform
_40110:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 242,4                                                    ; Set current attribute to 4
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 31,33
       byte 29,33
       byte 28,33
       byte 27,33
       byte 30,28
       byte 31,33
       byte 29,33
       byte 28,33
       byte 27,33
       byte 30,33
       byte 255                                                      ; End Marker
* Red Coloured Creature's Slot (see trivia)
_40138:
       byte 242,2                                                    ; Set current attribute to 2 (red)
       byte 248,_40150%256,_40150/256                                ; Jump to #R40150 (draw slot)
* Yellow Coloured Creature's Slot (see trivia)
_40143:
       byte 242,6                                                    ; Set current attribute to 6 (yellow)
       byte 248,_40150%256,_40150/256                                ; Jump to #R40150 (draw slot)
* White Coloured Creature's Slot (see trivia)
_40148:
       byte 242,7                                                    ; Set current attribute to 7 (white)
_40150:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 250,251,0                                                ; Change cursor's x- and y-coordinates by 0 and -5 characters respectively
       byte 25,33
       byte 27,33
       byte 28,33
       byte 29,33
       byte 26,28
       byte 9,36
       byte 10,28
       byte 10,36
       byte 9,28
       byte 11,36
       byte 11,28
       byte 9,36
       byte 10,28
       byte 31,33
       byte 28,33
       byte 27,33
       byte 29,33
       byte 30,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Edible Eyes (Level 3)
_40192:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 247,7                                                    ; Jump to one of the 7 addresses (see bugs) in the following list, chosen at random:
       byte _40212%256,_40212/256                                    ; #R40212 (eyes, closed)
       byte _40212%256,_40212/256                                    ; #R40212 (eyes, closed)
       byte _40212%256,_40212/256                                    ; #R40212 (eyes, closed)
       byte _40219%256,_40219/256                                    ; #R40219 (eyes, looking ahead)
       byte _40226%256,_40226/256                                    ; #R40226 (eyes, looking up)
       byte _40233%256,_40233/256                                    ; #R40233 (eyes, looking down)
       byte _40240%256,_40240/256                                    ; #R40240 (eyes, looking right)
       byte _40247%256,_40247/256                                    ; #R40247 (eyes, looking left)
* Closed
_40212:
       byte 28,3,33
       byte 28,131,33
       byte 255                                                      ; End Marker
* Looking Ahead
_40219:
       byte 29,6,33
       byte 32,134,33                                                ; (see bugs)
       byte 255                                                      ; End Marker
* Looking Up
_40226:
       byte 30,6,33
       byte 30,134,33
       byte 255                                                      ; End Marker
* Looking Down
_40233:
       byte 31,6,33
       byte 31,134,33
       byte 255                                                      ; End Marker
* Looking Right
_40240:
       byte 32,6,33
       byte 33,134,33
       byte 255                                                      ; End Marker
* Looking Left
_40247:
       byte 33,6,33
       byte 32,134,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Coloured Creatures (Level 3) Red
_40254:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 246,4,5,3,66,66,1                                        ; Decrease timer value (initially 4) and if now zero then reset to 5 and load one of
                                                                     ; the 3 following values at random into the Attribute field of the following
                                                                     ; instruction
       byte 51,66,31
       byte 248,_40296%256,_40296/256                                ; Jump to #R40296 (draw creature)
* Yellow
_40269:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 246,4,5,3,70,70,1                                        ; Decrease timer value (initially 4) and if now zero then reset to 5 and load one of
                                                                     ; the 3 following values at random into the Attribute field of the following
                                                                     ; instruction
       byte 51,70,31
       byte 248,_40296%256,_40296/256                                ; Jump to #R40296 (draw creature)
* White
_40284:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 246,4,5,3,71,71,1                                        ; Decrease timer value (initially 4) and if now zero then reset to 5 and load one of
                                                                     ; the 3 following values at random into the Attribute field of the following
                                                                     ; instruction
       byte 51,71,31
_40296:
       byte 52,6,33
       byte 53,69,33
       byte 52,134,31
       byte 236,2,54,70                                              ; Modify following instruction to display graphic of random index, chosen from 54 and
                                                                     ; 70
       byte 54,69,32
       byte 236,2,55,71                                              ; Modify following instruction to display graphic of random index, chosen from 55 and
                                                                     ; 71
       byte 55,69,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Clawed Foot (Level 3) Reaching, Open
_40320:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 251,_40404%256,_40404/256                                ; Process graphic layout data at #R40404 and upon returning, move cursor to base coordinates
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 36,6,33
       byte 37,70,34
       byte 37,198,33
       byte 36,134,28
       byte 39,70,33
       byte 40,70,33
       byte 41,6,33
       byte 40,198,33
       byte 39,134,28
       byte 42,6,33
       byte 43,6,34
       byte 43,134,33
       byte 42,134,33
       byte 255                                                      ; End Marker
* Reaching, Closed
_40368:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 251,_40404%256,_40404/256                                ; Process graphic layout data at #R40404 and upon returning, move cursor to base coordinates
       byte 44,6,34
       byte 44,134,29
       byte 45,6,33
       byte 46,70,33
       byte 47,6,33
       byte 46,198,33
       byte 45,134,29
       byte 48,70,33
       byte 49,70,33
       byte 48,198,33
       byte 255                                                      ; End Marker
* Leg
_40404:
       byte 250,241,1                                                ; Change cursor's x- and y-coordinates by 1 and -15 characters respectively
       byte 242,70                                                   ; Set current attribute to 70
       byte 50,32
       byte 32,32
       byte 33,32
       byte 34,32
       byte 32,32
       byte 33,32
       byte 34,32
       byte 35,32
       byte 50,32
       byte 33,32
       byte 34,32
       byte 32,32
       byte 33,32
       byte 34,32
       byte 32,32
       byte 38,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Large Yellow Creature (Level 3) Mouth Open
_40442:
       byte 251,_40589%256,_40589/256                                ; Process graphic layout data at #R40589 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_40858%256,_40858/256                                ; Process graphic layout data at #R40858 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_40457%256,_40457/256                                ; Jump to #R40457
* Mouth Closed
_40451:
       byte 251,_40589%256,_40589/256                                ; Process graphic layout data at #R40589 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_40975%256,_40975/256                                ; Process graphic layout data at #R40975 and upon returning, move cursor to base
                                                                     ; coordinates
_40457:
       byte 250,2,255                                                ; Change cursor's x- and y-coordinates by -1 and +2 characters respectively
       byte 3,79,33
       byte 3,207,37
       byte 3,79,33
       byte 3,207,25
       byte 4,79,33
       byte 2,207,37
       byte 2,79,33
       byte 4,207,33
       byte 255                                                      ; End Marker
* Animated, confused
_40485:
       byte 251,_40589%256,_40589/256                                ; Process graphic layout data at #R40589 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_40847%256,_40847/256                                ; Process graphic layout data at #R40847 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,2,255                                                ; Change cursor's x- and y-coordinates by -1 and +2 characters respectively
       byte 249,4,1                                                  ; If state n (initially 1) has remaining time of zero then reset its time to
                                                                     ; maximum and randomly select a new state, n, from the 4 in the following list.
                                                                     ; Jump to the address specified in the current state and decrease its remaining
                                                                     ; time:
       byte 3,3,_40513%256,_40513/256                                ; #R40513 (Eyes looking up-left, for 3 ticks)
       byte 3,3,_40532%256,_40532/256                                ; #R40532 (Eyes looking up-right, for 3 ticks)
       byte 6,6,_40551%256,_40551/256                                ; #R40551 (Eyes looking down-left, for 6 ticks)
       byte 6,6,_40570%256,_40570/256                                ; #R40570 (Eyes looking down-right, for 6 ticks)
* Eyes Looking Up-Left
_40513:
       byte 238,2                                                    ; Set Repeat Counter A to 2
_40515:
       byte 1,79,33,3,207,31
       byte 4,79,33,4,207,33
       byte 250,255,4                                                ; Change cursor's x- and y-coordinates by +4 and -1 characters respectively
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R40515 if not zero
       byte 255                                                      ; End Marker
* Eyes Looking Up-Right
_40532:
       byte 238,2                                                    ; Set Repeat Counter A to 2
_40534:
       byte 3,79,33,1,207,31
       byte 4,79,33,4,207,33
       byte 250,255,4                                                ; Change cursor's x- and y-coordinates by +4 and -1 characters respectively
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R40534 if not zero
       byte 255                                                      ; End Marker
* Eyes Looking Down-Left
_40551:
       byte 238,2                                                    ; Set Repeat Counter A to 2
_40553:
       byte 3,79,33,3,207,31
       byte 2,79,33,4,207,33
       byte 250,255,4                                                ; Change cursor's x- and y-coordinates by +4 and -1 characters respectively
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R40553 if not zero
       byte 255                                                      ; End Marker
* Eyes Looking Down-Right
_40570:
       byte 238,2                                                    ; Set Repeat Counter A to 2
_40572:
       byte 3,79,33,3,207,31
       byte 4,79,33,2,207,33
       byte 250,255,4                                                ; Change cursor's x- and y-coordinates by +4 and -1 characters respectively
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R40572 if not zero
       byte 255                                                      ; End Marker
* Top Part of Face
_40589:
       byte 244,11                                                   ; Set current graphic set to 11
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 5,6,33,5,134,33
       byte 7,6,33,8,6,33
       byte 8,134,33,7,134,33
       byte 5,6,33,5,134,24
       byte 9,70,33,10,49,33
       byte 10,177,33,16,198,33
       byte 11,70,33,11,198,33
       byte 16,70,33,10,49,33
       byte 10,177,33,9,198,22
       byte 12,70,33,13,49,35
       byte 14,49,33,15,48,161
       byte 15,176,33,14,177,35
       byte 13,177,33,12,198,20
       byte 16,70,33,17,49,33
       byte 18,49,35,19,49,33
       byte 20,48,161,20,176,161
       byte 19,177,35,18,177,33
       byte 17,177,33,16,198,18
       byte 21,6,33,22,49,33
       byte 23,49,33,24,49,33
       byte 25,49,33,26,49,33
       byte 27,48,161,28,48,161
       byte 28,176,161,27,176,161
       byte 26,177,33,25,177,33
       byte 24,177,33,23,177,33
       byte 22,177,33,21,134,17
       byte 29,6,33,30,49,33
       byte 31,49,33,32,49,33
       byte 33,49,33,34,55,33
       byte 35,70,33,36,55,33
       byte 36,183,33,35,198,33
       byte 34,183,33,33,177,33
       byte 32,177,33,31,177,33
       byte 30,177,33,29,134,18
       byte 37,70,33,38,49,33
       byte 39,49,33,40,6,33
       byte 41,71,34,42,71,33
       byte 42,199,34,41,199,33
       byte 40,134,33,39,177,33
       byte 38,177,33,37,198,20
       byte 43,70,43,43,198,20
       byte 44,70,45,44,198,33
       byte 255                                                      ; End Marker
* Jaw (Animated)
_40847:
       byte 249,2,1                                                  ; If state n (initially 1) has remaining time of zero then reset its time to
                                                                     ; maximum and randomly select a new state, n, from the 2 in the following list.
                                                                     ; Jump to the address specified in the current state and decrease its remaining
                                                                     ; time:
       byte 3,3,_40858%256,_40858/256                                ; #R40858 (Jaw open, for 3 ticks)
       byte 3,3,_40975%256,_40975/256                                ; #R40975 (Jaw closed, for 3 ticks)
* Jaw (Open)
_40858:
       byte 250,7,254                                                ; Change cursor's x- and y-coordinates by -2 and +7 characters respectively
       byte 45,6,41,45,134,22
       byte 0,54,33,46,6,41
       byte 46,134,33,0,54,20
       byte 47,70,33,48,70,33
       byte 49,6,41,49,134,33
       byte 48,198,33,47,198,19
       byte 50,70,33,51,70,33
       byte 52,70,41,52,198,33
       byte 51,198,33,50,198,19
       byte 53,6,33,54,70,33
       byte 55,70,33,56,6,39
       byte 56,134,33,55,198,33
       byte 54,198,33,53,134,21
       byte 58,70,33,0,54,33
       byte 59,70,37,59,198,33
       byte 0,54,33,58,198,24
       byte 62,70,33,63,70,37
       byte 63,198,33,62,198,33
       byte 250,254,250                                              ; Change cursor's x- and y-coordinates by -5 and -2 characters respectively
       byte 248,_41065%256,_41065/256                                ; Jump to #R41065
* Jaw (Closed)
_40975:
       byte 250,7,254                                                ; Change cursor's x- and y-coordinates by -2 and +7 characters respectively
       byte 6,70,33,64,70,33
       byte 64,198,37,64,70,33
       byte 64,198,33,6,198,22
       byte 65,70,33,0,54,33
       byte 0,54,33,66,70,37
       byte 66,198,33,0,54,33
       byte 0,54,33,65,198,20
       byte 67,70,33,68,70,33
       byte 69,6,33,70,6,39
       byte 70,134,33,69,134,33
       byte 68,198,33,67,198,19
       byte 71,70,33,72,70,33
       byte 73,6,41,73,134,33
       byte 72,198,33,71,198,33
       byte 250,252,247                                              ; Change cursor's x- and y-coordinates by -9 and -4 characters respectively
_41065:
       byte 57,71,35,57,199,29
       byte 60,55,33,61,70,33
       byte 61,198,33,60,55,29
       byte 238,4                                                    ; Set Repeat Counter A to 4
_41085:
       byte 0,54,33
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R41085 if not zero
       byte 255                                                      ; End Marker

* Graphic Layout Data Hatch (Level 3) Closed
_41090:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 238,8                                                    ; Set Repeat Counter A to 8
_41094:
       byte 72,5,33
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R41094 if not zero
       byte 255                                                      ; End Marker
* Fully Open With Small Bat (Animated)
_41099:
       byte 250,251,4                                                ; Change cursor's x- and y-coordinates by +4 and -4 characters respectively
       byte 251,_41141%256,_41141/256                                ; Process graphic layout data at #R41141 and upon returning, move cursor to base coordinates
       byte 250,249,0                                                ; Change cursor's x- and y-coordinates by 0 and -7 characters respectively
       byte 238,8                                                    ; Set Repeat Counter A to 8
_41110:
       byte 73,5,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R41110 if not zero
       byte 255                                                      ; End Marker
* Half Open With Small Bat (Animated)
_41115:
       byte 250,254,4                                                ; Change cursor's x- and y-coordinates by +4 and -2 characters respectively
       byte 251,_41141%256,_41141/256                                ; Process graphic layout data at #R41141 and upon returning, move cursor to base coordinates
       byte 242,5                                                    ; Set current attribute to 5
       byte 250,250,5                                                ; Change cursor's x- and y-coordinates by +5 and -5 characters respectively
       byte 74,31
       byte 238,5                                                    ; Set Repeat Counter A to 5
_41130:
       byte 75,33,76,30
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R41130 if not zero
       byte 250,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively
       byte 73,33
       byte 255                                                      ; End Marker
* Small Bat (Animated)
_41141:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 243,0,4                                                  ; Increase current state value n (initially 0), up to maximum of 4, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _41154%256,_41154/256                                    ; #R41154 (Small Bat, wings up)
       byte _41158%256,_41158/256                                    ; #R41158 (Small Bat, wings level)
       byte _41171%256,_41171/256                                    ; #R41171 (Small Bat, wings down)
       byte _41158%256,_41158/256                                    ; #R41158 (Small Bat, wings level)
* Small Bat (Wings Up)
_41154:
       byte 77,7,33
       byte 255                                                      ; End Marker
* Small Bat (Wings Level)
_41158:
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 79,7,33
       byte 80,7,33
       byte 79,135,33
       byte 255                                                      ; End Marker
* Small Bat (Wings Down)
_41171:
       byte 78,7,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Weight (Level 3)
_41175:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 81,66,31,82,66,33
       byte 0,18,33,82,194,30
       byte 83,66,33,0,18,33
       byte 83,194,30,84,66,33
       byte 0,18,33,84,194,33
       byte 255                                                      ; End Marker

* Update States of All Level 4 Entities
* 
* Used by the routine at #R34438.
_41211:
       bl   @_42266                    ; CALL 42266        ; Update state of Flying Skeleton Creature
       bl   @_42381                    ; CALL 42381        ; Update state of Snake
       bl   @_42064                    ; CALL 42064        ; Update states of drips
       bl   @_41767                    ; CALL 41767        ; Update state of Cannon and Projectile
       bl   @_41633                    ; CALL 41633        ; Update state of Ghost
       bl   @_41381                    ; CALL 41381        ; Update state of Skeleton (Level 4) and store current position in script data
       rt                              ; RET               ; Return

* Current Position in Skeleton's Script Data
_41230:
       data _41232                                                   ; (#R41232, Skeleton Idling)

* Script Data Skeleton (Level 4) Idling
_41232:
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 63,0                                                     ; Have Skeleton advance or retreat based upon positions of Berk and Fake Boni
       byte 1,0,_41232%256,_41232/256                                ; Jump to #R41232 (Skeleton Idling)

* Unused
* 
* This block contains unused script data: Skeleton (level 4) threatening. Input:  Facts#unusedskeletonscript(See
* trivia).
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte _42937%256,_42937/256                                    ; #R42937 (Skeleton, Stepping Forward, Frame 1, Full, Animated)
       byte _42937%256,_42937/256                                    ; #R42937 (Skeleton, Stepping Forward, Frame 1, Full, Animated)
       byte 2,0                                                      ; Move Skeleton left two characters...
       byte 2,0                                                      ; ...
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte 3,0                                                      ; Move Skeleton right two characters...
       byte 3,0                                                      ; ...
       byte 1,0,_41232%256,_41232/256                                ; Jump to #R41232 (Skeleton Idling)

* Script Data Skeleton (Level 4) Stepping Forward (Left)
_41280:
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte _42937%256,_42937/256                                    ; #R42937 (Skeleton, Stepping Forward, Frame 1, Full, Animated)
       byte 2,0                                                      ; Move Skeleton left two characters...
       byte 2,0                                                      ; ...
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte 1,0,_41232%256,_41232/256                                ; Jump to #R41232 (Skeleton Idling)

* Script Data Skeleton (Level 4) Stepping Back (Right)
_41318:
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte _42975%256,_42975/256                                    ; #R42975 (Skeleton, Stepping Forward, Frame 2, Full, Animated)
       byte 3,0                                                      ; Move Skeleton right two characters...
       byte 3,0                                                      ; ...
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 64,0                                                     ; Set number of iterations in following loop script instruction to random number, 1-10
       byte 27,0,1,0                                                 ; Start loop (3) for random number (1-10) of iterations
       byte _42901%256,_42901/256                                    ; #R42901 (Skeleton, Standing, Full, Animated)
       byte 28,0                                                     ; End loop (3)
       byte 1,0,_41232%256,_41232/256                                ; Jump to #R41232 (Skeleton Idling)

* Reset Skeleton to Initial State
* 
* Used by the routine at #R34751.
_41354:
       li   hl,_41232                  ; LD HL,41232       ; Set current position in Skeleton's script data...
       mov  hl,@_41230                 ; LD (41230),HL     ; ...to #R41232 (Skeleton Idling)
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
_41366:
       movb *ix,@l                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       movb @bytes+7,*hl               ; LD (HL),7         ; Set the attribute value to 7 (white)
       inc  ix                         ; INC IX            ; Advance IX to next address...
       inc  ix                         ; INC IX            ; ...
       sb   one,b                      ; DJNZ 41366        ; Decrease remaining number of blocks to modify and loop back to #R41366 if not zero
       jne  _41366                     ;                   
       rt                              ; RET               ; Return

* Update State of Skeleton (Level 4) and Store Current Position in Script Data
* 
* Used by the routine at #R41211.
_41381:
       li   ix,_45404                  ; LD IX,45404       ; Load IX with address of complex state data for Skeleton (Level 4)
       mov  @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Skeleton's Removed From Game Flag is set...
       andi tmp0,4                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Skeleton's Is Dying Flag is set...
       andi tmp0,2                     ;                   
       jne  _41424                     ; JR NZ,41424       ; ...then update state of Skeleton (dying) and return
       mov  @_41230,hl                 ; LD HL,(41230)     ; Load current position in Skeleton's script data from #R41230 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_41498                    ; CALL 41498        ; Kill Berk if he collides with Skeleton
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_41230                 ; LD (41230),HL     ; ...at #R41230 as current position in Skeleton's script data
       rt                              ; RET               ; Return

* Table of Addresses of Attribute Data in Skeleton's Graphic Layout Data Blocks
* 
* Each of the addresses in this table is of the "operand" of a "set attribute" instruction (i.e. 242) in the
* Skeleton's graphic layout data blocks. These are initially 7 (i.e. white). When the skeleton is killed, the
* routine at #R41424 (instructions starting at #R41473) decreases this attribute by one per game cycle. When the
* attribute values reach 1 (blue), the skeleton is removed from the game and replaced by Boni.
_41412:
       data _42910+1                                                 ; (#R42910) Standing, Full, Animated
       data _42946+1                                                 ; (#R42946) Stepping Forward, Frame 1, Full, Animated
       data _42987+1                                                 ; (#R42987) Stepping Forward, Frame 2, Full, Animated
       data _43022+1                                                 ; (#R43022) Head, Animated
       data _43061+1                                                 ; (#R43061) Torso and Spear, Extended
       data _43095+1                                                 ; (#R43095) Torso and Spear, Retracted

* Update State of Skeleton (Dying)
* 
* Used by the routine at #R41381. Input:  IX  Address of complex state data for Skeleton (Level 4)
_41424:
       movb @_42910+1,a                ; LD A,(42911)      ; If current attribute in Skeleton's graphic layout data is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _41473                     ; JR NZ,41473       ; ...then skip ahead to #R41473
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Skeleton's room to 0
       li   iy,_45417                  ; LD IY,45417       ; Load IY with address of complex state data for Boni (Level 4)
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set y-coordinate of Boni's top edge...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...to same as that of skeleton
       a    @bytes+3,a                 ; ADD A,3           ; Set y-coordinate of Boni's bottom edge...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...to three characters below this
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set x-coordinate of Boni's left edge...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...to same as that of skeleton
       ab   one,a                      ; INC A             ; Set x-coordinate of Boni's right edge...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...to one to the right of this
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set Boni's Can Fall Flag
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Skeleton's Removed From Game Flag
       rt                              ; RET               ; Return
* Current attribute in Skeleton's graphic layout data is not 1
_41473:
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
_41479:
       movb *ix,@l                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       sb   one,*hl                    ; DEC (HL)          ; Decrease the attribute value
       inc  ix                         ; INC IX            ; Advance IX to next address...
       inc  ix                         ; INC IX            ; ...
       sb   one,b                      ; DJNZ 41479        ; Decrease remaining number of blocks to modify and loop back to #R41479 if not zero
       jne  _41479                     ;                   
       movb @bytes+11,a                ; LD A,11           ; Set sound 11 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
       rt                              ; RET               ; Return

* Kill Berk if He Collides with Skeleton
* 
* See trivia Input:  IX  Address of complex state data for Skeleton (Level 4) (#R45404)
_41498:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _41513                     ; JR C,41513        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R41513
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _41513                     ; JR NZ,41513       ; ...then skip ahead to #R41513
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
* The instructions below do a "manual" check for a collision between the Skeleton and Berk. See trivia
_41513:
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is not 3 (Skeleton's room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge...
       sb   @bytes+5,a                 ; SUB 5             ; ...is at least five characters to the right of Berk's right edge...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...
       jl   !                          ; JP NC,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of Berk's bottom edge...
       cb   a,@bytes+116               ; CP 116            ; ...is less than 116...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (63) Have Skeleton Advance or Retreat Based Upon Positions of Berk and Fake Boni
* 
* The skeleton will step forward once, and then step back, if Berk is close enough and Fake Boni is in a room to the
* right. If Fake Boni is in the Skeleton's room, or a room to the left of this, then the Skeleton will step forward
* repeatedly while Berk is close enough and will only back off when Berk moves out of range. The range is nine, so
* if the distance between Berk's right edge and the Skeleton's left edge is less than nine then the Skeleton will
* advance. A distance of nine or more will see the Skeleton retreat. Note that the calculated range is based upon
* the Skeleton's state data at #R45404, in which the x-coordinates of his left and right edges do not match his
* apparent position or width graphically. Input:  IX  Address of complex state data for an entity Output: HL Address
* of next script instruction to execute
_41550:
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is 3 (Skeleton's room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  _41580                     ; JR Z,41580        ; ...then jump to #R41580
* Berk is not in Skeleton's room, or Fake Boni is in a room right of the Skeleton's room
_41561:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge is at least 128...
       cb   a,@bytes+128               ; CP 128            ; ...
       jhe  _41574                     ; JR NC,41574       ; ...then skip ahead to #R41574
       li   hl,_41318                  ; LD HL,41318       ; Point HL at script data for Skeleton stepping back (right)...
       b    @_48098                    ; JP 48098          ; ...and execute
_41574:
       li   hl,_41232                  ; LD HL,41232       ; Point HL at script data for Skeleton Idling...
       b    @_48098                    ; JP 48098          ; ...and execute
* Berk is in Skeleton's room
_41580:
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Skeleton's Must Process Current Script Data Flag is reset...
       andi tmp0,1                     ;                   
       jeq  _41597                     ; JR Z,41597        ; ...then skip ahead to #R41597
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Skeleton's Must Process Current Script Data Flag
       movb @_45430,a                  ; LD A,(45430)      ; If Fake Boni is in a room with index of 4 or more (room above Pit, or Pit)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
_41597:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge...
       sb   @bytes+9,a                 ; SUB 9             ; ...is at least nine characters to the right of Berk's right edge...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Skeleton's Must Process Current Script Data Flag
       li   hl,_41280                  ; LD HL,41280       ; Point HL at script data for Skeleton stepping forward (left)...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (64) Set Random (1 to 10) Number of Iterations in Following Loop Script Instruction
_41617:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 1-10...
       bl   @_54222                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       .push hl                        ; PUSH HL           ; Store HL (current position in script data)
       li   bc,4                       ; LD BC,4           ; Advance HL by four bytes...
       a    bc,hl                      ; ADD HL,BC         ; ...to number of iterations in next (loop) instruction...
       movb a,*hl                      ; LD (HL),A         ; ...and set number of iterations to number generated
       .pop hl                         ; POP HL            ; Restore HL (current position in script data)
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Update State of Ghost
* 
* Used by the routine at #R41211.
_41633:
       li   ix,_45794                  ; LD IX,45794       ; Load IX with address of complex state data for Ghost (Level 4)
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _41653                     ; JR NZ,41653       ; ...then skip ahead to #R41653
* If collision was with Berk, then IY will point to Berk's complex state data
       mov  @9(iy),tmp0                ; BIT 6,(IY+9)      ; If Berk is not flying...
       andi tmp0,64                    ;                   
       jeq  _41653                     ; JR Z,41653        ; ...then skip ahead to #R41653
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
_41653:
       movb @_34218,a                  ; LD A,(34218)      ; Load E with current character's current room index...
       movb a,@e                       ; LD E,A            ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with Ghost's current room index
       movb @4(ix),@c                  ; LD C,(IX+4)       ; Load C with y-coordinate of Ghost's top edge
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Ghost's bottom edge
       mov  @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Ghost's Moving Upwards Flag is set...
       andi tmp0,1                     ;                   
       jne  _41716                     ; JR NZ,41716       ; ...then skip ahead to #R41716
       cb   a,@bytes+4                 ; CP 4              ; If Ghost's current room is 4 (room above pit)...
       jeq  _41687                     ; JR Z,41687        ; ...then skip ahead to #R41687
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+119               ; CP 119            ; ...is not 119...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Ghost's Moving Upwards Flag
       rt                              ; RET               ; Return
* Ghost's current room is 4 (room above pit)
_41687:
       cb   a,@e                       ; CP E              ; If current character is in the same room as the Ghost...
       jeq  _41703                     ; JR Z,41703        ; ...then skip ahead to #R41703
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+119               ; CP 119            ; ...is not 119...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       ab   one,*ix                    ; INC (IX+0)        ; Increase index of Ghost's current room (to 5, pit)
       movb @bytes+94,a                ; LD A,94           ; Position Ghost such that the y-coordinate of its top edge is 115...
       jmp  _41758                     ; JR 41758          ; ...and return
* Current character and Ghost in same room (room above pit)
_41703:
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+121               ; CP 121            ; ...is not 121...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       ab   one,*ix                    ; INC (IX+0)        ; Increase index of Ghost's current room (to 5, pit)
       movb @bytes+100,a               ; LD A,100          ; Position Ghost such that the y-coordinate of its top edge is 100...
       jmp  _41758                     ; JR 41758          ; ...and return
* Ghost's Moving Upwards Flag is set
_41716:
       cb   a,@bytes+5                 ; CP 5              ; If Ghost's current room is 5 (pit)...
       jeq  _41731                     ; JR Z,41731        ; ...then skip ahead to #R41731
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+101               ; CP 101            ; ...is not 101...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Ghost's Moving Upwards Flag (i.e. moving downwards)
       rt                              ; RET               ; Return
* Ghost's current room is 5 (pit)
_41731:
       cb   a,@e                       ; CP E              ; If current character is in the same room as the Ghost...
       jeq  _41747                     ; JR Z,41747        ; ...then skip ahead to #R41747
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+101               ; CP 101            ; ...is not 101...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease index of Ghost's current room (to 4, room above pit)
       movb @bytes+121,a               ; LD A,121          ; Position Ghost such that the y-coordinate of its top edge is 121...
       jmp  _41758                     ; JR 41758          ; ...and return
* Current character and Ghost in same room (pit)
_41747:
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+100               ; CP 100            ; ...is not 100...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease index of Ghost's current room (to 4, room above pit)
       movb @bytes+115,a               ; LD A,115          ; Prepare to set y-coordinate of Ghost's top edge to 115
_41758:
       movb a,@4(ix)                   ; LD (IX+4),A       ; Set y-coordinate of Ghost's top edge to value in A
       a    @bytes+6,a                 ; ADD A,6           ; Add 6 to value in A (as Ghost is 6 characters tall)...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and set y-coordinate of Ghost's bottom edge to value in A
       rt                              ; RET               ; Return

* Update State of Cannon and Projectile
* 
* Used by the routine at #R41211.
_41767:
       bl   @_41961                    ; CALL 41961        ; Update State of Cannon's Projectile
       li   ix,_45508                  ; LD IX,45508       ; Load IX with address of complex state data for Cannon (Level 4)
       mov  @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Cannon's Just Loaded Flag is reset...
       andi tmp0,4                     ;                   
       jeq  _41805                     ; JR Z,41805        ; ...then skip ahead to #R41805
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease Cannon's Fire Timer...
       jeq  _41791                     ; JR Z,41791        ; ...and if now zero then skip ahead to #R41791
       li   bc,_42519                  ; LD BC,42519       ; Set Cannon's graphic layout data address to point to graphic layout data for Cannon
                                                           ; (Rocking) and return...
       b    @_42512                    ; JP 42512          ; ...
_41791:
       szcb @bits+2,@9(ix)             ; RES 2,(IX+9)      ; Reset Cannon's Just Loaded Flag
       movb @bytes+50,@12(ix)          ; LD (IX+12),50     ; Set Cannon's Fire Timer to 50
_41799:
       li   bc,_42530                  ; LD BC,42530       ; Set Cannon's graphic layout data address to point to graphic layout data for Cannon
                                                           ; (Dormant) and return...
       b    @_42512                    ; JP 42512          ; ...
* Cannon's Just Loaded Flag is reset, so Cannon has finished its rocking phase.
_41805:
       movb @_34209,a                  ; LD A,(34209)      ; If Cannon has no ammunition...
       socb a,a                        ; OR A              ; ...
       jeq  _41799                     ; JR Z,41799        ; ...then jump to #R41799 (Cannon dormant)
       mov  @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Cannon has its Is Being Carried Flag set...
       andi tmp0,32                    ;                   
       jne  _41799                     ; JR NZ,41799       ; ...then jump to #R41799 (Cannon dormant)
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is the same as the Cannon's room...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  _41833                     ; JR Z,41833        ; ...then skip ahead to #R41833
       joc  _41860                     ; JR C,41860        ; TODO: check code. If index of Berk's current room is greater than the index of the Cannon's room then skip
                                                           ; ahead to #R41860
       jmp  _41871                     ; JR 41871          ; Skip ahead to #R41871
* Berk and Cannon in same room
_41833:
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Cannon's right side is smaller than x-coordinate of Berk's left side
                                                           ; (i.e. Cannon is to left of Berk)...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...
       jl   _41860                     ; JR C,41860        ; ...then skip ahead to #R41860
       movb @7(iy),a                   ; LD A,(IY+7)       ; If x-coordinate of Berk's right side is smaller than x-coordinate of Cannon's left side
                                                           ; (i.e. Cannon is to right of Berk)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   _41871                     ; JR C,41871        ; ...then skip ahead to #R41871
* Berk and Cannon overlapping horizontally
       movb one,@e                     ; LD E,1            ; Load E with 1 (as Projectile will appear one character to the right of the Cannon's
                                                           ; coordinate position)
       movb @bytes+0,@9(ix)            ; LD (IX+9),0       ; Prepare to set Projectile's state to zero (fired vertically)
       li   bc,_42530                  ; LD BC,42530       ; Load BC with graphic layout data address for Cannon (Upright)
       jmp  _41880                     ; JR 41880          ; Skip ahead to #R41880
* Berk is to the right of the Cannon
_41860:
       movb one,@9(ix)                 ; LD (IX+9),1       ; Prepare to set Projectile's state to 1 (fired left)
       movb @bytes+2,@e                ; LD E,2            ; Load E with 2 (as Projectile will appear two characters to the right of the Cannon's
                                                           ; coordinate position)
       li   bc,_42556                  ; LD BC,42556       ; Load BC with graphic layout data address for Cannon (Tilted Right)
       jmp  _41880                     ; JR 41880          ; Skip ahead to #R41880
* Berk is to the left of the Cannon
_41871:
       movb @bytes+2,@9(ix)            ; LD (IX+9),2       ; Prepare to set Projectile's state to 2 (fired right)
       li   bc,_42594                  ; LD BC,42594       ; Load BC with graphic layout data address for Cannon (Tilted Left)
       movb @bytes+0,@e                ; LD E,0            ; Load E with 0 (as Projectile will appear at the same x-coordinate as in the Cannon's
                                                           ; coordinate position)
_41880:
       bl   @_42512                    ; CALL 42512        ; Set Cannon's graphic layout data address to value in BC
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Cannon's depth is 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  !                          ; RET Z             ; ...then return (Cannon won't fire if it is placed behind Berk)
       rt                              ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If Cannon's Fire Timer is at zero...
       socb a,a                        ; OR A              ; ...
       jeq  _41899                     ; JR Z,41899        ; ...then skip ahead to #R41899
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease Cannon's Fire Timer
       rt                              ; RET               ; Return
* Cannon's Fire Timer is at zero
_41899:
       li   hl,_34209                  ; LD HL,34209       ; Decrease ammunition level of Cannon (Level 4) by one...
       sb   one,*hl                    ; DEC (HL)          ; ...
       movb @bytes+50,@12(ix)          ; LD (IX+12),50     ; Set Cannon's Fire Timer to 50
       li   iy,_45599                  ; LD IY,45599       ; Load IY with address of complex state data for Cannon's Projectile
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set x-coordinate of Projectile's left and right sides to E plus x-coordinate of Cannon's
                                                           ; left side...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set y-coordinates of top and bottom of Projectile to be one less than Cannon's top
                                                           ; y-coordinate...
       sb   one,a                      ; DEC A             ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Set Projectile's room to same as Cannon's Room...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Projectile's depth to 1
       movb @9(ix),a                   ; LD A,(IX+9)       ; Set Projectile's state to value prepared previously...
       movb a,@9(iy)                   ; LD (IY+9),A       ; ...
       movb @bytes+251,@12(iy)         ; LD (IY+12),251    ; Set Projectile's y-velocity to -5
       li   bc,_51483                  ; LD BC,51483       ; Set Projectile's graphic layout data address to that for Explosion (Bubo's Projectile /
                                                           ; fallen drips, Level 4)...
       movb @c,@2(iy)                  ; LD (IY+2),C       ; ...as Projectile is launched from Cannon in an explosion...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       rt                              ; RET               ; Return

* Update State of Cannon's Projectile
* 
* Used by the routine at #R41767.
_41961:
       li   ix,_45599                  ; LD IX,45599       ; Load IX with address of complex state data for Cannon's Projectile
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Projectile's depth is zero...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       li   bc,_49699                  ; LD BC,49699       ; Set Projectile's graphic layout data address to that of drip stage 8, disconnected and
                                                           ; falling (ball)...
       bl   @_42512                    ; CALL 42512        ; ...
       movb @9(ix),a                   ; LD A,(IX+9)       ; If Projectile's state is zero (fired vertically)...
       socb a,a                        ; OR A              ; ...
       jeq  _42015                     ; JR Z,42015        ; ...then skip ahead to #R42015
       cb   a,@bytes+8                 ; CP 8              ; If Projectile's state is not 8 (finished)...
       jne  _41991                     ; JR NZ,41991       ; ...then skip ahead to #R41991
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Projectile's depth to 0
       rt                              ; RET               ; Return
_41991:
       cb   a,@bytes+2                 ; CP 2              ; If Projectile's state is not 2 (fired right)...
       jne  _42006                     ; JR NZ,42006       ; ...then skip ahead to #R42006
* Projectile flying left
       bl   @_42447                    ; CALL 42447        ; Move entity left two characters...
       bl   @_42447                    ; CALL 42447        ; ...
       bl   @_54348                    ; CALL 54348        ; Move entity at IX into room to the left, if appropriate
       jmp  _42015                     ; JR 42015          ; Skip ahead to #R42015
* Projectile flying right
_42006:
       bl   @_42505                    ; CALL 42505        ; Move entity right two characters...
       bl   @_42505                    ; CALL 42505        ; ...
       bl   @_54313                    ; CALL 54313        ; Move entity at IX into room to the right, if appropriate
* Update Projectile's vertical velocity
_42015:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load Projectile's velocity into A and E...
       movb a,@e                       ; LD E,A            ; ...
       a    @4(ix),a                   ; ADD A,(IX+4)      ; Add velocity to y-coordinates of top and bottom of projectile...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase velocity by one (initially negative so will accelerate downwards)
       movb @e,a                       ; LD A,E            ; If velocity (before increase) was not 5...
       cb   a,@bytes+5                 ; CP 5              ; ...i.e. projectile has not yet fallen back to floor-level...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @bytes+8,@9(ix)            ; LD (IX+9),8       ; Set Projectile's state to 8 (finished)
       li   bc,_51483                  ; LD BC,51483       ; Set Projectile's graphic layout data address to that of explosion (Bubo's Projectile / fallen
                                                           ; drips, Level 4)...
       bl   @_42512                    ; CALL 42512        ; ...
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       jnc  !                          ; RET C             ; TODO: check code. ...and if no collision occurred, then return
       rt                              ;                   
!
       cb   a,@bytes+36                ; CP 36             ; If collision was not with entity of class 36 (skeleton, Level 4)...
       jne  _42058                     ; JR NZ,42058       ; ...then skip ahead to #R42058
       li   hl,_45404+9                ; LD HL,45413       ; Set Skeleton's Is Dying Flag...
       socb @bits+1,*hl                ; SET 1,(HL)        ; ...
_42058:
       cb   a,@bytes+31                ; CP 31             ; If collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
       rt                              ; RET               ; Return

* Update States of Drips (Level 4)
* 
* Used by the routine at #R41211.
_42064:
       li   ix,_45521                  ; LD IX,45521       ; Load IX with address of complex state data for first drip (Level 4)
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are 6 drips to process)
_42070:
       .push bc                        ; PUSH BC           ; Store BC (B = Remaining number of drips to process)
       movb @12(ix),a                  ; LD A,(IX+12)      ; If current drip's velocity factor is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _42128                     ; JR NZ,42128       ; ...then skip ahead to #R42128 (handle drip's fall)
       movb @9(ix),a                   ; LD A,(IX+9)       ; If current drip's stage is not 8...
       cb   a,@bytes+8                 ; CP 8              ; ...
       jne  _42092                     ; JR NZ,42092       ; ...then skip ahead to #R42092
_42084:
       movb @8(ix),a                   ; LD A,(IX+8)       ; Reset current drip's complex state data to values stored in Table of Initial-State Data...
       bl   @_53994                    ; CALL 53994        ; ...
       jmp  _42119                     ; JR 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42092:
       cb   a,@bytes+7                 ; CP 7              ; If drip's stage is not 7...
       jne  _42102                     ; JR NZ,42102       ; ...then skip ahead to #R42102
       movb one,@12(ix)                ; LD (IX+12),1      ; Set current drip's velocity factor to 1
       jmp  _42119                     ; JR 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42102:
       movb a,@c                       ; LD C,A            ; Load drip's stage into C
       movb @bytes+15,a                ; LD A,15           ; Load A with a random number, 0-14...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (14 in 15 chance)...
       jne  _42119                     ; JR NZ,42119       ; ...then advance IX to next entry in complex state data and loop back to #R42070
       movb @c,a                       ; LD A,C            ; Load drip's stage back into A...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@9(ix)                   ; LD (IX+9),A       ; Store updated drip stage value
       bl   @_42251                    ; CALL 42251        ; Set drip's graphic layout data pointer to stage A graphic
_42119:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries are 13 bytes wide)
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next drip's complex state data
       .pop bc                         ; POP BC            ; Restore BC (B = Remaining number of drips to process)
       sb   one,b                      ; DJNZ 42070        ; Loop back to #R42070
       jne  _42070                     ;                   
       rt                              ; RET               ; Return
* Drip's velocity factor is not zero
_42128:
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase drip's velocity factor
       movb one,@1(ix)                 ; LD (IX+1),1       ; Set drip's depth to 1
       li   iy,_45508                  ; LD IY,45508       ; Load IY with address of complex state data for Cannon (Level 4)
       movb a,b                        ; LD B,A            ; Load B with drip's velocity factor
_42140:
       movb *iy,a                      ; LD A,(IY+0)       ; Load Cannon's current room
       cb   a,*ix                      ; CP (IX+0)         ; If Cannon is in a different room to the drip...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Cannon's depth is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of Cannon's left side...
       ab   one,a                      ; INC A             ; ...plus one...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not the same as the x-coordinate of the drip's left side...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @4(iy),a                   ; LD A,(IY+4)       ; If y-coordinate of top Cannon's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is not the same as the y-coordinate of the drip's top...
       jne  _42215                     ; JR NZ,42215       ; ...then skip ahead to #R42215
       movb @_34209,a                  ; LD A,(34209)      ; Increase Cannon's ammunition level by 10...
       a    @bytes+10,a                ; ADD A,10          ; ...
       mov  a,@_34209                  ; LD (34209),A      ; ...
       socb @bits+2,@9(iy)             ; SET 2,(IY+9)      ; Set Cannon's Just Loaded Flag
       movb @bytes+20,@12(iy)          ; LD (IY+12),20     ; Set Cannon's Fire Timer to 20
       jmp  _42084                     ; JR 42084          ; Reset current drip's state and loop back to #R42070 for next drip
_42190:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _42215                     ; JR NZ,42215       ; ...then skip ahead to #R42215
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
_42200:
       movb @bytes+8,a                 ; LD A,8            ; Set drip's graphical stage to 8 (exploding on contact)...
       movb a,@9(ix)                   ; LD (IX+9),A       ; ...and also set drip's stage to 8...
       bl   @_42251                    ; CALL 42251        ; ...
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; Set drip's velocity factor to zero
       b    @_42119                    ; JP 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42215:
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of top of drip is 120...
       cb   a,@bytes+120               ; CP 120            ; ...
       jeq  _42200                     ; JR Z,42200        ; ...then loop back to #R42200 (make drip explode and process next drip)
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move drip down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       sb   one,b                      ; DJNZ 42140        ; Decrease B (velocity factor) and loop back to #R42140 if not zero
       jne  _42140                     ;                   
       b    @_42119                    ; JP 42119          ; Advance IX to next entry in complex state data and loop back to #R42070

* Addresses of Graphic Layout Data for Drips (Level 4)
* 
* Used by the routine at #R42251.
_42233:
       data _50800                                                   ; Stage 0 - Blank
       data _49600                                                   ; Stage 1 - Green drip forming
       data _49615                                                   ; Stage 2 - Red drip enlarging
       data _49630                                                   ; Stage 3 - Magenta drip enlarging
       data _49645                                                   ; Stage 4 - Cyan drip enlarging
       data _49663                                                   ; Stage 5 - Yellow drip full size
       data _49681                                                   ; Stage 6 - Yellow drip extended
       data _49699                                                   ; Stage 7 - Drip disconnected and falling
       data _51483                                                   ; Stage 8 - Drip exploding on contact

* Set a Drip's (Level 4) Stage to A
* 
* Used by the routine at #R42064. Input:  A  Index of drip state (0-8) IX  Address of complex state data for a drip
* (level 4)
_42251:
       a    a,a                        ; ADD A,A           ; Double index of drip state...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       li   hl,_42233                  ; LD HL,42233       ; Point HL at start of table of Addresses of Graphic Layout Data for Drips (Level 4)
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL as offset
       movb *hl,@c                     ; LD C,(HL)         ; Load address (of graphic layout data) at this location into BC...
       inc  hl                         ; INC HL            ; ...
       movb *hl,b                      ; LD B,(HL)         ; ...
       bl   @_42512                    ; CALL 42512        ; Set drip's graphic layout data address to BC
       rt                              ; RET               ; Return

* Update State of Flying Skeleton Creature (Level 4)
* 
* Used by the routine at #R41211.
_42266:
       li   ix,_45482                  ; LD IX,45482       ; Load IX with address of complex state data for Flying Skeleton Creature (Level 4)
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _42285                     ; JR NZ,42285       ; ...then skip ahead to #R42285
       movb @_45391+10,a               ; LD A,(45401)      ; If Berk's Can Fall Flag is reset...
       mov  a,tmp0                     ; BIT 6,A           ; ...
       andi tmp0,64                    ;                   
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @_53667                    ;                   
!
_42285:
       equ  $
       li   hl,_45482+9                ; LD HL,45491       ; Load HL with address of Flying Skeleton Creature's flags
       mov  *hl,tmp0                   ; BIT 0,(HL)        ; If creature's Horizontal Direction Flag is set (moving left)...
       andi tmp0,1                     ;                   
       jne  _42320                     ; JR NZ,42320       ; ...then skip ahead to #R42320
* Horizontal Direction Flag reset (moving right)
       movb *ix,a                      ; LD A,(IX+0)       ; If creature's room is not 4 (Fake Boni's Room)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jne  _42309                     ; JR NZ,42309       ; ...then skip ahead to #R42309
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of creature's right edge is less than 126...
       cb   a,@bytes+126               ; CP 126            ; ...
       jl   _42309                     ; JR C,42309        ; ...then skip ahead to #R42309
       socb @bits+0,*hl                ; SET 0,(HL)        ; Set creature's Horizontal Direction Flag (moving left)
       rt                              ; RET               ; Return
_42309:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move creature right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @_54313                    ; CALL 54313        ; ...and move into room to the right, if appropriate
       jmp  _42346                     ; JR 42346          ; Skip ahead to #R42346
* Horizontal Direction Flag set (moving left)
_42320:
       movb *ix,a                      ; LD A,(IX+0)       ; If creature's room is not 1 (Door Room)...
       cb   a,one                      ; CP 1              ; ...
       jne  _42337                     ; JR NZ,42337       ; ...then skip ahead to #R42337
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of creature's left edge is at least 108...
       cb   a,@bytes+108               ; CP 108            ; ...
       jhe  _42337                     ; JR NC,42337       ; ...then skip ahead to #R42337
       szcb @bits+0,*hl                ; RES 0,(HL)        ; Reset creature's Horizontal Direction Flag (moving right)
       rt                              ; RET               ; Return
_42337:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move creature left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @_54348                    ; CALL 54348        ; ...and move into room to the left, if appropriate
_42346:
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load A with y-coordinate of creature's top edge
       mov  *hl,tmp0                   ; BIT 1,(HL)        ; If creature's Vertical Direction Flag is set (moving up)...
       andi tmp0,2                     ;                   
       jne  _42367                     ; JR NZ,42367       ; ...then skip ahead to #R42367
* Vertical Direction Flag reset, moving down
       cb   a,@bytes+108               ; CP 108            ; If y-coordinate of creature's top edge is not 108...
       jne  _42360                     ; JR NZ,42360       ; ...then skip ahead to #R42360
       socb @bits+1,*hl                ; SET 1,(HL)        ; Set creature's Vertical Direction Flag (moving up)
       rt                              ; RET               ; Return
* This entry point is used by the routine at #R41633.
_42360:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move creature down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       rt                              ; RET               ; Return
* Vertical Direction Flag set, moving up
_42367:
       cb   a,@bytes+100               ; CP 100            ; If y-coordinate of creature's top edge is not 100...
       jne  _42374                     ; JR NZ,42374       ; ...then skip ahead to #R42374
       szcb @bits+1,*hl                ; RES 1,(HL)        ; Reset creature's Vertical Direction Flag (moving down)
       rt                              ; RET               ; Return
* This entry point is used by the routine at #R41633.
_42374:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move creature up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       rt                              ; RET               ; Return

* Update State of Snake (Level 4)
* 
* Used by the routine at #R41211.
_42381:
       li   ix,_45495                  ; LD IX,45495       ; Point IX at start of state data for Snake (Level 4)
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       li   hl,_45495+12               ; LD HL,45507       ; Load HL with address of Snake's Attack Progress Index
       movb *hl,a                      ; LD A,(HL)         ; If Snake's Attack Progress Index is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _42415                     ; JR NZ,42415       ; ...then skip ahead to #R42415
* Snake's Attack Progress Index is zero
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's room is not 5 (Snake's room)...
       cb   a,@bytes+5                 ; CP 5              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  @12(iy),tmp0               ; BIT 7,(IY+12)     ; If Berk's Is Jumping Flag is set...
       andi tmp0,128                   ;                   
       jne  _42413                     ; JR NZ,42413       ; ...then skip ahead to #R42413
       mov  @9(iy),tmp0                ; BIT 0,(IY+9)      ; If Snake's Must Process Current Script Data Flag is set...
       andi tmp0,1                     ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
_42413:
       equ  $
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       rt                              ; RET               ; Return
* Snake's Attack Progress Index is not zero
_42415:
       cb   a,@bytes+8                 ; CP 8              ; If Snake's Attack Progress Index is less than 8...
       jl   _42454                     ; JR C,42454        ; ...then jump to #R42454 (Snake moving right)
       cb   a,@bytes+15                ; CP 15             ; If Snake's Attack Progress Index is less than 15...
       jl   _42459                     ; JR C,42459        ; ...then jump to #R42459 (Snake preparing to pounce)
       cb   a,@bytes+17                ; CP 17             ; If Snake's Attack Progress Index is less than 17...
       jl   _42461                     ; JR C,42461        ; ...then jump to #R42461 (Snake pouncing)
       jeq  _42480                     ; JR Z,42480        ; If Snake's Attack Progress Index is 17 then jump to #R42480 (Snake finished pouncing)
* Snake's Attack Progress Index is greater than 17
_42429:
       movb @bytes+20,*hl              ; LD (HL),20        ; Set Snake's Attack Progress Index to 20
       li   bc,_42648                  ; LD BC,42648       ; Set Snake's graphic layout data address to #R42648...
       bl   @_42512                    ; CALL 42512        ; ...(Snake, mouth closed, with animated tongue)
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Snake's left edge is not 83...
       cb   a,@bytes+83                ; CP 83             ; ...
       jne  _42447                     ; JR NZ,42447       ; ...then move Snake left one character and return
       movb @bytes+0,*hl               ; LD (HL),0         ; Set Snake's Attack Progress Index to 0
       rt                              ; RET               ; Return
* This entry point is used by the routine at #R41961.
_42447:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Decrease x-coordinates of left and right edges of entity at IX by one...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       rt                              ; RET               ; Return
* Snake's Attack Progress Index is less than 8
_42454:
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       bl   @_42505                    ; CALL 42505        ; Move Snake right one character
       rt                              ; RET               ; Return
* Snake's Attack Progress Index is 8 or more, but less than 15
_42459:
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       rt                              ; RET               ; Return
* Snake's Attack Progress Index is 15 or more, but less than 17
_42461:
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the y-coordinate of Berk's bottom edge is less than 116...
       cb   a,@bytes+116               ; CP 116            ; ...
       jl   _42429                     ; JR C,42429        ; ...then jump back to #R42429
       bl   @_42486                    ; CALL 42486        ; Open Snake's mouth and set Berk Has Been Killed Flag if Snake and Berk have collided
       movb @bytes+4,b                 ; LD B,4            ; Move Snake right four characters...
_42473:
       bl   @_42505                    ; CALL 42505        ; ...
       sb   one,b                      ; DJNZ 42473        ; ...
       jne  _42473                     ;                   
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       rt                              ; RET               ; Return
* Snake's Attack Progress Index is 17
_42480:
       bl   @_42486                    ; CALL 42486        ; Open Snake's mouth and set Berk Has Been Killed Flag if Snake and Berk have collided
       movb @bytes+20,*hl              ; LD (HL),20        ; Set Snake's Attack Progress Index to 20
       rt                              ; RET               ; Return

* Open Snake's Mouth and Set Berk Has Been Killed Flag if Snake and Berk Have Collided
* 
* Used by the routine at #R42381. Input:  HL  Address of Snake's Attack Progress Index IX  Address of complex state
* data for Snake (Level 4)
_42486:
       li   bc,_42703                  ; LD BC,42703       ; Set Snake's graphic layout data address to #R42703...
       bl   @_42512                    ; CALL 42512        ; ...(Snake, mouth open, attacking)
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       movb @bytes+18,*hl              ; LD (HL),18        ; Set Snake's Attack Progress Index to 18
       bl   @_53667                    ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       rt                              ; RET               ; Return

* Move Entity at IX Right One Character
* 
* Used by the routines at #R41961 and #R42381.
_42505:
       ab   one,@7(ix)                 ; INC (IX+7)        ; Increase x-coordinates of left and right edges of entity at IX by one...
       ab   one,@5(ix)                 ; INC (IX+5)        ; ...
       rt                              ; RET               ; Return

* Set Graphic Layout Data Address for Entity at IX to BC
* 
* Used by the routines at #R41767, #R41961, #R42251, #R42381 and #R42486. Input:  BC  Holds address of graphic
* layout data
_42512:
       movb @c,@2(ix)                  ; LD (IX+2),C       ; Set current entity's graphic layout data address to BC...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       rt                              ; RET               ; Return

* Graphic Layout Data Cannon (Level 4) Loaded (Animated)
_42519:
       byte 243,0,4                                                  ; Increase current state value n (initially 0), up to maximum of 4, resetting to
                                                                     ; zero if maximum reached and jump to n-th address in following list:
       byte _42530%256,_42530/256                                    ; #R42530 (Cannon, straight)
       byte _42556%256,_42556/256                                    ; #R42556 (Cannon, tilted right)
       byte _42530%256,_42530/256                                    ; #R42530 (Cannon, straight)
       byte _42594%256,_42594/256                                    ; #R42594 (Cannon, tilted left)
* Straight
_42530:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 41,66,33,0,18,33
       byte 41,194,30,42,66,34
       byte 42,194,30,44,66,34
       byte 44,194,33
       byte 248,_42629%256,_42629/256                                ; Jump to #R42629
* Tilted Right
_42556:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 48,2,31,49,2,33
       byte 0,18,33,50,66,33
       byte 51,2,29,52,66,34
       byte 0,18,33,53,2,29
       byte 54,66,34,55,66,33
       byte 248,_42629%256,_42629/256                                ; Jump to #R42629
* Tilted Left
_42594:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 48,130,30,51,130,33
       byte 50,194,33,0,18,33
       byte 49,130,29,53,130,33
       byte 0,18,34,52,194,30
       byte 55,194,34,54,194,33
_42629:
       byte 250,255,254                                              ; Change cursor's x- and y-coordinates by -2 and -1 characters respectively
       byte 43,50,32,45,50,31
       byte 46,70,33,47,70,33
       byte 46,198,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Snake (Level 4) Mouth Closed, With Animated Tongue
_42648:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 238,14                                                   ; Set Repeat Counter A to 14
_42652:
       byte 24,50,161
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R42652 if not zero
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 27,6,33,28,6,33
       byte 29,62,33,35,6,29
       byte 31,6,33,31,134,33
       byte 0,54,33,36,6,33
       byte 37,6,33
       byte 247,2                                                    ; Jump to one of the 2 addresses in the following list, chosen at random:
       byte _50800%256,_50800/256                                    ; #R50800 (blank)
       byte _42692%256,_42692/256                                    ; #R42692 (tongue, animated)
* Tongue, animated
_42692:
       byte 38,5,33
       byte 236,2,39,40                                              ; Modify following instruction to display graphic of random index, chosen from 39 and
                                                                     ; 40
       byte 39,5,33
       byte 255                                                      ; End Marker
* Mouth Open, Attacking
_42703:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 238,14                                                   ; Set Repeat Counter A to 14
_42707:
       byte 24,50,161
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R42707 if not zero
       byte 250,254,2                                                ; Change cursor's x- and y-coordinates by +2 and -2 characters respectively
       byte 27,6,33,25,6,33
       byte 26,7,28,27,6,33
       byte 28,6,33,29,62,33
       byte 30,6,29,31,6,33
       byte 31,134,33,0,54,33
       byte 32,6,31,33,6,33
       byte 34,6,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Ghost (Level 4) Full, Fully Animated
_42754:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 243,0,2                                                  ; Increase current state value n (initially 0), up to maximum of 2, resetting to zero
                                                                     ; if maximum reached and jump to n-th address in following list:
       byte _42763%256,_42763/256                                    ; #R42763 (Ghost, full, wings up, tail animated)
       byte _42797%256,_42797/256                                    ; #R42797 (Ghost, full, wings down, tail animated)
* Full, Wings Up, Tail Animated
_42763:
       byte 251,_42831%256,_42831/256                                ; Process graphic layout data at #R42831 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,254                                                ; Change cursor's x- and y-coordinates by -2 and 0 characters respectively
       byte 242,7                                                    ; Set current attribute to 7
       byte 59,32,60,33
       byte 61,31,62,33
       byte 63,33
       byte 250,254,3                                                ; Change cursor's x- and y-coordinates by +3 and -2 characters respectively
       byte 242,135                                                  ; Set current attribute to 135
       byte 59,31,61,33
       byte 60,31,63,33
       byte 62,33
       byte 255                                                      ; End Marker
* Full, Wings Down, Tail Animated
_42797:
       byte 251,_42831%256,_42831/256                                ; Process graphic layout data at #R42831 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,254                                                ; Change cursor's x- and y-coordinates by -2 and +1 characters respectively
       byte 242,7                                                    ; Set current attribute to 7
       byte 64,33,65,31
       byte 66,33,67,31
       byte 68,33
       byte 250,254,3                                                ; Change cursor's x- and y-coordinates by +3 and -2 characters respectively
       byte 242,135                                                  ; Set current attribute to 135
       byte 65,33,64,31
       byte 67,33,66,32
       byte 68,33
       byte 255                                                      ; End Marker
* Body and Tail, Without Wings
_42831:
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 56,7,33,56,135,31
       byte 57,7,33,57,135,31
       byte 58,7,33,58,135,31
       byte 0,63,33,0,63,31
       byte 236,2,69,72                                              ; Modify following instruction to display graphic of random index, chosen from 69 and
                                                                     ; 72
       byte 69,7,33
       byte 236,2,69,72                                              ; Modify following instruction to display graphic of random index, chosen from 69 and
                                                                     ; 72
       byte 69,135,31
       byte 236,2,70,73                                              ; Modify following instruction to display graphic of random index, chosen from 70 and
                                                                     ; 73
       byte 73,7,33
       byte 236,2,70,73                                              ; Modify following instruction to display graphic of random index, chosen from 70 and
                                                                     ; 73
       byte 73,135,31
       byte 236,2,71,74                                              ; Modify following instruction to display graphic of random index, chosen from 71 and
                                                                     ; 74
       byte 74,7,33
       byte 236,2,71,74                                              ; Modify following instruction to display graphic of random index, chosen from 71 and
                                                                     ; 74
       byte 74,135,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Skeleton (Level 4) Standing, Full, Animated
_42901:
       byte 251,_43020%256,_43020/256                                ; Process graphic layout data at #R43020 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_43047%256,_43047/256                                ; Process graphic layout data at #R43047 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,7,1                                                  ; Change cursor's x- and y-coordinates by +1 and +7 characters respectively
_42910:
       byte 242,7                                                    ; Set current attribute to 7
       byte 113,31,114,33
       byte 115,31,116,33
       byte 117,33,118,30
       byte 119,34,120,29
       byte 121,33,122,33
       byte 121,33,122,33
       byte 255                                                      ; End Marker
* Stepping Forward, Frame 1, Full, Animated
_42937:
       byte 251,_43020%256,_43020/256                                ; Process graphic layout data at #R43020 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_43047%256,_43047/256                                ; Process graphic layout data at #R43047 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,7,255                                                ; Change cursor's x- and y-coordinates by -1 and +7 characters respectively
_42946:
       byte 242,7                                                    ; Set current attribute to 7
       byte 108,33,109,33
       byte 110,30,116,34
       byte 123,30,119,34
       byte 117,33,118,28
       byte 121,33,122,35
       byte 120,31,121,33
       byte 122,33
       byte 255                                                      ; End Marker
* Stepping Forward, Frame 2, Full, Animated
_42975:
       byte 254,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively and store as
                                                                     ; new base coordinates
       byte 251,_43020%256,_43020/256                                ; Process graphic layout data at #R43020 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_43058%256,_43058/256                                ; Process graphic layout data at #R43058 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,7,0                                                  ; Change cursor's x- and y-coordinates by 0 and +7 characters respectively
_42987:
       byte 242,7                                                    ; Set current attribute to 7
       byte 124,33,125,33
       byte 126,29,127,33
       byte 128,33,129,33
       byte 130,30,131,34
       byte 132,33,133,33
       byte 134,27,121,33
       byte 122,35,135,33
       byte 136,33
       byte 255                                                      ; End Marker
* Head, Animated
_43020:
       byte 244,12                                                   ; Set current graphic set to 12
_43022:
       byte 242,7                                                    ; Set current attribute to 7
       byte 75,33,76,31
       byte 77,33,78,31
       byte 79,33,80,31
       byte 236,2,81,82                                              ; Modify following instruction to display graphic of random index, chosen from 81 and 82
       byte 81,33,83,33
       byte 84,33
       byte 255                                                      ; End Marker
* Torso and Spear, Animated
_43047:
       byte 249,2,1                                                  ; If state n (initially 1) has remaining time of zero then reset its time to maximum and
                                                                     ; randomly select a new state, n, from the 2 in the following list. Jump to the address
                                                                     ; specified in the current state and decrease its remaining time:
       byte 3,3,_43058%256,_43058/256                                ; #R43058 (Torso and spear, extended, for 3 ticks)
       byte 3,3,_43092%256,_43092/256                                ; #R43092 (Torso and spear, retracted, for 3 ticks)
* Torso and Spear, Extended
_43058:
       byte 250,4,0                                                  ; Change cursor's x- and y-coordinates by 0 and +4 characters respectively
_43061:
       byte 242,7                                                    ; Set current attribute to 7
       byte 98,33,99,33
       byte 100,33,101,24
       byte 90,33,91,33
       byte 92,33,102,33
       byte 103,33,104,33
       byte 105,33,106,33
       byte 91,30,107,33
       byte 255                                                      ; End Marker
* Torso and Spear, Retracted
_43092:
       byte 250,3,3                                                  ; Change cursor's x- and y-coordinates by +3 and +3 characters respectively
_43095:
       byte 242,7                                                    ; Set current attribute to 7
       byte 85,29,86,33
       byte 87,33,88,33
       byte 89,25,90,33
       byte 91,33,92,33
       byte 93,33,94,33
       byte 95,33,96,33
       byte 97,33,91,29
       byte 107,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Sausages (Level 4) Red Sausage
_43128:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 23,2,33,23,130,33
       byte 255                                                      ; End Marker
* Cyan Sausage
_43137:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 23,5,33,23,133,33
       byte 255                                                      ; End Marker

* State Data for Simple Entities (Level 1)
* 
* #TABLE(default,centre,:w)
* { =h Offset | =h Meaning }
* { 0 | Room index }
* { 1 | Depth (distance from screen) }
* { 2 & 3 | Address of graphic layout data }
* { 4 | y-coordinate + 100 (chars) }
* { 5 | x-coordinate + 100 (chars) }
* TABLE#
_43146:
       byte 1,2,_50389%256,_50389/256,107,100                        ; (#R50389) Left brickwork
       byte 1,2,_50389%256,_50389/256,106,117                        ; (#R50389) Right brickwork
       byte 1,0,_50479%256,_50479/256,107,107                        ; (#R50479) "Home Sweet Home" brick border
       byte 1,2,_50116%256,_50116/256,100,100                        ; (#R50116) Four arches
       byte 1,2,_50018%256,_50018/256,100,100                        ; (#R50018) Spider's web
       byte 1,1,_50238%256,_50238/256,121,100                        ; (#R50238) Left part of floor
       byte 1,1,_50211%256,_50211/256,121,120                        ; (#R50211) Right part of floor
_43188:
       byte 1,2,_50267%256,_50267/256,121,112                        ; (#R50267) Closed Trap Door
       byte 1,2,_50147%256,_50147/256,112,115                        ; (#R50147) Boni's shelf
       byte 2,1,_50359%256,_50359/256,100,100                        ; (#R50359) Left wall
       byte 2,1,_50359%256,_50359/256,99,109                         ; (#R50359) Right wall
       byte 3,1,_50359%256,_50359/256,100,100                        ; (#R50359) Left wall
       byte 3,1,_50359%256,_50359/256,99,115                         ; (#R50359) Right wall
       byte 4,1,_50160%256,_50160/256,121,100                        ; (#R50160) Floor (full width)
       byte 4,2,_50126%256,_50126/256,101,100                        ; (#R50126) Single arch, left
       byte 4,2,_50126%256,_50126/256,101,124                        ; (#R50126) Single arch, right
       byte 4,2,_50359%256,_50359/256,97,108                         ; (#R50359) Wall, vertical bricks, single row, left
       byte 4,2,_50359%256,_50359/256,97,123                         ; (#R50359) Wall, vertical bricks, single row, right
       byte 5,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 6,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 6,2,_50116%256,_50116/256,100,100                        ; (#R50116) Four arches
       byte 6,2,_50579%256,_50579/256,107,99                         ; (#R50579) Wall, horizontal bricks
       byte 7,1,_50238%256,_50238/256,121,94                         ; (#R50238) Left part of floor
       byte 7,1,_50211%256,_50211/256,121,126                        ; (#R50211) Right part of floor
       byte 7,2,_50116%256,_50116/256,100,100                        ; (#R50116) Four arches
       byte 8,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 8,1,_50359%256,_50359/256,101,100                        ; (#R50359) Wall, vertical bricks, single row, left
       byte 8,1,_50359%256,_50359/256,101,131                        ; (#R50359) Wall, vertical bricks, single row, right
       byte 9,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 9,2,_50116%256,_50116/256,100,100                        ; (#R50116) Four arches
       byte 9,2,_50609%256,_50609/256,111,123                        ; (#R50609) Row of five horizontal bricks
       byte 254                                                      ; End Marker

* State Data for Complex Entities (Level 1)
* 
* For more details on individual bits, see trivia.
_43333:
       byte 10,2,_50663%256,_50663/256,100,112,108,119,33,0,0,0,0    ; (#R50663) Entry door (above Trap Door Room, where Berk
                                                                     ; emerges at the end of the game)
       byte 10,1,_50800%256,_50800/256,120,100,121,131,129,0,0,240,0 ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 11,1,_50800%256,_50800/256,120,100,121,131,129,0,0,240,0 ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 9,2,_50663%256,_50663/256,112,124,120,131,33,2,0,192,0   ; (#R50663) Exit door
       byte 9,2,_50579%256,_50579/256,107,123,120,124,30,0,0,48,0    ; (#R50579) Wall, horizontal bricks
       byte 9,2,_50579%256,_50579/256,107,131,120,132,30,0,0,48,0    ; (#R50579) Wall, horizontal bricks
       byte 6,2,_50579%256,_50579/256,107,107,120,108,30,0,0,48,0    ; (#R50579) Wall, horizontal bricks
       byte 6,1,_50800%256,_50800/256,121,102,121,102,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
_43437:
       byte 0,1,_50283%256,_50283/256,114,112,121,119,129,0,0,240,0  ; (#R50283) Open Trap Door (also acts as marker, makes Berk
                                                                     ; and Drutt fall)
_43450:
       byte 1,1,_50800%256,_50800/256,114,120,121,120,128,0,0,48,0   ; (#R50800) Marker (prevents Berk and Drutt passing)
_43463:
       byte 6,1,_37205%256,_37205/256,93,115,98,118,30,0,128,192,0   ; (#R37205) Bat
       byte 7,1,_50800%256,_50800/256,120,106,121,125,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 8,1,_50609%256,_50609/256,100,96,100,105,130,0,0,240,0   ; (#R50609) Ceiling (left section)
       byte 8,1,_50609%256,_50609/256,100,126,100,135,130,0,0,240,0  ; (#R50609) Ceiling (right section)
       byte 8,2,_50642%256,_50642/256,107,119,108,122,35,0,0,240,0   ; (#R50642) Pit Platform
       byte 8,2,_50800%256,_50800/256,107,114,108,118,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 8,2,_50800%256,_50800/256,107,123,108,127,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 8,2,_50800%256,_50800/256,109,119,109,122,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 8,2,_50579%256,_50579/256,101,104,120,105,30,0,0,240,0   ; (#R50579) Wall, horizontal bricks
       byte 8,2,_50579%256,_50579/256,101,126,120,127,30,0,0,240,0   ; (#R50579) Wall, horizontal bricks
_43593:
       byte 1,1,_56804%256,_56804/256,115,123,121,128,31,0,128,192,0 ; (#R56804) Berk
_43606:
       byte 1,2,_50317%256,_50317/256,108,115,111,116,19,0,128,0,0   ; (#R50317) Boni
_43619:
       byte 1,2,_51314%256,_51314/256,124,115,128,116,30,0,128,192,0 ; (#R51314) Flying Skeleton Creature
       byte 6,2,_50792%256,_50792/256,105,103,105,104,17,0,128,240,0 ; (#R50792) Key
       byte 9,2,_50560%256,_50560/256,105,103,105,104,4,0,131,240,0  ; (#R50560) Red Sweet (Flying, duration = 3)
       byte 8,1,_50565%256,_50565/256,121,104,121,105,1,0,128,240,0  ; (#R50565) Green Sweet (Jumping, duration = permanent)
_43671:
       byte 1,1,_52417%256,_52417/256,121,129,121,129,18,0,128,192,0 ; (#R52417) Drutt
_43684:
       byte 0,0,_53340%256,_53340/256,121,109,121,110,24,0,128,0,0   ; (#R53340) Worm
       byte 2,1,_50800%256,_50800/256,120,100,121,131,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 3,1,_50800%256,_50800/256,120,100,121,131,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 4,1,_50609%256,_50609/256,100,99,100,108,130,0,0,240,0   ; (#R50609) Ceiling, left section
_43736:
       byte 4,1,_50609%256,_50609/256,100,123,100,132,130,0,0,240,0  ; (#R50609) Ceiling, right section
_43749:
       byte 5,2,_37888%256,_37888/256,103,118,106,120,27,0,128,0,0   ; (#R37888) Spider
_43762:
       byte 5,2,_37888%256,_37888/256,103,110,106,112,28,0,128,0,0   ; (#R37888) Spider
_43775:
       byte 5,2,_37888%256,_37888/256,103,102,106,104,29,0,128,0,0   ; (#R37888) Spider
       byte 5,2,_50008%256,_50008/256,100,100,0,0,30,0,0,0,0         ; (#R50008) Spiders' Webs
       byte 5,2,_50116%256,_50116/256,100,100,0,0,30,0,0,0,0         ; (#R50116) Spiders' Arches
       byte 255                                                      ; End Marker

* Room Dimension Data (Level 1)
* 
* #TABLE(default,centre,:w)
* { =h Offset | =h Meaning }
* { 0 | Room depth (number of depth levels) }
* { 1 | Position of left edge of room (chars) }
* { 2 | Position of right edge of room (chars) }
* { 3 | Position of top edge of room (chars) }
* { 4 | Position of bottom edge of room (chars) }
* TABLE#
_43815:
       byte 2,0,31,0,21                                              ; (01) Trap Door Room
       byte 2,11,20,0,21                                             ; (02) 1st room below Trap Door
       byte 2,8,23,0,21                                              ; (03) 2nd room below Trap Door
       byte 2,0,31,0,21                                              ; (04) Room at bottom of Trap Door Shaft
       byte 2,0,31,0,21                                              ; (05) Spider Room
       byte 2,0,31,0,21                                              ; (06) Bat Room
       byte 2,0,31,0,21                                              ; (07) Room at top of Pit
       byte 2,0,31,0,21                                              ; (08) Pit
       byte 2,0,31,0,21                                              ; (09) Door Room
       byte 2,0,31,0,21                                              ; (10) Entry Room
       byte 2,0,31,0,21                                              ; (11) Room above Trap Door Room
       byte 255                                                      ; End Marker

* Horizontal Room Connectivity Map (Level 1)
* 
* Each entry represents a link between two rooms. The first byte in the entry is the index of the room to the left
* and the second byte is the index of the room to the right.
_43871:
       byte 6,5                                                      ; Bat Room and Spider Room
       byte 5,4                                                      ; Spider Room and room at bottom of Trap Door Shaft
       byte 4,7                                                      ; Room at bottom of Trap Door Shaft and room at top of Pit
       byte 7,9                                                      ; Room at top of Pit and Door Room
       byte 255,255                                                  ; End Marker

* Unused
* 
* Data Block (09) (Level 1)
_43881:
       byte 255

* Vertical Room Connectivity Map (Level 1)
_43882:
       byte 1,2                                                      ; Trap Door Room and 1st room below Trap Door
       byte 2,3                                                      ; 1st room below Trap Door and 2nd room below Trap Door
       byte 3,4                                                      ; 2nd room below Trap Door and room at bottom of Trap Door Shaft
       byte 7,8                                                      ; Room at top of Pit and Pit
       byte 10,11                                                    ; Entry Room and room above Trap Door Room
       byte 11,1                                                     ; Room above Trap Door Room and Trap Door Room
       byte 255,255                                                  ; End Marker

* State Data for Simple Entities (Level 2)
_43896:
       byte 1,2,_51187%256,_51187/256,100,112                        ; (#R51187) Sides of ceiling gap
       byte 1,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor
       byte 1,2,_51253%256,_51253/256,100,103                        ; (#R51253) Stalactite
       byte 1,2,_51253%256,_51253/256,100,110                        ; (#R51253) Stalactite
       byte 1,2,_51253%256,_51253/256,100,120                        ; (#R51253) Stalactite
       byte 2,2,_50908%256,_50908/256,100,100                        ; (#R50908) Left wall
       byte 2,2,_50893%256,_50893/256,100,108                        ; (#R50893) Right wall
       byte 2,2,_50923%256,_50923/256,100,100                        ; (#R50923) Ceiling section (half)
       byte 3,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor
       byte 3,2,_51202%256,_51202/256,101,92                         ; (#R51202) Seven stalactites at various heights
       byte 4,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor
       byte 4,2,_51202%256,_51202/256,101,95                         ; (#R51202) Seven stalactites at various heights
       byte 5,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor (see trivia)
       byte 6,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor
       byte 7,1,_50806%256,_50806/256,121,100                        ; (#R50806) Floor
       byte 7,2,_51202%256,_51202/256,100,92                         ; (#R51202) Seven stalactites at various heights
       byte 254                                                      ; End Marker

* State Data for Complex Entities (Level 2)
_43993:
       byte 1,2,_50893%256,_50893/256,100,130,122,131,128,0,0,240,0  ; (#R50893) Right wall
       byte 1,2,_50923%256,_50923/256,100,96,101,112,130,0,0,192,0   ; (#R50923) Ceiling section (half)
       byte 1,2,_50923%256,_50923/256,100,120,101,131,130,0,0,192,0  ; (#R50923) Ceiling section (half)
       byte 1,2,_50800%256,_50800/256,120,99,120,114,50,0,0,48,0     ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 1,2,_50800%256,_50800/256,120,117,120,132,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 2,1,_50800%256,_50800/256,120,100,121,109,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 3,2,_50875%256,_50875/256,100,100,101,131,130,0,0,192,0  ; (#R50875) Ceiling (complete 1)
       byte 4,2,_50884%256,_50884/256,100,100,101,131,130,0,0,192,0  ; (#R50884) Ceiling (complete 2)
       byte 5,2,_50875%256,_50875/256,100,100,101,131,130,0,0,192,0  ; (#R50875) Ceiling (complete 1) (see trivia)
       byte 6,2,_50884%256,_50884/256,100,100,101,131,130,0,0,192,0  ; (#R50884) Ceiling (complete 2)
       byte 7,2,_50875%256,_50875/256,100,100,101,131,130,0,0,192,0  ; (#R50875) Ceiling (complete 1)
       byte 7,2,_50908%256,_50908/256,101,100,121,101,128,0,0,240,0  ; (#R50908) Left wall
_44149:
       byte 1,1,_57428%256,_57428/256,115,125,121,130,31,18,128,192,0 ; (#R57428) Berk
_44162:
       byte 3,1,_38766%256,_38766/256,120,100,121,102,25,0,128,241,100 ; (#R38766) Green Apebeast
       byte 3,1,_38766%256,_38766/256,120,129,121,131,25,0,128,242,115 ; (#R38766) Green Apebeast
       byte 4,1,_38766%256,_38766/256,120,100,121,102,25,0,128,241,100 ; (#R38766) Green Apebeast
       byte 4,1,_38766%256,_38766/256,120,129,121,131,25,0,128,242,115 ; (#R38766) Green Apebeast
_44214:
       byte 7,0,_39131%256,_39131/256,0,0,0,0,30,0,0,0,0             ; (#R39131) Bubo's projectile
_44227:
       byte 7,1,_38996%256,_38996/256,119,115,121,117,16,0,128,192,0 ; (#R38996) Bubo
_44240:
       byte 2,2,_50792%256,_50792/256,103,104,103,105,17,0,128,240,0 ; (#R50792) Key
       byte 2,2,_51271%256,_51271/256,119,104,120,105,2,0,128,240,0  ; (#R51271) Mushroom (Jumping, duration = permanent)
       byte 7,2,_50800%256,_50800/256,120,100,120,103,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 7,1,_50800%256,_50800/256,121,100,121,103,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 7,2,_51271%256,_51271/256,104,104,105,105,9,0,128,240,0  ; (#R51271) Mushroom (Immunity to Bubo, duration =
                                                                     ; permanent)
_44305:
       byte 6,1,_51253%256,_51253/256,98,111,98,111,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,104,98,104,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,113,98,113,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,116,98,116,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,121,98,121,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,123,98,123,34,0,0,240,0     ; (#R51253) Stalactite
       byte 6,1,_51253%256,_51253/256,98,124,98,124,34,0,0,240,0     ; (#R51253) Stalactite
_44396:
       byte 1,1,_52417%256,_52417/256,121,115,121,115,18,0,128,192,0 ; (#R52417) Drutt
_44409:
       byte 0,0,_53340%256,_53340/256,121,109,121,110,24,0,128,0,0   ; (#R53340) Worm
_44422:
       byte 1,1,_50668%256,_50668/256,113,122,121,129,33,3,0,192,0   ; (#R50668) Level 2 Door
       byte 255                                                      ; End Marker

* Room Dimension Data (Level 2)
_44436:
       byte 2,0,31,0,21                                              ; (01) Door Room
       byte 2,11,20,0,21                                             ; (02) Key Room
       byte 2,0,31,0,21                                              ; (03) First Apebeast Room
       byte 2,0,31,0,21                                              ; (04) Second Apebeast Room
       byte 2,0,31,0,21                                              ; (05) Unused (see trivia)
       byte 2,0,31,0,21                                              ; (06) Stalactite Room
       byte 2,0,31,0,21                                              ; (07) Bubo's Room
       byte 255                                                      ; End Marker

* Horizontal Room Connectivity Map (Level 2)
_44472:
       byte 7,4                                                      ; Bubo's Room and Second Apebeast Room
       byte 4,3                                                      ; Second Apebeast Room and First Apebeast Room
       byte 3,6                                                      ; First Apebeast Room and Stalactite Room
       byte 6,1                                                      ; Stalactite Room and Door Room
       byte 255,255                                                  ; End Marker

* Unused
* 
* Data Block (09) (Level 2)
_44482:
       byte 255

* Vertical Room Connectivity Map (Level 2)
_44483:
       byte 2,1                                                      ; Key Room and Door Room
       byte 255,255                                                  ; End Marker

* State Data for Simple Entities (Level 3)
_44487:
       byte 1,2,_49781%256,_49781/256,100,100                        ; (#R49781) Fifteen glowing tangleweeds
       byte 1,2,_40073%256,_40073/256,111,101                        ; (#R40073) Door Archway
       byte 1,1,_50801%256,_50801/256,121,100                        ; (#R50801) Floor
       byte 2,1,_50801%256,_50801/256,121,100                        ; (#R50801) Floor
       byte 2,2,_49789%256,_49789/256,100,96                         ; (#R49789) Six glowing tangleweeds
       byte 2,2,_49781%256,_49781/256,100,121                        ; (#R49781) Fifteen glowing tangleweeds
       byte 3,1,_50801%256,_50801/256,121,100                        ; (#R50801) Floor
       byte 3,2,_49797%256,_49797/256,100,100                        ; (#R49797) Twenty two glowing tangleweeds (full screen width)
       byte 4,1,_50801%256,_50801/256,121,79                         ; (#R50801) Floor
       byte 4,1,_50801%256,_50801/256,121,119                        ; (#R50801) Floor
       byte 4,2,_49789%256,_49789/256,100,100                        ; (#R49789) Six glowing tangleweeds
       byte 4,2,_49781%256,_49781/256,100,119                        ; (#R49781) Fifteen glowing tangleweeds
       byte 5,2,_49797%256,_49797/256,100,99                         ; (#R49797) Twenty two glowing tangleweeds (full screen width)
       byte 5,1,_50801%256,_50801/256,121,73                         ; (#R50801) Floor
       byte 5,1,_50801%256,_50801/256,121,121                        ; (#R50801) Floor
       byte 6,2,_49797%256,_49797/256,100,100                        ; (#R49797) Twenty two glowing tangleweeds (full screen width)
       byte 6,1,_50801%256,_50801/256,121,100                        ; (#R50801) Floor
       byte 7,2,_49797%256,_49797/256,100,100                        ; (#R49797) Twenty two glowing tangleweeds (full screen width)
       byte 7,1,_50801%256,_50801/256,121,119                        ; (#R50801) Floor
       byte 7,1,_50801%256,_50801/256,121,79                         ; (#R50801) Floor
       byte 254                                                      ; End Marker

* State Data for Complex Entities (Level 3)
_44608:
       byte 1,2,_50673%256,_50673/256,112,102,120,109,33,4,0,192,0   ; (#R50673) Level 3 Door
       byte 2,1,_49711%256,_49711/256,100,89,100,104,130,0,0,240,0   ; (#R49711) Ceiling (left section)
       byte 2,1,_49711%256,_49711/256,100,121,100,131,130,0,0,240,0  ; (#R49711) Ceiling (right section)
       byte 2,2,_40110%256,_40110/256,107,118,108,122,35,0,0,240,0   ; (#R40110) Platform
       byte 2,2,_50800%256,_50800/256,107,113,108,117,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 2,2,_50800%256,_50800/256,107,123,108,127,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 2,2,_50800%256,_50800/256,108,118,109,122,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 2,2,_40040%256,_40040/256,100,104,121,104,30,0,0,48,0    ; (#R40040) Vertical wall
       byte 3,1,_49705%256,_49705/256,100,100,100,131,130,0,0,240,0  ; (#R49705) Ceiling (full width)
       byte 4,1,_49711%256,_49711/256,100,95,100,110,130,0,0,240,0   ; (#R49711) Ceiling (left section)
       byte 4,1,_49711%256,_49711/256,100,119,100,131,130,0,0,240,0  ; (#R49711) Ceiling (right section)
       byte 4,2,_40040%256,_40040/256,100,119,121,119,30,0,0,48,0    ; (#R40040) Vertical wall
       byte 5,1,_50800%256,_50800/256,120,105,121,120,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 5,1,_49705%256,_49705/256,100,102,100,131,130,0,0,240,0  ; (#R49705) Ceiling (full width)
       byte 4,1,_41090%256,_41090/256,121,111,121,118,30,0,0,0,0     ; (#R41090) Hatch (closed)
       byte 6,2,_40138%256,_40138/256,115,106,115,110,32,0,0,128,0   ; (#R40138) Red coloured creature's slot (see trivia)
       byte 6,2,_40143%256,_40143/256,115,113,115,117,32,0,0,128,0   ; (#R40143) Yellow coloured creature's slot (see trivia)
       byte 6,2,_40148%256,_40148/256,115,120,115,124,32,0,0,128,0   ; (#R40148) White coloured creature's slot (see trivia)
       byte 7,1,_50800%256,_50800/256,120,111,121,118,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
_44855:
       byte 1,1,_57058%256,_57058/256,115,102,121,107,31,18,128,192,0 ; (#R57058) Berk
_44868:
       byte 3,2,_40451%256,_40451/256,122,113,135,118,26,0,128,0,0   ; (#R40451) Large yellow creature
_44881:
       byte 6,1,_40320%256,_40320/256,93,125,95,29,30,0,128,240,0    ; (#R40320) Clawed foot
_44894:
       byte 6,1,_40284%256,_40284/256,118,108,121,108,15,0,128,192,0 ; (#R40284) White coloured creature
       byte 6,1,_40254%256,_40254/256,118,115,121,115,13,0,128,192,0 ; (#R40254) Red coloured creature
       byte 6,1,_40269%256,_40269/256,118,122,121,122,14,0,128,192,0 ; (#R40269) Yellow coloured creature
       byte 2,2,_41175%256,_41175/256,118,121,120,123,12,0,128,240,0 ; (#R41175) Weight (see trivia)
       byte 3,2,_40192%256,_40192/256,120,109,120,110,10,0,148,240,0 ; (#R40192) Edible eyes (Floating, duration = 20)
       byte 7,2,_40192%256,_40192/256,120,126,120,127,5,0,130,240,0  ; (#R40192) Edible eyes (Flying, duration = 2)
_44972:
       byte 6,1,_40192%256,_40192/256,90,127,90,128,6,0,131,240,0    ; (#R40192) Edible eyes (Flying, duration = 3)
       byte 4,2,_40192%256,_40192/256,120,122,120,123,11,0,131,240,0 ; (#R40192) Edible eyes (Invisibility, duration = 3)
_44998:
       byte 1,1,_52417%256,_52417/256,121,115,121,115,18,0,160,192,0 ; (#R52417) Drutt
       byte 4,2,_50792%256,_50792/256,108,127,108,128,17,0,128,240,0 ; (#R50792) Key
_45024:
       byte 0,0,_53340%256,_53340/256,121,109,121,110,24,0,128,0,0   ; (#R53340) Worm
       byte 5,1,_40040%256,_40040/256,100,100,121,100,128,0,0,240,0  ; (#R40040) Vertical wall
       byte 1,1,_40040%256,_40040/256,100,100,121,100,128,0,0,240,0  ; (#R40040) Vertical wall
       byte 4,1,_40040%256,_40040/256,100,131,121,131,128,0,0,240,0  ; (#R40040) Vertical wall
       byte 4,2,_50800%256,_50800/256,120,129,120,131,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 4,1,_50800%256,_50800/256,121,129,121,131,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
_45102:
       byte 7,1,_40040%256,_40040/256,100,131,121,131,128,0,0,240,0  ; (#R40040) Vertical wall
       byte 255                                                      ; End Marker

* Room Dimension Data (Level 3)
_45116:
       byte 2,16,31,0,21                                             ; (01) Door Room
       byte 2,0,31,0,21                                              ; (02) Weight Room
       byte 2,0,31,0,21                                              ; (03) Large Yellow Creature Room
       byte 2,0,31,0,21                                              ; (04) Hatch Room
       byte 2,0,31,0,21                                              ; (05) Room above Weight Room
       byte 2,0,31,0,21                                              ; (06) Coloured Creatures' Room
       byte 2,0,31,0,21                                              ; (07) Room above Hatch Room
       byte 255                                                      ; End Marker

* Horizontal Room Connectivity Map (Level 3)
_45152:
       byte 1,2                                                      ; Door Room and Weight Room
       byte 2,3                                                      ; Weight Room and Large Yellow Creature Room
       byte 3,4                                                      ; Large Yellow Creature Room and Hatch Room
       byte 5,6                                                      ; Room above Weight Room and Coloured Creatures' Room
       byte 6,7                                                      ; Coloured Creatures' Room and room above Hatch Room
       byte 255,255                                                  ; End Marker

* Unused
* 
* Data Block (09) (Level 3)
_45164:
       byte 255

* Vertical Room Connectivity Map (Level 3)
_45165:
       byte 5,2                                                      ; Room above Weight Room and Weight Room
       byte 7,4                                                      ; Room above Hatch Room and Hatch Room
       byte 255,255                                                  ; End Marker

* State Data for Simple Entities (Level 4)
_45171:
       byte 1,2,_49178%256,_49178/256,100,126                        ; (#R49178) Left brickwork
       byte 1,2,240,195,121,100                                      ; (#R50126) Single arch
       byte 2,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 2,2,_49029%256,_49029/256,100,100                        ; (#R49029) Double Row of Green Bricks (full width)
       byte 2,2,_49178%256,_49178/256,100,107                        ; (#R49178) Left brickwork
       byte 2,2,_49178%256,_49178/256,100,125                        ; (#R49178) Left brickwork
       byte 3,2,_49029%256,_49029/256,100,100                        ; (#R49029) Double Row of Green Bricks (full width)
       byte 3,2,_49178%256,_49178/256,100,114                        ; (#R49178) Left brickwork
       byte 3,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 4,2,_49413%256,_49413/256,117,123                        ; (#R49413) Single wide brick
       byte 4,2,_49029%256,_49029/256,100,100                        ; (#R49029) Double Row of Green Bricks (full width)
       byte 4,1,_50238%256,_50238/256,121,99                         ; (#R50238) Left part of floor
       byte 4,1,_50211%256,_50211/256,121,121                        ; (#R50211) Right part of floor
       byte 5,1,240,195,121,100                                      ; (#R50126) Single arch
       byte 5,1,_49584%256,_49584/256,97,100                         ; (#R49584) Vertical red bar (outside normal game area)
       byte 5,1,_49584%256,_49584/256,102,127                        ; (#R49584) Vertical red bar (outside normal game area)
       byte 5,1,_49489%256,_49489/256,117,100                        ; (#R49489) Snake's Brickwork
       byte 254                                                      ; End Marker

* State Data for Complex Entities (Level 4)
_45274:
       byte 1,1,_50800%256,_50800/256,100,100,101,111,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 1,1,_50800%256,_50800/256,100,119,101,131,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 5,1,_49104%256,_49104/256,100,95,101,110,130,0,0,240,0   ; (#R49104) Two rows of horizontal brickwork (half-width, 1)
       byte 5,1,_49035%256,_49035/256,100,121,101,131,130,0,0,240,0  ; (#R49035) Two rows of horizontal brickwork (half-width, 2)
       byte 5,1,_50800%256,_50800/256,120,100,121,109,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 5,1,_50800%256,_50800/256,121,122,121,131,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 5,2,_50800%256,_50800/256,120,107,120,109,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 5,2,_50800%256,_50800/256,120,120,120,124,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
       byte 4,1,_50800%256,_50800/256,121,127,121,131,50,0,0,48,0    ; (#R50800) Marker (makes Drutt swap depth levels)
_45391:
       byte 1,1,_57428%256,_57428/256,115,102,121,107,31,18,128,192,0 ; (#R57428) Berk
_45404:
       byte 3,1,_42901%256,_42901/256,110,128,121,129,36,0,128,192,0 ; (#R42901) Skeleton
_45417:
       byte 3,0,_50317%256,_50317/256,0,0,0,0,19,0,128,240,2         ; (#R50317) Boni
_45430:
       byte 4,2,_50304%256,_50304/256,113,125,116,126,21,0,128,240,0 ; (#R50304) Fake Boni
_45443:
       byte 1,1,_52417%256,_52417/256,121,115,121,115,18,0,160,192,0 ; (#R52417) Drutt
       byte 4,2,_50792%256,_50792/256,114,118,114,119,17,0,128,240,0 ; (#R50792) Key
_45469:
       byte 0,0,_53340%256,_53340/256,121,109,121,110,24,0,128,0,0   ; (#R53340) Worm
_45482:
       byte 3,1,_51314%256,_51314/256,110,108,114,110,30,0,0,48,0    ; (#R51314) Flying Skeleton Creature
_45495:
       byte 5,1,_42648%256,_42648/256,119,83,119,101,30,0,128,0,0    ; (#R42648) Snake
_45508:
       byte 1,1,_42530%256,_42530/256,118,122,121,124,20,0,128,240,0 ; (#R42530) Cannon
_45521:
       byte 2,2,_50800%256,_50800/256,104,107,104,107,40,0,128,0,0   ; (#R50800) 1st drip from left (Red Sausage Room)
       byte 2,2,_50800%256,_50800/256,105,110,105,110,41,0,128,0,0   ; (#R50800) 2nd drip from left (Red Sausage Room)
       byte 2,2,_50800%256,_50800/256,102,115,102,115,43,0,128,0,0   ; (#R50800) 3rd drip from left (Red Sausage Room)
       byte 2,2,_50800%256,_50800/256,103,120,103,120,44,0,128,0,0   ; (#R50800) 4th drip from left (Red Sausage Room)
       byte 2,2,_50800%256,_50800/256,104,128,104,128,45,0,128,0,0   ; (#R50800) 5th drip from left (Red Sausage Room)
       byte 3,2,_50800%256,_50800/256,104,113,104,113,46,0,128,0,0   ; (#R50800) Drip (Skeleton's Room)
_45599:
       byte 0,0,_50800%256,_50800/256,0,0,0,0,30,0,128,0,0           ; (#R50800) Cannon's Projectile
       byte 2,1,_43128%256,_43128/256,121,110,121,111,3,0,128,240,0  ; (#R43128) Red Sausage (Jumping, duration = permanent)
       byte 4,1,_43137%256,_43137/256,121,124,121,125,7,0,134,240,0  ; (#R43137) Cyan Sausage (Flying, duration = 6)
       byte 5,2,_43137%256,_43137/256,120,111,120,112,8,0,131,240,0  ; (#R43137) Cyan Sausage (Flying, duration = 3)
       byte 1,1,_50678%256,_50678/256,113,102,121,109,33,1,0,192,0   ; (#R50678) Door
       byte 1,1,_49173%256,_49173/256,100,100,121,101,128,0,0,240,0  ; (#R49173) Yellow brick column
       byte 1,1,_49173%256,_49173/256,110,109,121,110,30,0,0,0,0     ; (#R49173) Yellow brick column
       byte 1,1,_49571%256,_49571/256,112,102,112,102,30,0,0,0,0     ; (#R49571) Long yellow brick
       byte 2,1,_49392%256,_49392/256,115,131,118,132,128,0,0,240,0  ; (#R49392) Blue and Red Mini Wall
       byte 3,1,_49392%256,_49392/256,115,99,118,100,128,0,0,240,0   ; (#R49392) Blue and Red Mini Wall
       byte 3,1,_49392%256,_49392/256,115,131,118,132,128,0,0,240,0  ; (#R49392) Blue and Red Mini Wall
       byte 4,1,_49392%256,_49392/256,115,99,118,101,128,0,0,240,0   ; (#R49392) Blue and Red Mini Wall
       byte 4,1,_50800%256,_50800/256,120,111,121,120,129,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt fall)
       byte 4,1,_49173%256,_49173/256,102,109,121,110,30,0,0,0,0     ; (#R49173) Yellow brick column
       byte 4,1,_49173%256,_49173/256,101,131,121,132,30,0,0,0,0     ; (#R49173) Yellow brick column
_45794:
       byte 4,1,_42754%256,_42754/256,111,121,114,122,30,0,0,0,0     ; (#R42754) Ghost
       byte 5,1,_50800%256,_50800/256,100,100,101,110,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 5,1,_50800%256,_50800/256,100,121,101,131,130,0,0,240,0  ; (#R50800) Marker (makes Berk and Drutt bounce off or bang
                                                                     ; head)
       byte 5,1,_49535%256,_49535/256,102,104,121,106,128,0,0,16,0   ; (#R49535) Left wall, short
_45846:
       byte 5,1,_49553%256,_49553/256,102,125,121,127,128,0,0,32,0   ; (#R49553) Right wall, long
       byte 255                                                      ; End Marker

* Room Dimension Data (Level 4)
_45860:
       byte 2,0,31,0,21                                              ; (01) Door Room
       byte 2,0,31,0,21                                              ; (02) Five Drips Room
       byte 2,0,31,0,21                                              ; (03) Skeleton's Room
       byte 2,0,31,0,21                                              ; (04) Fake Boni's Room
       byte 2,0,31,0,21                                              ; (05) Pit
       byte 255                                                      ; End Marker

* Horizontal Room Connectivity Map (Level 4)
_45886:
       byte 1,2                                                      ; Door Room and Five Drips Room
       byte 2,3                                                      ; Five Drips Room and Skeleton's Room
       byte 3,4                                                      ; Skeleton's Room and Fake Boni's Room
       byte 255,255                                                  ; End Marker

* Unused
* 
* Data Block (09) (Level 4)
_45894:
       byte 255

* Vertical Room Connectivity Map (Level 4)
_45895:
       byte 4,5                                                      ; Fake Boni's Room and Pit
       byte 255,255                                                  ; End Marker

* Populate Primary Display Buffer with Layout Data for Current Character's Current Room
* 
* Used by the routine at #R34438.
_45899:
       mov  @_34279,hl                 ; LD HL,(34279)     ; Modify instruction at #R46045 with address of Primary Display Buffer...
_45902:
       mov  hl,@_46045+1               ; LD (46046),HL     ; ...
       movb @_34230,a                  ; LD A,(34230)      ; Load C with depth of current character's current room...
       movb a,@c                       ; LD C,A            ; ...
       movb @_34218,a                  ; LD A,(34218)      ; Load B with index of current character's current room...
       movb a,b                        ; LD B,A            ; ...
       movb @bytes+0,d                 ; LD D,0            ; Load D with zero
* Start drawing simple entities
_45915:
       mov  @_34236,ix                 ; LD IX,(34236)     ; Load IX with start address of current level's simple state data
       movb @bytes+6,@e                ; LD E,6            ; Load DE with 6 (as simple state data entries are 6 bytes wide)
_45921:
       movb *ix,a                      ; LD A,(IX+0)       ; Load first byte of current simple state data entry into A
       cb   a,@bytes+255               ; CP 255            ; If this is 255 (end marker for complex state data)...
       jeq  _45961                     ; JR Z,45961        ; ...then skip ahead to #R45961
       cb   a,@bytes+254               ; CP 254            ; If it is not 254 (end marker for level's simple state data)...
       jne  _45939                     ; JR NZ,45939       ; ...then skip ahead to #R45939
* At this point, we have passed the end marker for the simple state data block and are now at the start of the
* complex state data block whose entries are 13 bytes wide.
       movb @bytes+13,@e               ; LD E,13           ; Load DE with 13
       inc  ix                         ; INC IX            ; Advance IX to start of complex state data block
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with entity's room index
* At this point, A holds the index of the room to which the simple or complex entity belongs
_45939:
       cb   a,b                        ; CP B              ; If entity's room is not the same as the current character's current room...
       jne  _45957                     ; JR NZ,45957       ; ...then skip ahead to #R45957
       movb @c,a                       ; LD A,C            ; If entity's depth is not the same as current depth in C...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  _45957                     ; JR NZ,45957       ; ...then skip ahead to #R45957
       .exx                            ; EXX               ; Switch registers
       .push ix                        ; PUSH IX           ; Store IX (pointer to current entry in simple/complex state data)
       bl   @_45965                    ; CALL 45965        ; Load Primary Display Buffer with graphic layout data for current entity
       .pop ix                         ; POP IX            ; Restore IX (pointer to current entry in simple/complex state data)
       .exx                            ; EXX               ; Switch registers
_45957:
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next entity's state data
       jmp  _45921                     ; JR 45921          ; Loop back to #R45921
_45961:
       sb   one,@c                     ; DEC C             ; Decrease current depth (i.e. closer to screen)
       jne  _45915                     ; JR NZ,45915       ; If depth is not zero (i.e. still depth levels to process) then loop back to #R45915
       rt                              ; RET               ; Return

* Populate Primary Display Buffer with Graphic Layout Data for Entity Whose Simple / Complex State Data is at
* Address in IX
* 
* Used by the routine at #R45899. Input:  IX  Address of complex state data for an entity IX  (Entry at #R45999,
* #R46001 or #R46003 only) Address of graphic layout data to draw B  (Entry at #R45999, #R46001 or #R46003 only) 0
* if current position in Display Buffer needs to be recalculated. 1 otherwise.
_45965:
       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load DE with address of graphic layout data for entity...
       movb @3(ix),d                   ; LD D,(IX+3)       ; ...
       movb @_34230+3,a                ; LD A,(34233)      ; Load A with y-coordinate of top edge of current character's current room...
       a    @4(ix),a                   ; ADD A,(IX+4)      ; ...add y-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,@l                       ; LD L,A            ; ...and load into L
       movb @_34230+1,a                ; LD A,(34231)      ; Load A with x-coordinate of left edge of current character's current room...
       a    @5(ix),a                   ; ADD A,(IX+5)      ; ...add x-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,h                        ; LD H,A            ; ...and load into H
       mov  hl,@_34281                 ; LD (34281),HL     ; Store x- and y-coordinates at #R34281
       .push de                        ; PUSH DE           ; Transfer address of graphic layout data in simple/complex state data from DE...
       .pop ix                         ; POP IX            ; ...into IX
       movb @bytes+0,b                 ; LD B,0            ; Reset Do Not Recalculate Display Buffer Address Flag, as address not yet calculated
       jmp  _46003                     ; JR 46003          ; Jump to #R46003 (read / process data at address in IX)
* This entry point is used by the routines at #R46427, #R46442, #R46460 and #R46599.
_45999:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46284, #R46295 and #R46306.
_46001:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46317, #R46347, #R46363, #R46460, #R46481, #R46495, #R46611,
* #R46628, #R46647 and #R46664.
_46003:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of graphic layout data entry is at least 236...
       cb   a,@bytes+236               ; CP 236            ; ...i.e. IX points to an instruction...
       jl   !                          ; JP NC,46218       ; ...then jump to appropriate graphic layout routine
       b    @_46218                    ;                   
!
* At this point, the graphic layout data pointed to by IX is graphical data, not an instruction. We only draw the
* graphics if they lie within the display area (i.e. have x- and y-coordinates less than 32 and 24 respectively, see
* trivia).
       movb h,a                        ; LD A,H            ; If x-coordinate of graphic to draw is 32 or more...
       cb   a,@bytes+32                ; CP 32             ; ...
       jl   !                          ; JP NC,46151       ; ...then skip ahead to #R46151
       b    @_46151                    ;                   
!
       movb @l,a                       ; LD A,L            ; If y-coordinate of graphic to draw is 24 or more...
       cb   a,@bytes+24                ; CP 24             ; ...
       jl   !                          ; JP NC,46151       ; ...then skip ahead to #R46151
       b    @_46151                    ;                   
!
       .push hl                        ; PUSH HL           ; Store HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
       sb   one,b                      ; DEC B             ; Decrease value of Don't Recalculate Display Buffer Address Flag
       jne  !                          ; JP Z,46051        ; If B is zero (i.e. we don't need to recalculate current position in display buffer), then
       b    @_46051                    ;                   
!
                                                           ; skip ahead to #R46051
* If B was 1, then we need to load DE with the address of the current position in the Primary Display Buffer.
       movb h,a                        ; LD A,H            ; Load C with three times entity's x-coordinate...
       a    a,a                        ; ADD A,A           ; ...
       a    h,a                        ; ADD A,H           ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @l,a                       ; LD A,L            ; Load DE with double entity's y-coordinate...
       a    a,a                        ; ADD A,A           ; ...
       movb a,@e                       ; LD E,A            ; ...
       movb @bytes+0,d                 ; LD D,0            ; ...
       movb d,b                        ; LD B,D            ; Set B to zero (BC now holds three times x-coordinate)
       li   hl,_46170                  ; LD HL,46170       ; Point HL at start of Table of Multiples of 96
       a    de,hl                      ; ADD HL,DE         ; Add double y-coordinate as offset
       movb *hl,@e                     ; LD E,(HL)         ; Load DE with corresponding multiple of 96...
       inc  hl                         ; INC HL            ; ...
       movb *hl,d                      ; LD D,(HL)         ; ...
* The operand of the instruction at #R46045 represents the address of the Primary Display Buffer. This is modified
* by the instruction at #R45902.
_46045:
       li   hl,0                       ; LD HL,0           ; Load HL with start address of Primary Display Buffer
       a    de,hl                      ; ADD HL,DE         ; Move HL to position in Primary Display Buffer corresponding to x- and y-coordinates of
                                                           ; entity...
       a    bc,hl                      ; ADD HL,BC         ; ...
       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now points to position in Primary Display Buffer for current entity) and HL
_46051:
       movb *de,a                      ; LD A,(DE)         ; Load A with Graphic Set Index plus one from this entry in Primary Display Buffer...
       ab   one,a                      ; INC A             ; ...and if value is now zero (i.e. old value was 255 corresponding to a block outside
                                                           ; dimensions of room)...
       jne  !                          ; JP Z,46150        ; ...then skip ahead to #R46150
       b    @_46150                    ;                   
!
       movb @_34268,a                  ; LD A,(34268)      ; Load current Graphic Set Index into this location in Primary Display Buffer...
       movb a,*de                      ; LD (DE),A         ; ...
       inc  de                         ; INC DE            ; Advance to Graphic Index in current character block's entry in Primary Display Buffer
       movb *ix,a                      ; LD A,(IX+0)       ; Load Graphic Index into current Display Buffer location...
       movb a,*de                      ; LD (DE),A         ; ...
       inc  de                         ; INC DE            ; Advance to next byte in current character block's display buffer entry (Attribute)
       movb @_34270,a                  ; LD A,(34270)      ; Load Current Attribute into A...
       socb a,a                        ; OR A              ; ...and if not zero...
       jne  _46077                     ; JR NZ,46077       ; ...then skip ahead to #R46077
* Current Attribute is zero (i.e. not set) so DE points to attribute data
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)...
       movb *ix,a                      ; LD A,(IX+0)       ; ...and load into A
* At this point, A holds an attribute value either from the graphic layout data, or the Current Attribute as stored
* at #R34270. This attribute is to be applied to the current display buffer location. IX (current position in
* graphic layout data) is pointing to either the graphic index (if the Current Attribute at #R34270 is set) or the
* attribute data (if the Current Attribute is not set). In either case, IX+1 is the address of the Cursor Shift
* byte. Bit 7 of the Cursor Shift byte is the Override Attribute Flag.
_46077:
       mov  @1(ix),tmp0                ; BIT 7,(IX+1)      ; If bit 7 (Override Attribute Flag) is set...
       andi tmp0,128                   ;                   
       jeq  !                          ; JP NZ,46111       ; ...then skip ahead to #R46111
       b    @_46111                    ;                   
!
* Override Attribute Flag reset
       movb a,@l                       ; LD L,A            ; Load L with attribute value
       andi a,56*256                   ; AND 56            ; Check PAPER bits
       movb @l,a                       ; LD A,L            ; Restore attribute value to A
       jeq  !                          ; JP NZ,46111       ; If PAPER is not zero (i.e. black) then skip ahead to #R46111
       b    @_46111                    ;                   
!
* The instructions between #R46091 and #R46110 (inclusive) are executed only when the PAPER component of the
* attribute in A (and L) is black. If the Preserve INK Flag is reset in the attribute value loaded (at #R46098) from
* the Display Buffer, then the instruction at #R46107 will leave the reset (i.e. black) PAPER bits in A. If the
* Preserve INK Flag is set, then the instructions between #R46104 and #R46106 (inclusive) will shift the bits used
* for INK into the PAPER positions and this PAPER colour (originally INK colour) will be preserved when the
* instruction at #R46107 is executed.
_46091:
       equ  $
       andi a,192*256                  ; AND 192           ; Reset all bits except Preserve INK and Mirror flags
       movb a,b                        ; LD B,A            ; Load B with Preserve INK and Mirror flags
       movb @l,a                       ; LD A,L            ; Restore attribute value to A
       andi a,63*256                   ; AND 63            ; Reset bits Preserve INK and Mirror flags
       movb a,@c                       ; LD C,A            ; Load C with INK and PAPER bits of attribute value
_46098:
       movb *de,a                      ; LD A,(DE)         ; Load value currently in Display Buffer into A...
       mov  a,tmp0                     ; BIT 6,A           ; ...and if Preserve INK Flag is reset...
       andi tmp0,64                    ;                   
       jne  !                          ; JP Z,46107        ; ...then skip ahead to #R46107
       b    @_46107                    ;                   
!
* Preserve INK Flag set in Display Buffer
_46104:
       equ  $
       a    a,a                        ; ADD A,A           ; Shift INK bits into PAPER bits...
       a    a,a                        ; ADD A,A           ; ...
_46106:
       a    a,a                        ; ADD A,A           ; ...
_46107:
       andi a,56*256                   ; AND 56            ; Reset all except PAPER bits
       socb b,a                        ; OR B              ; (Re)set Preserve INK and Mirror flags as stored in B previously
_46110:
       socb @c,a                       ; OR C              ; Set INK bits as stored in C previously (PAPER was black)
_46111:
       movb a,*de                      ; LD (DE),A         ; Load attribute in A into Display Buffer
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
* Read Cursor Shift byte. Bits 0-6 of this byte control where the cursor to write to Primary Display Buffer is moved
* to after writing the current character block. A value of 33 advances the cursor right by one character. A value,
* n, less than 33 moves the cursor down a character row, and left by 33-(n+1) characters. A value greater than 33
* moves the cursor right by (n+1)-33 characters. Bit 7 is the Override Attribute Flag.
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (End Marker)...
       jne  !                          ; JP Z,46418        ; ...then jump to #R46418 (load HL with stored coordinates from #R34281 and return from
       b    @_46418                    ;                   
!
                                                           ; drawing)
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33, and if remaining value is 0 (i.e. original value was 33)...
       jne  !                          ; JP Z,46140        ; ...then skip ahead to #R46140...
       b    @_46140                    ;                   
!
_46128:
       equ  $
       joc  !                          ; JP NC,46132       ; TODO: check code. ...else, if value was greater than 33 then skip ahead to #R46132
       b    @_46132                    ;                   
!
* Cursor Shift byte was less than 33 (move the cursor down a character row, and left by 33-(n+1) characters)
       ab   one,@l                     ; INC L             ; Increase y-coordinate
_46132:
       ab   one,a                      ; INC A             ; Increase A (x-coordinate offset) and add to x-coordinate...
       a    h,a                        ; ADD A,H           ; ...
       movb a,h                        ; LD H,A            ; ...
_46135:
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address as change in coordinates is non-trivial
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* Cursor Shift byte was 33 (move the cursor right by one character)
_46140:
       inc  de                         ; INC DE            ; Advance pointer to start of next entry in Primary Display Buffer
       ab   one,h                      ; INC H             ; Increase x-coordinate by one
       jne  !                          ; JP Z,46135        ; If x-coordinate is zero then jump back to #R46135 (see trivia)
       b    @_46135                    ;                   
!
       movb one,b                      ; LD B,1            ; Prepare to skip over recalculation of Display Buffer address as we moved right one character
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* First byte in Primary Display Buffer entry for current position is 255 (i.e. outside dimensions of room)
_46150:
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
_46151:
       movb @_34270,a                  ; LD A,(34270)      ; Load Current Attribute into A...
       socb a,a                        ; OR A              ; ...and if not zero...
       jeq  !                          ; JP NZ,46160       ; ...then skip ahead to #R46160
       b    @_46160                    ;                   
!
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)
_46160:
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33...
       b    @_46128                    ; JP 46128          ; ...and jump back to #R46128 to update current drawing position

* Table of Multiples of 96
* 
* Used in calculating position in Display Buffer data for a given y-coordinate (as Display Buffer data is 3 bytes
* per character block, so 1 character row's worth of data is 3 x 32 = 96 bytes
_46170:
       data 0
       data 96
       data 192
       data 288
       data 384
       data 480
       data 576
       data 672
       data 768
       data 864
       data 960
       data 1056
       data 1152
       data 1248
       data 1344
       data 1440
       data 1536
       data 1632
       data 1728
       data 1824
       data 1920
       data 2016
       data 2112
       data 2208

* Jump to Appropriate Graphic Layout Routine
* 
* Used by the routine at #R45965. Input:  A  Index of graphic layout data instruction IX  Address of current graphic
* layout data instruction
_46218:
       inc  ix                         ; INC IX            ; Advance IX to first parameter byte in graphic layout data
       sb   @bytes+236,a               ; SUB 236           ; Subtract 236 to get zero-based index of required instruction
       a    a,a                        ; ADD A,A           ; Load double index of graphic layout data instruction into BC...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+0,b                 ; LD B,0            ; ...
       .push hl                        ; PUSH HL           ; Store HL
       li   hl,_46244                  ; LD HL,46244       ; Point HL at start of Table of Addresses of Graphic Layout Data Handling Routines
       a    bc,hl                      ; ADD HL,BC         ; Add doubled instruction index as offset to HL to point to address of required routine
       movb *hl,a                      ; LD A,(HL)         ; Modify JP instruction at #R46241 with this address...
_46232:
       mov  a,@_46241+1                ; LD (46242),A      ; ...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; ...
       mov  a,@_46241+2                ; LD (46243),A      ; ...
       .pop hl                         ; POP HL            ; Restore HL
* The operand of the instruction at #R46241 represents the addresses of the required graphic layout data handling
* routine. This is modified by the instruction at #R46232.
_46241:
       b    0                          ; JP 0              ; TODO. 

* Table of Addresses of Graphic Layout Data Handling Routines
* 
* Graphic layout data is stored in the form of encoded instructions. Generally an instruction is simply to display a
* graphic of given index with a given attribute and then to advance the position of the drawing "cursor". If the
* first byte (normally the graphic index) is 236 or greater, however, then we are dealing with a special
* instruction; the values 236 and above can be considered to be opcodes. These opcodes correspond to calls/jumps to
* routines at addresses stored in this table. The opcodes all take different combinations of parameters.
_46244:
       data _46317                                                   ; (236)
       data _46284                                                   ; (237)
       data _46611                                                   ; (238)
       data _46628                                                   ; (239)
       data _46647                                                   ; (240)
       data _46664                                                   ; (241)
       data _46295                                                   ; (242)
       data _46559                                                   ; (243)
       data _46306                                                   ; (244)
       data _46347                                                   ; (245)
       data _46363                                                   ; (246)
       data _46577                                                   ; (247)
       data _46481                                                   ; (248)
       data _46495                                                   ; (249)
       data _46427                                                   ; (250)
       data _46460                                                   ; (251)
       data _46599                                                   ; (252)
       data _46594                                                   ; (253)
       data _46442                                                   ; (254)
       data _46418                                                   ; (255)

* Graphic Layout Routine (237) Set New Pending Sound Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
_46284:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
       bl   @_59613                    ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46001                    ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (242) Set Current Attribute Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
_46295:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       mov  a,@_34270                  ; LD (34270),A      ; ...and set as current Attribute
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46001                    ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (244) Set Current Graphic Set Index Input:  IX  Address of first parameter in current
* graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
_46306:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       mov  a,@_34268                  ; LD (34268),A      ; ...and set as current Graphic Set Index
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46001                    ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (236) Set Graphic Index in Next Instruction to Value Randomly Selected from List
* 
* Read Current Byte (n, random number cap), generate random number m (1 to n inclusive) and copy the m-th byte in
* following list into position after end of list bytes (i.e. the graphic index field of the next graphic layout data
* entry), then advance current position to this location. Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic
* layout data instruction to process
_46317:
       .push ix                        ; PUSH IX           ; Store current position in graphic layout data
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte (Random Number Cap) from graphic layout data into A...
       movb a,@e                       ; LD E,A            ; ...and copy into E
       bl   @_54222                    ; CALL 54222        ; Load BC with a random number, 1-A...
       ab   one,a                      ; INC A             ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by number of bytes stored in BC
       movb *ix,a                      ; LD A,(IX+0)       ; Load byte at this location into A
       .pop ix                         ; POP IX            ; Restore previous position in graphic layout data
       movb @e,@c                      ; LD C,E            ; Load Random Number Cap into BC...
       ab   one,@c                     ; INC C             ; ...and add one
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by this number of bytes
       movb a,*ix                      ; LD (IX+0),A       ; Store byte previously read at current position
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (245) Decrease Timer Value, and if Zero, Reset and Write Random Graphic Index from List
* into Next Instruction
* 
* Decrease timer value (1st parameter). If now zero, then reset timer to value in 2nd parameter, then load one of
* the n (3rd parameter) following values chosen at random into the Graphic Index field of the next instruction.
* Input:  IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate
* Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
_46347:
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease timer value
       jne  _46370                     ; JR NZ,46370       ; If timer is not zero, then advance IX to start of next instruction and process
       bl   @_46385                    ; CALL 46385        ; Reset timer to maximum, advance IX to start of next instruction and set value here (graphic
                                                           ; index) to random value from sequence of data following previous instruction...
       movb @e,*ix                     ; LD (IX+0),E       ; ...
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (246) Decrease Timer Value, and if Zero, Reset and Write Random Attribute from List into
* Next Instruction
* 
* Decrease timer value (1st parameter). If now zero, then reset timer to value in 2nd parameter, then load one of
* the n (3rd parameter) following values chosen at random into the Attribute field of the next instruction. Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
_46363:
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease timer value
       jeq  _46376                     ; JR Z,46376        ; If timer is zero, then reset timer, advance to next instruction and set that instruction's
                                                           ; attribute to random value from sequence
* This entry point is used by the routine at #R46347.
_46370:
       bl   @_46409                    ; CALL 46409        ; Advance to next instruction and process...
       b    @_46003                    ; JP 46003          ; ...
_46376:
       bl   @_46385                    ; CALL 46385        ; Reset timer to maximum, advance IX to start of next instruction and set second value here
                                                           ; (attribute) to random value from sequence of data following previous instruction...
       movb @e,@1(ix)                  ; LD (IX+1),E       ; ...
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Reset Timer to Initial Value then Load E with Random Value from Sequence (in Graphic Layout Data)
* 
* Used by the routines at #R46347 and #R46363. Input:  B  Always zero IX  Current address in graphic layout data
_46385:
       movb @1(ix),a                   ; LD A,(IX+1)       ; Set current timer value to maximum...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       movb @2(ix),a                   ; LD A,(IX+2)       ; Load A with number of states
       bl   @_54222                    ; CALL 54222        ; Set C to a random number between 3 and (number of states + 2)...
       a    @bytes+3,a                 ; ADD A,3           ; ...
       movb a,@c                       ; LD C,A            ; ...
       .push ix                        ; PUSH IX           ; Store IX (current position in graphic layout data)
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by C bytes (BC = C, as B = 0)
       movb *ix,@e                     ; LD E,(IX+0)       ; Load E with value at this position
       .pop ix                         ; POP IX            ; Restore IX (old position in graphic layout data)
* This entry point is used by the routine at #R46363.
_46409:
       movb @2(ix),a                   ; LD A,(IX+2)       ; Advance IX by number of states + 3 bytes to arrive at start of next data...
       a    @bytes+3,a                 ; ADD A,3           ; ...
       movb a,@c                       ; LD C,A            ; ...
       a    bc,ix                      ; ADD IX,BC         ; ...
       rt                              ; RET               ; Return

* Graphic Layout Routine (255) Load HL with Stored Coordinates from 34281 and Return from Drawing
* 
* Note that when returning from another block of graphic layout data, the Current Attribute stored at #R34270 (and
* set in the called block) is not preserved. Upon returning, the Current Attribute value is cleared. Output: B  Do
* Not Recalculate Display Buffer Address Flag (0) H  Current x-coordinate L  Current y-coordinate
_46418:
       sb   a,a                        ; XOR A             ; Set Current Attribute to zero...
       mov  a,@_34270                  ; LD (34270),A      ; ...
_46422:
       mov  @_34281,hl                 ; LD HL,(34281)     ; Load HL with base x- and y-coordinates
       movb a,b                        ; LD B,A            ; Set B to zero
       rt                              ; RET               ; Return

* Graphic Layout Routine (250) Adjust x- and y-Coordinates for Drawing Without Storing
* 
* Read following two bytes in graphic layout data and adjust y- and x-coordinates by these amounts respectively,
* without storing. These new coordinates will be lost on the next draw operation, being overwritten by the values
* stored at #R34281. Input:  IX  Address of first parameter in current graphic layout data instruction Output: B  Do
* Not Recalculate Display Buffer Address Flag (0)
_46427:
       movb *ix,a                      ; LD A,(IX+0)       ; Read delta-y into A...
       a    @l,a                       ; ADD A,L           ; ...and adjust y-coordinate by this amount...
       movb a,@l                       ; LD L,A            ; ...
       movb @1(ix),a                   ; LD A,(IX+1)       ; Read delta-x into A...
       a    h,a                        ; ADD A,H           ; ...and adjust x-coordinate by this amount...
       movb a,h                        ; LD H,A            ; ...
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (254) Adjust x- and y-Coordinates for Drawing and Set as New Base Coordinates
* 
* Read following two bytes in graphic layout data and adjust y- and x-coordinates by these amounts respectively,
* storing at #R34281 as base coordinates. These new coordinates will be used as the starting position on the next
* draw operation. Input:  H  Current x-coordinate L  Current y-coordinate IX  Address of first parameter in current
* graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
_46442:
       movb *ix,a                      ; LD A,(IX+0)       ; Read delta-y into A...
       a    @l,a                       ; ADD A,L           ; ...and adjust y-coordinate by this amount...
       movb a,@l                       ; LD L,A            ; ...
       movb @1(ix),a                   ; LD A,(IX+1)       ; Read delta-x into A...
       a    h,a                        ; ADD A,H           ; ...and adjust x-coordinate by this amount...
       movb a,h                        ; LD H,A            ; ...
       mov  hl,@_34281                 ; LD (34281),HL     ; Store new coordinates at #R34281
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (251) Process Graphic Layout Data at Following Address and Return When Complete
* 
* Functionally equivalent to "CALL" instruction. Read current WORD (address) from graphic layout data, load graphic
* layout data at that address into Primary Display Buffer and return to previous position. Upon returning (via
* routine at #R46418 when a 255 is encountered), the position of the cursor (i.e. the value in HL) is reset to the
* base coordinates as stored at #R34281 - see instruction at #R46422. Input:  IX  Address of first parameter in
* current graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
_46460:
       movb *ix,@c                     ; LD C,(IX+0)       ; Load BC with destination graphic layout data address...
       movb @1(ix),b                   ; LD B,(IX+1)       ; ...
       .push ix                        ; PUSH IX           ; Store IX (current position in graphic layout data)
       .push bc                        ; PUSH BC           ; Transfer address just read into BC into IX...
       .pop ix                         ; POP IX            ; ...
       bl   @_46003                    ; CALL 46003        ; Load graphic layout data from this new location into Primary Display Buffer (recursive call)
       .pop ix                         ; POP IX            ; Restore IX (previously stored position in graphic layout data)
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (248) Jump to Graphic Layout Data Address
* 
* Read current WORD (address) from graphic layout data and move graphic layout data Pointer to this address. Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
_46481:
       movb *ix,@c                     ; LD C,(IX+0)       ; Load next two bytes as a WORD into IX...
       movb @1(ix),b                   ; LD B,(IX+1)       ; ...
       .push bc                        ; PUSH BC           ; ...
       .pop ix                         ; POP IX            ; ...
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (249) Jump to Time-Weighted, Randomly Selected Graphic Layout Data Address in List Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
_46495:
       .push ix                        ; PUSH IX           ; Store IX (pointer to first parameter in graphic layout data)
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with current state number
       a    a,a                        ; ADD A,A           ; Multiply A by four and add two...
       a    a,a                        ; ADD A,A           ; ...to give number of bytes of data to skip over...
       a    @bytes+2,a                 ; ADD A,2           ; ...
       movb a,@c                       ; LD C,A            ; Load BC with value in A...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; ...and add to IX to advance to start of data for current state
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease the timer value for this state...
       jne  _46544                     ; JR NZ,46544       ; ...and if not zero, skip ahead to #R46544
       .pop ix                         ; POP IX            ; Restore (pointer to first parameter in graphic layout data)
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with random number...
       bl   @_54222                    ; CALL 54222        ; ...from zero to one less than number of states...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and set this as the index of the current state
       a    a,a                        ; ADD A,A           ; Multiply A by four and add two...
       a    a,a                        ; ADD A,A           ; ...to give number of bytes of data to skip over...
       a    @bytes+2,a                 ; ADD A,2           ; ...
       movb a,@c                       ; LD C,A            ; Load BC with value in A
       a    bc,ix                      ; ADD IX,BC         ; Advance IX to start of data for (new) current state
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with random number...
       bl   @_54222                    ; CALL 54222        ; ...from one to maximum timer value for state...
       ab   one,a                      ; INC A             ; ...
       movb a,*ix                      ; LD (IX+0),A       ; ...and set as current timer value for this state
       jmp  _46545                     ; JR 46545          ; Skip ahead to #R46545
_46544:
       .pop bc                         ; POP BC            ; Restore BC (graphic layout data position, was previously in IX)
_46545:
       movb @2(ix),@c                  ; LD C,(IX+2)       ; Load IX with graphic layout data address...
       movb @3(ix),b                   ; LD B,(IX+3)       ; ...in current state's data...
       .push bc                        ; PUSH BC           ; ...
       .pop ix                         ; POP IX            ; ...
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (243) Increment Index, n, and Jump to n-th Address in Following List
* 
* Read first parameter (n) from graphic layout data, increment (resetting to zero if it is equal to the length of
* the list of addresses as specified by the second parameter) and jump to n-th address. Input:  IX  Address of first
* parameter in current graphic layout data instruction Output: A  Number of bytes in graphic layout data to skip
* over
_46559:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
       ab   one,a                      ; INC A             ; Increase by one
       cb   a,@1(ix)                   ; CP (IX+1)         ; If following byte (cap value) is greater than current byte...
       jl   _46569                     ; JR C,46569        ; ...then skip ahead to #R46569
       sb   a,a                        ; XOR A             ; Reset current value to zero as cap value reached
_46569:
       movb a,*ix                      ; LD (IX+0),A       ; Load current value back into current position in graphic layout data
       a    a,a                        ; ADD A,A           ; Load double current value + 2 (as we're skipping over first two bytes and subsequent data are
                                                           ; WORD addresses) into A...
       a    @bytes+2,a                 ; ADD A,2           ; ...
       jmp  _46586                     ; JR 46586          ; Jump to #R46586

* Graphic Layout Routine (247) Jump to Randomly Selected Graphic Layout Data Address from List
* 
* Read current byte value (n) from graphic layout data, generate random number m (0 - n-1) then jump to address in
* m-th WORD after current position. Input:  A  (Entry at #R46585) Number of words in graphic layout data to skip
* over A  (Entry at #R46586) Number of bytes in graphic layout data to skip over IX  Address of first parameter in
* current graphic layout data instruction Output: IX  Address of next graphic layout data instruction to process
_46577:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
       inc  ix                         ; INC IX            ; Advance pointer to next byte
       bl   @_54222                    ; CALL 54222        ; Load A with a random number between 0 and (A-1)
* This entry point is used by the routine at #R46594.
_46585:
       a    a,a                        ; ADD A,A           ; Double the number
* This entry point is used by the routine at #R46559.
_46586:
       movb a,@c                       ; LD C,A            ; Load BC with offset value in A...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by offset value
       b    @_46481                    ; JP 46481          ; Jump to #R46481 (set current position in graphic layout data to value of WORD at this
                                                           ; address)

* Graphic Layout Routine (253) Jump to Graphic Layout Data Address Selected from List, Based Upon Width of Berk's
* Carried Entity Output: A  Number of words in graphic layout data to skip over
_46594:
       movb @_34272,a                  ; LD A,(34272)      ; Load A with width of entity (characters) carried by Berk, minus 1
       jmp  _46585                     ; JR 46585          ; Set current position in graphic layout data to value of A-th word in list

* Unused routine
* 
* Graphic layout routine (252): if Berk is holding nothing then jump to address. Input:IX Address of first parameter
* in current graphic layout data instruction Output:B Do Not Recalculate Display Buffer Address Flag (0)
_46599:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,46481        ; ...then jump to #R46481 (set current position in graphic layout data to value of WORD at this
       b    @_46481                    ;                   
!
                                                           ; address)
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_45999                    ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (238) Start Loop (1 / 2)
* 
* Start a loop in graphic layout data. The parameter is the repeat count. The current value of the repeat counter is
* stored at #R34274 and the address of the next instruction (i.e. the first instruction that is processed in each
* loop) is stored at #R34294. Input:  IX  Address of first parameter in current graphic layout data instruction
* Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction
* to process
_46611:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       mov  a,@_34274                  ; LD (34274),A      ; ...into #R34274 (repeat counter)
       inc  ix                         ; INC IX            ; Advance IX to next position in graphic layout data...
       mov  ix,@_34294                 ; LD (34294),IX     ; ...and store at #R34294
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (239) End Loop (1 / 2) Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX
* Address of next graphic layout data instruction to process
_46628:
       movb @_34274,a                  ; LD A,(34274)      ; Decrement repeat counter...
       sb   one,a                      ; DEC A             ; ...
       mov  a,@_34274                  ; LD (34274),A      ; ...
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       jne  !                          ; JP Z,46003        ; If repeat counter is zero, then exit loop and process subsequent bytes...
       b    @_46003                    ;                   
!
       mov  @_34294,ix                 ; LD IX,(34294)     ; ...else, restore stored position in graphic layout data (start of loop)...
       b    @_46003                    ; JP 46003          ; ...and continue processing data from this point

* Graphic Layout Routine (240) Start Loop (2 / 2)
* 
* Start a loop in graphic layout data. The parameter is the repeat count. The current value of the repeat counter is
* stored at #R34275 and the address of the next instruction (i.e. the first instruction that is processed in each
* loop) is stored at #R34296. Input:  IX  Address of first parameter in current graphic layout data instruction
* Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction
* to process
_46647:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       mov  a,@_34275                  ; LD (34275),A      ; ...into #R34275 (repeat counter)
       inc  ix                         ; INC IX            ; Advance IX to next position in graphic layout data...
       mov  ix,@_34296                 ; LD (34296),IX     ; ...and store at #R34296
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @_46003                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (241) End Loop (2 / 2) Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX
* Address of next graphic layout data instruction to process
_46664:
       movb @_34275,a                  ; LD A,(34275)      ; Decrement repeat counter...
       sb   one,a                      ; DEC A             ; ...
       mov  a,@_34275                  ; LD (34275),A      ; ...
       movb @bytes+0,b                 ; LD B,0            ; Prepare to recalculate Display Buffer address
       jne  !                          ; JP Z,46003        ; If repeat counter is zero, then exit loop and process subsequent bytes...
       b    @_46003                    ;                   
!
       mov  @_34296,ix                 ; LD IX,(34296)     ; ...else, restore stored position in graphic layout data (start of loop)...
       b    @_46003                    ; JP 46003          ; ...and continue processing data from this point

* Current Keyboard Controls
_46683:
       text 'X'                                                      ; Right
       text 'Z'                                                      ; Left
       text 'A'                                                      ; Forward
       text 'Q'                                                      ; Back
       text 'C'                                                      ; Berk / Drutt
       text 'P'                                                      ; Pause
       text 'R'                                                      ; Restart

* Table of Attribute File Addresses for Main Menu Strings
_46690:
       data 22666                                                    ; "S   START   "
       data 22762                                                    ; "K NEW KEYS  "
_46694:
       data 22851                                                    ; "J +KEMPSTON "
_46696:
       data 22947                                                    ; "   RIGHT    "
       data 23043                                                    ; "   LEFT     "
       data 23139                                                    ; "   FORWARD  "
       data 22865                                                    ; "   BACK     "
       data 22961                                                    ; "   BERK/DRUT"
       data 23057                                                    ; "   PAUSE    "
       data 23153                                                    ; "   RESTART  "

* Table of Main Menu Strings
_46710:
       text 'S   START   '
       text 'K NEW KEYS  '
       text 'J +KEMPSTON '
       text '   RIGHT    '
       text '   LEFT     '
       text '   FORWARD  '
       text '   BACK     '
       text '   BERK/DRUT'                                           ; (see bugs)
       text '   PAUSE    '
       text '   RESTART  '

* Display and Handle Main Menu
* 
* Used by the routine at #R34438.
_46830:
       movb one,a                      ; LD A,1            ; Load A with 1 (blue)
       mov  a,@_34217                  ; LD (34217),A      ; Store at #R34217 and...
       ; OUT (254),A                   ; OUT (254),A       ; ...set border to this value (blue)
       movb @bytes+9,a                 ; LD A,9            ; Fill top 22 rows of Attribute File with blue PAPER & blue INK...
       bl   @_53649                    ; CALL 53649        ; ...
       bl   @_47140                    ; CALL 47140        ; Print "THROUGH the TRAPDOOR" string
       bl   @_47628                    ; CALL 47628        ; Print SCORE / TOTAL / HI-SC string in current character's colours
       li   ix,_46690                  ; LD IX,46690       ; Point IX at Table of Attribute File Addresses for Main Menu Strings
       li   iy,_46710                  ; LD IY,46710       ; Point IY at start of Table of Main Menu Strings
       movb @bytes+112,a               ; LD A,112          ; Load A with 112 (black INK on yellow PAPER)
       mov  a,@_34269                  ; LD (34269),A      ; Store at #R34269
       movb @bytes+10,b                ; LD B,10           ; Load B with 10 as there are 10 strings to print (loop counter)
_46863:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of strings to print)
       movb *ix,@l                     ; LD L,(IX+0)       ; Load Attribute File address at which to print text into HL...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       movb @bytes+12,b                ; LD B,12           ; Load B with 12 as there are 12 characters to print (loop counter)
_46872:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining characters to print)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load E with text character to print
       bl   @_47682                    ; CALL 47682        ; Print double-height text character in E
       inc  iy                         ; INC IY            ; Advance IY to next character in text to print
       inc  hl                         ; INC HL            ; Advance to next Attribute File location
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining characters to print)
       sb   one,b                      ; DJNZ 46872        ; Loop back for next character
       jne  _46872                     ;                   
       inc  ix                         ; INC IX            ; Advance IX to next entry in list of Attribute File addresses to print to...
       inc  ix                         ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of strings to print)
       sb   one,b                      ; DJNZ 46863        ; Loop back for next string
       jne  _46863                     ;                   
       bl   @_46946                    ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl   @_47084                    ; CALL 47084        ; Print keyboard controls on main menu
* This entry point is used by the routine at #R46968.
_46900:
       bl   @_47955                    ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
       cb   a,@bytes+83                ; CP 83             ; If pressed key was not 83 (S)...
       jne  _46915                     ; JR NZ,46915       ; ...then skip ahead to #R46915
       movb @bytes+2,a                 ; LD A,2            ; Set current border colour to red...
       mov  a,@_34217                  ; LD (34217),A      ; ...
       ; OUT (254),A                   ; OUT (254),A       ; ...
       rt                              ; RET               ; Return
_46915:
       cb   a,@bytes+74                ; CP 74             ; If pressed key was not 74 (J)...
       jne  _46968                     ; JR NZ,46968       ; ...then jump to #R46968 (if "K" pressed then redefine controls)
       movb @_34298,a                  ; LD A,(34298)      ; If we are in Joystick Mode...
       socb a,a                        ; OR A              ; ...
       jne  _46937                     ; JR NZ,46937       ; ...then skip ahead to #R46937
       bl   @_47043                    ; CALL 47043        ; If Kempston Interface not present, or Kempston Joystick moved / fire pressed...
       joc  _46900                     ; JR C,46900        ; TODO: check code. ...then jump to #R46900
       movb one,a                      ; LD A,1            ; Set Joystick Mode to On...
       mov  a,@_34298                  ; LD (34298),A      ; ...(see trivia)
       jmp  _46938                     ; JR 46938          ; Skip ahead to #R46938
_46937:
       sb   one,a                      ; DEC A             ; Set Joystick Mode to Off...
_46938:
       mov  a,@_34298                  ; LD (34298),A      ; ...
       bl   @_46946                    ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       jmp  _46900                     ; JR 46900          ; Loop back to #R46900

* Draw Joystick "J" (Main Menu) in Colour Depending Upon Joystick Mode
* 
* Used by the routine at #R46830.
_46946:
       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode Flag is set...
       socb a,a                        ; OR A              ; ...
       jne  _46956                     ; JR NZ,46956       ; ...then skip ahead to #R46956
       movb @bytes+112,a               ; LD A,112          ; Load A with attribute value for black INK, yellow PAPER, BRIGHT
       jmp  _46958                     ; JR 46958          ; Skip ahead to #R46958
_46956:
       movb @bytes+114,a               ; LD A,114          ; Load A with attribute value for red INK, yellow PAPER, BRIGHT
_46958:
       movb @bytes+74,@e               ; LD E,74           ; Load E with 74 (index for character "J")
       li   ix,_46694                  ; LD IX,46694       ; Point IX at entry for "J +KEMPSTON " in table of Attribute File addresses at which to print
                                                           ; menu strings
       bl   @_47071                    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
       rt                              ; RET               ; Return

* If "K" Pressed then Redefine Controls
* 
* Used by the routine at #R46830. Input:  A  ASCII code of pressed key
_46968:
       cb   a,@bytes+75                ; CP 75             ; If pressed key was not 75 (K)...
       jne  _46900                     ; JR NZ,46900       ; ...then jump to Main Menu handling routine at #R46900
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
       li   hl,_46683                  ; LD HL,46683       ; Point HL at start of Table of Current Keyboard Controls
_46977:
       movb @bytes+63,*hl              ; LD (HL),63        ; Set current entry in table to 63 (ASCII code for "?")
       inc  hl                         ; INC HL            ; Advance HL to next entry
       sb   one,b                      ; DJNZ 46977        ; Decrease remaining number of controls to change and loop back to #R46977 if not zero
       jne  _46977                     ;                   
       movb @bytes+112,a               ; LD A,112          ; Load A with the attribute value for black INK, yellow PAPER, BRIGHT
       bl   @_47084                    ; CALL 47084        ; Print keyboard controls on main menu
       li   iy,_46683                  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       li   ix,_46696                  ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
                                                           ; print for main menu
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
_46997:
       .push bc                        ; PUSH BC           ; Store BC (remaining number of controls to define)
       movb @bytes+198,a               ; LD A,198          ; Load A with 198 (yellow INK, black PAPER, BRIGHT, FLASH)
       movb @bytes+32,@e               ; LD E,32           ; Load E with 32 (" ")
       bl   @_47071                    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
_47005:
       bl   @_47955                    ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
       bl   @_47060                    ; CALL 47060        ; If key pressed matches a direction, or the Berk / Drutt key...
       jeq  _47005                     ; JR Z,47005        ; ...then loop back to #R47005
       movb a,@e                       ; LD E,A            ; Load keycode of pressed control into E...
       movb @e,*iy                     ; LD (IY+0),E       ; ...and store in Table of Current Keyboard Controls
       inc  iy                         ; INC IY            ; Advance IY to next control
       movb @bytes+113,a               ; LD A,113          ; Load A with 113 (blue INK, yellow PAPER, BRIGHT)
       bl   @_47071                    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
       inc  ix                         ; INC IX            ; Advance IX to next entry in table of Attribute File addresses...
       inc  ix                         ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (remaining number of controls to define)
       sb   one,b                      ; DJNZ 46997        ; Decrease remaining number of controls to define and loop back to #R46997 if not zero
       jne  _46997                     ;                   
       sb   a,a                        ; XOR A             ; Switch Joystick Mode to Off...
       mov  a,@_34298                  ; LD (34298),A      ; ...
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl   @_47084                    ; CALL 47084        ; Print keyboard controls on main menu
       b    @_46900                    ; JP 46900          ; Jump to Main Menu handling routine at #R46900

* Set Carry Flag if Kempston Interface not Present, or Kempston Joystick Moved / Fire Pressed
* 
* Used by the routine at #R46830. Output: F  Carry Flag set if Kempston Interface not present, Kempston Joystick
* moved or fire pressed, reset otherwise
_47043:
       movb @bytes+0,b                 ; LD B,0            ; Set B to zero (to repeat check loop 256 times)
_47045:
       ; IN A,(31)                     ; IN A,(31)         ; Read value from Port 31 into A (Kempston Interface)
       socb a,a                        ; OR A              ; If retrieved value is not zero (i.e. Kempston Interface not present, or Kempston Joystick not
                                                           ; centred / fire button pressed)...
       jne  _47053                     ; JR NZ,47053       ; ...then skip ahead to #R47053
       sb   one,b                      ; DJNZ 47045        ; Decrease B (loop counter) and loop back to #R47045 to check Kempston status again if counter
       jne  _47045                     ;                   
                                                           ; not zero
       rt                              ; RET               ; Return
_47053:
       movb @bytes+6,a                 ; LD A,6            ; Set sound 6 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
       ; SCF                           ; SCF               ; Set Carry Flag
       rt                              ; RET               ; Return

* Set Zero Flag if Key Whose Index is in A Matches a Direction, or the Berk / Drutt Key
* 
* Used by the routine at #R46968. Input:  A  Index of pressed key Output: F  Zero Flag set if input key index
* matches an entry in table at #R46683, reset otherwise HL  Address of matching entry in table at #R46683 (if match
* found)
_47060:
       li   hl,_46683                  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
       movb @bytes+5,b                 ; LD B,5            ; Load B with 5 (as we are checking the first five defined keys, see bugs)
_47065:
       cb   a,*hl                      ; CP (HL)           ; If character code at current HL position matches the key we are checking...
       jne  !                          ; RET Z             ; ...then return with Zero Flag set
       rt                              ;                   
!
       inc  hl                         ; INC HL            ; Advance HL to next character in keyboard controls table
       sb   one,b                      ; DJNZ 47065        ; Loop back to #R47065 to check next control
       jne  _47065                     ;                   
       rt                              ; RET               ; Return

* Set Attribute and Location and Print Double-Height Character in E
* 
* Used by the routines at #R46946 and #R46968. Input:  A  Attribute for character to print E  Character to print IX
* Points to memory location holding Attribute File address at which to print character
_47071:
       mov  a,@_34269                  ; LD (34269),A      ; Set text printing attribute to value in A
       movb *ix,@l                     ; LD L,(IX+0)       ; Load Attribute File address to print character to into HL...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       bl   @_47682                    ; CALL 47682        ; Print double-height text character in E
       rt                              ; RET               ; Return

* Print Keyboard Controls on Main Menu
* 
* Used by the routines at #R46830 and #R46968. Input:  A  Attribute for printing text
_47084:
       mov  a,@_34269                  ; LD (34269),A      ; Set attribute for printing text
       li   ix,_46696                  ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
                                                           ; print
       li   iy,_46683                  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7, as there are 7 keyboard controls (loop counter)
_47097:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining control keys)
       movb *ix,@l                     ; LD L,(IX+0)       ; Load HL with Attribute File address at which to print character...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       movb *iy,@e                     ; LD E,(IY+0)       ; Load E with character to print (current keyboard control)
       bl   @_47682                    ; CALL 47682        ; Print double-height text character in E
       inc  iy                         ; INC IY            ; Advance IY to next keyboard control
       inc  ix                         ; INC IX            ; Advance IX to next entry in list of Attribute File addresses...
       inc  ix                         ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining control keys)
       sb   one,b                      ; DJNZ 47097        ; Loop back to #R47097 for next keyboard control
       jne  _47097                     ;                   
       rt                              ; RET               ; Return

* "THROUGH the TRAPDOOR" String
_47120:
       text 'THROUGH the TRAPDOOR'

* Print "THROUGH the TRAPDOOR" String
* 
* Used by the routine at #R46830.
_47140:
       movb @bytes+20,b                ; LD B,20           ; Load B with 20 (length of string to print)
       li   hl,22566                   ; LD HL,22566       ; Point HL at position to start printing text in Attribute File
       movb @bytes+79,a                ; LD A,79           ; Load A with 79, for blue PAPER, white INK, BRIGHT
       li   ix,_47120                  ; LD IX,47120       ; Point IX to text to print
       jmp  _47224                     ; JR 47224          ; Print the text and return

* "SORRY BERK,  BUT YOUR TIME IS UP" String
_47153:
       text 'SORRY BERK,  BUT YOUR TIME IS UP'

* Print "SORRY BERK,  BUT YOUR TIME IS UP" String
* 
* Used by the routine at #R34438.
_47185:
       movb @bytes+32,b                ; LD B,32           ; Load B with 32 (length of string to print)
       movb @bytes+199,a               ; LD A,199          ; Load A with 199, for black PAPER, white INK, BRIGHT, FLASH
       li   ix,_47153                  ; LD IX,47153       ; Point IX to text to print
       li   hl,23232                   ; LD HL,23232       ; Point HL at position at which to start printing text in Attribute File (start of second-last
                                                           ; row)
       jmp  _47224                     ; JR 47224          ; Print the text and return

* "HOME SWEET HOME" String
_47198:
       text 'HOME SWEET HOME'

* Print "HOME SWEET HOME" String
* 
* Used by the routine at #R34438.
_47213:
       movb @bytes+15,b                ; LD B,15           ; Set string length to 15
       movb @bytes+68,a                ; LD A,68           ; Set attribute to green INK on black PAPER, BRIGHT
       li   ix,_47198                  ; LD IX,47198       ; Point IX at "HOME SWEET HOME" text
       li   hl,22792                   ; LD HL,22792       ; Point HL at Attribute File address at which to print text
* This entry point is used by the routines at #R47140 and #R47185.
_47224:
       mov  a,@_34269                  ; LD (34269),A      ; Store attribute at #R34269
_47227:
       .push bc                        ; PUSH BC           ; Store BC (B=remaining length of text)
       movb *ix,@e                     ; LD E,(IX+0)       ; Load character of text to print into E
       bl   @_47682                    ; CALL 47682        ; Print double-height text character in E
       inc  ix                         ; INC IX            ; Advance IX to next text character to print
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address at which to print
       .pop bc                         ; POP BC            ; Restore BC (B = remaining length of text)
       sb   one,b                      ; DJNZ 47227        ; Decrease remaining length of text by one and repeat loop for next character
       jne  _47227                     ;                   
       rt                              ; RET               ; Return

* Reset Show Score Flag and Draw Timer Figures Bar
* 
* Used by the routines at #R34438, #R34916 and #R47468.
_47241:
       movb @_34208,a                  ; LD A,(34208)      ; Reset Show Score Flag...
       szcb @bits+7,a                  ; RES 7,A           ; ...
       mov  a,@_34208                  ; LD (34208),A      ; ...
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @_34210,a                  ; LD A,(34210)      ; Load remaining time / lives into A...
       socb a,a                        ; OR A              ; ...and if zero...
       jeq  _47267                     ; JR Z,47267        ; ...then skip ahead 47267
       movb a,b                        ; LD B,A            ; Load number of lives into B
_47260:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of open eyes to draw)
       bl   @_47315                    ; CALL 47315        ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of open eyes to draw)
       sb   one,b                      ; DJNZ 47260        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47260 if not
       jne  _47260                     ;                   
                                                           ; zero
_47267:
       movb @_34210,a                  ; LD A,(34210)      ; Load remaining time / lives into E...
       movb a,@e                       ; LD E,A            ; ...
       movb @bytes+16,a                ; LD A,16           ; Load A with number of lives lost by subtracting E from 16...
       sb   @e,a                       ; SUB E             ; ...
       jeq  _47284                     ; JR Z,47284        ; If zero, then skip ahead to #R47284
       movb a,b                        ; LD B,A            ; Load number of lost lives into B as counter for loop
_47277:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of closed eyes to draw)
       bl   @_47302                    ; CALL 47302        ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of closed eyes to draw)
       sb   one,b                      ; DJNZ 47277        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47277 if not
       jne  _47277                     ;                   
                                                           ; zero
_47284:
       movb @bytes+27,@c               ; LD C,27           ; Set graphic index to 27 (timer figures' bodies)
       movb @_34226,a                  ; LD A,(34226)      ; Load attribute of current character into A
       movb @bytes+16,b                ; LD B,16           ; Load B with 16 (as 16 timer figures' bodies to draw)
_47291:
       .push bc                        ; PUSH BC           ; Store B (remaining number of timer figure bodies to draw)
       bl   @_47333                    ; CALL 47333        ; Draw left half of timer figure's body and invert mirror flag on attribute
       bl   @_47333                    ; CALL 47333        ; Draw right half of timer figure's body
       .pop bc                         ; POP BC            ; Restore B (remaining number of timer figure bodies to draw)
       sb   one,b                      ; DJNZ 47291        ; Decrease B and loop back to #R47291
       jne  _47291                     ;                   
       rt                              ; RET               ; Return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Closed) at Attribute File Address IX and Advance IX
* by Two Bytes
* 
* Used by the routines at #R47241 and #R47363. Input:  IX  Pointer to a location in Attribute File
_47302:
       bl   @_47355                    ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47305
       movb @_34226,a                  ; LD A,(34226)      ; Load A with the attribute of the current character
       movb @bytes+28,@c               ; LD C,28           ; Load C with 28 (graphic index of timer figures' closed eyes)
       bl   @_47333                    ; CALL 47333        ; Draw the left (closed) eye at Attribute File address in IX and advance IX by one byte
       jmp  _47333                     ; JR 47333          ; Draw the right (closed) eye at Attribute File address in IX, advance IX by one byte and
                                                           ; return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Open, Random Frame) at Attribute File Address IX and
* Advance IX by Two Bytes
* 
* Used by the routines at #R47241, #R47363 and #R47431. Input:  IX  Attribute File address at which to draw pair of
* eyes Output: IX  Attribute File address two bytes on from initial IX
_47315:
       bl   @_47355                    ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47318
       bl   @_47323                    ; CALL 47323        ; Draw Timer Figure's left eye (random frame) at Attribute File address in IX and advance IX by
                                                           ; one byte
       jmp  _47333                     ; JR 47333          ; Draw Timer Figure's right eye (same frame as above), advance IX by one byte then return

* Draw a Timer Figure's Eye (Random Frame) at Attribute File Address in IX and Advance IX by One Byte
* 
* Used by the routine at #R47315. Input:  IX  (Entry at #R47323 and #R47333) Pointer to a location in Attribute File
* A  (Entry at #R47333 only) Attribute C  (Entry at #R47333 only) Graphic Index (e.g. 27 for timer figures' bodies)
* Output: A  Attribute (including inverted mirror flag) IX  Pointer to next location in Attribute File
_47323:
       movb @bytes+5,a                 ; LD A,5            ; Load A with a random number, 0-4...
       bl   @_54222                    ; CALL 54222        ; ...
       a    @bytes+29,a                ; ADD A,29          ; Add 29 (as 29 is the index of the first of five eye direction graphics) in C...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+7,a                 ; LD A,7            ; Set attribute for timer indicator figures' eyes to white INK on black PAPER
* This entry point is used by the routines at #R47241, #R47302 and #R47315.
_47333:
       movb @bytes+4,b                 ; LD B,4            ; Set Graphic Set Index to 4
       .push af                        ; PUSH AF           ; Store AF (A = attribute)
       .push bc                        ; PUSH BC           ; Store BC (B = graphic set index, C = graphic index)
       bl   @_54144                    ; CALL 54144        ; Draw a graphic character block to display
       .pop bc                         ; POP BC            ; Restore BC (B = graphic set index, C = graphic index)
       movb @c,a                       ; LD A,C            ; Load Graphic Index into A
       cb   a,@bytes+32                ; CP 32             ; If graphic index is less than 32 (i.e. we're not dealing with #32 - eyes looking right or #33
                                                           ; - eyes looking left and don't need to cancel inversion at 47350)...
       jl   _47348                     ; JR C,47348        ; ...then skip ahead to #R47348
       xor  one,a                      ; XOR 1             ; Add or subtract 1 if Graphic Index is 32 or 33 respectively (Timer Figures' Eyes looking
                                                           ; right or left respectively) to cancel out inversion at 47350
_47348:
       movb a,@c                       ; LD C,A            ; Load Graphic Index into C
       .pop af                         ; POP AF            ; Restore AF (A = attribute)
       ; XOR 128                       ; XOR 128           ; Flip mirror flag to prepare to draw mirror image of just-drawn character block
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       rt                              ; RET               ; Return

* If Show Score Flag is Reset then Return to Calling Routine, else Return to Routine that Called Calling Routine
* 
* Used by the routines at #R47302 and #R47315.
_47355:
       movb @_34208,a                  ; LD A,(34208)      ; If Show Score Flag is reset...
       mov  a,tmp0                     ; BIT 7,A           ; ...
       andi tmp0,128                   ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove return address from stack...
       rt                              ; RET               ; ...and return to routine that called the calling routine

* Update Eyes of a Randomly Selected Timer Figure, Increase Timer Tick Counter and Process Timer Figure Blinking
* 
* Used by the routine at #R34438.
_47363:
       bl   @_47431                    ; CALL 47431        ; Select a remaining Timer Figure at random and update its eyes to a random (open-eyed) frame
       bl   @_47468                    ; CALL 47468        ; Increase Timer Tick Counter and reduce remaining time if Counter > 767
       movb @_34227,a                  ; LD A,(34227)      ; If Blink Duration Counter is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _47388                     ; JR Z,47388        ; ...then skip ahead to #R47388
       sb   one,a                      ; DEC A             ; Decrease Blink Duration Counter by one...
       mov  a,@_34227                  ; LD (34227),A      ; ...
       socb a,a                        ; OR A              ; If decreased Blink Duration Counter is not zero...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       mov  @_34264,ix                 ; LD IX,(34264)     ; Restore Attribute File address of eyes of currently blinking timer figure into IX
       b    @_47315                    ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
* Make a randomly chosen timer figure blink
_47388:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 0-9...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (9 in 10 chance)...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @_34210,a                  ; LD A,(34210)      ; Load remaining time / lives into A
       cb   a,@bytes+2                 ; CP 2              ; If less than two time / lives remain...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       bl   @_54222                    ; CALL 54222        ; Load A with a random number, 0-(x-1) (where x is remaining time / lives)
       a    a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. point to a random "awake" timer figure)
       mov  ix,@_34264                 ; LD (34264),IX     ; Store Attribute File address of eyes of currently blinking timer figure at 34264
       bl   @_47302                    ; CALL 47302        ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address IX and advance IX by two bytes
       movb @bytes+10,a                ; LD A,10           ; Set Blink Duration Counter to a random number, 1-9...
       bl   @_54222                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       mov  a,@_34227                  ; LD (34227),A      ; ...
       rt                              ; RET               ; Return

* Select a Remaining Timer Figure at Random and Update its Eyes to a Random (Open-Eyed) Frame
* 
* Used by the routine at #R47363.
_47431:
       movb @_34210,a                  ; LD A,(34210)      ; Load remaining time / lives into A...
       socb a,a                        ; OR A              ; ...and if none remain...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       movb a,@e                       ; LD E,A            ; Load remaining time / lives into E
       movb @bytes+18,a                ; LD A,18           ; Load A with 18 minus remaining time / lives (i.e. number in range 2 to 18)...
       sb   @e,a                       ; SUB E             ; ...
* As the value of x (Remaining Time / Lives) decreases, the probability that a randomly generated number between 0
* and (18-x) is 2 or more increases. This probability is used to ensure that the rate at which each timer figure is
* updated remains roughly constant.
       bl   @_54222                    ; CALL 54222        ; Load A with a random number, 0-(17 minus remaining time / lives)
       cb   a,@bytes+2                 ; CP 2              ; If generated number is 2 or more...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @e,a                       ; LD A,E            ; Load remaining time / lives into A
* If remaining time / lives is one, then there is only one Timer Figure to update
       cb   a,one                      ; CP 1              ; If this is 1...
       jne  !                          ; JP Z,47315        ; ...then jump to #R47315 (If Show Score Flag reset then draw pair of Timer Figure eyes and
       b    @_47315                    ;                   
!
                                                           ; return)
* Otherwise, randomly select one of the remaining Timer Figures to update
       bl   @_54222                    ; CALL 54222        ; Load A with random number between 0 and (x-1) where x is remaining time / lives
       a    a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. advance IX to point to left eye of randomly chosen Timer Figure)
       b    @_47315                    ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return

* Increase Timer Tick Counter and Reduce Remaining Time if Counter > 767
* 
* Used by the routine at #R47363.
_47468:
       mov  @_34211,hl                 ; LD HL,(34211)     ; Increase Timer Tick Counter by one...
       inc  hl                         ; INC HL            ; ...
       mov  hl,@_34211                 ; LD (34211),HL     ; ...
       movb h,a                        ; LD A,H            ; If Timer Tick Counter is less than 768 (i.e. 3 x 256)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       li   hl,0                       ; LD HL,0           ; Reset Timer Tick Counter to zero...
       mov  hl,@_34211                 ; LD (34211),HL     ; ...
* This entry point is used by the routine at #R53723.
_47485:
       movb @_34210,a                  ; LD A,(34210)      ; If no time / lives remain...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,47241        ; ...then reset Show Score Flag, draw timer figures bar and return
       b    @_47241                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease current time / lives by one...
       mov  a,@_34210                  ; LD (34210),A      ; ...
       b    @_47241                    ; JP 47241          ; Reset Show Score Flag, and draw timer figures bar and return

* Update Scores and Display
* 
* Used by the routine at #R34438.
_47499:
       li   hl,_34208                  ; LD HL,34208       ; Set Show Score Flag...
       socb @bits+7,*hl                ; SET 7,(HL)        ; ...
       li   hl,0                       ; LD HL,0           ; Set HL to zero
       movb @_34210,a                  ; LD A,(34210)      ; If no time / lives remain...
       socb a,a                        ; OR A              ; ...
       jeq  _47526                     ; JR Z,47526        ; ...then skip ahead to #R47526
       movb a,b                        ; LD B,A            ; Load HL with 1000 x current remaining time / lives...
       li   de,1000                    ; LD DE,1000        ; ...
_47517:
       a    de,hl                      ; ADD HL,DE         ; ...
       sb   one,b                      ; DJNZ 47517        ; ...
       jne  _47517                     ;                   
       mov  @_34211,de                 ; LD DE,(34211)     ; Subtract value of Timer Tick Counter (i.e. Score Penalty) from current level's score...
       sb   de,hl                      ; SBC HL,DE         ; ...
_47526:
       mov  hl,@_34213                 ; LD (34213),HL     ; Set score for current level
       mov  @_34215,de                 ; LD DE,(34215)     ; Load DE with current total score
       a    de,hl                      ; ADD HL,DE         ; Add score for current level to total score...
       mov  hl,@_34215                 ; LD (34215),HL     ; ...and store
       mov  @_34299,de                 ; LD DE,(34299)     ; Load current high score into DE
       sb   de,hl                      ; SBC HL,DE         ; Subtract high score from current total score...
       joc  _47551                     ; JR C,47551        ; TODO: check code. ...and if this is less than zero (i.e. high score is higher than current total score) then
                                                           ; skip ahead to #R47551
       mov  @_34215,hl                 ; LD HL,(34215)     ; Load current total score into HL...
       mov  hl,@_34299                 ; LD (34299),HL     ; ...and store as new high score
_47551:
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       mov  a,@_34210                  ; LD (34210),A      ; ...
       li   iy,_47589+7                ; LD IY,47596       ; Point IY at "numeric (score)" part of string at 47589
       mov  @_34213,hl                 ; LD HL,(34213)     ; Load HL with current score...
       bl   @_47741                    ; CALL 47741        ; ...and convert to string at IY
       li   iy,_47589+20               ; LD IY,47609       ; Point IY at "numeric (total)" part of string at 47589
       mov  @_34215,hl                 ; LD HL,(34215)     ; Load HL with current total score...
       bl   @_47741                    ; CALL 47741        ; ...and convert to string at IY
       li   iy,_47589+33               ; LD IY,47622       ; Point IY at "numeric (high score)" part of string at 47589
       mov  @_34299,hl                 ; LD HL,(34299)     ; Load HL with current high score...
       bl   @_47741                    ; CALL 47741        ; ...and convert to string at IY
       b    @_47628                    ; JP 47628          ; Print SCORE / TOTAL / HI-SC string in current character's colours and return

* Score / Total / High Score String
_47589:
       text '*SCORE#00000* TOTAL#00000* HI-SC#00999$'

* Print Score / Total / High Score String in Current Character's Colours
* 
* Used by the routines at #R34916, #R46830 and #R47499.
_47628:
       li   iy,_47589                  ; LD IY,47589       ; Point IY at SCORE / TOTAL / HI-SC text
       li   hl,23232                   ; LD HL,23232       ; Set Attribute File address at which to print text to start of second-last character row
_47635:
       movb *iy,a                      ; LD A,(IY+0)       ; Load a character from the string into A
       cb   a,@bytes+36                ; CP 36             ; If the character is 36 (end marker)...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       cb   a,@bytes+42                ; CP 42             ; If character is not 42 ("set attribute to current character's colours" marker)...
       jne  _47660                     ; JR NZ,47660       ; ...then skip ahead to #R47660
       movb @_34226,a                  ; LD A,(34226)      ; Load current character's attribute into A (blue for Berk, yellow for Drutt)
       cb   a,one                      ; CP 1              ; If blue (Berk)...
       jeq  _47656                     ; JR Z,47656        ; ...then skip ahead to #R47656
       movb @bytes+112,a               ; LD A,112          ; Load A with value for black INK, yellow PAPER, BRIGHT (Drutt's colours)
       jmp  _47666                     ; JR 47666          ; Skip ahead to #R47666
_47656:
       movb @bytes+79,a                ; LD A,79           ; Load A with value for white INK, blue PAPER, BRIGHT (Berk's colours)
       jmp  _47666                     ; JR 47666          ; Skip ahead to #R47666
_47660:
       cb   a,@bytes+35                ; CP 35             ; If character is not 35 ("set attribute to standard" marker)...
       jne  _47673                     ; JR NZ,47673       ; ...then skip ahead to #R47673
       movb @bytes+71,a                ; LD A,71           ; Load A with value for white INK, black PAPER, BRIGHT
_47666:
       mov  a,@_34269                  ; LD (34269),A      ; Store this value as the attribute to print text
       inc  iy                         ; INC IY            ; Advance IY to next character in string to print
       jmp  _47635                     ; JR 47635          ; Loop back to #R47635 for next character
_47673:
       movb a,@e                       ; LD E,A            ; Load character to print into E
       bl   @_47682                    ; CALL 47682        ; Print double-height text character in E
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address
       inc  iy                         ; INC IY            ; Advance IY to next character to process
       jmp  _47635                     ; JR 47635          ; Loop back to #R47635 for next character

* Print a Double-Height Text Character
* 
* Used by the routines at #R46830, #R47071, #R47084, #R47213 and #R47628. Input:  HL  Attribute File address at
* which to print character E  Character to print
_47682:
       li   bc,32                      ; LD BC,32          ; Load BC with 32 (width of a row in Attribute File)
       .push hl                        ; PUSH HL           ; Store HL (Attribute File address at which to print character)
       movb @bytes+0,d                 ; LD D,0            ; Set D to zero
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now Attribute File address at which to print character) and HL (now H = 0, L =
                                                           ; character to print)
       a    hl,hl                      ; ADD HL,HL         ; Multiply index of character to print by eight in HL, as each character's graphic data is
                                                           ; eight bytes long...
       a    hl,hl                      ; ADD HL,HL         ; ...
       a    hl,hl                      ; ADD HL,HL         ; ...
       li   de,15360                   ; LD DE,15360       ; Add eight times character index to 15360 in HL, to point to graphic of character in ROM...
       a    de,hl                      ; ADD HL,DE         ; ...
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to graphic of character in ROM) and HL (now 15360)
       .pop hl                         ; POP HL            ; Restore HL (Attribute File address at which to print character)
       bl   @_47709                    ; CALL 47709        ; Print top half of a double-height text character
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL to advance down a character row
       bl   @_47709                    ; CALL 47709        ; Print bottom half of a double-height text character
       andi a,0*256                    ; AND A             ; Reset Carry Flag
       sb   bc,hl                      ; SBC HL,BC         ; Subtract 32 from HL to restore to value it had upon starting this routine
       rt                              ; RET               ; Return

* Print Half of a Double-Height Text Character
* 
* The most significant byte of the Attribute File address starts off as 88 for the top third of the screen. In the
* middle third it becomes 89 and in the lower third it reaches 90. The most significant byte of the Display File
* address (for the top pixel row of each character row) is 64 in the top third, 72 in the middle third and 80 in the
* lower third. Generally speaking, therefore, the most significant byte in the Display File address increases by
* eight for every increase of one in the attribute address most significant byte, so multiplying the latter by eight
* (giving 192, 200 or 208, values roll over 255-0 boundary with excess truncated) would put it on the same scale as
* the former (64, 72 or 80). Input:  DE  15360 + 8 x character index [+4 for second run-through] (i.e. points to ROM
* graphic data for the character of interest) HL  Attribute File address at which to print character
_47709:
       .push hl                        ; PUSH HL           ; Store HL
       .push bc                        ; PUSH BC           ; Store BC
       movb @_34269,a                  ; LD A,(34269)      ; Load stored attribute into A
       movb a,*hl                      ; LD (HL),A         ; Write this to Attribute File
       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
       a    a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
       a    a,a                        ; ADD A,A           ; ...
       a    a,a                        ; ADD A,A           ; ...
       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File
       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (loop counter)
_47724:
       movb *de,a                      ; LD A,(DE)         ; Load a byte from the graphic data into C...
       movb a,@c                       ; LD C,A            ; ...
       ; SRL C                         ; SRL C             ; Shift bitmap data left one pixel in C
       socb @c,a                       ; OR C              ; Merge this into bitmap data already in A to give a "bold" typeface appearance
       andi a,127*256                  ; AND 127           ; Drop the leftmost bit to prevent one character touching the next (space between letters)
       movb a,*hl                      ; LD (HL),A         ; Load the bitmap data into two consecutive rows to provide double-height (2 chars) text...
       ab   one,h                      ; INC H             ; ...
       movb a,*hl                      ; LD (HL),A         ; ...
       ab   one,h                      ; INC H             ; ...
       inc  de                         ; INC DE            ; Advance to next byte of graphic data
       sb   one,b                      ; DJNZ 47724        ; Repeat for next row of graphic data
       jne  _47724                     ;                   
       .pop bc                         ; POP BC            ; Restore BC
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Convert Number in HL to String at IY
* 
* Used by the routine at #R47499. Input:  HL  A number to convert to string IY  A location in memory to store a
* number converted to a string
_47741:
       li   de,10000                   ; LD DE,10000       ; Convert the ten thousands to a character...
       bl   @_47772                    ; CALL 47772        ; ...
       li   de,1000                    ; LD DE,1000        ; Convert the thousands to a character...
       bl   @_47772                    ; CALL 47772        ; ...
       li   de,100                     ; LD DE,100         ; Convert the hundreds to a character...
       bl   @_47772                    ; CALL 47772        ; ...
       li   de,10                      ; LD DE,10          ; Convert the tens to a character...
       bl   @_47772                    ; CALL 47772        ; ...
       movb @l,a                       ; LD A,L            ; Load remainder (units) into L
       a    @bytes+48,a                ; ADD A,48          ; Add as offset to 48 (ASCII code for "0")
       movb a,*iy                      ; LD (IY+0),A       ; Load ASCII character code into units position in string
       rt                              ; RET               ; Return

* Convert a Digit of Numeric Data to its String Equivalent
* 
* Used by the routine at #R47741. Input:  DE  Current power of ten HL  A number to convert to string IY  A location
* in memory to store a current digit converted to a string
_47772:
       movb @bytes+47,*iy              ; LD (IY+0),47      ; Set character in string to "/" (character immediately before "0")
       andi a,0*256                    ; AND A             ; Reset Carry Flag
_47777:
       ab   one,*iy                    ; INC (IY+0)        ; Advance character at current string position to next numeric character up
       sb   de,hl                      ; SBC HL,DE         ; Subtract current power of ten from number to convert
       jnc  _47777                     ; JR NC,47777       ; TODO: check code. If number to convert has not dropped below 0 (i.e. we have not yet subtracted too many of the
                                                           ; current power of ten) then loop back to #R47777
       a    de,hl                      ; ADD HL,DE         ; We have subtracted one too many of the current power of ten, so add it back to make the
                                                           ; remainder positive
       inc  iy                         ; INC IY            ; Advance to next character in the string as we are finished dealing with the current power of
                                                           ; ten
       rt                              ; RET               ; Return

* Read Keyboard and Load Pressed Key Character into A
* 
* Used by the routines at #R47893 and #R47942. Output: A  Index of the key that was pressed
_47788:
       .exx                            ; EXX               ; Swap registers
       li   bc,65278                   ; LD BC,65278       ; Load B and C with 254
       li   hl,_47853                  ; LD HL,47853       ; Point HL at list of return values
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard) [IN 65278 reads the half row CAPS SHIFT to V]
       socb @bits+0,a                  ; SET 0,A           ; Set bit 0 of A (i.e. clear pressing of CAPS SHIFT)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       ; XOR 31                        ; XOR 31            ; Invert all of the lowest five bits
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       li   de,5                       ; LD DE,5           ; Advance HL by five characters in list of return values string...
       a    de,hl                      ; ADD HL,DE         ; ...
       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 as there are 6 keyboard half-rows to test (loop counter)
_47811:
       sra  b,1                        ; RLC B             ; With each loop, change BC from 65278 -> 65022 -> 64510 -> 63486 -> 61438 -> 57342 -> 49150
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       ; XOR 31                        ; XOR 31            ; Invert all of the lowest five bits
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       inc  hl                         ; INC HL            ; Advance HL by five characters in list of return values string...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       sb   one,@e                     ; DEC E             ; Decrease number of remaining keyboard half-rows to check
       jne  _47811                     ; JR NZ,47811       ; If there are any more half rows to check then loop back to #R47811
       sra  b,1                        ; RLC B             ; Set BC to 32766 for final keyboard half-row
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
       socb @bits+1,a                  ; SET 1,A           ; Set bit 1 of A (i.e. clear pressing of SYMBOL SHIFT)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       ; XOR 31                        ; XOR 31            ; Invert all of the lowest five bits
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       .exx                            ; EXX               ; Swap registers
       rt                              ; RET               ; Return [no key pressed]
_47843:
       srl  a,1                        ; SRL A             ; Shift bits right
       joc  _47850                     ; JR C,47850        ; TODO: check code. If carry flag is set, then this is the key that was pressed, so skip ahead to #R47850
       inc  hl                         ; INC HL            ; Advance HL to check next character
       jmp  _47843                     ; JR 47843          ; Loop back to #R47843
_47850:
       movb *hl,a                      ; LD A,(HL)         ; Load current character in list of return values string into A as this is the key that was
                                                           ; pressed
       .exx                            ; EXX               ; Swap registers
       rt                              ; RET               ; Return [key pressed]

* Return Values from Keyboard Reading Routine
_47853:
       text 'cZXCVASDFGQWERT1234509876POIUYeLKJH yMNB'

* Check for Control Key Press and Store at 34219
* 
* Used by the routine at #R34438.
_47893:
       sb   a,a                        ; XOR A             ; Clear previously stored control input...
       mov  a,@_34219                  ; LD (34219),A      ; ...
       bl   @_47788                    ; CALL 47788        ; Read keyboard and load character of pressed key into A
       socb a,a                        ; OR A              ; If no key was pressed...
       jeq  _47930                     ; JR Z,47930        ; ...then read joystick input and return
       movb one,@e                     ; LD E,1            ; Set least significant bit of E as we are testing the first keyboard control first
       movb @bytes+7,b                 ; LD B,7            ; Set B to 7 as there are 7 keyboard controls to check (loop counter)
       li   hl,_46683                  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
_47910:
       cb   a,*hl                      ; CP (HL)           ; If pressed key is the same as the current keyboard control...
       jeq  _47921                     ; JR Z,47921        ; ...then skip ahead to #R47921
       inc  hl                         ; INC HL            ; Advance HL to next keyboard control
       ; SLA E                         ; SLA E             ; Shift E left
       sb   one,b                      ; DJNZ 47910        ; Loop back to #R47910 for next keyboard control
       jne  _47910                     ;                   
       sb   a,a                        ; XOR A             ; Set A to zero
       jmp  _47926                     ; JR 47926          ; Skip ahead to #R47926
_47921:
       movb @e,a                       ; LD A,E            ; Load input bitmap into A (bit that is set represents the control that has been pressed)
       mov  a,tmp0                     ; BIT 5,A           ; If bit 5 is set (i.e. Berk / Drutt key has been pressed)...
       andi tmp0,32                    ;                   
       jne  _47942                     ; JR NZ,47942       ; ...then jump to #R47942 (Wait for current key to be released and another to be pressed,
                                                           ; storing in A) and return
* This entry point is used by the routine at #R47930.
_47926:
       mov  a,@_34219                  ; LD (34219),A      ; Store control input at #R34219
       rt                              ; RET               ; Return

* If Joystick Mode is On, then Read Joystick Input
* 
* Used by the routine at #R47893.
_47930:
       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode is Off...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       ; IN A,(31)                     ; IN A,(31)         ; Read state of Kempston joystick into A
       andi a,31*256                   ; AND 31            ; If joystick input is non-zero...
       jne  _47926                     ; JR NZ,47926       ; ...then jump to #R47926
       rt                              ; RET               ; Return

* Wait for Current Key to Be Released and Another to Be Pressed, Storing in A
* 
* Used by the routines at #R34438, #R47893 and #R47955.
_47942:
       bl   @_47788                    ; CALL 47788        ; Read keyboard and load character of pressed key into A
       socb a,a                        ; OR A              ; If a key is pressed...
       jne  _47942                     ; JR NZ,47942       ; ...then loop back to #R47942
_47948:
       bl   @_47788                    ; CALL 47788        ; Read keyboard and load character of pressed key into A
       socb a,a                        ; OR A              ; If a key is not pressed...
       jeq  _47948                     ; JR Z,47948        ; ...then loop back to #R47948
       rt                              ; RET               ; Return

* Wait for Key-Press, Store Pressed Key Code in A and Play Main Menu Sound
* 
* Used by the routines at #R46830 and #R46968. Output: A  code of pressed key
_47955:
       bl   @_47942                    ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
       .push af                        ; PUSH AF           ; Store AF (A = last pressed key)
       movb @bytes+2,a                 ; LD A,2            ; Set sound 2 as pending if appropriate, then play and clear pending sound...
       bl   @_59722                    ; CALL 59722        ; ...
       .pop af                         ; POP AF            ; Restore AF (A = last pressed key)
       rt                              ; RET               ; Return

* Table of Script Routine Start Addresses
_47966:
       data 0                                                        ; (00) - Unused
       data _48285                                                   ; (01) - Load HL (Script Data Pointer) with New Address
       data _48660                                                   ; (02) - Move Entity at IX (and if Berk, Carried Entity) Left One Character
       data _48615                                                   ; (03) - Move Entity at IX (and if Berk, Carried Entity) Right One Character
       data _48133                                                   ; (04) - If Current Character and Target Entity are in the Same Room then Set Pending Sound
       data 0                                                        ; (05) - Unused
       data _48238                                                   ; (06) - Set Berk's Facing Into Screen Flag, and Reset his Facing Left and Facing Right flags
       data _48234                                                   ; (07) - Reset Berk's Facing Into Screen, Facing Left and Facing Right Flags
       data _48267                                                   ; (08) - Set Must Process Current Script Data Flag for Entity at IX
       data _48260                                                   ; (09) - Reset Must Process Current Script Data Flag for Entity at IX
       data _48212                                                   ; (10) - Reset Entity's Walking Left and Walking Right flags
       data _48220                                                   ; (11) - Set Entity Walking Left Flag
       data _48216                                                   ; (12) - Set Entity Walking Right Flag
       data _48242                                                   ; (13) - Set Berk's Facing Left Flag, and Reset his Facing Into Screen and Facing Right Flags
       data _48246                                                   ; (14) - Set Berk's Facing Right Flag, and Reset his Facing Into Screen and Facing Left Flags
       data _48274                                                   ; (15) - Jump to New Address if Berk Is Carrying Something
       data _48148                                                   ; (16) - Have Berk Hold an Entity, and Position it Appropriately Between his Hands
       data _48154                                                   ; (17) - Have Berk Put Down an Entity in Front of Him, if Appropriate
       data _48158                                                   ; (18) - Have Berk Put Down an Entity Behind Him, if Appropriate
       data _48698                                                   ; (19) - Move Carried Entity to Berk's Left as he Faces Left
       data _48704                                                   ; (20) - Move Carried Entity to Berk's Right as he Faces Right
       data _48692                                                   ; (21) - Move Carried Entity in Front of Berk as he Faces Out of Screen
       data _48686                                                   ; (22) - Move Carried Entity Behind Berk as he Faces Into Screen
       data _48295                                                   ; (23) - Start Loop (1 / 3)
       data _48307                                                   ; (24) - End Loop (1 / 3)
       data _48324                                                   ; (25) - Start Loop (2 / 3)
       data _48336                                                   ; (26) - End Loop (2 / 3)
       data _48353                                                   ; (27) - Start Loop (3 / 3)
       data _48365                                                   ; (28) - End Loop (3 / 3)
       data _48920                                                   ; (29) - Make Berk Start Falling, and Drop his Carried Entity if Appropriate
_48026:
       data _48934                                                   ; (30) - Check Berk's Fall Velocity, and React to Landing
       data _48976                                                   ; (31) - React to Berk's Landing
       data _48487                                                   ; (32) - Update Berk's Position and State (Flying) Depending Upon Control Input
       data _49010                                                   ; (33) - Advance Berk's Jump and Select Next Phase if Current Phase Complete
       data _48541                                                   ; (34) - Move Entity at IX (and if Berk, Carried Entity) Up One Character
       data _48567                                                   ; (35) - Move Entity at IX (and if Berk, Carried Entity) Down One Character
       data _36950                                                   ; (36) - Set Boni's Room (Level 1) to Zero
       data _36957                                                   ; (37) - Remove Flying Skeleton Creature from Level 1, and Terminate Script Processing
       data _36984                                                   ; (38) - Close the Trap Door
       data _36990                                                   ; (39) - Open the Trap Door
       data _37778                                                   ; (40) - Move Spider Down One Character, and if at Bottom, Advance it to Bounce / Climb Up Mode
       data _37718                                                   ; (41) - Move Spider Up One Character and, if Home, Reset its Timer and Make it Wait
       data _37753                                                   ; (42) - Decrease Remaining Time Until Spider Next Descends and if Zero, Start Descent
       data _51779                                                   ; (43) - Select Next Action for Drutt Depending Upon Control Input
       data _52029                                                   ; (44) - Move Entity Up One Character
       data _52038                                                   ; (45) - Move Entity Down One Character
       data _52047                                                   ; (46) - Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling
                                                                     ; if Appropriate
       data _52142                                                   ; (47) - Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity
                                                                     ; Falling if Appropriate
       data _34901                                                   ; (48) - Return
       data _34901                                                   ; (49) - Return
       data _52243                                                   ; (50) - Advance Drutt's Jump and Select Next Phase if Current Phase Complete
       data _52309                                                   ; (51) - Swap Drutt's Current Depth Level if Possible
       data _52967                                                   ; (52) - Increase Worm's Age and Decrease Time Until Direction Change, or React to Drutt's
                                                                     ; Presence
       data _52870                                                   ; (53) - Move Worm Left if Possible, Otherwise Choose New Direction
       data _52889                                                   ; (54) - Move Worm Right if Possible, Otherwise Choose New Direction
       data _52914                                                   ; (55) - Choose New Direction and Start Crawling (Worm)
       data _36471                                                   ; (56) - Give Berk Power Corresponding to Entity Eaten
       data _36610                                                   ; (57) - Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside
                                                                     ; Current Room
       data _36390                                                   ; (58) - Have Berk Interact Appropriately with a Door in Front of Him
       data _36385                                                   ; (59) - Have Berk Interact Appropriately with a Door Behind Him
       data _38554                                                   ; (60) - Check Position of Apebeast and Turn If Appropriate
       data _38165                                                   ; (61) - Fire Bubo's Projectile
       data _48142                                                   ; (62) - Move Entity at IX into Room to the Left, if Appropriate
       data _41550                                                   ; (63) - Have Skeleton Advance or Retreat Based Upon Positions of Berk and Fake Boni
       data _41617                                                   ; (64) - Set Random (1 to 10) Number of Iterations in Following Loop Script Instruction

* Advance HL to Next Script Instruction and Execute
* 
* Used by the routines at #R35735, #R36116, #R36390, #R36471, #R36542, #R36610, #R36947, #R36950, #R36984, #R36990,
* #R37085, #R37639, #R37753, #R38074, #R38165, #R38540, #R38554, #R41498, #R41617, #R48133, #R48142, #R48148,
* #R48158, #R48220, #R48246, #R48260, #R48267, #R48274, #R48307, #R48336, #R48365, #R48487, #R48567, #R48593,
* #R48641, #R48686, #R48692, #R48698, #R48704, #R48920, #R49010, #R51765, #R52029, #R52038, #R52047, #R52142,
* #R52243, #R52309, #R52860, #R52870, #R52889 and #R52967. Input:  IX  (Entry at #R48096 and #R48098) Address of
* complex state data for an entity Output: HL  Current position in script data
_48096:
       inc  hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
       inc  hl                         ; INC HL            ; ...
* This entry point is used by the routines at #R35577, #R35735, #R36008, #R36036, #R36116, #R36367, #R36390,
* #R36471, #R36638, #R37085, #R37639, #R37718, #R37753, #R37778, #R38074, #R38554, #R41550, #R48285, #R48295,
* #R48307, #R48324, #R48336, #R48353, #R48365, #R48388, #R48934, #R48976, #R49010, #R51765, #R51779, #R51904,
* #R51924, #R51944, #R51954, #R51960, #R52053, #R52148, #R52243, #R52908, #R52914, #R52967 and #R53083.
_48098:
       inc  hl                         ; INC HL            ; Advance Script Data Pointer by one byte
       movb *hl,a                      ; LD A,(HL)         ; Load byte at this location into A
       dec  hl                         ; DEC HL            ; Move HL back one byte
       socb a,a                        ; OR A              ; If byte loaded into A was zero (i.e. a script instruction)...
       jeq  _48117                     ; JR Z,48117        ; ...then skip ahead to #R48117
* HL pointing to a graphic layout data address, rather than a script instruction
       mov  hl,@_34277                 ; LD (34277),HL     ; Store address in HL at #R34277 as position in script currently running
       movb *hl,a                      ; LD A,(HL)         ; Load word at location HL into Graphic Layout Address in current entity's complex state data
                                                           ; entry (IX)...
       movb a,@2(ix)                   ; LD (IX+2),A       ; ...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; ...
       movb a,@3(ix)                   ; LD (IX+3),A       ; ...
       rt                              ; RET               ; Return
* HL pointing to a script instruction
_48117:
       movb *hl,a                      ; LD A,(HL)         ; Load script "instruction" into A
       .push hl                        ; PUSH HL           ; Store HL (pointer to current position in script data)
       li   hl,_47966                  ; LD HL,47966       ; Point HL at Table of Script Routine Start Addresses
       a    a,a                        ; ADD A,A           ; Load double index of script instruction into BC...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,hl                      ; ADD HL,BC         ; ...and add as offset in HL to point to start address of required script routine
       movb *hl,@c                     ; LD C,(HL)         ; Load address at this location into BC...
       inc  hl                         ; INC HL            ; ...
       movb *hl,b                      ; LD B,(HL)         ; ...
       .pop hl                         ; POP HL            ; Restore HL (pointer to current position in script data)
       .push bc                        ; PUSH BC           ; Push address in BC onto stack...
       rt                              ; RET               ; ...and RET to this address

* Script Routine (04) If Current Character and Target Entity are in the Same Room then Set Pending Sound Input:  HL
* Current position in script data IX  Address of complex state data for an entity
_48133:
       inc  hl                         ; INC HL            ; Advance HL to parameter (sound index)...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load A with sound index
       bl   @_59601                    ; CALL 59601        ; If current character is in same room as target entity at IX then set pending sound to A
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (62) Move Entity at IX into Room to the Left, if Appropriate
_48142:
       bl   @_54348                    ; CALL 54348        ; Move entity at IX into room to the left, if appropriate
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (16) Have Berk Hold an Entity, and Position it Appropriately Between his Hands
_48148:
       bl   @_48850                    ; CALL 48850        ; Have Berk hold an entity, and position it appropriately between his hands
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (17) Have Berk Put Down an Entity in Front of Him, if Appropriate Output: D  Depth offset for
* entity being put down
_48154:
       movb @bytes+0,d                 ; LD D,0            ; Load D with depth offset of 0 (as Berk is putting down an entity in front of him)
       jmp  _48160                     ; JR 48160          ; Have Berk put down an entity, if appropriate

* Script Routine (18) Have Berk Put Down an Entity Behind Him, if Appropriate Input:  D  (Entry at #R48160 only)
* Depth offset for entity being put down IX  Address of complex state data (current level) for Berk
_48158:
       movb @bytes+255,d               ; LD D,255          ; Load D with depth offset of -1 (as Berk is putting down an entity behind him)
* This entry point is used by the routine at #R48154.
_48160:
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is reset...
       andi tmp0,16                    ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
* Berk is carrying something
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       mov  a,@_34221                  ; LD (34221),A      ; ...
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...and reset its Is Being Carried Flag
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load E with height of entity minus one...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       movb @_34222,a                  ; LD A,(34222)      ; Load A with y-coordinate minus one of top edge of coloured creature slot Berk is interacting
                                                           ; with...
       socb a,a                        ; OR A              ; ...and if this is not zero...
       jne  _48198                     ; JR NZ,48198       ; ...then skip ahead to #R48198
* Value at #R34222 is zero (i.e. Berk not interacting with a coloured creature slot on Level 3)
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load A with y-coordinate of Berk's bottom edge...
       a    d,a                        ; ADD A,D           ; ...plus depth offset...
* At this point, A holds either the y-coordinate of Berk's bottom edge plus depth offset, or the y-coordinate minus
* one of the top edge of (actually the y-coordinate of the bottom of the space within) a coloured creature slot on
* Level 3. This value in A is the y-coordinate that the carried entity's bottom edge will take on when that entity
* is put down.
_48198:
       movb a,@6(iy)                   ; LD (IY+6),A       ; Set the y-coordinate of the bottom edge of the put-down entity to value in A
       sb   @e,a                       ; SUB E             ; Set the y-coordinate of the top edge of the put-down entity...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...to that of the bottom edge, minus the height as appropriate
       sb   a,a                        ; XOR A             ; Set value at #R34222 to zero...
       mov  a,@_34222                  ; LD (34222),A      ; ...as Berk is not (any longer) interacting with a coloured creature slot on Level 3
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (10) Reset Walking Left and Walking Right Flags
* 
* Used by the routine at #R36542. Output: E  Combination of flags to (re)set
_48212:
       movb @bytes+0,@e                ; LD E,0            ; Reset Entity Walking Left and Entity Walking Right flags...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

* Script Routine (12) Reset Walking Left Flag and Set Walking Right Flag Output: E  Combination of flags to (re)set
_48216:
       movb one,@e                     ; LD E,1            ; Set Entity Walking Right Flag, reset Entity Walking Left Flag...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

* Script Routine (11) Set Walking Left Flag and Reset Walking Right Flag Input:  E  (Entry at #R48222 only)
* Combination of flags to (re)set IX  Address of complex state data for an entity
_48220:
       movb @bytes+2,@e                ; LD E,2            ; Prepare to set Entity Walking Left Flag and reset Entity Walking Right Flag
* This entry point is used by the routines at #R48212 and #R48216.
_48222:
       movb @11(ix),a                  ; LD A,(IX+11)      ; (Re)set Walking Left and Walking Right flags as prepared in E...
       andi a,240*256                  ; AND 240           ; ...and reset Unused (11,2) and Unused (11,3) flags...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (07) Reset Berk's Facing Into Screen, Facing Left and Facing Right Flags Output: B  Combination of
* flags to (re)set
_48234:
       movb @bytes+0,b                 ; LD B,0            ; Reset Berk's Facing Into Screen, Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (06) Set Berk's Facing Into Screen Flag, and Reset his Facing Left and Facing Right Flags Output: B
* Combination of flags to (re)set
_48238:
       movb @bytes+2,b                 ; LD B,2            ; Set Berk's Facing Into Screen Flag, and reset his Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (13) Set Berk's Facing Left Flag, and Reset his Facing Into Screen and Facing Right Flags Output: B
* Combination of flags to (re)set
_48242:
       movb @bytes+4,b                 ; LD B,4            ; Set Berk's Facing Left Flag, and reset his Facing Into Screen and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (14) Set Berk's Facing Right Flag, and Reset his Facing Into Screen and Facing Left Flags Input:  B
* (Entry at #R48248 only) Combination of flags to (re)set IX  Address of complex state data (current level) for Berk
_48246:
       movb @bytes+8,b                 ; LD B,8            ; Prepare to set Berk's Facing Right Flag, and reset his Facing Into Screen and Facing Left
                                                           ; flags
* This entry point is used by the routines at #R48234, #R48238 and #R48242.
_48248:
       movb @9(ix),a                   ; LD A,(IX+9)       ; Load A with Berk's flags...
       andi a,241*256                  ; AND 241           ; ...clearing Facing Into Screen, Facing Left and Facing Right flags
       a    b,a                        ; ADD A,B           ; Combine with flags in B...
       movb a,@9(ix)                   ; LD (IX+9),A       ; ...and store
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (09) Reset Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
_48260:
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Must Process Current Script Data Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (08) Set Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
_48267:
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Must Process Current Script Data Flag
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (15) Jump to New Address if Berk Is Carrying Something Input:  HL  Current position in script data
* IX  Address of complex state data for an entity
_48274:
       inc  hl                         ; INC HL            ; Advance HL to parameter for current instruction...
       inc  hl                         ; INC HL            ; ...
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is carrying an entity...
       andi tmp0,16                    ;                   
       jne  _48287                     ; JR NZ,48287       ; ...then read parameter address into HL and execute next script instruction at that address
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (01) Load HL (Script Data Pointer) with New Address
* 
* Functionality analogous to JP instruction. Input:  HL  Address in script data Output: HL  New address in script
* data
_48285:
       inc  hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
       inc  hl                         ; INC HL            ; ...
* This entry point is used by the routine at #R48274.
_48287:
       movb *hl,@c                     ; LD C,(HL)         ; Read WORD at this location into HL...
       inc  hl                         ; INC HL            ; ...(i.e. update Script Data Pointer to this address)...
       movb *hl,b                      ; LD B,(HL)         ; ...
       .push bc                        ; PUSH BC           ; ...
       .pop hl                         ; POP HL            ; ...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (23) Start Loop (1 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34285 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34285. Output: HL  Address of next
* script instruction to execute
_48295:
       bl   @_48382                    ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       mov  a,@_34285                  ; LD (34285),A      ; Store repeat count at #R34285
       mov  hl,@_34285+1               ; LD (34286),HL     ; Store address to return to (i.e. first instruction in loop) at #R34285...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (24) End Loop (1 / 3) Output: HL  Address of next script instruction to execute
_48307:
       movb @_34285,a                  ; LD A,(34285)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       mov  a,@_34285                  ; LD (34285),A      ; ...and store
       mov  @_34285+1,hl               ; LD HL,(34286)     ; Load HL with address of first instruction in loop...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (25) Start Loop (2 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34288 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34288. Output: HL  Address of next
* script instruction to execute
_48324:
       bl   @_48382                    ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       mov  a,@_34288                  ; LD (34288),A      ; Store repeat count at #R34288
       mov  hl,@_34288+1               ; LD (34289),HL     ; Store address to return to (i.e. first instruction in loop) at #R34288...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (26) End Loop (2 / 3) Output: HL  Address of next script instruction to execute
_48336:
       movb @_34288,a                  ; LD A,(34288)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       mov  a,@_34288                  ; LD (34288),A      ; ...and store
       mov  @_34288+1,hl               ; LD HL,(34289)     ; Load HL with address of first instruction in loop...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (27) Start Loop (3 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34291 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34291. Output: HL  Address of next
* script instruction to execute
_48353:
       bl   @_48382                    ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       mov  a,@_34291                  ; LD (34291),A      ; Store repeat count at #R34291
       mov  hl,@_34291+1               ; LD (34292),HL     ; Store address to return to (i.e. first instruction in loop) at #R34291...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (28) End Loop (3 / 3) Output: HL  Address of next script instruction to execute
_48365:
       movb @_34291,a                  ; LD A,(34291)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       mov  a,@_34291                  ; LD (34291),A      ; ...and store
       mov  @_34291+1,hl               ; LD HL,(34292)     ; Load HL with address of first instruction in loop...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Load A with Script Instruction Parameter then Advance HL to Next Instruction
* 
* Used by the routines at #R48295, #R48324 and #R48353.
_48382:
       inc  hl                         ; INC HL            ; Advance HL by two bytes, beyond end of current instruction...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load value here into A
       inc  hl                         ; INC HL            ; Advance HL by two more bytes to start of next instruction...
       inc  hl                         ; INC HL            ; ...
       rt                              ; RET               ; Return

* Decrease Remaining Time for Current Power and if Zero, Exit Calling Routine and Run Script Data for Removal of
* Power
* 
* Used by the routines at #R35689, #R36542 and #R48487.
_48388:
       mov  @_34224,de                 ; LD DE,(34224)     ; Load remaining power time into DE
       movb @e,a                       ; LD A,E            ; Increase E (number of game-cycles power has been in use in current block)...
       ab   one,a                      ; INC A             ; ...
       movb a,@e                       ; LD E,A            ; ...
       cb   a,@bytes+15                ; CP 15             ; If 16 game-cycles of power use have not yet elapsed...
       jne  _48402                     ; JR NZ,48402       ; ...then skip ahead to #R48402
       movb @bytes+0,@e                ; LD E,0            ; Reset number of game-cycles power has been in use to zero...
       sb   one,d                      ; DEC D             ; ...and decrease remaining number of 16-game-cycles
_48402:
       mov  de,@_34224                 ; LD (34224),DE     ; Store updated remaining power time...
       jeq  !                          ; RET NZ            ; ...and return if this is not zero
       rt                              ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @_48417                    ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original position
       li   hl,_35275                  ; LD HL,35275       ; Point HL at script data for Berk's power expiring...
       b    @_48098                    ; JP 48098          ; ...and execute

* Remove Berk's Current Power and Reset Sweet / Mushroom / Edible Eyes / Sausage to its Original Position
* 
* Used by the routines at #R36390, #R36471, #R39151 and #R48388.
_48417:
       movb @_34220,a                  ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       .push ix                        ; PUSH IX           ; Store IX
       cb   a,@bytes+6                 ; CP 6              ; If Berk's current power is not 6 (flying, level 3, 2)...
       jne  _48445                     ; JR NZ,48445       ; ...then skip ahead to #R48445
       movb @bytes+13,a                ; LD A,13           ; Reset complex state data for Red Coloured Creature to that stored in Initial-State Table...
       bl   @_53987                    ; CALL 53987        ; ...
       movb @bytes+14,a                ; LD A,14           ; Reset complex state data for Yellow Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @_53987                    ; CALL 53987        ; ...
       movb @bytes+15,a                ; LD A,15           ; Reset complex state data for White Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @_53987                    ; CALL 53987        ; ...
       jmp  _48474                     ; JR 48474          ; Skip ahead to #R48474
_48445:
       cb   a,@bytes+10                ; CP 10             ; If Berk's current power is not 10 (floating)...
       jne  _48474                     ; JR NZ,48474       ; ...then skip ahead to #R48474
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       szcb @bits+7,@9(ix)             ; RES 7,(IX+9)      ; Reset Berk's Moving Upwards Flag
       movb @bytes+192,@11(ix)         ; LD (IX+11),192    ; Reset Berk's Walking Right, Walking Left, Unused (11,2), Unused (11,3), Impassable Leftwards
                                                           ; and Impassable Rightwards flags and set his Interaction (11,6) and Interaction (11,7) flags
       szcb @bits+7,@8(ix)             ; RES 7,(IX+8)      ; Reset bit 7 of Berk's class value (change from 159 to 31)
       sb   one,@6(ix)                 ; DEC (IX+6)        ; Decrease Berk's bottom y-coordinate by two...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @_55516                    ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
_48474:
       movb @_34220,a                  ; LD A,(34220)      ; Reset complex state data for entity responsible for Berk's current power to that stored in
                                                           ; Initial-State Table...
       bl   @_53987                    ; CALL 53987        ; ...
       sb   a,a                        ; XOR A             ; Clear Berk's current power...
       mov  a,@_34220                  ; LD (34220),A      ; ...
       .pop ix                         ; POP IX            ; Restore IX
       rt                              ; RET               ; Return

* Script Routine (32) Update Berk's Position and State (Flying) Depending Upon Control Input
* 
* See pokes Input:  IX  (Entry at #R48487 only) Address of complex state data (current level) for Berk IX  (Entry at
* #R48541 only) Address of complex state data for an entity Output: HL  Address of next script instruction to
* execute
_48487:
       bl   @_48388                    ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was not with entity of class 130 (causes Berk and Drutt to bounce off or
                                                           ; bang head)...
       jne  _48507                     ; JR NZ,48507       ; ...then skip ahead to #R48507
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset entity's Is Flying Flag
       li   hl,_35359                  ; LD HL,35359       ; Load HL with script data address for Berk starting to fall downwards
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_48507:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is 121 or greater...
       cb   a,@bytes+121               ; CP 121            ; ...
       jhe  _48527                     ; JR NC,48527       ; ...then skip ahead to #R48527
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 0,A           ; If right pressed...
       andi tmp0,1                     ;                   
       jeq  !                          ; JP NZ,48593       ; ...then move Berk right one character, and into new room if appropriate
       b    @_48593                    ;                   
!
       mov  a,tmp0                     ; BIT 1,A           ; If left pressed...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,48641       ; ...then move Berk left one character, and into new room if appropriate
       b    @_48641                    ;                   
!
_48527:
       equ  $
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is less than 98...
       cb   a,@bytes+98                ; CP 98             ; ...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       bl   @_55433                    ; CALL 55433        ; Change Berk's room up one if appropriate
       bl   @_48710                    ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37718. It is also the start of the routine triggered by instruction
* 34 in script data.
_48541:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease y-coordinates of entity's top and bottom edges by one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@4(iy)                 ; DEC (IY+4)        ; ...and decrease its top and bottom y-coordinates by one character...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (35) Move Entity at IX (and if Berk, Carried Entity) Down One Character
* 
* Used by the routine at #R37778. Input:  IX  Address of complex state data for an entity
_48567:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase y-coordinates of entity's top and bottom edges by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@4(iy)                 ; INC (IY+4)        ; ...and increase its top and bottom y-coordinates by one character...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Right One Character, and Into New Room if Appropriate
* 
* Used by the routine at #R48487. Input:  IX  (Entry at #R48593 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48615 only) Address of complex state data for an entity
_48593:
       movb @_34235,a                  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Berk's right side is less than x-coordinate of right of current room...
       cb   a,@e                       ; CP E              ; ...
       jl   _48615                     ; JR C,48615        ; ...then skip ahead to #R48615 (move Berk right by one character
       bl   @_54505                    ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the right, then jump to #R48096 (advance HL to next script
       b    @_48096                    ;                   
!
                                                           ; instruction and execute)
       bl   @_54383                    ; CALL 54383        ; Move Berk into room to right of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       bl   @_48710                    ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 03 in script data.
_48615:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Increase x-coordinates of entity's left and right edges by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...and increase its left and right x-coordinates by one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Left One Character, and Into New Room if Appropriate
* 
* Used by the routine at #R48487. Input:  IX  (Entry at #R48641 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48660 only) Address of complex state data for an entity
_48641:
       movb @bytes+100,a               ; LD A,100          ; If Berk's left-side x-coordinate is greater than 100 (x-coordinate of left side of room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   _48660                     ; JR C,48660        ; ...then skip ahead to #R48660 (move Berk left by one character)
       bl   @_54539                    ; CALL 54539        ; Load B with index of room to left of entity's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the left, then jump to #R48096 (advance HL to next script
       b    @_48096                    ;                   
!
                                                           ; instruction and execute)
       bl   @_54419                    ; CALL 54419        ; Move Berk into room to left of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       bl   @_48710                    ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 02 in script data.
_48660:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Decrease x-coordinates of entity's left and right edges by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16                    ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...and decrease its left and right x-coordinates by one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (22) Move Carried Entity Behind Berk as he Faces Into Screen
_48686:
       bl   @_48715                    ; CALL 48715        ; Move carried entity behind Berk as he faces into screen
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (21) Move Carried Entity in Front of Berk as he Faces Out of Screen
_48692:
       bl   @_48710                    ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (19) Move Carried Entity to Berk's Left as he Faces Left
_48698:
       bl   @_48738                    ; CALL 48738        ; Move carried entity to Berk's left as he faces left
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (20) Move Carried Entity to Berk's Right as he Faces Right
_48704:
       bl   @_48727                    ; CALL 48727        ; Move carried entity to Berk's right as he faces right
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Carried Entity in Front of Berk as he Faces Out of Screen
* 
* Used by the routines at #R36008, #R48487, #R48593, #R48641 and #R48692.
_48710:
       bl   @_48760                    ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       jmp  _48719                     ; JR 48719          ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850) and return

* Move Carried Entity Behind Berk as he Faces into Screen
* 
* Used by the routine at #R48686.
_48715:
       bl   @_48760                    ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routine at #R48710.
_48719:
       xor  one,a                      ; XOR 1             ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850)...
       ab   one,a                      ; INC A             ; ...
       a    @5(ix),a                   ; ADD A,(IX+5)      ; ...
       jmp  _48749                     ; JR 48749          ; Set carried entity's horizontal position and depth and return

* Move Carried Entity to Berk's Right as he Faces Right
* 
* Used by the routines at #R48704 and #R54383.
_48727:
       bl   @_48760                    ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
       neg a                           ; NEG               ; Subtract width of carried entity minus one divided by two...
       a    @7(ix),a                   ; ADD A,(IX+7)      ; ...from Berk's right-side x-coordinate and load into A
       jmp  _48749                     ; JR 48749          ; Set carried entity's calculated horizontal position and depth and return

* Move Carried Entity to Berk's Left as he Faces Left
* 
* Used by the routines at #R48698 and #R54419. Input:  IY  Address of complex state data for an entity carried by
* Berk
_48738:
       bl   @_48760                    ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       a    a,a                        ; ADD A,A           ; Double A to give width minus one... (see bugs)
       ab   one,a                      ; INC A             ; ...and add one to get width of entity
       neg a                           ; NEG               ; Subtract width of carried entity...
       a    @5(ix),a                   ; ADD A,(IX+5)      ; ...from Berk's left-side x-coordinate and load into A
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routines at #R48715 and #R48727.
_48749:
       movb a,@5(iy)                   ; LD (IY+5),A       ; Set carried entity's horizontal position and depth...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb d,@1(iy)                   ; LD (IY+1),D       ; ...
       rt                              ; RET               ; Return

* Load A, D and E with Positional Data for a Carried Entity or Return
* 
* Used by the routines at #R48710, #R48715, #R48727 and #R48738. Input:  IX  Address of complex state data for an
* entity Output: A  Width of carried entity (characters) minus 1, divided by two D  Depth of entity at IX (Berk) E
* Width of carried entity (characters) minus 1 IY  Address of complex state data for entity held by Berk
_48760:
       mov  @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity IX is Berk and his Carrying Something Flag is set...
       andi tmp0,16                    ;                   
       jne  _48768                     ; JR NZ,48768       ; ...then skip ahead to #R48768
       .pop bc                         ; POP BC            ; Pop top value (return address) off stack...
       rt                              ; RET               ; ...and return to routine that called the calling routine
_48768:
       mov  @_34260,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       movb *ix,a                      ; LD A,(IX+0)       ; Set this entity's room to be same as Berk's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       bl   @_48897                    ; CALL 48897        ; Move carried entity into vertical position appropriate to its height
       movb @_34272,a                  ; LD A,(34272)      ; Load A and E with width of entity (characters) carried by Berk, minus 1...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; Divide A by two, removing remainder
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load carried entity's depth into D
       rt                              ; RET               ; Return

* Unused routine
* 
* Assuming that IX and IY contain the addresses of two entities' complex state data, this routine will position the
* entity at IX such that it is horizontally centred with respect to, and B characters below the entity at IY. Input:
* IX  Address of complex state data for Entity 1 (assumed) IY  Address of complex state data for Entity 2 (assumed)
* B  Vertical offset (assumed)
_48791:
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height of Entity 1 minus one...
       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of bottom edge of Entity 2 plus B...
       a    b,a                        ; ADD A,B           ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; Set y-coordinate of bottom edge of Entity 1 to A
       sb   @c,a                       ; SUB C             ; Update y-coordinate of top edge of Entity 1 accordingly...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load B with width of Entity 1 minus one...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...
       movb a,b                        ; LD B,A            ; ...
       srl  a,1                        ; SRL A             ; Load C with half of width of Entity 1 minus one...
       movb a,@c                       ; LD C,A            ; ...
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with half of width of Entity 2 minus one...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; ...
       a    @5(iy),a                   ; ADD A,(IY+5)      ; ...and add x-coordinate of left edge of Entity 2
* At this point, A holds the x-coordinate of the mid-point of Entity 2
       sb   @c,a                       ; SUB C             ; Subtract half of width of Entity 1 minus one...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set as x-coordinate of left edge of Entity 1
       a    b,a                        ; ADD A,B           ; Update x-coordinate of right edge of entity 2 accordingly...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @8(ix),a                   ; LD A,(IX+8)       ; If Entity 1 is not Berk...
       cb   a,@bytes+31                ; CP 31             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       .push hl                        ; PUSH HL           ; Store HL
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Have Berk Hold an Entity, and Position it Appropriately Between his Hands
* 
* The instruction blocks #R48872-#R48894 and #R48897-#R48916 move the entity that Berk is carrying into position
* (i.e. between Berk's hands), at a horizontal or vertical position appropriate to the height / width of that
* entity. These instructions result in the following x- or y-coordinates (left or top of carried entity relative to
* left or top of carrier, i.e. Berk): Input:  IX  Address of complex state data (current level) for Berk IY  (entry
* at #R48897) Address of complex state data for an entity carried by Berk Output: IY  Address of complex state data
* for entity held by Berk
_48850:
       mov  @_34256,iy                 ; LD IY,(34256)     ; Load IY with address of complex state data for entity to be held by Berk...
       mov  iy,@_34260                 ; LD (34260),IY     ; ...and store at #R34260 as address of state data for entity held by Berk
       socb @bits+5,@10(iy)            ; SET 5,(IY+10)     ; Set the entity's Is Being Carried Flag
       socb @bits+4,@9(ix)             ; SET 4,(IX+9)      ; Set Berk's Carrying Something Flag
       movb @8(iy),a                   ; LD A,(IY+8)       ; Set class of entity held by Berk to be this entity's class...
       mov  a,@_34221                  ; LD (34221),A      ; ...
_48872:
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with the width of the entity, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       mov  a,@_34272                  ; LD (34272),A      ; ...and store at #R34272
       movb a,@e                       ; LD E,A            ; Load E with width of entity, minus 1
       srl  a,1                        ; SRL A             ; Move entity defined at IY into horizontal position appropriate to its height (see notes
                                                           ; above)...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       a    @5(ix),a                   ; ADD A,(IX+5)      ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       a    @e,a                       ; ADD A,E           ; ...
_48894:
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
* This entry point is used by the routine at #R48760.
_48897:
       movb @6(iy),a                   ; LD A,(IY+6)       ; Move entity defined at IY into vertical position appropriate to its height (see notes
                                                           ; above)...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; ...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       a    @4(ix),a                   ; ADD A,(IX+4)      ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       a    @e,a                       ; ADD A,E           ; ...
_48916:
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       rt                              ; RET               ; Return

* Script Routine (29) Make Berk Start Falling, and Drop his Carried Entity if Appropriate Input:  IX  Address of
* complex state data for an entity
_48920:
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set Berk's initial velocity factor to 2
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set Berk's "Can Fall" flag
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (30) Check Berk's Fall Velocity, and React to Landing
* 
* See trivia and pokes Input:  IX  Address of complex state data (current level) for Berk Output: HL  Address of
* next script instruction to execute
_48934:
       mov  @10(ix),tmp0               ; BIT 6,(IX+10)     ; If Berk's "Can Fall" Flag is reset (i.e. Berk has landed)...
       andi tmp0,64                    ;                   
       jeq  _48958                     ; JR Z,48958        ; ...then skip ahead to #R48958
       mov  @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8                     ;                   
       jne  _48952                     ; JR NZ,48952       ; ...then skip ahead to #R48952
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       b    @_48098                    ; JP 48098          ; ...and execute
_48952:
       li   hl,_35367                  ; LD HL,35367       ; Point HL at script data for Berk falling rapidly (horizontal, arms outstretched)...
       b    @_48098                    ; JP 48098          ; ...and execute
_48958:
       mov  @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8                     ;                   
       jne  _48970                     ; JR NZ,48970       ; ...then skip ahead to #R48970
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @_48098                    ; JP 48098          ; ...and execute
_48970:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (31) React to Berk's Landing
* 
* See trivia Input:  IX  Address of complex state data for an entity Output: HL  Address of next script instruction
* to execute
_48976:
       mov  @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8                     ;                   
       jne  _48988                     ; JR NZ,48988       ; ...then skip ahead to #R48988
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @_48098                    ; JP 48098          ; ...and execute
_48988:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @_48098                    ; JP 48098          ; ...and execute

* Table of Addresses of Berk's Jump Script Data
_48994:
       data _35441                                                   ; (1) - Berk starting to jump straight up
       data _35447                                                   ; (2) - Unused
       data _35457                                                   ; (3) - Berk landing (after jump)
       data _35469                                                   ; (4) - Berk jumping left
       data _35481                                                   ; (5) - Berk jumping right
       data _35283                                                   ; (6) - Berk banging head
       data _35339                                                   ; (7) - Berk falling to the right
       data _35303                                                   ; (8) - Berk falling to the left

* Script Routine (33) Advance Berk's Jump and Select Next Phase if Current Phase Complete Output: HL  Address of
* next script instruction to execute
_49010:
       bl   @_55041                    ; CALL 55041        ; Handle Berk's jump, and load A with Jump State Index as appropriate...
       movb @e,a                       ; LD A,E            ; ...
       socb a,a                        ; OR A              ; If Jump State Index is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease Jump State Index
       li   de,_48994                  ; LD DE,48994       ; Load DE with start address of Table of Addresses of Berk's Jump Script Data
       bl   @_53814                    ; CALL 53814        ; Advance DE by 2xA Bytes, load WORD at this location into HL...
       .ex_de_hl                       ; EX DE,HL          ; ...
       b    @_48098                    ; JP 48098          ; ...and execute script instruction at this location

* Graphic Layout Data Architecture (Level 4) Double Row of Green Bricks, 32 Characters Wide
_49029:
       byte 250,0,16                                                 ; Change cursor's x- and y-coordinates by +16 and 0 characters
                                                                     ; respectively
       byte 251,_49104%256,_49104/256                                ; Process graphic layout data at #R49104 and upon returning, move
                                                                     ; cursor to base coordinates
* Double Row of Green Bricks (1 / 2), 16 Characters Wide
_49035:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 9,161,10,161,11,161
       byte 9,161,10,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,10,161,11,145
       byte 9,161,11,161
       byte 9,161,10,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,11,161
       byte 255                                                      ; End Marker
* Double Row of Green Bricks (2 / 2), 16 Characters Wide
_49104:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 9,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,10,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,11,145
       byte 9,161,10,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 255                                                      ; End Marker
* Yellow Brick Column
_49173:
       byte 242,6                                                    ; Set current attribute to 6
       byte 248,_49180%256,_49180/256                                ; Jump to #R49180 (brick column)
* Green Brick Column
_49178:
       byte 242,4                                                    ; Set current attribute to 4
_49180:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,0,249                                                ; Change cursor's x- and y-coordinates by -7 and 0 characters
                                                                     ; respectively
       byte 9,161,10,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,10,161,10,161,11,143
       byte 9,161,10,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,10,161,10,161,10,161,11,161
       byte 9,161,10,161,11,148
       byte 9,161,11,161
       byte 9,161,10,161,10,161,11,161
       byte 9,161,10,161,11,161
       byte 9,161,11,153
       byte 9,161,10,161,10,161,11,161
       byte 9,161,11,155
       byte 9,161,10,161,10,161,11,158
       byte 9,161,10,161,11,157
       byte 9,161,10,161,11,158
       byte 9,161,10,161,11,159
       byte 9,161,11,159
       byte 9,161,10,161,11,158
       byte 9,161,11,158
       byte 9,161,10,161,10,161,11,158
       byte 9,161,11,159
       byte 9,161,10,161,11,158
       byte 9,161,11,158
       byte 9,161,10,161,11,158
       byte 9,161,10,161,10,161,11,158
       byte 9,161,10,161,11,158
       byte 9,161,11,158
       byte 9,161,10,161,11,159
       byte 9,161,11,158
       byte 9,161,10,161,10,161,11,161
       byte 255                                                      ; End Marker
* Small Red and Blue Wall
_49392:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,2                                                    ; Set current attribute to 2
       byte 238,4                                                    ; Set Repeat Counter A to 4
_49398:
       byte 9,161,11,159
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R49398 if not zero
       byte 242,1                                                    ; Set current attribute to 1
       byte 238,3                                                    ; Set Repeat Counter A to 3
_49407:
       byte 9,161,11,159
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R49407 if not zero
       byte 255                                                      ; End Marker
* Fake Boni's Alcove
_49413:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 250,251,0                                                ; Change cursor's x- and y-coordinates by 0 and -4 characters
                                                                     ; respectively
       byte 9,161,10,161
       byte 10,161,10,161
       byte 10,161,11,153
       byte 9,161,10,161
       byte 10,161,11,163
       byte 9,161,11,154
       byte 9,161,10,161
       byte 11,163,9,161
       byte 10,161,11,154
       byte 9,161,11,163
       byte 9,161,11,154
       byte 9,161,10,161
       byte 11,163,9,161
       byte 10,161,11,154
       byte 9,161,10,161
       byte 10,161,10,161
       byte 10,161,11,161
       byte 255                                                      ; End Marker
* Snake's Brickwork
_49489:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 9,161,10,161
       byte 10,161,10,161
       byte 11,161
       byte 250,3,251                                                ; Change cursor's x- and y-coordinates by -4 and +3 characters
                                                                     ; respectively
       byte 9,161,10,161
       byte 11,161,9,161
       byte 11,161,9,161
       byte 11,154,9,161
       byte 10,161,10,161
       byte 11,161,9,161
       byte 10,161,11,161
       byte 255                                                      ; End Marker
* Left Wall, Short
_49535:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 238,8                                                    ; Set Repeat Counter A to 8
_49541:
       byte 9,161,10,161
       byte 11,159,9,161
       byte 11,158
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R49541 if not zero
       byte 255                                                      ; End Marker
* Right Wall, Long
_49553:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,4                                                    ; Set current attribute to 4
       byte 238,11                                                   ; Set Repeat Counter A to 11
_49559:
       byte 9,161,10,161
       byte 11,158,9,161
       byte 11,159
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R49559 if not zero
       byte 255                                                      ; End Marker
* Long Yellow Brick
_49571:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 242,6                                                    ; Set current attribute to 6
       byte 9,161,10,161
       byte 10,161,11,161
       byte 255                                                      ; End Marker
* Vertical Red Bar (Outside Normal Game Area)
_49584:
       byte 242,18                                                   ; Set current attribute to 18
       byte 238,20                                                   ; Set Repeat Counter A to 20
_49588:
       byte 0,33,0,33
       byte 0,33,0,33
       byte 0,28
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R49588 if not zero
       byte 255                                                      ; End Marker
* Drip Stage 1 - Green Drip, Forming
_49600:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,4,33,14,4,33
       byte 13,4,33
       byte 255                                                      ; End Marker
* Drip Stage 2 - Red Drip, Enlarging
_49615:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,2,33,15,2,33
       byte 13,2,33
       byte 255                                                      ; End Marker
* Drip Stage 3 - Magenta Drip, Enlarging
_49630:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,3,33,16,3,33
       byte 13,3,33
       byte 255                                                      ; End Marker
* Drip Stage 4 - Cyan Drip, Enlarging
_49645:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,5,33,17,5,33
       byte 13,5,31,18,5,33
       byte 255                                                      ; End Marker
* Drip Stage 5 - Yellow Drip, Full Size
_49663:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,6,33,19,6,33
       byte 13,6,31,20,6,33
       byte 255                                                      ; End Marker
* Drip Stage 6 - Yellow Drip, Extended
_49681:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters
                                                                     ; respectively
       byte 12,6,33,21,6,33
       byte 13,6,31,22,70,33
       byte 255                                                      ; End Marker
* Drip Stage 7 - Drip Disconnected and Falling / Cannon Projectile
_49699:
       byte 244,12                                                   ; Set current graphic set to 12
       byte 22,71,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Architecture (Level 3) Ceiling (Full Width)
_49705:
       byte 251,_49716%256,_49716/256                                ; Process graphic layout data at #R49716 and upon returning, move cursor to base coordinates
       byte 250,0,16                                                 ; Change cursor's x- and y-coordinates by +16 and 0 characters respectively
* Ceiling (Half Width)
_49711:
       byte 242,196                                                  ; Set current attribute to 196
       byte 248,_49718%256,_49718/256                                ; Jump to #R49718
_49716:
       byte 242,68                                                   ; Set current attribute to 68
_49718:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 32,33,27,33
       byte 28,33,9,33
       byte 10,33,30,33
       byte 31,33,28,33
       byte 13,33,14,33
       byte 9,33,32,33
       byte 31,33,30,33
       byte 14,33,10,33
       byte 255                                                      ; End Marker
* Platform
       byte 244,10                                                   ; Set current graphic set to 10
       byte 242,4                                                    ; Set current attribute to 4
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 31,33,29,33
       byte 28,33,27,33
       byte 30,28,31,33
       byte 29,33,28,33
       byte 27,33,30,33
       byte 255                                                      ; End Marker
* Fifteen Glowing Tangleweeds, Animated
_49781:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 254,0,246                                                ; Change cursor's x- and y-coordinates by -10 and 0 characters respectively and store as new
                                                                     ; base coordinates
       byte 248,_49841%256,_49841/256                                ; Jump to #R49841
* Six Glowing Tangleweeds, Animated
_49789:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 254,0,233                                                ; Change cursor's x- and y-coordinates by -23 and 0 characters respectively and store as new
                                                                     ; base coordinates
       byte 248,_49901%256,_49901/256                                ; Jump to #R49901
* Twenty Two Glowing Tangleweeds, Animated
_49797:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 250,254,0                                                ; Change cursor's x- and y-coordinates by 0 and -2 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,251,1                                                ; Change cursor's x- and y-coordinates by +1 and -5 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,251,3                                                ; Change cursor's x- and y-coordinates by +3 and -5 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,251,6                                                ; Change cursor's x- and y-coordinates by +6 and -5 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,252,7                                                ; Change cursor's x- and y-coordinates by +7 and -4 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,251,8                                                ; Change cursor's x- and y-coordinates by +8 and -5 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,254,9                                                ; Change cursor's x- and y-coordinates by +9 and -2 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
_49841:
       byte 250,0,10                                                 ; Change cursor's x- and y-coordinates by +10 and 0 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,251,11                                               ; Change cursor's x- and y-coordinates by +11 and -5 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,250,14                                               ; Change cursor's x- and y-coordinates by +14 and -6 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,253,14                                               ; Change cursor's x- and y-coordinates by +14 and -3 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,255,17                                               ; Change cursor's x- and y-coordinates by +17 and -1 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,251,18                                               ; Change cursor's x- and y-coordinates by +18 and -5 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,253,19                                               ; Change cursor's x- and y-coordinates by +19 and -3 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,255,20                                               ; Change cursor's x- and y-coordinates by +20 and -1 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,253,21                                               ; Change cursor's x- and y-coordinates by +21 and -3 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,252,22                                               ; Change cursor's x- and y-coordinates by +22 and -4 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
_49901:
       byte 250,254,23                                               ; Change cursor's x- and y-coordinates by +23 and -2 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,255,25                                               ; Change cursor's x- and y-coordinates by +25 and -1 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,252,26                                               ; Change cursor's x- and y-coordinates by +26 and -4 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,253,28                                               ; Change cursor's x- and y-coordinates by +28 and -3 characters respectively
       byte 251,_49971%256,_49971/256                                ; Process graphic layout data at #R49971 and upon returning, move cursor to base coordinates
       byte 250,0,30                                                 ; Change cursor's x- and y-coordinates by +30 and 0 characters respectively
       byte 251,_49934%256,_49934/256                                ; Process graphic layout data at #R49934 and upon returning, move cursor to base coordinates
       byte 250,252,31                                               ; Change cursor's x- and y-coordinates by +31 and -4 characters respectively
_49934:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _49942%256,_49942/256                                    ; #R49942 (Green Tangleweed 1)
       byte _49947%256,_49947/256                                    ; #R49947 (Yellow Tangleweed 1)
       byte _49952%256,_49952/256                                    ; #R49952 (Green Tangleweed 1) (see trivia)
* Green Tangleweed (1)
_49942:
       byte 242,4                                                    ; Set current attribute to 4
       byte 248,_49954%256,_49954/256                                ; Jump to #R49954
* Yellow Tangleweed (1)
_49947:
       byte 242,6                                                    ; Set current attribute to 6
       byte 248,_49954%256,_49954/256                                ; Jump to #R49954
* Green Tangleweed (1)
_49952:
       byte 242,4                                                    ; Set current attribute to 4
_49954:
       byte 9,32,10,32
       byte 11,32,12,32
       byte 13,32,14,32
       byte 15,32,16,33
       byte 255                                                      ; End Marker
* Glowing Tangleweed (2)
_49971:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _49979%256,_49979/256                                    ; #R49979 (Green Tangleweed 2)
       byte _49984%256,_49984/256                                    ; #R49984 (Yellow Tangleweed 2)
       byte _49989%256,_49989/256                                    ; #R49989 (Green Tangleweed 2) (see trivia)
* Green Tangleweed (2)
_49979:
       byte 242,4                                                    ; Set current attribute to 4
       byte 248,_49991%256,_49991/256                                ; Jump to #R49991
* Yellow Tangleweed (2)
_49984:
       byte 242,6                                                    ; Set current attribute to 6
       byte 248,_49991%256,_49991/256                                ; Jump to #R49991
* Green Tangleweed (2)
_49989:
       byte 242,4                                                    ; Set current attribute to 4
_49991:
       byte 17,32,18,32
       byte 19,32,20,32
       byte 21,32,22,32
       byte 23,32,24,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Architecture (Level 1) Part 1 Three Spider's Webs
_50008:
       byte 240,3                                                    ; Set Repeat Counter B to 3
_50010:
       byte 251,_50018%256,_50018/256                                ; Process graphic layout data at #R50018 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 254,0,8                                                  ; Change cursor's x- and y-coordinates by +8 and 0 characters respectively and store as
                                                                     ; new base coordinates
       byte 241                                                      ; Decrement Repeat Counter B and loop back to #R50010 if not zero
       byte 255                                                      ; End Marker
* Spider's Web
_50018:
       byte 244,5                                                    ; Set current graphic set to 5
       byte 242,7                                                    ; Set current attribute to 7
       byte 250,2,2                                                  ; Change cursor's x- and y-coordinates by +2 and +2 characters respectively
       byte 1,161,2,161
       byte 3,157,4,161
       byte 5,161,6,161
       byte 7,161,8,156
       byte 9,161,10,161
       byte 11,161,12,161
       byte 13,161,14,155
       byte 15,161,16,161
       byte 17,161,18,161
       byte 19,156,20,165
       byte 21,161
       byte 255                                                      ; End Marker
* Upper Section of Arch
_50068:
       byte 242,4                                                    ; Set current attribute to 4
       byte 244,3                                                    ; Set current graphic set to 3
       byte 250,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively
       byte 56,33,57,33
       byte 58,33,59,28
       byte 60,33,61,33
       byte 62,33,63,33
       byte 9,33,10,26
       byte 11,33,12,33
       byte 13,35,14,33
       byte 15,33,16,25
       byte 17,33,18,37
       byte 19,33,20,33
       byte 255                                                      ; End Marker
* Four Arches
_50116:
       byte 240,4                                                    ; Set Repeat Counter B to 4
_50118:
       byte 251,_50126%256,_50126/256                                ; Process graphic layout data at #R50126 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 254,0,8                                                  ; Change cursor's x- and y-coordinates by +8 and 0 characters respectively and store as
                                                                     ; new base coordinates
       byte 241                                                      ; Decrement Repeat Counter B and loop back to #R50118 if not zero
       byte 255                                                      ; End Marker
* Single Arch
_50126:
       byte 251,_50068%256,_50068/256                                ; Process graphic layout data at #R50068 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,4,0                                                  ; Change cursor's x- and y-coordinates by 0 and +4 characters respectively
       byte 242,6                                                    ; Set current attribute to 6
       byte 23,39,22,25
       byte 30,39,29,25
       byte 32,39,31,33
       byte 255                                                      ; End Marker
* Boni's Platform
_50147:
       byte 242,6                                                    ; Set current attribute to 6
       byte 244,3                                                    ; Set current graphic set to 3
       byte 29,33,30,31
       byte 31,33,32,33
       byte 255                                                      ; End Marker
* Floor (Full Width, 32 chars)
_50160:
       byte 251,_50238%256,_50238/256                                ; Process graphic layout data at #R50238 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,12                                                 ; Change cursor's x- and y-coordinates by +12 and 0 characters respectively
       byte 242,4                                                    ; Set current attribute to 4
       byte 52,161,53,161
       byte 54,161,55,161
       byte 242,132                                                  ; Set current attribute to 132
       byte 55,161,54,161
       byte 53,161,52,161
       byte 44,161,43,161
       byte 42,161,41,161
       byte 40,161,39,161
       byte 38,161,37,161
       byte 36,161,35,161
       byte 34,161,33,161
       byte 255                                                      ; End Marker
* Right Half of Floor
_50211:
       byte 242,132                                                  ; Set current attribute to 132
       byte 44,161,43,161
       byte 42,161,41,161
       byte 40,161,39,161
       byte 38,161,37,161
       byte 36,161,35,161
       byte 34,161,33,161
       byte 255                                                      ; End Marker
* Left Part of Floor (Also Used in Level 4)
_50238:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 242,4                                                    ; Set current attribute to 4
       byte 33,161,34,161
       byte 35,161,36,161
       byte 37,161,38,161
       byte 39,161,40,161
       byte 41,161,42,161
       byte 43,161,44,161
       byte 255                                                      ; End Marker
* Trap Door, Closed
_50267:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 242,70                                                   ; Set current attribute to 70
       byte 45,161,46,161
       byte 238,5                                                    ; Set Repeat Counter A to 5
_50277:
       byte 47,161
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50277 if not zero
       byte 48,161
       byte 255                                                      ; End Marker
* Trap Door, Open
_50283:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 250,0,8                                                  ; Change cursor's x- and y-coordinates by +8 and 0 characters respectively
       byte 238,7                                                    ; Set Repeat Counter A to 7
_50290:
       byte 49,78,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50290 if not zero
       byte 51,78,33
       byte 250,250,0                                                ; Change cursor's x- and y-coordinates by 0 and -6 characters respectively
       byte 50,6,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Boni Fake Boni (Level 4)
_50304:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 242,6                                                    ; Set current attribute to 6
       byte 248,_50321%256,_50321/256                                ; Jump to #R50321
* Boni Talking (Animated)
_50311:
       byte 247,2                                                    ; Jump to one of the 2 addresses in the following list, chosen at random:
       byte _50317%256,_50317/256                                    ; #R50317 (Boni, mouth closed)
       byte _50338%256,_50338/256                                    ; #R50338 (Boni, mouth open)
* Boni (Mouth closed)
_50317:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 242,7                                                    ; Set current attribute to 7
_50321:
       byte 9,33,10,31
       byte 11,33,12,31
       byte 13,33,14,31
       byte 15,33,16,33
       byte 255                                                      ; End Marker
* Boni (Mouth open)
_50338:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 242,7                                                    ; Set current attribute to 7
       byte 1,33,2,31
       byte 3,33,4,31
       byte 5,33,6,31
       byte 7,33,8,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Architecture (Level 1) Part 2 Wall, vertical bricks, single row
_50359:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 238,3                                                    ; Set Repeat Counter A to 3
_50363:
       byte 25,4,160,27,4,160
       byte 26,4,160,28,4,160
       byte 25,132,160,27,132,160
       byte 26,132,160,28,132,160
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50363 if not zero
       byte 255                                                      ; End Marker
* Background brickwork
_50389:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 250,0,12                                                 ; Change cursor's x- and y-coordinates by +12 and 0 characters respectively
       byte 21,4,33,23,4,21
       byte 22,4,33,24,4,32
       byte 250,0,7                                                  ; Change cursor's x- and y-coordinates by +7 and 0 characters respectively
       byte 25,4,32,27,4,27
       byte 23,132,33,21,132,27
       byte 24,132,33,22,132,33
       byte 250,1,8                                                  ; Change cursor's x- and y-coordinates by +8 and +1 characters respectively
       byte 23,132,33,22,132,24
       byte 22,4,33,22,132,33
       byte 250,1,3                                                  ; Change cursor's x- and y-coordinates by +3 and +1 characters respectively
       byte 26,4,32,28,4,25
       byte 23,132,33,22,132,43
       byte 25,132,32,28,4,21
       byte 21,4,33,23,4,33
       byte 250,1,5                                                  ; Change cursor's x- and y-coordinates by +5 and +1 characters respectively
       byte 22,4,33,24,4,33
       byte 255                                                      ; End Marker
* "Home Sweet Home" Message Brick Border (End of Game)
_50479:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 242,4                                                    ; Set current attribute to 4
       byte 21,161,23,161
       byte 22,161,24,161
       byte 21,161,24,161
       byte 22,161,23,161
       byte 21,161,23,161
       byte 22,161,24,161
       byte 22,161,23,161
       byte 21,161,24,161
       byte 25,144,26,176
       byte 27,144,27,176
       byte 26,144,21,161
       byte 23,161,22,161
       byte 24,161,21,161
       byte 24,161,22,161
       byte 23,161,21,161
       byte 23,161,22,161
       byte 24,161,22,161
       byte 23,161,21,161
       byte 24,161,28,161
       byte 255                                                      ; End Marker

* Graphic Layout Data Sweets (Level 1) Red Sweet
_50560:
       byte 242,66                                                   ; Set current attribute to 66
       byte 248,_50572%256,_50572/256                                ; Jump to #R50572
* Green Sweet
_50565:
       byte 242,68                                                   ; Set current attribute to 68
       byte 248,_50572%256,_50572/256                                ; Jump to #R50572
* Cyan Sweet (Unused)
       byte 242,69                                                   ; Set current attribute to 69
_50572:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 17,33,18,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Architecture (Level 1) Part 3 Vertical Wall (Horizontal Bricks)
_50579:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 238,5                                                    ; Set Repeat Counter A to 5
_50583:
       byte 21,4,33,24,4,31
       byte 22,4,33,23,4,31
       byte 23,132,33,21,132,31
       byte 24,132,33,22,132,31
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50583 if not zero
       byte 255                                                      ; End Marker
* Row of five horizontal bricks
_50609:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 21,4,33,24,4,33
       byte 22,4,33,23,4,33
       byte 23,132,33,21,132,33
       byte 24,132,33,22,132,33
       byte 21,4,33,24,4,33
       byte 255                                                      ; End Marker
* Platform (Pit)
_50642:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 238,2                                                    ; Set Repeat Counter A to 2
_50649:
       byte 21,4,33,24,4,33
       byte 22,4,33,23,4,29
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50649 if not zero
       byte 255                                                      ; End Marker

* Graphic Layout Data Doors Level 1
_50663:
       byte 244,3                                                    ; Set current graphic set to 3
       byte 248,_50680%256,_50680/256                                ; Jump to #R50680
* Level 2
_50668:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 248,_50680%256,_50680/256                                ; Jump to #R50680
* Level 3
_50673:
       byte 244,10                                                   ; Set current graphic set to 10
       byte 248,_50680%256,_50680/256                                ; Jump to #R50680
* Level 4
_50678:
       byte 244,12                                                   ; Set current graphic set to 12
_50680:
       byte 251,_50701%256,_50701/256                                ; Process graphic layout data at #R50701 and upon returning,
                                                                     ; move cursor to base coordinates
       byte 244,4                                                    ; Set current graphic set to 4
       byte 250,251,3                                                ; Change cursor's x- and y-coordinates by +3 and -5
                                                                     ; characters respectively
       byte 21,6,33,21,134,31
       byte 22,6,33,22,134,33
       byte 255                                                      ; End Marker
* Door (Common)
_50701:
       byte 238,9                                                    ; Set Repeat Counter A to 9
_50703:
       byte 251,_50711%256,_50711/256                                ; Process graphic layout data at #R50711 and upon returning,
                                                                     ; move cursor to base coordinates
       byte 254,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1
                                                                     ; characters respectively and store as new base coordinates
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R50703 if not
                                                                     ; zero
       byte 255                                                      ; End Marker
* Door Patterns
_50711:
       byte 242,5                                                    ; Set current attribute to 5
       byte 243,0,4                                                  ; Increase current state value n (initially 0), up to
                                                                     ; maximum of 4, resetting to zero if maximum reached and
                                                                     ; jump to n-th address in following list:
       byte _50724%256,_50724/256                                    ; #R50724
       byte _50741%256,_50741/256                                    ; #R50741
       byte _50758%256,_50758/256                                    ; #R50758
       byte _50775%256,_50775/256                                    ; #R50775
* Door Pattern Sequences (these are cycled through)
_50724:
       byte 1,33,2,33,3,33,4,33,5,33,6,33,7,33,8,33,255              ; Door row state 1
_50741:
       byte 2,33,3,33,4,33,1,33,6,33,7,33,8,33,5,33,255              ; Door row state 2
_50758:
       byte 3,33,4,33,1,33,2,33,7,33,8,33,5,33,6,33,255              ; Door row state 3
_50775:
       byte 4,33,1,33,2,33,3,33,8,33,5,33,6,33,7,33,255              ; Door row state 4

* Graphic Layout Data Miscellaneous Part 2 Key
_50792:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 19,7,33
       byte 20,7,33
_50800:
       byte 255                                                      ; End Marker

* Graphic Layout Data Architecture (Level 2)
* 
* Note that the graphic layout data that describes the floor of the rooms on Level 2 is also used (with a different
* attribute value) for the floors on Level 3. Green Floor (Level 3)
_50801:
       byte 242,4                                                    ; Set current attribute to 4
       byte 248,_50808%256,_50808/256                                ; Jump to #R50808
* Red Floor
_50806:
       byte 242,2                                                    ; Set current attribute to 2
_50808:
       byte 244,1                                                    ; Set current graphic set to 1
       byte 1,161,2,161
       byte 3,161,4,161
       byte 5,161,6,161
       byte 7,161,8,161
       byte 9,161,10,161
       byte 11,161,12,161
       byte 13,161,14,161
       byte 15,161,16,161
       byte 1,161,2,161
       byte 3,161,4,161
       byte 5,161,6,161
       byte 7,161,8,161
       byte 9,161,10,161
       byte 11,161,12,161
       byte 13,161,14,161
       byte 15,161,16,161
       byte 255                                                      ; End Marker
* Ceiling 1
_50875:
       byte 251,_50923%256,_50923/256                                ; Process graphic layout data at #R50923 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,16                                                 ; Change cursor's x- and y-coordinates by +16 and 0 characters respectively
       byte 248,_51000%256,_51000/256                                ; Jump to #R51000 (Ceiling Section 2)
* Ceiling 2
_50884:
       byte 251,_51000%256,_51000/256                                ; Process graphic layout data at #R51000 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,16                                                 ; Change cursor's x- and y-coordinates by +16 and 0 characters respectively
       byte 248,_50923%256,_50923/256                                ; Jump to #R50923 (Ceiling Section 1)
* Right Wall
_50893:
       byte 251,_51069%256,_51069/256                                ; Process graphic layout data at #R51069 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,7,0                                                  ; Change cursor's x- and y-coordinates by 0 and +7 characters respectively
       byte 251,_51100%256,_51100/256                                ; Process graphic layout data at #R51100 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,14,0                                                 ; Change cursor's x- and y-coordinates by 0 and +14 characters respectively
       byte 248,_51069%256,_51069/256                                ; Jump to #R51069 (Right Wall Section 1)
* Left Wall
_50908:
       byte 251,_51159%256,_51159/256                                ; Process graphic layout data at #R51159 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,7,0                                                  ; Change cursor's x- and y-coordinates by 0 and +7 characters respectively
       byte 251,_51131%256,_51131/256                                ; Process graphic layout data at #R51131 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,14,0                                                 ; Change cursor's x- and y-coordinates by 0 and +14 characters respectively
       byte 248,_51159%256,_51159/256                                ; Jump to #R51159 (Left Wall Section 1)
* Ceiling Section 1
_50923:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 0,18,33,0,18,33
       byte 27,66,33,28,66,33
       byte 29,66,33,0,18,33
       byte 0,18,33,0,18,33
       byte 0,18,33,0,18,33
       byte 30,66,33,31,66,33
       byte 0,18,33,0,18,33
       byte 0,18,33,0,18,17
       byte 242,66                                                   ; Set current attribute to 66
       byte 32,33,33,35
       byte 34,33,9,33
       byte 10,33,32,33
       byte 33,33,11,35
       byte 12,33,13,33
       byte 14,33,32,33
       byte 255                                                      ; End Marker
* Ceiling Section 2
_51000:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 0,18,33,32,66,33
       byte 0,18,33,0,18,33
       byte 0,18,33,30,66,33
       byte 9,66,33,33,66,33
       byte 11,66,33,12,66,33
       byte 29,66,33,0,18,33
       byte 0,18,33,0,18,33
       byte 242,66                                                   ; Set current attribute to 66
       byte 28,33,29,17
       byte 33,34,12,33
       byte 14,33,33,38
       byte 34,33,32,33
       byte 9,33,33,34
       byte 34,33
       byte 255                                                      ; End Marker
* Right Wall Section 1
_51069:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 250,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively
       byte 238,8                                                    ; Set Repeat Counter A to 8
_51076:
       byte 0,18,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R51076 if not zero
       byte 250,249,255                                              ; Change cursor's x- and y-coordinates by -1 and -7 characters respectively
       byte 242,66                                                   ; Set current attribute to 66
       byte 15,32,16,32
       byte 17,32,18,32
       byte 19,32,16,32
       byte 20,33
       byte 255                                                      ; End Marker
* Right Wall Section 2
_51100:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 250,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively
       byte 238,8                                                    ; Set Repeat Counter A to 8
_51107:
       byte 0,18,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R51107 if not zero
       byte 250,249,255                                              ; Change cursor's x- and y-coordinates by -1 and -7 characters respectively
       byte 242,66                                                   ; Set current attribute to 66
       byte 18,32,16,32
       byte 19,32,16,32
       byte 20,32,18,32
       byte 17,33
       byte 255                                                      ; End Marker
* Left Wall Section 1
_51131:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 238,8                                                    ; Set Repeat Counter A to 8
_51135:
       byte 0,18,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R51135 if not zero
       byte 250,249,1                                                ; Change cursor's x- and y-coordinates by +1 and -7 characters respectively
       byte 242,194                                                  ; Set current attribute to 194
       byte 15,32,16,32
       byte 17,32,18,32
       byte 19,32,16,32
       byte 20,33
       byte 255                                                      ; End Marker
* Left Wall Section 1
_51159:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 238,8                                                    ; Set Repeat Counter A to 8
_51163:
       byte 0,18,32
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R51163 if not zero
       byte 250,249,1                                                ; Change cursor's x- and y-coordinates by +1 and -7 characters respectively
       byte 242,194                                                  ; Set current attribute to 194
       byte 18,32,16,32
       byte 19,32,16,32
       byte 20,32,18,32
       byte 17,33
       byte 255                                                      ; End Marker
* Sides of Ceiling Gap
_51187:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 15,194,39,18,66,25
       byte 7,66,39,20,66,33                                         ; See bugs
       byte 255                                                      ; End Marker
* Nine stalactites at various heights
_51202:
       byte 250,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,255,7                                                ; Change cursor's x- and y-coordinates by +7 and -1 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,254,11                                               ; Change cursor's x- and y-coordinates by +11 and -2 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,17                                                 ; Change cursor's x- and y-coordinates by +17 and 0 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,255,20                                               ; Change cursor's x- and y-coordinates by +20 and -1 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,26                                                 ; Change cursor's x- and y-coordinates by +26 and 0 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,254,29                                               ; Change cursor's x- and y-coordinates by +29 and -2 characters respectively
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,255,33                                               ; Change cursor's x- and y-coordinates by +33 and -1 characters respectively (see
                                                                     ; trivia)
       byte 251,_51253%256,_51253/256                                ; Process graphic layout data at #R51253 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,35                                                 ; Change cursor's x- and y-coordinates by +35 and 0 characters respectively (see
                                                                     ; trivia)
_51253:
       byte 244,8                                                    ; Set current graphic set to 8
       byte 22,66,32,23,66,32
       byte 24,66,32,25,2,32
       byte 26,2,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Mushroom
_51271:
       byte 244,4                                                    ; Set current graphic set to 4
       byte 34,71,33,35,71,31
       byte 36,7,33,37,7,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Flying Skeleton Creature Boni being kidnapped, shouting for help, animated
_51286:
       byte 251,_51314%256,_51314/256                                ; Process graphic layout data at #R51314 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_50311%256,_50311/256                                ; Process graphic layout data at #R50311 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 244,6                                                    ; Set current graphic set to 6
       byte 250,2,2                                                  ; Change cursor's x- and y-coordinates by +2 and +2 characters respectively
       byte 242,7                                                    ; Set current attribute to 7
       byte 21,33,22,161
       byte 23,161,24,33
       byte 255                                                      ; End Marker
* Boni being kidnapped, mouth closed
_51308:
       byte 251,_51314%256,_51314/256                                ; Process graphic layout data at #R51314 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_50317%256,_50317/256                                ; Jump to #R50317 (Boni, Mouth Closed)
* Flying Skeleton Creature, animated
_51314:
       byte 244,6                                                    ; Set current graphic set to 6
       byte 251,_51345%256,_51345/256                                ; Process graphic layout data at #R51345 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,5,0                                                  ; Change cursor's x- and y-coordinates by 0 and +5 characters respectively
       byte 2,7,33,2,135,31
       byte 247,2                                                    ; Jump to one of the 2 addresses in the following list, chosen at random:
       byte _51334%256,_51334/256                                    ; #R51334 (tail pointing left)
       byte _51338%256,_51338/256                                    ; #R51338 (tail pointing right)
* Tail pointing left
_51334:
       byte 3,7,33
       byte 255                                                      ; End Marker
* Tail pointing right
_51338:
       byte 250,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively
       byte 3,135,33
       byte 255                                                      ; End Marker
* Upper Body & Wings, animated
_51345:
       byte 243,0,4                                                  ; Increase current state value n (initially 0), up to maximum of 4, resetting to zero if
                                                                     ; maximum reached and jump to n-th address in following list:
       byte _51356%256,_51356/256                                    ; #R51356 (upper body and wings, frame 1)
       byte _51398%256,_51398/256                                    ; #R51398 (upper body and wings, frame 2)
       byte _51441%256,_51441/256                                    ; #R51441 (upper body and wings, frame 3)
       byte _51398%256,_51398/256                                    ; #R51398 (upper body and wings, frame 2)
* Upper Body and Wings, Frame 1
_51356:
       byte 254,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively and store as
                                                                     ; new base coordinates
       byte 251,_51380%256,_51380/256                                ; Process graphic layout data at #R51380 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 242,7                                                    ; Set current attribute to 7
       byte 250,2,254                                                ; Change cursor's x- and y-coordinates by -2 and +2 characters respectively
       byte 4,33,5,31
       byte 6,33,7,32
       byte 8,33,1,33
       byte 255                                                      ; End Marker
* Right Wing and Upper-Right Body Section, Frame 1
_51380:
       byte 242,135                                                  ; Set current attribute to 135
       byte 250,2,2                                                  ; Change cursor's x- and y-coordinates by +2 and +2 characters respectively
       byte 5,33,4,31
       byte 7,33,6,30
       byte 1,33,8,33
       byte 255                                                      ; End Marker
* Upper Body and Wings, Frame 2
_51398:
       byte 251,_51421%256,_51421/256                                ; Process graphic layout data at #R51421 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 242,7                                                    ; Set current attribute to 7
       byte 250,3,254                                                ; Change cursor's x- and y-coordinates by -2 and +3 characters respectively
       byte 9,33,10,30
       byte 11,33,12,33
       byte 13,33,14,29
       byte 20,33
       byte 255                                                      ; End Marker
* Right Wing and Upper-Right Body Section, Frame 2
_51421:
       byte 242,135                                                  ; Set current attribute to 135
       byte 250,3,2                                                  ; Change cursor's x- and y-coordinates by +2 and +3 characters respectively
       byte 10,33,9,30
       byte 14,33,13,33
       byte 12,33,11,32
       byte 20,33
       byte 255                                                      ; End Marker
* Upper Body and Wings, Frame 3
_51441:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and store as
                                                                     ; new base coordinates
       byte 251,_51465%256,_51465/256                                ; Process graphic layout data at #R51465 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 242,7                                                    ; Set current attribute to 7
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 15,33,16,33
       byte 14,30,17,33
       byte 18,31,19,33
       byte 255                                                      ; End Marker
* Right Wing and Upper-Right Body Section, Frame 3
_51465:
       byte 242,135                                                  ; Set current attribute to 135
       byte 250,4,1                                                  ; Change cursor's x- and y-coordinates by +1 and +4 characters respectively
       byte 14,33,16,33
       byte 15,31,18,33
       byte 17,32,19,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Explosion (Bubo's Projectile, Fallen Drips and Firing Cannon, Level 4)
_51483:
       byte 237,4                                                    ; Set sound 4 (explosion) as pending
       byte 244,9                                                    ; Set current graphic set to 9
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters respectively
       byte 40,7,33,41,7,33
       byte 40,135,30,42,7,33
       byte 43,120,33,42,135,30
       byte 45,7,33,46,7,33
       byte 45,135,33
       byte 255                                                      ; End Marker

* Current Position in Drutt's Script Data
_51518:
       data _51524

* Script Data Drutt Facing Out of Screen (Falling)
_51520:
       byte _52371%256,_52371/256                                    ; #R52371 (Drutt, facing out of screen, fully animated)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Drutt Facing Out of Screen
_51524:
       byte _52379%256,_52379/256                                    ; #R52379 (Drutt, facing out of screen, legs bent, eyes and mouth animated)
       byte _52392%256,_52392/256                                    ; #R52392 (Drutt, facing out of screen, legs partially extended, eyes and mouth animated)
       byte _52392%256,_52392/256                                    ; #R52392 (Drutt, facing out of screen, legs partially extended, eyes and mouth animated)
       byte _52379%256,_52379/256                                    ; #R52379 (Drutt, facing out of screen, legs bent, eyes and mouth animated)
       byte _52392%256,_52392/256                                    ; #R52392 (Drutt, facing out of screen, legs partially extended, eyes and mouth animated)
       byte _52392%256,_52392/256                                    ; #R52392 (Drutt, facing out of screen, legs partially extended, eyes and mouth animated)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Move Drutt and Any Pushed Entity Right By a Hop of Size Four
* 
* If Drutt is not pushing anything, then he will hop right by four characters. If he is pushing something, then
* Drutt and the pushed entity will move right in alternate steps, traversing half the distance (two characters) on
* average.
_51538:
       byte 12,0                                                     ; Set Drutt's Walking Right Flag
       byte _52442%256,_52442/256                                    ; #R52442 (Drutt, facing right, legs bent)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52460%256,_52460/256                                    ; #R52460 (Drutt, facing right, legs extended back, jumping)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52476%256,_52476/256                                    ; #R52476 (Drutt, facing right, legs bent, airborne)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52489%256,_52489/256                                    ; #R52489 (Drutt, facing right, legs bent, landing)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte 4,0,9,0                                                  ; If current character and target entity are in the same room then set pending sound to 9
                                                                     ; (Drutt hopping)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Move Drutt and Any Pushed Entity Right By a Hop of Size Three
* 
* If Drutt is not pushing anything, then he will hop right by three characters. If he is pushing something, then
* Drutt and the pushed entity will move right in alternate steps, traversing half the distance (one and a half
* characters) on average.
_51562:
       byte 12,0                                                     ; Set Drutt's Walking Right Flag
       byte _52442%256,_52442/256                                    ; #R52442 (Drutt, facing right, legs bent)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52460%256,_52460/256                                    ; #R52460 (Drutt, facing right, legs extended back, jumping)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52476%256,_52476/256                                    ; #R52476 (Drutt, facing right, legs bent, airborne)
       byte 47,0                                                     ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52489%256,_52489/256                                    ; #R52489 (Drutt, facing right, legs bent, landing)
       byte 4,0,9,0                                                  ; If current character and target entity are in the same room then set pending sound to 9
                                                                     ; (Drutt hopping)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Move Drutt and Any Pushed Entity Left By a Hop of Size Four
* 
* If Drutt is not pushing anything, then he will hop left by four characters. If he is pushing something, then Drutt
* and the pushed entity will move left in alternate steps, traversing half the distance (two characters) on average.
_51584:
       byte 11,0                                                     ; Set Drutt's Walking Left Flag
       byte _52523%256,_52523/256                                    ; #R52523 (Drutt, facing left, legs bent)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52541%256,_52541/256                                    ; #R52541 (Drutt, facing left, legs extended back, jumping)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52557%256,_52557/256                                    ; #R52557 (Drutt, facing left, legs bent, airborne)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52570%256,_52570/256                                    ; #R52570 (Drutt, facing left, legs bent, landing)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte 4,0,9,0                                                  ; If current character and target entity are in the same room then set pending sound to 9
                                                                     ; (Drutt hopping)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Move Drutt and Any Pushed Entity Left By a Hop of Size Three
* 
* If Drutt is not pushing anything, then he will hop left by three characters. If he is pushing something, then
* Drutt and the pushed entity will move left in alternate steps, traversing half the distance (one and a half
* characters) on average.
_51608:
       byte 11,0                                                     ; Set Drutt's Walking Left Flag
       byte _52523%256,_52523/256                                    ; #R52523 (Drutt, facing left, legs bent)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52541%256,_52541/256                                    ; #R52541 (Drutt, facing left, legs extended back, jumping)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52557%256,_52557/256                                    ; #R52557 (Drutt, facing left, legs bent, airborne)
       byte 46,0                                                     ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                                     ; appropriate
       byte _52570%256,_52570/256                                    ; #R52570 (Drutt, facing left, legs bent, landing)
       byte 4,0,9,0                                                  ; If current character and target entity are in the same room then set pending sound to 9
                                                                     ; (Drutt hopping)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Drutt Swapping Depth Levels
_51630:
       byte 10,0                                                     ; Reset Drutt's Walking Left and Walking Right flags
       byte _52379%256,_52379/256                                    ; #R52379 (Drutt, facing out of screen, legs bent, eyes and mouth animated)
       byte 44,0                                                     ; Move Drutt up two characters...
       byte 44,0                                                     ; ...
       byte _52417%256,_52417/256                                    ; #R52417 (Drutt, facing out of screen, legs fully extended, eyes and mouth animated)
       byte 44,0                                                     ; Move Drutt up two characters...
       byte 44,0                                                     ; ...
       byte _52417%256,_52417/256                                    ; #R52417 (Drutt, facing out of screen, legs fully extended, eyes and mouth animated)
       byte 44,0                                                     ; Move Drutt up one character
       byte 51,0                                                     ; Swap Drutt's current depth level if possible
       byte _52417%256,_52417/256                                    ; #R52417 (Drutt, facing out of screen, legs fully extended, eyes and mouth animated)
       byte 45,0                                                     ; Move Drutt down one character
       byte _52417%256,_52417/256                                    ; #R52417 (Drutt, facing out of screen, legs fully extended, eyes and mouth animated)
       byte 45,0                                                     ; Move Drutt down two characters...
       byte 45,0                                                     ; ...
       byte _52417%256,_52417/256                                    ; #R52417 (Drutt, facing out of screen, legs fully extended, eyes and mouth animated)
       byte 45,0                                                     ; Move Drutt down two characters...
       byte 45,0                                                     ; ...
       byte _52379%256,_52379/256                                    ; #R52379 (Drutt, facing out of screen, legs bent, eyes and mouth animated)
       byte 4,0,9,0                                                  ; If current character and target entity are in the same room then set pending sound to 9
                                                                     ; (Drutt hopping)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Script Data Drutt Jumping
* 
* Drutt Starting to Jump Straight Up
_51674:
       byte 10,0                                                     ; Reset Drutt's Walking Left and Walking Right flags
       byte _52379%256,_52379/256                                    ; #R52379 (Drutt, facing out of screen, legs bent, eyes and mouth animated)
_51678:
       byte _52371%256,_52371/256                                    ; #R52371 (Drutt, facing out of screen, fully animated)
       byte 50,0                                                     ; Advance Drutt's jump and select next phase if current phase complete
       byte 1,0,_51678%256,_51678/256                                ; Jump to #R51678
* Drutt Jumping Left
_51686:
       byte 11,0                                                     ; Set Drutt's Walking Left Flag
       byte _52541%256,_52541/256                                    ; #R52541 (Drutt, facing left, legs extended back, jumping)
       byte 50,0                                                     ; Advance Drutt's jump and select next phase if current phase complete
       byte 1,0,_51686%256,_51686/256                                ; Jump to #R51686
* Drutt Jumping Right
_51696:
       byte 12,0                                                     ; Set Drutt's Walking Right Flag
       byte _52460%256,_52460/256                                    ; #R52460 (Drutt, facing right, legs extended back, jumping)
       byte 50,0                                                     ; Advance Drutt's jump and select next phase if current phase complete
       byte 1,0,_51696%256,_51696/256                                ; Jump to #R51696

* Script Data Drutt Eating a Worm
_51706:
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte _52677%256,_52677/256                                    ; #R52677 (Drutt, facing out of screen, legs partially extended, eating a worm, animated)
       byte 4,0,8,0                                                  ; If current character and target entity are in the same room then set pending sound to 8
                                                                     ; (Drutt eating a worm)
       byte _52648%256,_52648/256                                    ; #R52648 (Drutt, facing out of screen, smiling, legs partially extended, eyes blinking)
       byte _52648%256,_52648/256                                    ; #R52648 (Drutt, facing out of screen, smiling, legs partially extended, eyes blinking)
       byte _52648%256,_52648/256                                    ; #R52648 (Drutt, facing out of screen, smiling, legs partially extended, eyes blinking)
       byte _52648%256,_52648/256                                    ; #R52648 (Drutt, facing out of screen, smiling, legs partially extended, eyes blinking)
       byte 43,0                                                     ; Select next action for Drutt depending upon control input

* Reset Drutt to Initial State
* 
* Used by the routine at #R34751.
_51732:
       li   hl,_51524                  ; LD HL,51524       ; Set current position in Drutt's script data...
       mov  hl,@_51518                 ; LD (51518),HL     ; ...to #R51524 (Drutt facing out of screen)
       rt                              ; RET               ; Return

* Update States of Drutt and Worm and Store Current Positions in Script Data
* 
* Used by the routine at #R34438.
_51739:
       bl   @_52837                    ; CALL 52837        ; Update state of Worm and store current position in script data
       mov  @_34242,ix                 ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       bl   @_53848                    ; CALL 53848        ; Store room size data for Drutt's current room
       mov  @_51518,hl                 ; LD HL,(51518)     ; Load current position in Drutt's script data from #R51518 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_51765                    ; CALL 51765        ; Update state of Drutt
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_51518                 ; LD (51518),HL     ; ...at #R51518 as current position in Drutt's script data
       rt                              ; RET               ; Return

* Update State of Drutt
* 
* If Drutt is being carried or falling, then he should be prevented from doing anything. This is accomplished by
* constantly resetting his current script data position to be #R51520. This does nothing except redraw Drutt. Input:
* IX  Address of complex state data (current level) for Drutt Output: HL  Address of next script instruction to
* execute
_51765:
       movb @10(ix),a                  ; LD A,(IX+10)      ; If both Drutt's Being Carried and Can Fall flags are reset...
       andi a,96*256                   ; AND 96            ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (43) Select Next Action for Drutt Depending Upon Control Input Input:  IX  Address of complex state
* data (current level) for Drutt Output: HL  Address of next script instruction to execute
_51779:
       bl   @_54768                    ; CALL 54768        ; Check Drutt for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
       cb   a,@bytes+129               ; CP 129            ; ...and if collision was not with entity of class 129 (causes other entities to start
                                                           ; falling)...
       jne  _51792                     ; JR NZ,51792       ; ...then skip ahead to #R51792
       bl   @_55516                    ; CALL 55516        ; Set Drutt's Can Fall Flag and initial velocity factor to 2
       b    @_52038                    ; JP 52038          ; Move Drutt down one character, advance HL to next script instruction and execute
_51792:
       mov  @_34244,iy                 ; LD IY,(34244)     ; Load IY with address of current level's complex state data for worm
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  _51841                     ; JR Z,51841        ; ...then skip ahead to #R51841
* Drutt Mode Flag is set (i.e. Drutt Mode)
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Drutt's Under Player Control Flag
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       mov  a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1                     ;                   
       jne  _51904                     ; JR NZ,51904       ; ...then randomly select script data for rightward hop of size three or four, and execute
       mov  a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2                     ;                   
       jne  _51924                     ; JR NZ,51924       ; ...then randomly select script data for leftward hop of size three or four, and execute
       mov  a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4                     ;                   
       jeq  !                          ; JP NZ,51954       ; ...then point HL at script data for Drutt swapping depth levels and execute
       b    @_51954                    ;                   
!
       mov  a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8                     ;                   
       jeq  !                          ; JP NZ,51944       ; ...then jump to #R51944 (start Drutt jumping)
       b    @_51944                    ;                   
!
* At this point, no control has been pressed, so Drutt is effectively not under player control
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is zero (i.e. not in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51960                    ; JP 51960          ; Move Drutt closer to the worm and eat it if close enough
* Drutt Mode Flag is reset (i.e. Berk Mode)
_51841:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is not zero (i.e. is in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  !                          ; JP NZ,51960       ; ...then move Drutt closer to the worm and eat it if close enough
       b    @_51960                    ;                   
!
       mov  @_34240,iy                 ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt is in the same room as Berk...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
* The following code will make Drutt move closer to the target (a worm, or Berk if in Berk Mode) if the target's
* room is directly to the left or right of Drutt's room (i.e. no vertical separation). Otherwise, Drutt will perform
* a random action. This entry point is used by the routine at #R51960.
_51864:
       bl   @_53194                    ; CALL 53194        ; Load A with value indicating which direction room A lies relative to Drutt's current room
       cb   a,one                      ; CP 1              ; If target room is to the right...
       jeq  _51904                     ; JR Z,51904        ; ...then randomly select script data for rightward hop of size three or four, and execute
       cb   a,@bytes+2                 ; CP 2              ; If target room is to the left...
       jeq  _51924                     ; JR Z,51924        ; ...then randomly select script data for leftward hop of size three or four, and execute
* This entry point is used by the routine at #R51960.
_51875:
       movb @bytes+7,a                 ; LD A,7            ; Load A with a random number, 0-6...
       bl   @_54222                    ; CALL 54222        ; ...
       li   de,_51890                  ; LD DE,51890       ; Point DE at Table of Addresses of Script Data for Drutt's Actions...
       bl   @_53814                    ; CALL 53814        ; ...and load DE with entry of index A in this table
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (now contains address of randomly selected script data)
       b    @_48098                    ; JP 48098          ; Execute script data at address in HL

* Table of Addresses of Script Data for Drutt's Actions
* 
* When Drutt is neither under player control nor seeking a target (a worm or Berk) then his actions are determined
* by randomly selecting a script data address from this table and executing. There is:
_51890:
       data _51538                                                   ; Move Drutt and any pushed entity right by a hop of size four
       data _51608                                                   ; Move Drutt and any pushed entity left by a hop of size three
       data _51630                                                   ; Drutt swapping depth levels
       data _51524                                                   ; Drutt facing out of screen
       data _51524                                                   ; Drutt facing out of screen
       data _51524                                                   ; Drutt facing out of screen
       data _51524                                                   ; Drutt facing out of screen

* Randomly Select Script Data for Rightward Hop of Size Three or Four, and Execute
* 
* Used by the routine at #R51779.
_51904:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51918                     ; JR Z,51918        ; ...then skip ahead to #R51918
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @_48098                    ; JP 48098          ; ...and execute
_51918:
       li   hl,_51562                  ; LD HL,51562       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size
                                                           ; three...
       b    @_48098                    ; JP 48098          ; ...and execute

* Randomly Select Script Data for Leftward Hop of Size Three or Four, and Execute
* 
* Used by the routine at #R51779.
_51924:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51938                     ; JR Z,51938        ; ...then skip ahead to #R51938
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @_48098                    ; JP 48098          ; ...and execute
_51938:
       li   hl,_51608                  ; LD HL,51608       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size three...
       b    @_48098                    ; JP 48098          ; ...and execute

* Start Drutt Jumping
* 
* Used by the routine at #R51779.
_51944:
       movb @bytes+130,@12(ix)         ; LD (IX+12),130    ; Set Drutt's Is Jumping Flag and set initial Jump Velocity to 2
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @_48098                    ; JP 48098          ; ...and execute

* Point HL at Script Data for Drutt Swapping Depth Levels and Execute
* 
* Used by the routine at #R51779.
_51954:
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @_48098                    ; JP 48098          ; ...and execute

* Move Drutt Closer to the Worm and Eat it if Close Enough
* 
* Used by the routine at #R51779. Input:  IX  Address of complex state data (current level) for Drutt IY  Address of
* complex state data (current level) for Worm
_51960:
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt and worm are not in the same room...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  !                          ; JP NZ,51864       ; ...then move Drutt closer to worm if appropriate, otherwise make Drutt perform random action
       b    @_51864                    ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If Drutt's left edge...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the worm's...
       jl   _52017                     ; JR C,52017        ; ...then skip ahead to #R52017
       movb @7(iy),a                   ; LD A,(IY+7)       ; If worm's right edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of Drutt's left edge...
       jl   _52023                     ; JR C,52023        ; ...then skip ahead to #R52023
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of Drutt's top edge...
       cb   a,@bytes+120               ; CP 120            ; ...is less than 120...
       jhe  !                          ; JP C,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51875                    ;                   
!
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is the same as Drutt's...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jeq  _52007                     ; JR Z,52007        ; ...then skip ahead to #R52007
* Drutt and worm in same room, at different depth and same x-coordinate
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt and worm in same room, at same depth and same x-coordinate
_52007:
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set worm's depth to zero (i.e. remove from play)
       li   hl,_51706                  ; LD HL,51706       ; Point HL at script data for Drutt eating a worm...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt's left edge to left of worm's
_52017:
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @_48098                    ; JP 48098          ; ...and execute
* Worm's right edge to left of Drutt's left edge
_52023:
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (44) Move Entity Up One Character
* 
* Used by the routine at #R48026. Input:  IX  Address of complex state data for an entity
_52029:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move entity up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (45) Move Entity Down One Character
* 
* Used by the routine at #R51779. Input:  IX  Address of complex state data for an entity
_52038:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (46) Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if
* Appropriate
_52047:
       bl   @_52053                    ; CALL 52053        ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                           ; appropriate
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if Appropriate
* 
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
_52053:
       bl   @_54666                    ; CALL 54666        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; left...
       joc  _52087                     ; JR C,52087        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R52087
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  _52076                     ; JR NC,52076       ; ...then skip ahead to #R52076
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _52087                     ; JR Z,52087        ; ...then skip ahead to #R52087 (move Drutt left without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       bl   @_52098                    ; CALL 52098        ; Advance position of entity pushed left by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       rt                              ; RET               ; Return
* Collision with entity of class 22 or greater
_52076:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52087                     ; JR Z,52087        ; ...then skip ahead to #R52087
* At this point, the entity to Drutt's left is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @_48098                    ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
_52087:
       bl   @_54348                    ; CALL 54348        ; Move Drutt into room to the left, if appropriate...
       joc  !                          ; RET NC            ; TODO: check code. ...and if Drutt can't enter new room then return
       rt                              ;                   
!
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Drutt left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       rt                              ; RET               ; Return

* Advance Position of Entity Pushed Left by Drutt
* 
* Used by the routine at #R52053. Input:  IY  Address of complex state data for entity pushed by Drutt
_52098:
       .push iy                        ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
       .pop ix                         ; POP IX            ; ...to IX
       bl   @_54666                    ; CALL 54666        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the left...
       joc  _52112                     ; JR C,52112        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R52112
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52134                     ; JR Z,52134        ; ...then skip ahead to #R52134
       rt                              ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
_52112:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of left edge of pushed entity is at least 103...
       cb   a,@bytes+103               ; CP 103            ; ...i.e. not yet at left edge of room...
       jhe  _52127                     ; JR NC,52127       ; ...then skip ahead to #R52127
       bl   @_54539                    ; CALL 54539        ; Load B with index of room to left of current character's current room...
       jne  !                          ; RET Z             ; ...and if there is no room to the left then return
       rt                              ;                   
!
       bl   @_54348                    ; CALL 54348        ; Move pushed entity into room to the left, if appropriate...
       joc  !                          ; RET NC            ; TODO: check code. ...and if pushed entity can't enter new room then return
       rt                              ;                   
!
_52127:
       equ  $
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move pushed entity left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       rt                              ; RET               ; Return
_52134:
       bl   @_55516                    ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       bl   @_52127                    ; CALL 52127        ; Move pushed entity left two characters...
       jmp  _52127                     ; JR 52127          ; ...and return

* Script Routine (47) Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if
* Appropriate
_52142:
       bl   @_52148                    ; CALL 52148        ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                           ; appropriate
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if Appropriate
* 
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
_52148:
       bl   @_54569                    ; CALL 54569        ; Check Drutt for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       joc  _52182                     ; JR C,52182        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R52182
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class 22 or greater (can't be picked up)...
       jhe  _52171                     ; JR NC,52171       ; ...then skip ahead to #R52171
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _52182                     ; JR Z,52182        ; ...then skip ahead to #R52182 (move Drutt right without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       bl   @_52193                    ; CALL 52193        ; Advance position of entity pushed right by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       rt                              ; RET               ; Return
* Collision with entity of class 22 or greater
_52171:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52182                     ; JR Z,52182        ; ...then skip ahead to #R52182
* At this point, the entity to Drutt's right is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @_48098                    ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
_52182:
       bl   @_54313                    ; CALL 54313        ; Move Drutt into room to the right, if appropriate...
       joc  !                          ; RET NC            ; TODO: check code. ...and if Drutt can't enter new room then return
       rt                              ;                   
!
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Drutt right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       rt                              ; RET               ; Return

* Advance Position of Entity Pushed Right by Drutt
* 
* Used by the routine at #R52148. Input:  IY  Address of complex state data for entity pushed by Drutt
_52193:
       .push iy                        ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
       .pop ix                         ; POP IX            ; ...to IX
       bl   @_54569                    ; CALL 54569        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the right...
       joc  _52207                     ; JR C,52207        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R52207
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52235                     ; JR Z,52235        ; ...then skip ahead to #R52235
       rt                              ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
_52207:
       movb @_34235,a                  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       sb   @bytes+2,a                 ; SUB 2             ; ...minus 2...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; ...and if x-coordinate of right edge of pushed entity is less than this...
       cb   a,@e                       ; CP E              ; ...i.e. not yet at right edge of room...
       jl   _52227                     ; JR C,52227        ; ...then skip ahead to #R52227
       bl   @_54505                    ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jne  !                          ; RET Z             ; ...and if there is no room to the right then return
       rt                              ;                   
!
       bl   @_54313                    ; CALL 54313        ; Move pushed entity into room to the right, if appropriate...
       joc  !                          ; RET NC            ; TODO: check code. ...and if pushed entity can't enter new room then return
       rt                              ;                   
!
_52227:
       equ  $
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move pushed entity right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       sb   a,a                        ; XOR A             ; Load A with zero (see trivia)
       rt                              ; RET               ; Return
_52235:
       bl   @_55516                    ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       bl   @_52227                    ; CALL 52227        ; Move pushed entity right two characters...
       jmp  _52227                     ; JR 52227          ; ...and return

* Script Routine (50) Advance Drutt's Jump and Select Next Phase if Current Phase Complete
* 
* The CALL at #R52243 will be RETurned from if Drutt's Is Jumping Flag is reset. Otherwise, E will be loaded with
* Drutt's jump state index (see #R55041). Output: HL  Address of next script instruction to execute
_52243:
       bl   @_55023                    ; CALL 55023        ; Handle Drutt's jump, and load A with Jump State Index as appropriate
       movb @e,a                       ; LD A,E            ; If jump state index is zero...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       cb   a,one                      ; CP 1              ; If jump state index is 1...
       jeq  _52259                     ; JR Z,52259        ; ...then skip ahead to #R52259
       cb   a,@bytes+2                 ; CP 2              ; If jump state index is not 2...
       jne  _52265                     ; JR NZ,52265       ; ...then skip ahead to #R52265
* Jump state index is 1 (landed on floor / platform and Back (control input) bit set) or 2 (unused)
_52259:
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @_48098                    ; JP 48098          ; ...and execute
* Jump state index is not 2
_52265:
       cb   a,@bytes+3                 ; CP 3              ; If jump state index is not 3...
       jne  _52275                     ; JR NZ,52275       ; ...then skip ahead to #R52275
* Jump state index is 3 (Drutt's jump velocity less than 4, and back not pressed, i.e. terminate jumping)
       li   hl,_51524                  ; LD HL,51524       ; Point HL at script data for Drutt facing out of screen...
       b    @_48098                    ; JP 48098          ; ...and execute
* Jump state index is not 3
_52275:
       cb   a,@bytes+4                 ; CP 4              ; If jump state index is not 4...
       jne  _52285                     ; JR NZ,52285       ; ...then skip ahead to #R52285
* Jump state index is 4 (bounced off an obstruction to the right or Left (control input) Bit set)
       li   hl,_51686                  ; LD HL,51686       ; Point HL at script data for Drutt Jumping Left...
       b    @_48098                    ; JP 48098          ; ...and execute
* Jump state index is not 4
_52285:
       cb   a,@bytes+5                 ; CP 5              ; If jump state index is not 5...
       jne  _52295                     ; JR NZ,52295       ; ...then skip ahead to #R52295
* Jump state index is 5 (bounced off an obstruction to the left or Right (control input) Bit set)
       li   hl,_51696                  ; LD HL,51696       ; Point HL at script data for Drutt Jumping Right...
       b    @_48098                    ; JP 48098          ; ...and execute
* Jump state index is not 5
_52295:
       cb   a,@bytes+6                 ; CP 6              ; If jump state index is not 6...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
* Jump state index is 6 (Drutt has banged his head on something above him)
       bl   @_55516                    ; CALL 55516        ; Set Drutt's Can Fall Flag and set initial velocity factor of 2
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (51) Swap Drutt's Current Depth Level if Possible
_52309:
       bl   @_52315                    ; CALL 52315        ; Swap Drutt's current depth level if possible
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Swap Drutt's Current Depth Level if Possible
* 
* Used by the routine at #R52309. Input:  IX  Address of complex state data (current level) for Drutt
_52315:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's depth is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _52351                     ; JR NZ,52351       ; ...then skip ahead to #R52351
* Drutt's depth is 1
       movb @_34230,a                  ; LD A,(34230)      ; If Drutt's current depth is the same as number of available depth levels in current room...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...i.e. room has depth of 1...
       jne  !                          ; RET Z             ; ...then return (as there is no other depth level for Drutt to move to)
       rt                              ;                   
!
* The following collision check is usually only satisfied by Berk. This prevents Drutt from jumping back a depth
* level while in front of (at same depth level as) Berk.
       bl   @_54878                    ; CALL 54878        ; Check Drutt for collision with another entity (only those defined before, and in reverse
                                                           ; order) at same depth level whose Interaction (11,7) Flag is set...
       joc  !                          ; RET NC            ; TODO: check code. ...and if a collision occurred, then return
       rt                              ;                   
!
* The following collision check prevents Drutt from jumping back when there is an obstruction (e.g. the brick
* columns in the pit room, level 1) behind him.
       bl   @_54890                    ; CALL 54890        ; Check Drutt for collision with another entity (in reverse order) at next depth level into
                                                           ; screen whose Interaction (11,7) Flag is set...
       joc  _52341                     ; JR C,52341        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R52341
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
_52341:
       equ  $
       ab   one,@1(ix)                 ; INC (IX+1)        ; Increase Drutt's depth (i.e. move backward away from screen)
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease Drutt's top and bottom y-coordinates...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       rt                              ; RET               ; Return
* Drutt's depth is not 1
_52351:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's current depth is 1... (see trivia)
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
* The following collision check prevents Drutt from jumping forward a depth level while in behind an obstruction
* (e.g. Berk).
       bl   @_54764                    ; CALL 54764        ; Check Drutt for collision with another entity at next depth level out of screen whose
                                                           ; Interaction (11,6) Flag is set...
       joc  !                          ; RET NC            ; TODO: check code. ...and if a collision occurred, then return
       rt                              ;                   
!
       sb   one,@1(ix)                 ; DEC (IX+1)        ; Decrease Drutt's depth (i.e. move forward towards screen)
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase Drutt's top and bottom y-coordinates...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       rt                              ; RET               ; Return

* Graphic Layout Data Drutt Facing out of screen, fully animated, jumping / falling / held by Berk
_52371:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _52379%256,_52379/256                                    ; #R52379 (facing out of screen, legs bent, eyes and mouth animated)
       byte _52395%256,_52395/256                                    ; #R52395 (facing out of screen, legs partially extended, eyes and mouth animated)
       byte _52417%256,_52417/256                                    ; #R52417 (facing out of screen, legs fully extended, eyes and mouth animated)
* Facing out of screen, legs bent, eyes and mouth animated
_52379:
       byte 251,_52604%256,_52604/256                                ; Process graphic layout data at #R52604 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 45,6,34,45,134,33
       byte 255                                                      ; End Marker
* Facing out of screen, legs partially extended, eyes and mouth animated
_52392:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and
                                                                     ; store as new base coordinates
_52395:
       byte 251,_52604%256,_52604/256                                ; Process graphic layout data at #R52604 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 38,6,34,38,134,30
       byte 46,6,33,47,6,33
       byte 46,134,33
       byte 255                                                      ; End Marker
* Facing out of screen, legs fully extended, eyes and mouth animated
_52417:
       byte 251,_52604%256,_52604/256                                ; Process graphic layout data at #R52604 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 38,6,34,38,134,30
       byte 58,6,33,56,6,33
       byte 58,134,31,57,6,33
       byte 255                                                      ; End Marker
* Facing right, legs bent
_52442:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 48,7,31,38,6,33
       byte 49,6,161,50,6,33
       byte 255                                                      ; End Marker
* Facing right, legs extended back (jumping)
_52460:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52505%256,_52505/256                                ; Process graphic layout data at #R52505 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 51,6,33,52,6,33
       byte 255                                                      ; End Marker
* Facing right, legs bent, airborne
_52476:
       byte 254,254,0                                                ; Change cursor's x- and y-coordinates by 0 and -2 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52505%256,_52505/256                                ; Process graphic layout data at #R52505 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 53,6,33
       byte 255                                                      ; End Marker
* Facing right, legs bent, landing
_52489:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52505%256,_52505/256                                ; Process graphic layout data at #R52505 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 54,6,33,55,6,33
       byte 255                                                      ; End Marker
* Body, facing right
_52505:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 48,7,31,38,6,33
       byte 0,54,33,38,134,33
       byte 255                                                      ; End Marker
* Facing left, legs bent
_52523:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 48,135,31,50,134,33
       byte 49,134,161,38,134,33
       byte 255                                                      ; End Marker
* Facing left, legs extended back (jumping)
_52541:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52586%256,_52586/256                                ; Process graphic layout data at #R52586 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 52,134,33,51,134,33
       byte 255                                                      ; End Marker
* Facing left, legs bent, airborne
_52557:
       byte 254,254,0                                                ; Change cursor's x- and y-coordinates by 0 and -2 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52586%256,_52586/256                                ; Process graphic layout data at #R52586 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 53,134,33
       byte 255                                                      ; End Marker
* Facing left, legs bent, landing
_52570:
       byte 254,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively and
                                                                     ; store as new base coordinates
       byte 251,_52586%256,_52586/256                                ; Process graphic layout data at #R52586 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 55,134,33,54,134,33
       byte 255                                                      ; End Marker
* Body, facing left
_52586:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 48,135,31,38,6,33
       byte 0,54,33,38,134,33
       byte 255                                                      ; End Marker
* Mouth and eyes (animated)
_52604:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 236,3,39,40,41                                           ; Modify following instruction to display graphic of random index, chosen from 39,
                                                                     ; 40 and 41
       byte 0,48,161
       byte 250,255,254                                              ; Change cursor's x- and y-coordinates by -2 and -1 characters respectively
       byte 249,2,0                                                  ; If state n (initially 1) has remaining time of zero then reset its time to
                                                                     ; maximum and randomly select a new state, n, from the 2 in the following list.
                                                                     ; Jump to the address specified in the current state and decrease its remaining
                                                                     ; time:
       byte 2,4,_52628%256,_52628/256                                ; #R52628 (eyes, open, facing out of screen, for 4 ticks)
       byte 1,2,_52638%256,_52638/256                                ; #R52638 (eyes, closed, facing out of screen, for 2 ticks)
* Eyes (Open, Facing Out of Screen)
_52628:
       byte 37,7,33,35,7,33
       byte 37,135,33
       byte 255                                                      ; End Marker
* Eyes (Closed, Facing Out of Screen)
_52638:
       byte 37,6,33,36,6,33
       byte 37,134,33
       byte 255                                                      ; End Marker
* Facing out of screen, smiling, legs partially extended, eyes blinking
_52648:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,255                                              ; Change cursor's x- and y-coordinates by -1 and -1 characters respectively
       byte 38,6,33,42,48,161
       byte 38,134,30,46,6,34
       byte 46,134,33
       byte 250,254,253                                              ; Change cursor's x- and y-coordinates by -3 and -2 characters respectively
       byte 247,2                                                    ; Jump to one of the 2 addresses in the following list, chosen at random:
       byte _52628%256,_52628/256                                    ; #R52628 (eyes, open, facing out of screen)
       byte _52638%256,_52638/256                                    ; #R52638 (eyes, closed, facing out of screen)
* Facing out of screen, legs partially extended, eating a worm (animated)
_52677:
       byte 251,_52648%256,_52648/256                                ; Process graphic layout data at #R52648 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 236,2,43,44                                              ; Modify following instruction to display graphic of random index, chosen from 43
                                                                     ; and 44
       byte 0,48,160
       byte 243,1,6                                                  ; Increase current state value n (initially 1), up to maximum of 6, resetting to
                                                                     ; zero if maximum reached and jump to n-th address in following list:
       byte _52705%256,_52705/256                                    ; #R52705 (worm facing left, curved up into Drutt's mouth)
       byte _52715%256,_52715/256                                    ; #R52715 (worm facing right, curved up into Drutt's mouth)
       byte _52705%256,_52705/256                                    ; #R52705 (worm facing left, curved up into Drutt's mouth)
       byte _52715%256,_52715/256                                    ; #R52715 (worm facing right, curved up into Drutt's mouth)
       byte _52722%256,_52722/256                                    ; #R52722 (worm's eyes facing out of screen)
       byte _52722%256,_52722/256                                    ; #R52722 (worm's eyes facing out of screen)
* Worm facing left, curved up into Drutt's mouth
_52705:
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 7,7,33,59,3,33
       byte 255                                                      ; End Marker
* Worm facing right, curved up into Drutt's mouth
_52715:
       byte 59,131,33,7,135,33
       byte 255                                                      ; End Marker
* Worm's eyes facing out of screen
_52722:
       byte 34,7,33
       byte 255                                                      ; End Marker

* Current Position in Worm's Script Data
_52726:
       data _52729

* Worm's Age
_52728:
       byte 0

* Script Data Worm
* 
* Unused
_52729:
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte 1,0,_52729%256,_52729/256                                ; Jump to #R52729
* Worm Rising from Floor then Choosing Next Direction
_52735:
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte 34,0                                                     ; Move worm up one character
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte 34,0                                                     ; Move worm up one character
* Choosing Next Direction
_52747:
       byte _53358%256,_53358/256                                    ; #R53358 (Worm looking left, normal)
       byte _53358%256,_53358/256                                    ; #R53358 (Worm looking left, normal)
       byte _53358%256,_53358/256                                    ; #R53358 (Worm looking left, normal)
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte _53373%256,_53373/256                                    ; #R53373 (Worm looking right, normal)
       byte _53373%256,_53373/256                                    ; #R53373 (Worm looking right, normal)
       byte _53373%256,_53373/256                                    ; #R53373 (Worm looking right, normal)
       byte _53340%256,_53340/256                                    ; #R53340 (Worm looking ahead, blinking)
       byte 55,0                                                     ; Choose new worm direction and start crawling
* Crawling Left
_52765:
       byte 53,0                                                     ; Move worm left if possible, otherwise jump to #R52747 (choose new direction)
       byte _53462%256,_53462/256                                    ; #R53462 (Worm crawling left, frame 1 / 2)
       byte _53462%256,_53462/256                                    ; #R53462 (Worm crawling left, frame 1 / 2)
       byte _53477%256,_53477/256                                    ; #R53477 (Worm crawling left, frame 2 / 2)
       byte _53477%256,_53477/256                                    ; #R53477 (Worm crawling left, frame 2 / 2)
       byte 52,0                                                     ; Increase worm's age and decrease Time Until Direction Change or start fleeing if Drutt is
                                                                     ; nearby
       byte 1,0,_52765%256,_52765/256                                ; Jump to #R52765
* Crawling Right
_52781:
       byte 54,0                                                     ; Move worm right if possible, otherwise jump to #R52747 (choose new direction)
       byte _53525%256,_53525/256                                    ; #R53525 (Worm crawling right, frame 1 / 2)
       byte _53525%256,_53525/256                                    ; #R53525 (Worm crawling right, frame 1 / 2)
       byte _53501%256,_53501/256                                    ; #R53501 (Worm crawling right, frame 2 / 2)
       byte _53501%256,_53501/256                                    ; #R53501 (Worm crawling right, frame 2 / 2)
       byte 52,0                                                     ; Increase worm's age and decrease Time Until Direction Change or start fleeing if Drutt is
                                                                     ; nearby
       byte 1,0,_52781%256,_52781/256                                ; Jump to #R52781
* Fleeing Left
_52797:
       byte _53403%256,_53403/256                                    ; #R53403 (Worm looking right, alarmed)
       byte _53403%256,_53403/256                                    ; #R53403 (Worm looking right, alarmed)
       byte _53403%256,_53403/256                                    ; #R53403 (Worm looking right, alarmed)
       byte _53403%256,_53403/256                                    ; #R53403 (Worm looking right, alarmed)
_52805:
       byte 53,0                                                     ; Move worm left if possible, otherwise jump to #R52747 (choose new direction)
       byte _53454%256,_53454/256                                    ; #R53454 (Worm crawling left, alarmed, frame 1 / 2)
       byte _53489%256,_53489/256                                    ; #R53489 (Worm crawling left, alarmed, frame 2 / 2)
       byte 52,0                                                     ; Increase worm's age and decrease Time Until Direction Change or continue fleeing if Drutt
                                                                     ; is nearby
       byte 1,0,_52805%256,_52805/256                                ; Jump to #R52805
* Fleeing Right
_52817:
       byte _53388%256,_53388/256                                    ; #R53388 (Worm looking left, alarmed)
       byte _53388%256,_53388/256                                    ; #R53388 (Worm looking left, alarmed)
       byte _53388%256,_53388/256                                    ; #R53388 (Worm looking left, alarmed)
       byte _53388%256,_53388/256                                    ; #R53388 (Worm looking left, alarmed)
_52825:
       byte 54,0                                                     ; Move worm right if possible, otherwise jump to #R52747 (choose new direction)
       byte _53543%256,_53543/256                                    ; #R53543 (Worm crawling right, alarmed, frame 1 / 2)
       byte _53513%256,_53513/256                                    ; #R53513 (Worm crawling right, alarmed, frame 2 / 2)
       byte 52,0                                                     ; Increase worm's age and decrease Time Until Direction Change or continue fleeing if Drutt
                                                                     ; is nearby
       byte 1,0,_52825%256,_52825/256                                ; Jump to #R52825

* Update State of Worm and Store Current Position in Script Data
* 
* Used by the routine at #R51739.
_52837:
       mov  @_34244,ix                 ; LD IX,(34244)     ; Load IX with address of current level's complex state data for worm
       bl   @_53848                    ; CALL 53848        ; Store room size data for worm's current room
       mov  @_52726,hl                 ; LD HL,(52726)     ; Load current position in worm's script data from #R52726 into HL...
       mov  hl,@_34277                 ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @_52860                    ; CALL 52860        ; Update state of worm
       mov  @_34277,hl                 ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@_52726                 ; LD (52726),HL     ; ...at #R52726 as current position in worm's script data
       rt                              ; RET               ; Return

* Update State of Worm
* 
* Used by the routine at #R52837. Input:  IX  Address of complex state data (current level) for Worm
_52860:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If worm's depth is zero (i.e. not currently active)...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,53083        ; ...then attempt to spawn a new worm...
       b    @_53083                    ;                   
!
       b    @_48096                    ; JP 48096          ; ...otherwise advance HL to next script instruction and execute

* Script Routine (53) Move Worm Left if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
_52870:
       bl   @_54666                    ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52908                     ; JR NC,52908       ; TODO: check code. ...and if a collision occurred, then have worm choose new direction
       bl   @_54348                    ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; TODO: check code. ...and if worm can't enter new room then have worm choose new direction
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move worm left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (54) Move Worm Right if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
_52889:
       bl   @_54569                    ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52908                     ; JR NC,52908       ; TODO: check code. ...and if a collision occurred, then have worm choose new direction
       bl   @_54313                    ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; TODO: check code. ...and if worm can't enter new room then have worm choose new direction
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move worm right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute

* Execute Script Data for Worm Choosing Next Direction
* 
* Used by the routines at #R52870 and #R52889.
_52908:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (55) Choose New Direction and Start Crawling (Worm) Input:  IX  Address of complex state data for
* an entity
_52914:
       bl   @_53057                    ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       movb @bytes+20,a                ; LD A,20           ; Load A with a random number, 5-24...
       bl   @_54222                    ; CALL 54222        ; ...
       a    @bytes+5,a                 ; ADD A,5           ; ...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...and set worm's Time Until Direction Change to this value
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if zero (1 in 2 chance)...
       jne  _52951                     ; JR NZ,52951       ; ...then skip ahead to #R52951
* Have worm move left
       bl   @_54666                    ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52961                     ; JR NC,52961       ; TODO: check code. ...and if a collision occurred, then start worm crawling right
       bl   @_54348                    ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52961                     ; JR NC,52961       ; TODO: check code. ...and if worm can't enter new room then start worm crawling right
_52945:
       li   hl,_52765                  ; LD HL,52765       ; Point HL at script data for worm, crawling left...
       b    @_48098                    ; JP 48098          ; ...and execute
* Have worm move right
_52951:
       bl   @_54569                    ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52945                     ; JR NC,52945       ; TODO: check code. ...and if a collision occurred, then start worm crawling left
       bl   @_54313                    ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52945                     ; JR NC,52945       ; TODO: check code. ...and if worm can't enter new room then start worm crawling left
_52961:
       li   hl,_52781                  ; LD HL,52781       ; Point HL at script data for worm, crawling right...
       b    @_48098                    ; JP 48098          ; ...and execute

* Script Routine (52) Increase Worm's Age and Decrease Time Until Direction Change, or React to Drutt's Presence
* 
* When both Drutt and the worm are in the same room, and the worm is alerted to Drutt's presence, then the worm will
* take on its alarmed appearance and start fleeing in the direction away from Drutt. As long as Drutt remains in the
* same room as the worm, and within the "alerting" distance, the worm will continue fleeing in the same direction,
* and its Time Until Direction Change will be frozen. Input:  IX  Address of complex state data for an entity
* Output: HL  Address of next script instruction to execute
_52967:
       bl   @_53057                    ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       mov  @_34242,iy                 ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt
       movb *ix,a                      ; LD A,(IX+0)       ; If Drutt and the worm are in the same room...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  _53004                     ; JR Z,53004        ; ...then skip ahead to #R53004
* Drutt and worm in different rooms, so countdown to next direction change resumes as worm out of danger
_52982:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset In Danger Flag
       movb @12(ix),a                  ; LD A,(IX+12)      ; If worm's Time Until Direction Change is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _52998                     ; JR Z,52998        ; ...then skip ahead to #R52998 (have worm choose new direction)
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease worm's Time Until Direction Change
       b    @_48096                    ; JP 48096          ; Advance HL to next script instruction and execute
_52998:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt and worm in same room, so worm potentially in danger
_53004:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of worm's left edge...
       ab   one,a                      ; INC A             ; ...plus one...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...minus x-coordinate of Drutt's left edge
       joc  _53034                     ; JR C,53034        ; TODO: check code. If negative then skip ahead to #R53034
       cb   a,@bytes+10                ; CP 10             ; If worm's left edge is 9 characters or more to the right of Drutt's...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52817                  ; LD HL,52817       ; Point HL at script data for worm, fleeing right...
       b    @_48098                    ; JP 48098          ; ...and execute
* Drutt's left edge more than one character to the right of worm's left edge
_53034:
       neg a                           ; NEG               ; If worm's left edge is 11 characters or more to the left of Drutt's...
       cb   a,@bytes+10                ; CP 10             ; ...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       mov  @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @_48096                    ;                   
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52797                  ; LD HL,52797       ; Point HL at script data for worm, fleeing left...
       b    @_48098                    ; JP 48098          ; ...and execute

* Increase Worm's Age and Set its Depth to Zero if it has Expired
* 
* Used by the routines at #R52914 and #R52967. Input:  IX  Address of complex state data (current level) for Worm
_53057:
       movb @_52728,a                  ; LD A,(52728)      ; Increase current Worm Age value...
       ab   one,a                      ; INC A             ; ...
       mov  a,@_52728                  ; LD (52728),A      ; ...
       mov  a,tmp0                     ; BIT 7,A           ; If Worm Age is less than 128...
       andi tmp0,128                   ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       movb @_34218,a                  ; LD A,(34218)      ; If current character's room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is the same as the worm's...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       sb   a,a                        ; XOR A             ; Set the worm's depth to zero...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...
       mov  a,@_52728                  ; LD (52728),A      ; Reset Worm Age to zero
       .pop bc                         ; POP BC            ; Remove top value from stack (return address in calling routine)
       rt                              ; RET               ; Return (to routine that called the calling routine)

* Attempt to Spawn a New Worm
* 
* Used by the routine at #R52860. Input:  IX  Address of complex state data (current level) for Worm
_53083:
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @_54222                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If random number is not zero (59 in 60 chance)...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       movb @_34218,a                  ; LD A,(34218)      ; Set worm's current room to same as current character's...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       bl   @_53848                    ; CALL 53848        ; Store room size data for worm's current room
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 99...
       sb   @bytes+100,a               ; SUB 100           ; ...and subtract 100 to get x-coordinate (zero-based) of right side of the room
       bl   @_54222                    ; CALL 54222        ; Load A with a random x-coordinate within current room
       a    @bytes+100,a               ; ADD A,100         ; Add 100 to restore coordinate system
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set this as the worm's left x-coordinate
       a    @bytes+2,a                 ; ADD A,2           ; Add two to this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as the worm's right x-coordinate
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 1-2...
       bl   @_54222                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and assign the worm this depth
       movb @bytes+124,a               ; LD A,124          ; Load A with 124 (y-coordinate of character row below bottom of room)
       sb   @1(ix),a                   ; SUB (IX+1)        ; Subtract worm's depth value to get its bottom y-coordinate...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and assign
       .push af                        ; PUSH AF           ; Store AF (A = bottom y-coordinate of worm)
       movb @bytes+121,@4(ix)          ; LD (IX+4),121     ; Set worm's top y-coordinate to 121
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set
       .pop bc                         ; POP BC            ; Store AF (B = bottom y-coordinate of worm)
       jnc  _53154                     ; JR NC,53154       ; TODO: check code. If a collision occurred then set worm's depth to zero and return
       movb b,@4(ix)                   ; LD (IX+4),B       ; Set worm's top y-coordinate to same as its bottom y-coordinate
       li   hl,_52735                  ; LD HL,52735       ; Point HL at script data for worm rising from floor...
       b    @_48098                    ; JP 48098          ; ...and execute
_53154:
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set worm's depth to zero
       rt                              ; RET               ; Return

* Pathfinding Data Table
* 
* When built, this table has a header and a main data block. The header is three bytes long and contains the values:
_53159:
       byte 0,0,0
_53162:
       byte 0,0
       byte 0,0
       byte 0,0
       byte 0,0
       byte 0

* Unused
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0
       byte 0,0,100,100,100,100,100

* Load A with Value Indicating Which Direction Room A Lies Relative to Room in State Data at IX
* 
* Direction index value in A denotes which direction (left or right), e.g. Drutt, has to travel to reach the target
* room: Input:  A  Target room index (e.g. Berk's room or worm's room) IX  Address of complex state data (current
* level) for Drutt Output: A  Direction index
_53194:
       .push hl                        ; PUSH HL           ; Store HL
       .push ix                        ; PUSH IX           ; Store IX
       movb a,@e                       ; LD E,A            ; Load E with target room index
       movb *ix,a                      ; LD A,(IX+0)       ; Load D with Drutt's current room...
       movb a,d                        ; LD D,A            ; ...
       li   hl,_53159                  ; LD HL,53159       ; Set first two bytes of header to 255 (Start Marker)...
       movb @bytes+255,*hl             ; LD (HL),255       ; ...
       inc  hl                         ; INC HL            ; ...
       movb @bytes+255,*hl             ; LD (HL),255       ; ...
       inc  hl                         ; INC HL            ; Set third byte of header to index of Drutt's current room...
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; Advance HL to first byte of first entry
       bl   @_54542                    ; CALL 54542        ; Load B with index of room to left of Drutt's current room...
       jeq  _53228                     ; JR Z,53228        ; ...and if there is no such room then skip ahead to #R53228
       movb @e,a                       ; LD A,E            ; If room to left of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb @bytes+2,a                 ; LD A,2            ; Load A with 2 ("go left")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to left is target room) then restore registers and return
       b    @_53336                    ;                   
!
       bl   @_53309                    ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to left of Drutt is to the left
_53228:
       bl   @_54508                    ; CALL 54508        ; Load B with index of room to right of Drutt's room...
       jeq  _53243                     ; JR Z,53243        ; ...and if there is no such room then skip ahead to #R53243
       movb @e,a                       ; LD A,E            ; If room to right of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb one,a                      ; LD A,1            ; Load A with 1 ("go right")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to right is target room) then restore registers and return
       b    @_53336                    ;                   
!
       bl   @_53309                    ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to right of Drutt is to the right
* Now the Pathfinding Data Table has a header and zero, one or two records, depending upon the horizontal
* connectivity of Drutt's current room.
_53243:
       li   ix,_53162                  ; LD IX,53162       ; Load IX with address of first entry in Pathfinding Data Table
_53247:
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load D with index of room from current entry in Pathfinding Data Table
       bl   @_54542                    ; CALL 54542        ; Load B with index of room to left of room D...
       jeq  _53271                     ; JR Z,53271        ; ...and if there is no such room then skip ahead to #R53271
       movb @e,a                       ; LD A,E            ; If room to left of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @_53333                    ;                   
!
       bl   @_53317                    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  _53271                     ; JR Z,53271        ; ...then skip ahead to #R53271
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @_53309                    ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
_53271:
       bl   @_54508                    ; CALL 54508        ; Load B with index of room to right of room D...
       jeq  _53292                     ; JR Z,53292        ; ...and if there is no such room then skip ahead to #R53292
       movb @e,a                       ; LD A,E            ; If room to right of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @_53333                    ;                   
!
       bl   @_53317                    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  _53292                     ; JR Z,53292        ; ...then skip ahead to #R53292
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @_53309                    ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
_53292:
       inc  ix                         ; INC IX            ; Advance IX by two bytes to next entry in Pathfinding Data Table...
       inc  ix                         ; INC IX            ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; If byte at this location is not 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  !                          ; JP NZ,53247       ; ...then loop back to #R53247
       b    @_53247                    ;                   
!
* At this point, the search has checked all rooms and not found the target room.
       .pop ix                         ; POP IX            ; Restore IX
       .pop hl                         ; POP HL            ; Restore HL
       sb   a,a                        ; XOR A             ; Set A to zero
       rt                              ; RET               ; Return

* Add Entry to Pathfinding Data Table for Room B in Direction A
* 
* B contains the room the pathfinding routine is currently looking at, and A contains a value that denotes which
* direction this room lies in relative to Drutt's current room. Input:  A  Direction index (1 or 2) B  Index of room
* being examined HL  Current address of end of Pathfinding Data Table
_53309:
       movb a,*hl                      ; LD (HL),A         ; Store direction index
       inc  hl                         ; INC HL            ; Advance by one byte
       movb b,a                        ; LD A,B            ; Store index of room being examined...
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; Advance by one byte
       movb @bytes+255,*hl             ; LD (HL),255       ; Store 255 (End Marker)
       rt                              ; RET               ; Return

* Set Zero Flag if Room B Has an Entry in Pathfinding Data Table, Otherwise Reset
* 
* Used by the routine at #R53194. Input:  HL  Address of end of Pathfinding Data Table B  Index of room to check
* table for Output: F  (Zero Flag) Set if room B is already stored in Pathfinding Data Table, reset otherwise
_53317:
       .push hl                        ; PUSH HL           ; Store HL (address of end of Pathfinding Data Table)
_53318:
       dec  hl                         ; DEC HL            ; Move HL back to previous entry's room index...
       movb *hl,a                      ; LD A,(HL)         ; ...load into A...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (Start Marker, so room B not found)...
       jeq  _53330                     ; JR Z,53330        ; ...then skip ahead to #R53330
       dec  hl                         ; DEC HL            ; Move HL back to entry's direction index
       cb   a,b                        ; CP B              ; If room to search for not the same as current entry's room...
       jne  _53318                     ; JR NZ,53318       ; ...then loop back to #R53318 to test next entry
* At this point, the room we're looking for (in B) is already stored in the Pathfinding Data Table and the Zero Flag
* is set.
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       rt                              ; RET               ; Return
_53330:
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       sb   one,a                      ; DEC A             ; Reset Zero Flag
       rt                              ; RET               ; Return

* Load A with Direction Index in Pathfinding Data Table entry at Address in IX, Restore Registers and Return
* 
* Used by the routine at #R53194. Input:  IX  Address of an entry in Pathfinding Data Table
_53333:
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with direction index for entry at IX
* This entry point is used by the routine at #R53194.
_53336:
       .pop ix                         ; POP IX            ; Restore IX
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Graphic Layout Data Worm Looking ahead, animated
_53340:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,254,1                                                ; Change cursor's x- and y-coordinates by +1 and -2 characters respectively
       byte 251,_53561%256,_53561/256                                ; Process graphic layout data at #R53561 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 3,3,32,4,3,33
       byte 255                                                      ; End Marker
* Looking left, normal
_53358:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 5,7,33,6,3,32
       byte 4,3,33
       byte 255                                                      ; End Marker
* Looking right, normal
_53373:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 6,131,33,5,135,31
       byte 4,3,33
       byte 255                                                      ; End Marker
* Looking left, alarmed
_53388:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,0                                                ; Change cursor's x- and y-coordinates by 0 and -1 characters respectively
       byte 7,7,33,6,3,32
       byte 4,3,33
       byte 255                                                      ; End Marker
* Looking right, alarmed
_53403:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,255,1                                                ; Change cursor's x- and y-coordinates by +1 and -1 characters respectively
       byte 6,131,33,7,135,31
       byte 4,3,33
       byte 255                                                      ; End Marker
* Unused
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,254,1                                                ; Change cursor's x- and y-coordinates by +1 and -2 characters respectively
       byte 1,7,32,3,3,32
       byte 8,3,32,9,3,33
       byte 255                                                      ; End Marker
* Unused
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,254,1                                                ; Change cursor's x- and y-coordinates by +1 and -2 characters respectively
       byte 1,7,32,3,3,31
       byte 9,131,33,8,131,33
       byte 255                                                      ; End Marker
* Crawling Left, Alarmed (Frame 1 / 2)
_53454:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 7,7,33
       byte 248,219,208                                              ; Jump to #R53464
* Crawling Left (Frame 1 / 2)
_53462:
       byte 244,7                                                    ; Set current graphic set to 7
_53464:
       byte 5,7,33,10,3,33
       byte 10,3,33,9,3,33
       byte 255                                                      ; End Marker
* Crawling Left (Frame 2 / 2)
_53477:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 5,7,33,11,3,33
       byte 9,3,33
       byte 255                                                      ; End Marker
* Crawling Left, Alarmed (Frame 2 / 2)
_53489:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 7,7,33,11,3,33
       byte 9,3,33
       byte 255                                                      ; End Marker
* Crawling Right (Frame 2 / 2)
_53501:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 9,131,33,11,131,33
       byte 5,135,33
       byte 255                                                      ; End Marker
* Worm Crawling Right, Alarmed (Frame 2 / 2)
_53513:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 9,131,33,11,131,33
       byte 7,135,33
       byte 255                                                      ; End Marker
* Crawling Right (Frame 1 / 2)
_53525:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 9,131,33,10,131,33
       byte 10,131,33,5,135,33
       byte 255                                                      ; End Marker
* Crawling Right, Alarmed (Frame 1 / 2)
_53543:
       byte 244,7                                                    ; Set current graphic set to 7
       byte 250,0,255                                                ; Change cursor's x- and y-coordinates by -1 and 0 characters respectively
       byte 9,131,33,10,131,33
       byte 10,131,33,7,135,33
       byte 255                                                      ; End Marker
* Eyes, looking ahead, animated
_53561:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _53569%256,_53569/256                                    ; #R53569 (eyes, looking ahead, open)
       byte _53569%256,_53569/256                                    ; #R53569 (eyes, looking ahead, open)
       byte _53573%256,_53573/256                                    ; #R53573 (eyes, looking ahead, closed)
* Eyes, looking ahead, open
_53569:
       byte 1,7,33
       byte 255                                                      ; End Marker
* Eyes, looking ahead, closed
_53573:
       byte 2,3,33
       byte 255                                                      ; End Marker

* Cycle Attributes (Long, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R53723.
_53577:
       movb @bytes+21,b                ; LD B,21           ; Set repeat counter to 21
       jmp  _53583                     ; JR 53583          ; Flash screen when Berk is "killed"

* Cycle Attributes (Short, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R36616.
_53581:
       movb @bytes+7,b                 ; LD B,7            ; Set repeat counter to 7
* This entry point is used by the routine at #R53577.
_53583:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of iterations required)
       li   hl,22528                   ; LD HL,22528       ; Point HL at start of Attribute File
       li   bc,704                     ; LD BC,704         ; Set BC to 704 (i.e. gap between start of Attribute File and start of second-last row (timer
                                                           ; figures))
_53590:
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jeq  _53602                     ; JR Z,53602        ; If value is zero (black INK) then skip ahead to #R53602
       ab   one,a                      ; INC A             ; Increase INK value to next colour
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jne  _53602                     ; JR NZ,53602       ; If value is not zero (black INK) then skip ahead to #R53602
       movb one,a                      ; LD A,1            ; INK value was zero, so set now to blue INK
_53602:
       movb a,@e                       ; LD E,A            ; Load new INK value into E
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jeq  _53616                     ; JR Z,53616        ; If black PAPER, then skip ahead to #R53616
       a    @bytes+8,a                 ; ADD A,8           ; Increase to next PAPER colour
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jne  _53616                     ; JR NZ,53616       ; If PAPER component is not black then skip ahead to #R53616
       movb @bytes+8,a                 ; LD A,8            ; PAPER value was zero, so set now to blue PAPER
_53616:
       socb @e,a                       ; OR E              ; Add INK component back in
       socb @bytes+64,a                ; OR 64             ; Set BRIGHT flag
       movb a,*hl                      ; LD (HL),A         ; Paint new attribute back to current position in Attribute File
       andi a,16*256                   ; AND 16            ; Set / reset speaker bit
       socb @bytes+2,a                 ; OR 2              ; Set RED bit to maintain red border
       ; OUT (254),A                   ; OUT (254),A       ; Set border and set / reset speaker state
       inc  hl                         ; INC HL            ; Advance to next byte of Attribute File
       dec  bc                         ; DEC BC            ; Decrease remaining number of character blocks to process
       movb b,a                        ; LD A,B            ; If number of remaining character blocks is not zero...
       socb @c,a                       ; OR C              ; ...
       jne  _53590                     ; JR NZ,53590       ; ...then loop back to #R53590
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of iterations required)
       sb   one,b                      ; DJNZ 53583        ; Loop back for next iteration
       jne  _53583                     ;                   
* This entry point is used by the routine at #R53887.
_53635:
       li   hl,_61312                  ; LD HL,61312       ; Clear Display Buffers 1 and 2...
       li   bc,4224                    ; LD BC,4224        ; ...
       movb @bytes+0,*hl               ; LD (HL),0         ; ...
       movb h,d                        ; LD D,H            ; ...
       movb @l,@e                      ; LD E,L            ; ...
       inc  de                         ; INC DE            ; ...
       .ldir                           ; LDIR              ; ...
       rt                              ; RET               ; Return

* Fill Top 22 Rows of Attribute File with Attribute Value in A
* 
* Used by the routines at #R46830 and #R53723. Input:  A  Attribute
_53649:
       li   hl,22528                   ; LD HL,22528       ; Point HL at start of Attribute File
       movb @l,@e                      ; LD E,L            ; Point DE one byte after this...
       movb h,d                        ; LD D,H            ; ...
       inc  de                         ; INC DE            ; ...
       li   bc,703                     ; LD BC,703         ; Set counter to 703, as we are filling 704 characters (32*22)
       movb a,*hl                      ; LD (HL),A         ; Set first byte to A...
       .ldir                           ; LDIR              ; ...and repeat for remaining 703 bytes
       movb @bytes+3,b                 ; LD B,3            ; Pause for three iterations...
       bl   @_34675                    ; CALL 34675        ; ...
       rt                              ; RET               ; Return

* Set "Berk Has Been Killed" Flag
* 
* Used by the routines at #R36116, #R36390, #R37085, #R37639, #R38074, #R38219, #R38540, #R38592, #R39934, #R41498,
* #R41633, #R41961, #R42064, #R42266 and #R42486.
_53667:
       movb @_34208,a                  ; LD A,(34208)      ; Set "Berk Has Been Killed" Flag...
       socb @bits+2,a                  ; SET 2,A           ; ...
       mov  a,@_34208                  ; LD (34208),A      ; ...
       rt                              ; RET               ; Return

* Table of Berk's Reset Complex State Data Addresses
* 
* Addresses of complex state data reverted to by Berk after he is "killed"
       data _53684                                                   ; Level 1
       data _53710                                                   ; Level 2
       data _53697                                                   ; Level 3
       data _53710                                                   ; Level 4

* Berk's Reset Complex State Data
* 
* Complex state data reverted to by Berk after he is "killed"
_53684:
       byte 4,1,103,231,85,113,91,118,31,1,192,192,10                ; Level 1
_53697:
       byte 1,1,103,231,85,107,91,112,31,1,192,192,10                ; Level 3
_53710:
       byte 1,1,103,231,85,113,91,118,31,1,192,192,10                ; Levels 2 & 4

* If Berk Has Been Killed then Reset his Position and State, Flash Screen and Decrease Time / Lives
* 
* Used by the routine at #R34438.
_53723:
       li   hl,_34208                  ; LD HL,34208       ; Point HL at Game Flags
       szcb @bits+3,*hl                ; RES 3,(HL)        ; Reset "Reset Spiders to Initial State" Flag
       mov  *hl,tmp0                   ; BIT 2,(HL)        ; If "Berk Has Been Killed" Flag is not set...
       andi tmp0,4                     ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       szcb @bits+2,*hl                ; RES 2,(HL)        ; Reset "Berk Has Been Killed" Flag
       socb @bits+3,*hl                ; SET 3,(HL)        ; Set "Reset Spiders to Initial State" Flag
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       bl   @_36296                    ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   de,_53667+7                ; LD DE,53674       ; Point DE at location two bytes (1 WORD) before start of Table of Addresses of Berk Reset Data
       movb @_34207,a                  ; LD A,(34207)      ; Load current level number into A
       bl   @_53814                    ; CALL 53814        ; Load DE with that level's address (from table at #R53676) for complex state data to revert
                                                           ; Berk to after he is killed
       .ex_de_hl                       ; EX DE,HL          ; Swap HL (now address of complex state data to revert to) and DE
       mov  @_34240,de                 ; LD DE,(34240)     ; Load DE with address of current level's complex state data for Berk
       li   bc,13                      ; LD BC,13          ; Overwrite Berk's current complex state data...
       .ldir                           ; LDIR              ; ...with reset data from table at #R53684 for current level
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       mov  hl,@_35687                 ; LD (35687),HL     ; ...and store at #R35687 (as current position in Berk's script data)
       bl   @_53577                    ; CALL 53577        ; Cycle attributes (long, full-screen) and clear display buffers
       movb @bytes+127,a               ; LD A,127          ; Fill top 22 rows of Attribute File with white PAPER and white INK, BRIGHT...
       bl   @_53649                    ; CALL 53649        ; ...
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @_47485                    ; CALL 47485        ; Decrease current time / lives by one if greater than zero and redraw Timer Figures
       rt                              ; RET               ; Return

* Set Each Value in Primary Display Buffer Within Play Area to Zero
* 
* Used by the routine at #R34438.
_53782:
       mov  @_34279,hl                 ; LD HL,(34279)     ; Load HL with start address of Primary Display Buffer
       li   bc,704                     ; LD BC,704         ; Set BC to 704, as there are 704 entries in a Display Buffer
       li   de,3                       ; LD DE,3           ; Load DE with 3 as each entry in the Display Buffer is three bytes wide
_53791:
       movb *hl,a                      ; LD A,(HL)         ; Read first byte in Display Buffer...
       ab   one,a                      ; INC A             ; ...and add one
       jne  !                          ; JP Z,53806        ; If value is now zero (i.e. was previously 255 and therefore outside normal play area), then
       b    @_53806                    ;                   
!
                                                           ; skip ahead to #R53806
       sb   a,a                        ; XOR A             ; Set all values in current entry to zero...
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; ...
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; ...
       movb a,*hl                      ; LD (HL),A         ; ...
       inc  hl                         ; INC HL            ; ...
       b    @_53807                    ; JP 53807          ; Skip ahead to #R53807
_53806:
       a    de,hl                      ; ADD HL,DE         ; Advance current position in Display Buffer to next entry
_53807:
       dec  bc                         ; DEC BC            ; Decrease remaining number of entries to process
       movb b,a                        ; LD A,B            ; If remaining number of entries is not zero...
       socb @c,a                       ; OR C              ; ...
       jeq  !                          ; JP NZ,53791       ; ...then loop back to #R53791
       b    @_53791                    ;                   
!
       rt                              ; RET               ; Return

* Advance DE by 2xA Bytes and Load WORD at this Location into DE
* 
* Used by the routines at #R49010, #R51779 and #R53723. Input:  A  Index DE  Base address Output: DE  WORD value at
* DE (input) + 2 x A (input)
_53814:
       .push hl                        ; PUSH HL           ; Store HL
       a    a,a                        ; ADD A,A           ; Load HL with double index...
       movb a,@l                       ; LD L,A            ; ...
       movb @bytes+0,h                 ; LD H,0            ; ...
       a    de,hl                      ; ADD HL,DE         ; Add HL to DE as offset, in HL
       movb *hl,@e                     ; LD E,(HL)         ; Load address at HL into DE...
       inc  hl                         ; INC HL            ; ...
       movb *hl,d                      ; LD D,(HL)         ; ...
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Copy Room Dimension Data Entry for Current Character / Entity's Current Room to Temporary Store Location (34230)
* 
* Used by the routines at #R34916 and #R53887. Input:  IX  (Entry at #R53848 only) Address of complex state data for
* an entity
_53825:
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  _53838                     ; JR Z,53838        ; ...then skip ahead to #R53838
       mov  @_34242,ix                 ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       jmp  _53842                     ; JR 53842          ; Skip ahead to #R53842
_53838:
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
_53842:
       movb *ix,a                      ; LD A,(IX+0)       ; Store current character's current room at 34218...
       mov  a,@_34218                  ; LD (34218),A      ; ...
* This entry point is used by the routines at #R35689, #R37062, #R39278, #R51739, #R52837, #R53083, #R54480 and
* #R55525.
_53848:
       movb *ix,a                      ; LD A,(IX+0)       ; Load entity's current room into A
       sb   one,a                      ; DEC A             ; Subtract 1...
       movb a,@e                       ; LD E,A            ; ...and multiply by 5...
       a    a,a                        ; ADD A,A           ; ...
       a    a,a                        ; ADD A,A           ; ...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@c                       ; LD C,A            ; Load into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       mov  @_34248,hl                 ; LD HL,(34248)     ; Load start address of current level's room dimension data into HL...
       a    bc,hl                      ; ADD HL,BC         ; ...and add BC as offset
       mov  hl,@_34262                 ; LD (34262),HL     ; Store HL at #R34262
       movb @bytes+5,@c                ; LD C,5            ; Set BC to 5 (as entries are 5 bytes wide)
       li   de,_34230                  ; LD DE,34230       ; Copy data entry in room dimension data for entity's current room to #R34230...
       .ldir                           ; LDIR              ; ...
       movb @_34230+1,a                ; LD A,(34231)      ; Load position (chars) of left side of current room into E...
       movb a,@e                       ; LD E,A            ; ...
       movb @_34230+2,a                ; LD A,(34232)      ; Subtract position (chars) of right side of current room in A...
       sb   @e,a                       ; SUB E             ; ...
       a    @bytes+100,a               ; ADD A,100         ; ...and add 100
       mov  a,@_34235                  ; LD (34235),A      ; Store value (width of current room + 99) at #R34235
       rt                              ; RET               ; Return

* Paint Red Areas Outside Accessible Areas of Current Character's Current Room
* 
* Used by the routines at #R34438, #R34916, #R36616, #R48791, #R53723 and #R54456.
_53887:
       bl   @_53825                    ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .push ix                        ; PUSH IX           ; Store IX
       bl   @_53635                    ; CALL 53635        ; Clear Display Buffers 1 & 2
       .exx                            ; EXX               ; Switch registers
       li   hl,_61312                  ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,_63424                  ; LD DE,63424       ; Point DE at Display Buffer 2
       .exx                            ; EXX               ; Switch registers
       mov  @_34230+1,hl               ; LD HL,(34231)     ; For current character's current room, set H = room's right edge position and L = room's left
                                                           ; edge position (chars)
       mov  @_34230+3,de               ; LD DE,(34233)     ; For current character's current room, set D = room's bottom edge position and E = room's top
                                                           ; edge position (chars)
       li   ix,22528                   ; LD IX,22528       ; Point IX at first byte of Attribute File
       movb @bytes+0,b                 ; LD B,0            ; Set initial y-coordinate (characters) to zero
_53916:
       movb b,a                        ; LD A,B            ; Load A with current y-coordinate
       cb   a,@e                       ; CP E              ; If y-coordinate of top of room is greater than current y-coordinate...
       jl   _53950                     ; JR C,53950        ; ...then skip ahead to #R53950
       movb d,a                        ; LD A,D            ; Load A with y-coordinate of bottom of room
       cb   a,b                        ; CP B              ; If y-coordinate of bottom of room is less than current y-coordinate...
       jl   _53950                     ; JR C,53950        ; ...then skip ahead to #R53950
       movb @bytes+0,@c                ; LD C,0            ; Set initial x-coordinate to zero
_53926:
       movb @c,a                       ; LD A,C            ; Load A with current x-coordinate
       cb   a,@l                       ; CP L              ; If x-coordinate of left of room is greater than current x-coordinate...
       jl   _53940                     ; JR C,53940        ; ...then skip ahead to #R53940
       movb h,a                        ; LD A,H            ; Load A with x-coordinate of right of room
       cb   a,@c                       ; CP C              ; If x-coordinate of right of room is less than current x-coordinate...
       jl   _53940                     ; JR C,53940        ; ...then skip ahead to #R53940
       .exx                            ; EXX               ; Switch registers
       bl   @_53977                    ; CALL 53977        ; Advance pointers in Display Buffers and Attribute File address to next character
       jmp  _53943                     ; JR 53943          ; Skip ahead to #R53943
* Current x-coordinate, C, is outside range of x-coordinates spanned by room
_53940:
       bl   @_53968                    ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
_53943:
       ab   one,@c                     ; INC C             ; Advance C by one (move right one character)
       mov  @c,tmp0                    ; BIT 5,C           ; If bit 5 is not set (x-coordinate has not reached 32)...
       andi tmp0,32                    ;                   
       jeq  _53926                     ; JR Z,53926        ; ...then loop back to #R53926
       jmp  _53959                     ; JR 53959          ; Skip ahead to #R53959
* Current y-coordinate, B, is outside range of y-coordinates spanned by room
_53950:
       .push bc                        ; PUSH BC           ; Store BC (B = current y-coordinate, C = current x-coordinate)
       movb @bytes+32,b                ; LD B,32           ; Load counter with 32 (as there are 32 characters per row)
_53953:
       bl   @_53968                    ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
       sb   one,b                      ; DJNZ 53953        ; Loop back to #R53953 for next character block
       jne  _53953                     ;                   
       .pop bc                         ; POP BC            ; Restore BC (B = current y-coordinate, C = current x-coordinate)
_53959:
       ab   one,b                      ; INC B             ; Increase current y-coordinate by one
       movb b,a                        ; LD A,B            ; If y-coordinate has not reached 22...
       cb   a,@bytes+22                ; CP 22             ; ...
       jne  _53916                     ; JR NZ,53916       ; ...then loop back to #R53916
       .pop ix                         ; POP IX            ; Restore IX
       rt                              ; RET               ; Return

* Print Red Cell to Current Attribute File Position (Outside Play Area) and Mark as Unused in Display Buffers
* 
* Used by the routine at #R53887. Input:  IX  Address of start of Attribute File (22528) HL'  Current position in
* display buffer 1 (at #R61312) DE'  Current position in display buffer 2 (at #R63424)
_53968:
       movb @bytes+18,*ix              ; LD (IX+0),18      ; Set attribute to red INK, red PAPER
       .exx                            ; EXX               ; Switch registers
       movb @bytes+255,a               ; LD A,255          ; Load 255 into current positions in Display Buffers 1 and 2...
       movb a,*hl                      ; LD (HL),A         ; ...
       movb a,*de                      ; LD (DE),A         ; ...
* This entry point is used by the routine at #R53887.
_53977:
       inc  hl                         ; INC HL            ; Advance display buffer 1 pointer by three bytes to next entry...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inc  de                         ; INC DE            ; Advance display buffer 2 pointer by three bytes to next entry...
       inc  de                         ; INC DE            ; ...
       inc  de                         ; INC DE            ; ...
       .exx                            ; EXX               ; Switch registers
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       rt                              ; RET               ; Return

* Reset Complex State Data for First Entity of Class A to that Stored in Initial-State Table at 59821
* 
* Used by the routines at #R37639 and #R48417. Input:  A  Entity class value IX  (Entry at #R53994 only) Address of
* complex state data for an entity
_53987:
       bl   @_54019                    ; CALL 54019        ; Load IX with address of complex state data for first entry in current level that has class
                                                           ; A...
       .push iy                        ; PUSH IY           ; ...
       .pop ix                         ; POP IX            ; ...
* This entry point is used by the routine at #R42064.
_53994:
       li   iy,_59821                  ; LD IY,59821       ; Point IY at start of Table of Initial-State Data for Complex Entities
       bl   @_54023                    ; CALL 54023        ; Advance IY to first entry in copied complex state data that has class A
       .push ix                        ; PUSH IX           ; Store IX (address of entry in complex state data to overwrite)
       movb @e,b                       ; LD B,E            ; Load B with 13 (DE set to 13 in routine at #R54019)
_54004:
       movb *iy,a                      ; LD A,(IY+0)       ; Overwrite IX data entry with IY data...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       inc  ix                         ; INC IX            ; ...
       inc  iy                         ; INC IY            ; ...
       sb   one,b                      ; DJNZ 54004        ; ...
       jne  _54004                     ;                   
       .pop ix                         ; POP IX            ; Restore IX (address of entry in complex state data just overwritten)
       rt                              ; RET               ; Return

* Point IY at First Entry in Current Level's Complex State Data that has Class A
* 
* Used by the routines at #R36753 and #R53987. Input:  A  Value of an entity class Output: IY  Address of complex
* state data for first entity of class A
_54019:
       mov  @_34238,iy                 ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
* This entry point is used by the routine at #R53987.
_54023:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
_54026:
       cb   a,@8(iy)                   ; CP (IY+8)         ; If current IY entity has class A...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       a    de,iy                      ; ADD IY,DE         ; Advance to entry for next entity
       jmp  _54026                     ; JR 54026          ; Loop back to #R54026

* Draw Contents of Primary Display Buffer to Display
* 
* If either the graphic index, or the graphic set index for the current entry in the Primary Display Buffer is zero,
* then only the attribute from that entry is rendered; the currently displayed bitmap data (from the previous frame)
* is preserved.
_54034:
       li   ix,22528                   ; LD IX,22528       ; Point IX at first byte of Attribute File
       li   hl,_61312                  ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,_63424                  ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @_34271,a                  ; LD A,(34271)      ; If "Display Buffer 2 is Primary" Flag is reset...
       socb a,a                        ; OR A              ; ...i.e. Display Buffer 1 is Primary...
       jne  !                          ; JP Z,54052        ; ...then skip ahead to #R54052
       b    @_54052                    ;                   
!
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
_54052:
       .push de                        ; PUSH DE           ; Copy address of Secondary Display Buffer into IY...
       .pop iy                         ; POP IY            ; ...
_54055:
       movb *hl,a                      ; LD A,(HL)         ; Read Graphic Set Index from Primary Display Buffer into A
       inc  hl                         ; INC HL            ; Advance HL to next byte (Graphic Index) in Primary Display Buffer
       socb a,a                        ; OR A              ; If Graphic Set Index is zero...
       jne  !                          ; JP Z,54130        ; ...then skip ahead to #R54130
       b    @_54130                    ;                   
!
       cb   a,@bytes+255               ; CP 255            ; If Graphic Set Index is 255 (character block outside room's dimensions)...
       jne  !                          ; JP Z,54140        ; ...then skip ahead to #R54140
       b    @_54140                    ;                   
!
       movb a,b                        ; LD B,A            ; Transfer Graphic Set Index into B
       movb @bytes+0,@e                ; LD E,0            ; Set E to zero
       cb   a,*iy                      ; CP (IY+0)         ; If Graphic Set Index in Primary Display Buffer entry is different to Graphic Set Index in
                                                           ; Secondary Display Buffer entry...
       jeq  !                          ; JP NZ,54076       ; ...then skip ahead to #R54076
       b    @_54076                    ;                   
!
       ab   one,@e                     ; INC E             ; Increase E
_54076:
       movb *hl,a                      ; LD A,(HL)         ; Load Graphic Index from Primary Display Buffer
       socb a,a                        ; OR A              ; If Graphic Index is zero...
       jne  !                          ; JP Z,54130        ; ...then skip ahead to #R54130
       b    @_54130                    ;                   
!
       movb a,@c                       ; LD C,A            ; Transfer Graphic Index into C
       cb   a,@1(iy)                   ; CP (IY+1)         ; If Graphic Index in Primary Display Buffer is different to Graphic Index in Secondary Display
                                                           ; Buffer...
       jeq  !                          ; JP NZ,54089       ; ...then skip ahead to #R54089
       b    @_54089                    ;                   
!
       ab   one,@e                     ; INC E             ; Increase E
_54089:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Read attribute from Primary Display Buffer
       cb   a,@2(iy)                   ; CP (IY+2)         ; If attribute in Display Buffer entry A is different to attribute in Secondary Display Buffer
                                                           ; entry...
       jeq  !                          ; JP NZ,54102       ; ...then skip ahead to #R54102
       b    @_54102                    ;                   
!
       mov  @e,tmp0                    ; BIT 1,E           ; If E is 2 (i.e. both Graphic Set Index and Graphic Index are the same)...
       andi tmp0,2                     ;                   
       jeq  !                          ; JP NZ,54107       ; ...then skip ahead to #R54107, over drawing instructions (no need to redraw what is already
       b    @_54107                    ;                   
!
                                                           ; there)
_54102:
       equ  $
       .push hl                        ; PUSH HL           ; Store HL (pointer to current position in Primary Display Buffer)
       bl   @_54144                    ; CALL 54144        ; Draw a graphic character block to display
       .pop hl                         ; POP HL            ; Restore HL (pointer to current position in Primary Display Buffer)
_54107:
       inc  hl                         ; INC HL            ; Advance HL to next byte in Primary Display Buffer (start of next entry)
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .push ix                        ; PUSH IX           ; Copy current Attribute File address from IX to DE...
       .pop de                         ; POP DE            ; ...
       movb @e,a                       ; LD A,E            ; If current Attribute File address is not at the start of the seventh row of a third of the
                                                           ; display (i.e. row 7, 15 or 23)...
       cb   a,@bytes+192               ; CP 192            ; ...
       jne  _54122                     ; JR NZ,54122       ; ...then skip ahead to #R54122
       movb d,a                        ; LD A,D            ; If current Attribute File address is 23232 (256*90 + 192, i.e. at start of second last
                                                           ; display character row)...
       cb   a,@bytes+90                ; CP 90             ; ...
       jne  !                          ; RET Z             ; ...then return, as only timer figures appear in last two rows
       rt                              ;                   
!
_54122:
       equ  $
       li   de,3                       ; LD DE,3           ; Advance current position in Secondary Display Buffer by 3 bytes...
       a    de,iy                      ; ADD IY,DE         ; ...
       b    @_54055                    ; JP 54055          ; Loop back to #R54055
_54130:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Load attribute into A
       socb @bits+6,a                  ; SET 6,A           ; Set BRIGHT flag
       movb a,*ix                      ; LD (IX+0),A       ; Place attribute at current position in Attribute File
       b    @_54107                    ; JP 54107          ; Loop back to #R54107
_54140:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       b    @_54107                    ; JP 54107          ; Loop back to #R54107

* Draw a Graphic Character Block to Display
* 
* This routine uses the same technique as seen in the routine at #R47709 to convert from an Attribute File address
* to a Display File address. See the notes in #R47709 for more details. Input:  A  Attribute value (bit 7 is
* "mirror" flag, rather than FLASH) B  Graphic set index C  Graphic index IX  Address in Attribute File
_54144:
       socb @bits+6,a                  ; SET 6,A           ; Set Bright Flag
       movb a,*ix                      ; LD (IX+0),A       ; Load attribute value into current Attribute File address
       sb   a,a                        ; XOR A             ; Load graphic set index into HL..
       movb b,@l                       ; LD L,B            ; ...
       movb a,h                        ; LD H,A            ; ...
       a    hl,hl                      ; ADD HL,HL         ; Double (as start address entries in table at #R27000 are two bytes wide)...
       li   de,_27000                  ; LD DE,27000       ; ...and add as offset to #R27000 (in HL)...
       a    de,hl                      ; ADD HL,DE         ; ...
       movb *hl,@e                     ; LD E,(HL)         ; Load start address for this graphic set into DE...
       inc  hl                         ; INC HL            ; ...
       movb *hl,d                      ; LD D,(HL)         ; ...
       movb @c,@l                      ; LD L,C            ; Load graphic index into HL...
       movb a,h                        ; LD H,A            ; ...
       a    hl,hl                      ; ADD HL,HL         ; Multiply by eight, as graphic blocks are eight bytes long...
       a    hl,hl                      ; ADD HL,HL         ; ...
       a    hl,hl                      ; ADD HL,HL         ; ...
       a    de,hl                      ; ADD HL,DE         ; Add to address of start of this graphic set as an offset in HL
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to required graphic data) and HL (now address of start of graphic set
                                                           ; from table at #R27000)
       .push ix                        ; PUSH IX           ; Switch Attribute File address into HL...
       .pop hl                         ; POP HL            ; ...
       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
       a    a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
       a    a,a                        ; ADD A,A           ; ...
       a    a,a                        ; ADD A,A           ; ...
       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File
       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now Display File address) and HL (now pointer to graphic data)
       mov  *ix,tmp0                   ; BIT 7,(IX+0)      ; If mirror flag is set for Attribute File at current location...
       andi tmp0,128                   ;                   
       jeq  !                          ; JP NZ,54194       ; ...then skip to #R54194 to draw mirrored version
       b    @_54194                    ;                   
!
       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
_54187:
       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
       movb a,*de                      ; LD (DE),A         ; ...and load into Display File
       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
       sb   one,b                      ; DJNZ 54187        ; Loop back for next row of pixels
       jne  _54187                     ;                   
       rt                              ; RET               ; Return

* Draw Mirrored Graphic Character Block to Display File
* 
* Used by the routine at #R54144. Input:  HL  Address of bitmap data to draw IX  Address in Attribute File
_54194:
       szcb @bits+7,*ix                ; RES 7,(IX+0)      ; Reset Bit 7 (Mirror Flag, shared with FLASH flag so would cause graphic to flash)
       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
_54200:
       .push bc                        ; PUSH BC           ; Store BC (B = current counter value)
       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
       .push hl                        ; PUSH HL           ; Store HL (pointer to graphic data)
       li   hl,_27030                  ; LD HL,27030       ; Point HL at mirror graphic lookup table
       movb a,@c                       ; LD C,A            ; Load graphic "value" into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,hl                      ; ADD HL,BC         ; ...and add to HL as offset
       movb *hl,a                      ; LD A,(HL)         ; Read byte at this location (mirror image of graphic data read by instruction at 54201)
       .pop hl                         ; POP HL            ; Restore HL (pointer to graphic data)
       movb a,*de                      ; LD (DE),A         ; Load (mirrored) graphic data into Display File
       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
       .pop bc                         ; POP BC            ; Restore BC (B = current counter value)
       sb   one,b                      ; DJNZ 54200        ; Loop back for next row of pixels
       jne  _54200                     ;                   
       rt                              ; RET               ; Return

* Data for Pseudo-Random Number Generator
_54219:
       data 0                                                        ; Seed
_54221:
       byte 0                                                        ; Temporary store for range value

* Load A with a Pseudo-Random Number Between 0 and the Higher of 2 and A (Input)
* 
* This routine uses a linear congruential generator to generate a new pseudo-random number based upon a seed value.
* The seed value is stored at #R54219, is initially set to the value in the least significant byte of the system
* variable FRAMES, and subsequently set to the previously generated pseudo-random number. On entering this routine,
* the A register holds the range for the random number (e.g. 5 means this routine will generate a random number in
* the range 0-4 inclusive). A range of less than 2 is not allowed, so if A is less than this then it will be set to
* 2. Input:  A  Range Output: A  Generated random number
_54222:
       cb   a,@bytes+2                 ; CP 2              ; If range is less than 2...
       jl   !                          ; JP NC,54229       ; ...then set range to 2...
       b    @_54229                    ;                   
!
       movb @bytes+2,a                 ; LD A,2            ; ...
_54229:
       mov  a,@_54221                  ; LD (54221),A      ; Store range at #R54211
       .push hl                        ; PUSH HL           ; Store HL
       .push de                        ; PUSH DE           ; Store DE
       .push bc                        ; PUSH BC           ; Store BC
       mov  @_54219,de                 ; LD DE,(54219)     ; Load DE with seed
       movb @e,h                       ; LD H,E            ; Load least significant byte of random seed into H
       movb @bytes+253,@l              ; LD L,253          ; Set L to 253
       movb d,a                        ; LD A,D            ; Load most significant byte (MSB) of random seed into A
* At this point, the three registers A, H and L encode a 24-bit number whose value is (256 * seed + 253)
       socb a,a                        ; OR A              ; Reset carry flag
       sb   de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
       sb   de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
* At this point, the three registers A, H and L encode a 24-bit number whose value is (254 * seed + 253)
       movb a,@e                       ; LD E,A            ; Calculate (AHL mod 65,537)...
       movb @bytes+0,d                 ; LD D,0            ; ...loading result into HL...
       sb   de,hl                      ; SBC HL,DE         ; ...
       joc  !                          ; JP NC,54261       ; TODO: check code. ...and if this is negative...
       b    @_54261                    ;                   
!
       inc  hl                         ; INC HL            ; ...then add one (as zero in HL can represent both zero and 65,536)
_54261:
       mov  hl,@_54219                 ; LD (54219),HL     ; Store HL (new seed) at #R54219
* At this point, HL contains a new pseudo-random 16-bit number
       .push hl                        ; PUSH HL           ; Copy 16-bit pseudo-random number from HL into DE...
       .pop de                         ; POP DE            ; ...
       movb @_54221,a                  ; LD A,(54221)      ; Load A with range as stored previously
       sb   one,a                      ; DEC A             ; Decrease range by 1 to get maximum value as we want the output to range from 0 to (A-1)...
       movb a,b                        ; LD B,A            ; ...and load into B (loop counter)
* In the following loop we are obtaining the number of times that 65,536 goes into RANGE x DE. In other words,
* (RANGE x DE) is divided by 65,536 and the integer part of the result is loaded into A. A is therefore limited to
* values between zero, and the value A had on entering this routine minus one, inclusive.
       sb   a,a                        ; XOR A             ; Set A to zero
_54272:
       a    de,hl                      ; ADD HL,DE         ; Add DE to HL
       joc  !                          ; JP NC,54277       ; TODO: check code. If DE has not crossed the 65,535 - 0 boundary then skip ahead to #R54277
       b    @_54277                    ;                   
!
       ab   one,a                      ; INC A             ; Increase A (count of number of times DE rolls over from 65,535 to 0)
_54277:
       sb   one,b                      ; DJNZ 54272        ; Decrease B and loop back to #R54272
       jne  _54272                     ;                   
       .pop bc                         ; POP BC            ; Restore BC
       .pop de                         ; POP DE            ; Restore DE
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Move Entity at IX into New Room (Left or Right) if it is at the Edge of its Current Room
* 
* Used by the routines at #R35735 and #R55041. Input:  IX  Address of complex state data for an entity
_54283:
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 97...
       sb   one,a                      ; DEC A             ; ...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of left side (+100) of entity is greater than this...
       jl   _54306                     ; JR C,54306        ; ...then skip ahead to #R54306
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of right side (+100) of entity is not less than 102...
       cb   a,@bytes+102               ; CP 102            ; ...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       bl   @_54539                    ; CALL 54539        ; Load B with index of room to left of entity's current room
       bl   @_54419                    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       rt                              ; RET               ; Return
_54306:
       bl   @_54505                    ; CALL 54505        ; Load B with index of room to right of current character's current room
       bl   @_54383                    ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
       rt                              ; RET               ; Return

* Move Entity at IX into Room to the Right, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading side (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading side crosses the boundary.
* This routine (along with its counterpart at #R54348) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the right, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
_54313:
       movb @_34235,a                  ; LD A,(34235)      ; Load C with width of entity's current room (chars) + 99...
       movb a,@c                       ; LD C,A            ; ...
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  _54329                     ; JR Z,54329        ; ...then skip ahead to #R54329
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of Drutt's left edge
       jmp  _54332                     ; JR 54332          ; Skip ahead to #R54332
_54329:
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right edge
_54332:
       cb   a,@c                       ; CP C              ; If x-coordinate of room's right edge is greater than x-coordinate in A...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       bl   @_54505                    ; CALL 54505        ; Load B with index of room to right of current character's current room
       jeq  _54381                     ; JR Z,54381        ; If there is no room to the right, then jump to #R54381
       bl   @_54383                    ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
       bl   @_54569                    ; CALL 54569        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _54381                     ; JR NC,54381       ; TODO: check code. ...and if a collision occurred, then jump to #R54381
       rt                              ; RET               ; Return

* Move Entity at IX into Room to the Left, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading edge (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading edge crosses the boundary.
* This routine (along with its counterpart at #R54313) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the left, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
_54348:
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  _54363                     ; JR Z,54363        ; ...then skip ahead to #R54363
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Drutt's right edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       jmp  _54369                     ; JR 54369          ; Skip ahead to #R54369
_54363:
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Berk's left edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
_54369:
       equ  $
       bl   @_54539                    ; CALL 54539        ; Load B with index of room to left of entity's current room
       jeq  _54381                     ; JR Z,54381        ; If there is no room to the left, then jump to #R54381
       bl   @_54419                    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       bl   @_54666                    ; CALL 54666        ; Set Carry Flag if entity at IX has not collided with another impassable / pushable entity
                                                           ; immediately to the left, reset otherwise
       rt                              ; RET               ; Return
* This entry point is used by the routine at #R54313.
_54381:
       sb   a,a                        ; XOR A             ; Set A to zero
       rt                              ; RET               ; Return

* Move Entity at IX into Room to Right of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48593, #R54283 and #R54313. Input:  IX  Address of complex state data for an entity
_54383:
       bl   @_54398                    ; CALL 54398        ; Set character's position to be left-hand side of new room to right
       bl   @_54456                    ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       mov  @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128                   ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       bl   @_48727                    ; CALL 48727        ; If entity is Berk then move carried entity to Berk's right as he faces right
       rt                              ; RET               ; Return

* Set Entity's Position to be Left-Hand Side of New Room to Right
* 
* Used by the routine at #R54383. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
_54398:
       movb @_34235,a                  ; LD A,(34235)      ; Load D with i.e. x-coordinate of right edge of room (width of current room (chars) + 99)
                                                           ; minus x-coordinate of right-edge of current character...
       sb   @7(ix),a                   ; SUB (IX+7)        ; ...(i.e. [negative] distance by which entity's right edge is to the right of right edge of
                                                           ; room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @_54480                    ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @bytes+99,a                ; LD A,99           ; Load A with x-coordinate of left edge of current (new) room
       sb   d,a                        ; SUB D             ; Subtract D (negative)...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as new x-coordinate of entity's right edge
       sb   @e,a                       ; SUB E             ; Subtract (width - 1) of entity...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set this as x-coordinate of entity's left edge
       rt                              ; RET               ; Return

* Move Entity at IX into Room to Left of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48641, #R54283 and #R54348.
_54419:
       bl   @_54434                    ; CALL 54434        ; Set entity's position to be right-hand side of new room to left
       bl   @_54456                    ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       mov  @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128                   ;                   
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
       bl   @_48738                    ; CALL 48738        ; If entity is Berk then move carried entity to Berk's left as he faces left
       rt                              ; RET               ; Return

* Set Entity's Position to be Right-Hand Side of New Room to Left
* 
* Used by the routine at #R54419. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
_54434:
       movb @bytes+100,a               ; LD A,100          ; Load D with x-coordinate of left edge of room minus x-coordinate of left edge of current
                                                           ; entity...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...(i.e. distance by which entity's left edge is to the left of left edge of room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @_54480                    ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current (new) room (chars) + 99
       sb   d,a                        ; SUB D             ; Subtract D...
       ab   one,a                      ; INC A             ; ...and add one to get x-coordinate of entity's left edge in new room
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set entity's left edge to this position
       a    @e,a                       ; ADD A,E           ; Add (width - 1) of entity...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set this as x-coordinate of entity's right edge
       rt                              ; RET               ; Return

* Paint Red Areas Outside Current Character's Room if IX Points to Current Character's Complex State Data
* 
* Used by the routines at #R54383, #R54419, #R55433 and #R55616. Input:  IX  Address of complex state data for an
* entity
_54456:
       movb @_34208,a                  ; LD A,(34208)      ; Set Zero Flag if Drutt Mode Flag is reset...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       movb @8(ix),a                   ; LD A,(IX+8)       ; Load Entity Class Value of entity at IX into A
       jne  _54471                     ; JR NZ,54471       ; If Zero Flag is reset (i.e. Drutt Mode) then skip ahead to #R54471
       cb   a,@bytes+31                ; CP 31             ; If Entity Class is 31 (i.e. Berk)...
       jeq  _54474                     ; JR Z,54474        ; ...then paint red areas outside accessible areas of current character's current room and
                                                           ; return
       rt                              ; RET               ; Return
_54471:
       cb   a,@bytes+18                ; CP 18             ; If Entity Class is not 18 (i.e. Drutt)...
       jeq  !                          ; RET NZ            ; ...then return
       rt                              ;                   
!
_54474:
       equ  $
       .push hl                        ; PUSH HL           ; Store HL
       bl   @_53887                    ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Set Room of Entity at IX to B, Store Room Size Data for New Room and Load E with Entity's Width Minus One
* 
* Used by the routines at #R54398, #R54434, #R55433 and #R55616. Input:  B  Destination room index IX  Address of
* complex state data for an entity Output: E  Entity's width, minus one (characters)
_54480:
       movb b,a                        ; LD A,B            ; Set entity's current room to be destination room...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       .push hl                        ; PUSH HL           ; Store HL
       .push de                        ; PUSH DE           ; Store DE
       bl   @_53848                    ; CALL 53848        ; Store room size data for entity's current room
       .pop de                         ; POP DE            ; Restore DE
       .pop hl                         ; POP HL            ; Restore HL
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of entity's right...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...subtract x-coordinate of entity's left...
       movb a,@e                       ; LD E,A            ; ...and load result (entity's width minus one) into E
       rt                              ; RET               ; Return

* Unused routine
* 
* This routine is not used. It is assumed, since this routine flows into the routine at #R54505, that this unused
* routine was also intended to deal with room connectivity. As there are routines to deal with vertical and
* horizontal (left-right) connectivity, it is possible that this routine was originally intended to handle
* horizontal (forward-back) connectivity.
_54499:
       mov  @_34252,iy                 ; LD IY,(34252)     ; Load IY with address of Unused Data Block (09)
       jmp  _54512                     ; JR 54512          ; Load B with index of room, as related to room of index D via data in Unused Data Block (09)

* Load B with Index of Room to Right of an Entity's Current Room
* 
* Used by the routines at #R48593, #R52193, #R54283 and #R54313. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54512 only) An entry in a room connectivity table D  (entry at #R54508 and #R54512 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the right, reset otherwise
_54505:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
_54508:
       mov  @_34250,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
* This entry point is used by the routine at #R54499.
_54512:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (left room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  _54527                     ; JR NZ,54527       ; ...then skip ahead to #R54527
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (right room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       rt                              ; RET               ; Return
_54527:
       inc  iy                         ; INC IY            ; Advance by two bytes to the next entry...
       inc  iy                         ; INC IY            ; ...
       jmp  _54512                     ; JR 54512          ; Loop back to #R54512

* Unused routine
* 
* This routine is not used. It is assumed, since this routine flows into the routine at #R54539, that this unused
* routine was also intended to deal with room connectivity. As there are routines to deal with vertical and
* horizontal (left-right) connectivity, it is possible that this routine was originally intended to handle
* horizontal (forward-back) connectivity.
_54533:
       mov  @_34252,iy                 ; LD IY,(34252)     ; Load IY with address of Unused Data Block (09)
       jmp  _54546                     ; JR 54546          ; Load B with index of room, as related to room of index D via data in Unused Data Block (09)

* Load B with Index of Room to Left of an Entity's Current Room
* 
* Used by the routines at #R48641, #R52098, #R54283 and #R54348. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54546 only) An entry in a room connectivity table D  (entry at #R54542 and #R54546 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the left, reset otherwise
_54539:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
_54542:
       mov  @_34250,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
* This entry point is used by the routine at #R54533.
_54546:
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (right room index) of first entry
_54548:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (right room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  _54563                     ; JR NZ,54563       ; ...then skip ahead to #R54563
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (left room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       rt                              ; RET               ; Return
_54563:
       inc  iy                         ; INC IY            ; Advance by two bytes to the next entry...
       inc  iy                         ; INC IY            ; ...
       jmp  _54548                     ; JR 54548          ; Loop back to #R54548

* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Right
* 
* Used by the routines at #R36116, #R52148, #R52193, #R52889, #R52914, #R54313 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
_54569:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @_34238,iy                 ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
_54576:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  _54585                     ; JR NZ,54585       ; ...then skip ahead to #R54585
       ; SCF                           ; SCF               ; Set Carry Flag
       rt                              ; RET               ; Return
_54585:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  _54662                     ; JR NZ,54662       ; ...then advance IY to next entity
       mov  @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32                    ;                   
       jeq  !                          ; JP NZ,54662       ; ...then advance IY to next entity
       b    @_54662                    ;                   
!
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  _54662                     ; JR Z,54662        ; ...then advance IY to next entity
       mov  a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128                   ;                   
       jne  _54620                     ; JR NZ,54620       ; ...then skip over depth check to #R54620
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  _54662                     ; JR NZ,54662       ; ...then advance IY to next entity
_54620:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Rightwards" Flag reset...
       andi a,32*256                   ; AND 32            ; ...
       jne  !                          ; JP Z,54662        ; ...then advance IY to next entity
       b    @_54662                    ;                   
!
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity at IX...
       ab   one,a                      ; INC A             ; ...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is not immediately to the left of the left side of the entity at IY...
       jne  _54662                     ; JR NZ,54662       ; ...then advance IY to next entity
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   _54662                     ; JR C,54662        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   _54662                     ; JR C,54662        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@_34258                 ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       rt                              ; RET               ; Return
_54662:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  _54576                     ; JR 54576          ; Loop back to #R54576

* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Left
* 
* Used by the routines at #R36116, #R52053, #R52098, #R52870, #R52914, #R54348 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
_54666:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @_34238,iy                 ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
_54673:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  _54682                     ; JR NZ,54682       ; ...then skip ahead to #R54682
       ; SCF                           ; SCF               ; Set Carry Flag
       rt                              ; RET               ; Return
_54682:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  _54760                     ; JR NZ,54760       ; ...then advance IY to next entity
       mov  @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32                    ;                   
       jeq  !                          ; JP NZ,54760       ; ...then advance IY to next entity
       b    @_54760                    ;                   
!
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jne  !                          ; JP Z,54760        ; ...then advance IY to next entity
       b    @_54760                    ;                   
!
       mov  a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128                   ;                   
       jne  _54718                     ; JR NZ,54718       ; ...then skip over depth check to #R54620
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  _54760                     ; JR NZ,54760       ; ...then advance IY to next entity
_54718:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Leftwards" Flag reset...
       andi a,16*256                   ; AND 16            ; ...
       jne  !                          ; JP Z,54760        ; ...then advance IY to next entity
       b    @_54760                    ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If the left side of entity at IX...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...is not immediately to the right of the right side of the entity at IY...
       jne  _54760                     ; JR NZ,54760       ; ...then advance IY to next entity
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   _54760                     ; JR C,54760        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   _54760                     ; JR C,54760        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@_34258                 ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       rt                              ; RET               ; Return
_54760:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  _54673                     ; JR 54673          ; Loop back to #R54673

* Check Entity at IX for Collision With Another Entity at Next Depth Level Out Of Screen Whose Interaction (11,6)
* Flag is Set
* 
* Used by the routines at #R37639 and #R52315. Input:  IX  Address of complex state data for an entity Output: F
* Carry Flag set if no entity found, reset otherwise A  Class of entity, if found, otherwise 255 IY  Address of
* complex state data for colliding entity
_54764:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level out of screen)
       jmp  _54770                     ; JR 54770          ; Jump to collision detection routine

* Check Entity at IX for Collision With Another Entity at Same Depth Whose Interaction (11,6) Flag is Set
* 
* Used by the routines at #R36036, #R36542, #R37085, #R38074, #R38219, #R38540, #R38592, #R41498, #R41633, #R41961,
* #R42064, #R42266, #R42486, #R48487, #R51779, #R53083, #R55196 and #R55525. Input:  IX  Address of complex state
* data for an entity C  (Entry at #R54770 only) Depth offset Output: F  Carry Flag set if no entity found, reset
* otherwise A  Class of entity, if found, otherwise 255 IY  Address of complex state data for colliding entity
_54768:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
* This entry point is used by the routine at #R54764.
_54770:
       mov  @_34238,iy                 ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
_54777:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  _54786                     ; JR NZ,54786       ; ...then skip ahead to #R54786
       ; SCF                           ; SCF               ; Set Carry Flag
       rt                              ; RET               ; Return
_54786:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  _54874                     ; JR NZ,54874       ; ...then advance IY to next entity
       mov  @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32                    ;                   
       jeq  !                          ; JP NZ,54874       ; ...then advance IY to next entity
       b    @_54874                    ;                   
!
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  _54874                     ; JR Z,54874        ; ...then advance IY to next entity
       mov  a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128                   ;                   
       jne  _54822                     ; JR NZ,54822       ; ...then skip over depth check to #R54822
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       a    @c,a                       ; ADD A,C           ; ...plus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  _54874                     ; JR NZ,54874       ; ...then advance IY to next entity
_54822:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,6) Flag reset...
       andi a,64*256                   ; AND 64            ; ...
       jne  !                          ; JP Z,54874        ; ...then advance IY to next entity
       b    @_54874                    ;                   
!
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   _54874                     ; JR C,54874        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   _54874                     ; JR C,54874        ; ...then advance IY to next entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   _54874                     ; JR C,54874        ; ...then advance IY to next entity
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   _54874                     ; JR C,54874        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@_34258                 ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       rt                              ; RET               ; Return
* This entry point is used by the routines at #R55196 and #R55525.
_54871:
       li   de,13                      ; LD DE,13          ; Load DE with 13, as entries in complex state data are 13 bytes wide
_54874:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  _54777                     ; JR 54777          ; Loop back to #R54777

* Check Entity at IX for Collision With Another Entity (Only those Defined Before, and in Reverse Order) at Same
* Depth Level Whose Interaction (11,7) Flag is Set
* 
* Used by the routine at #R52315. Input:  IX  Address of complex state data for an entity Output: F  Carry Flag set
* if no entity found, reset otherwise A  Class of entity, if found, otherwise 254 IY  Address of complex state data
* for colliding entity
_54878:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
       .push ix                        ; PUSH IX           ; Load IY with address in IX...
       .pop iy                         ; POP IY            ; ...
       li   de,65523                   ; LD DE,65523       ; Load DE with -13
       b    @_54987                    ; JP 54987          ; Move IY back to previous entity in complex state data and jump into collision check routine

* Check Entity at IX for Collision With Another Entity (in Reverse Order) at Next Depth Level Into Screen Whose
* Interaction (11,7) Flag is Set
* 
* The address stored at #R34246 is the address of complex state data for the entity to start with when doing
* collision checks in reverse order. On levels 2, 3 and 4, the value stored here is the address of the complex state
* data of the last entity, which means that on these levels, all entities are checked. On Level 1, however, the
* value stored is the address of the complex state data of the sixth-last entity. The remaining five entities after
* this address on Level 1 are the three spiders, their webs and their arches. This means that on Level 1, these
* spiders, webs and arches are excluded from certain collision checks. Input:  IX  Address of complex state data for
* an entity C  (Entry at #R54899 only) Depth offset Output: F  Carry Flag set if no entity found, reset otherwise A
* Class of entity, if found, otherwise 254 IY  Address of complex state data for colliding entity
_54890:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level into screen)
       li   de,65523                   ; LD DE,65523       ; Load DE with -13 (as entries in complex state data are 13 bytes wide)
       mov  @_34246,iy                 ; LD IY,(34246)     ; Load IY with current level's start address for reverse-order collision checks
_54899:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  _54987                     ; JR NZ,54987       ; ...then move IY back to previous entity
       mov  @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32                    ;                   
       jeq  !                          ; JP NZ,54987       ; ...then move IY back to previous entity
       b    @_54987                    ;                   
!
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  _54987                     ; JR Z,54987        ; ...then move IY back to previous entity
       mov  a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128                   ;                   
       jne  _54935                     ; JR NZ,54935       ; ...then skip over depth check to #R54935
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       sb   @c,a                       ; SUB C             ; ...minus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  _54987                     ; JR NZ,54987       ; ...then move IY back to previous entity
_54935:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,7) Flag reset...
       andi a,128*256                  ; AND 128           ; ...
       jne  !                          ; JP Z,54987        ; ...then move IY back to previous entity
       b    @_54987                    ;                   
!
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   _54987                     ; JR C,54987        ; ...then move IY back to previous entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   _54987                     ; JR C,54987        ; ...then move IY back to previous entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   _54987                     ; JR C,54987        ; ...then move IY back to previous entity
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   _54987                     ; JR C,54987        ; ...then move IY back to previous entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@_34258                 ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       rt                              ; RET               ; Return
       li   de,65523                   ; LD DE,65523       ; Load DE with -13
* This entry point is used by the routine at #R54878.
_54987:
       movb @-1(iy),a                  ; LD A,(IY-1)       ; If byte before current IY position is 254 (i.e. end marker for simple state data)...
       cb   a,@bytes+254               ; CP 254            ; ...
       jne  !                          ; JP Z,55000        ; ...then skip ahead to #R55000
       b    @_55000                    ;                   
!
       a    de,iy                      ; ADD IY,DE         ; Move IY back 13 bytes (i.e. to start of previous entry)
       b    @_54899                    ; JP 54899          ; Jump to #R54899
_55000:
       ; SCF                           ; SCF               ; Set Carry Flag
       rt                              ; RET               ; Return

* Unused routine
* 
* This routine seems to be involved with the relative positioning of two different entities, assuming that IX
* contains a complex state data address.
       mov  @_34258,iy                 ; LD IY,(34258)     ; Load IY with address of complex state data for entity involved in last collision check
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of this entity, minus one...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; Divide result by two, clearing remainder...
       sb   one,a                      ; DEC A             ; ...and subtract one
       a    @5(iy),a                   ; ADD A,(IY+5)      ; Add x-coordinate of entity's left edge
       cb   a,@5(ix)                   ; CP (IX+5)         ; 
       rt                              ; RET               ; Return

* Cached Control Input
* 
* This value is set by the instruction at #R55066. It holds a value read from control input when handling
* characters' jumps.
_55022:
       byte 0

* Handle Drutt's Jump, and Load E with Jump State Index As Appropriate
* 
* See description of routine at #R55041 for details. Output: E  (via routine at #R55041) Jump state index (see
* #R55041)
_55023:
       mov  @_34242,ix                 ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       mov  @12(ix),tmp0               ; BIT 7,(IX+12)     ; If Drutt's Is Jumping Flag is reset...
       andi tmp0,128                   ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
* Drutt's Is Jumping Flag is set
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jeq  _55065                     ; JR Z,55065        ; ...then handle Drutt's jump, and load E with jump state index as appropriate based upon no
                                                           ; control input
       jmp  _55060                     ; JR 55060          ; Handle Drutt's jump, and load E with jump state index as appropriate based upon current
                                                           ; control input

* Handle Berk's Jump, and Load E with Jump State Index As Appropriate
* 
* This routine updates the position, direction and velocity of a jumping character (Berk if entry at #R55041 or
* Drutt if entry via routine at #R55023) based upon various conditions (control input, collisions with obstructions
* and the character's current position, direction and velocity). Register E is loaded (either by this routine, or
* the CALLed routine at #R55196) with a value determined by these conditions. The value in E in turn determines how
* the character's jump will progress. A given numeric value may result from more than one set of conditions.
* Possible output values in E are: Input:  IX  Address of complex state data (current level) for Berk (entry via
* #R55041) or Drutt (entry via #R55060 and #R55065) Output: E  Jump state index (see table above)
_55041:
       bl   @_54283                    ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       mov  @_34240,ix                 ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       mov  @12(ix),tmp0               ; BIT 7,(IX+12)     ; If Berk's Is Jumping Flag is reset...
       andi tmp0,128                   ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
* Berk's Is Jumping Flag is set
       movb @_34208,a                  ; LD A,(34208)      ; If Drutt Mode Flag is set...
       mov  a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1                     ;                   
       jne  _55065                     ; JR NZ,55065       ; ...then skip ahead to #R55065
* From this point onwards, IX points to either Berk's complex state data (entry via #R55041) or Drutt's complex
* state data (entry via #R55060 or #R55065). This entry point is used by the routine at #R55023.
_55060:
       movb @_34219,a                  ; LD A,(34219)      ; Load A with control input
       jmp  _55066                     ; JR 55066          ; Skip ahead to #R55066
* This entry point is used by the routine at #R55023.
_55065:
       sb   a,a                        ; XOR A             ; Load A with zero
_55066:
       mov  a,@_55022                  ; LD (55022),A      ; Store value in A at #R55022
       mov  @11(ix),tmp0               ; BIT 0,(IX+11)     ; If jumper's Walking Right Flag is reset...
       andi tmp0,1                     ;                   
       jeq  _55128                     ; JR Z,55128        ; ...then skip ahead to #R55128
* Walking Right Flag is set
       movb @bytes+2,b                 ; LD B,2            ; Load B with 2 (as Berk and Drutt jump right by two characters)
_55077:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of characters to move)
       bl   @_54569                    ; CALL 54569        ; Check jumper for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       joc  _55108                     ; JR C,55108        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R55108
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class less than 22 (can be picked up)...
       jl   _55108                     ; JR C,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55108                     ; JR Z,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _55108                     ; JR Z,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+159               ; CP 159            ; If collision was not with entity of class 159 (Berk floating)...
       jne  _55124                     ; JR NZ,55124       ; ...then skip ahead to #R55124
* Collision with Berk, floating
       movb @bytes+241,@11(iy)         ; LD (IY+11),241    ; Set Berk's Walking Right, Impassable Leftwards, Impassable Rightwards, Interaction (11,6)
                                                           ; and Interaction (11,7) flags and reset his Walking Left, Unused (11,2) and Unused (11,3)
                                                           ; flags
       bl   @_55187                    ; CALL 55187        ; Set Character Swap Pending Flag
       jmp  _55124                     ; JR 55124          ; Skip ahead to #R55124
* No collision, or collision with entity of class 50, 129 or less than 22
_55108:
       bl   @_54313                    ; CALL 54313        ; Move jumper into room to the right, if appropriate...
       jnc  _55124                     ; JR NC,55124       ; TODO: check code. ...and if jumper can't enter new room then skip ahead to #R55124
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move jumper right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       sb   one,b                      ; DJNZ 55077        ; Decrease remaining number of characters to move, and if not zero, loop back to #R55077
       jne  _55077                     ;                   
       jmp  _55196                     ; JR 55196          ; Handle vertical component of jumper's jump, load E with Jump State Index and return
* Collision with other class of entity
_55124:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       movb @bytes+4,@e                ; LD E,4            ; Load E with 4 (jumper has bounced off an obstruction to the right while jumping right)
       rt                              ; RET               ; Return
* Walking Right Flag is reset
_55128:
       mov  @11(ix),tmp0               ; BIT 1,(IX+11)     ; If jumper's Walking Left Flag is reset...
       andi tmp0,2                     ;                   
       jeq  _55196                     ; JR Z,55196        ; ...then skip ahead to #R55196 (handle vertical component of jumper's jump, load E with Jump
                                                           ; State Index and return)
* Walking Left Flag is set
       movb @bytes+2,b                 ; LD B,2            ; Load B with 2 (as Berk and Drutt jump left by two characters)
_55136:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of characters to move)
       bl   @_54666                    ; CALL 54666        ; Check jumper for collision with another impassable / pushable entity immediately to the
                                                           ; left...
       joc  _55167                     ; JR C,55167        ; TODO: check code. ...and if a collision has not occurred, then skip ahead to #R55167
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class less than 22 (can be picked up)...
       jl   _55167                     ; JR C,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55167                     ; JR Z,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _55167                     ; JR Z,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+159               ; CP 159            ; If collision was not with entity of class 159 (Berk floating)...
       jne  _55183                     ; JR NZ,55183       ; ...then skip ahead to #R55183
* Collision with Berk, floating
       movb @bytes+242,@11(iy)         ; LD (IY+11),242    ; Set Berk's Walking Left, Impassable Leftwards, Impassable Rightwards, Interaction (11,6) and
                                                           ; Interaction (11,7) flags and reset his Walking Right and Unused (11,2) and Unused (11,3)
                                                           ; flags
       bl   @_55187                    ; CALL 55187        ; Set Character Swap Pending Flag
       jmp  _55183                     ; JR 55183          ; Skip ahead to #R55183
* No collision, or collision with entity of class 50, 129 or less than 22
_55167:
       bl   @_54348                    ; CALL 54348        ; Move jumper into room to the left, if appropriate...
       jnc  _55183                     ; JR NC,55183       ; TODO: check code. ...and if jumper can't enter new room then skip ahead to #R55183
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move jumper left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       sb   one,b                      ; DJNZ 55136        ; Decrease remaining number of characters to move, and if not zero, loop back to #R55136
       jne  _55136                     ;                   
       jmp  _55196                     ; JR 55196          ; Handle vertical component of jumper's jump, load E with Jump State Index and return
* Collision with other class of entity
_55183:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       movb @bytes+5,@e                ; LD E,5            ; Load E with 5 (jumper has bounced off an obstruction to the left while jumping left)
       rt                              ; RET               ; Return

* Set Character Swap Pending Flag
* 
* Used by the routine at #R55041.
_55187:
       movb @_34208,a                  ; LD A,(34208)      ; Set Character Swap Pending Flag...
       socb @bits+6,a                  ; SET 6,A           ; ...
       mov  a,@_34208                  ; LD (34208),A      ; ...
       rt                              ; RET               ; Return

* Handle Vertical Component of Character's Jump, and Load E with Jump State Index As Appropriate
* 
* This routine handles the vertical component of Berk's or Drutt's jumping, checking for collisions (e.g. Berk or
* Drutt hitting an obstruction above, or Drutt knocking down an entity such as a key). The routine also checks the
* cached control input value at #R55022 to determine the outcome of the next "bounce" if the jumper is on the floor
* (for example, start a leftward jump if left was pressed). Input:  IX  Address of complex state data (current
* level) for Berk or Drutt Output: E  Jump state index (see table in description of routine at #R55041)
_55196:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load A with current velocity of jumper's jump...
       andi a,15*256                   ; AND 15            ; ...
       mov  @12(ix),tmp0               ; BIT 6,(IX+12)     ; If Downward Jump Phase Flag is set...
       andi tmp0,64                    ;                   
       jne  _55281                     ; JR NZ,55281       ; ...then skip ahead to #R55281
* Downward Jump Phase Flag is reset, i.e. in upward phase of jump
       socb a,a                        ; OR A              ; If current velocity of jumper's jump is at least one...
       jne  _55234                     ; JR NZ,55234       ; ...then skip ahead to #R55234
* Current velocity of jumper's jump is zero
       movb @_55022,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       mov  a,tmp0                     ; BIT 3,A           ; ...and if Back Bit is reset...
       andi tmp0,8                     ;                   
       jeq  _55223                     ; JR Z,55223        ; ...then skip ahead to #R55223
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move jumper up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
_55223:
       socb @bits+6,@12(ix)            ; SET 6,(IX+12)     ; Set Downward Jump Phase Flag
       bl   @_55421                    ; CALL 55421        ; Increase current velocity of jumper's jump if less than 7
       movb one,a                      ; LD A,1            ; Prepare to set velocity of jumper's jump to one, downwards
       jmp  _55284                     ; JR 55284          ; Skip ahead to #R55284 (handle downward phase of jump)
* Current velocity of jumper's jump is at least 1
_55234:
       movb a,b                        ; LD B,A            ; Load B with current velocity of jumper's jump
_55235:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move jumper up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _55258                     ; JR C,55258        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R55258
       cb   a,@bytes+130               ; CP 130            ; If collision was not with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jne  _55258                     ; JR NZ,55258       ; ...then skip ahead to #R55258
* Jumper has banged his head
       movb @bytes+6,a                 ; LD A,6            ; Set pending sound index to 6 (banging head) if it is currently zero, or lower priority...
       bl   @_59613                    ; CALL 59613        ; ...
       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 (jumper has banged his head on something above him)
       rt                              ; RET               ; Return
* No collision, or collision with entity other than that of class 130
_55258:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up, or 255 for no
                                                           ; collision)...
       jhe  _55270                     ; JR NC,55270       ; ...then skip ahead to #R55270
* Drutt has knocked down an entity, e.g. Red Sweet on Level 1
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set initial velocity factor of entity jumper collided with to 2...
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; ...and set its "Can Fall" flag
_55270:
       bl   @_55433                    ; CALL 55433        ; Change jumper's room up one if appropriate
       sb   one,b                      ; DJNZ 55235        ; Decrease B (remaining number of characters to move up) and loop back to #R55235 if not zero
       jne  _55235                     ;                   
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease current velocity of jumper's jump, slowing ascent
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (jumper jumping upwards, no collision)
       rt                              ; RET               ; Return
* Downward Jump Phase Flag is set, i.e. in downward phase of jump
_55281:
       bl   @_55421                    ; CALL 55421        ; Increase current velocity of jumper's jump if less than 7, speeding descent, and load into A
_55284:
       movb a,b                        ; LD B,A            ; Load B with velocity of jumper's jump
_55285:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move jumper down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       bl   @_54768                    ; CALL 54768        ; Check jumper for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
       joc  _55300                     ; JR C,55300        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R55300
       cb   a,@bytes+35                ; CP 35             ; If collision was with an entity of class 35 (platform, Level 1 or Level 3)...
       jeq  _55363                     ; JR Z,55363        ; ...then skip ahead to #R55363
* No collision, or collision with entity other than that of class 35
_55300:
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load A with y-coordinate of jumper's bottom edge...
       a    @1(ix),a                   ; ADD A,(IX+1)      ; ...and add jumper's depth
       cb   a,@bytes+122               ; CP 122            ; If A is 122 (i.e. jumper is at bottom of screen)...
       jeq  _55320                     ; JR Z,55320        ; ...then skip ahead to #R55320
       sb   one,b                      ; DJNZ 55285        ; Decrease B (remaining number of characters to move down) and loop back to #R55285 if not zero
       jne  _55285                     ;                   
       .push hl                        ; PUSH HL           ; Store HL
       bl   @_55616                    ; CALL 55616        ; Change jumper's room down one if appropriate
       .pop hl                         ; POP HL            ; Restore HL
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (jumper jumping downwards, no collision)
       rt                              ; RET               ; Return
* Jumper is at the bottom of the screen
_55320:
       bl   @_54768                    ; CALL 54768        ; Check jumper for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
_55323:
       joc  _55363                     ; JR C,55363        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R55363
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55334                     ; JR Z,55334        ; ...then skip ahead to #R55334
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that jumper did collide with
       bl   @_54871                    ; CALL 54871        ; Resume checking jumper for collision with another entity at same depth whose Interaction
                                                           ; (11,6) Flag is set
       jmp  _55323                     ; JR 55323          ; ...and jump back to #R55323
* Collision with entity of class 129
_55334:
       movb @8(ix),a                   ; LD A,(IX+8)       ; If jumper is not Berk...
       cb   a,@bytes+31                ; CP 31             ; ...(class = 31).....
       jne  _55285                     ; JR NZ,55285       ; ...then jump back to #R55285 (continue moving downwards)
       movb @5(ix),a                   ; LD A,(IX+5)       ; If Berk's left edge...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is at or to the right of the colliding entity's left edge...
       jhe  _55352                     ; JR NC,55352       ; ...then skip ahead to #R55352
* Berk's left edge is to the left of colliding entity's left edge
       movb @bytes+7,@e                ; LD E,7            ; Load E with 7 (jumper is Berk, his left edge is to the left of colliding, class=129, entity's
                                                           ; left edge)
       rt                              ; RET               ; Return
* Berk's left edge is at, or to the right of, colliding entity's left edge
_55352:
       movb @7(iy),a                   ; LD A,(IY+7)       ; If Berk's right edge...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...is at or to the right of the colliding entity's right edge...
       jhe  _55285                     ; JR NC,55285       ; ...then jump back to #R55285 (continue moving downwards)
* Berk's right edge is to the left of colliding entity's right edge
       movb @bytes+8,@e                ; LD E,8            ; Load E with 8 (jumper is Berk, and he is between left and right edges of colliding,
                                                           ; class=129, entity)
       rt                              ; RET               ; Return
* Downward phase, and collision with entity of class 35 (platform, Level 1 or Level 3) or no collision at bottom of
* screen
_55363:
       szcb @bits+6,@12(ix)            ; RES 6,(IX+12)     ; Reset Downward Jump Phase Flag (i.e. prepare to jump up again)
       movb @_55022,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       mov  a,tmp0                     ; BIT 3,A           ; ...and if Back Bit is reset...
       andi tmp0,8                     ;                   
       jeq  _55377                     ; JR Z,55377        ; ...then skip ahead to #R55377
       movb one,@e                     ; LD E,1            ; Load E with 1 (jumper landed on floor / platform and Back Control Input Bit set)
       rt                              ; RET               ; Return
* Back Bit is reset
_55377:
       movb @12(ix),a                  ; LD A,(IX+12)      ; If current velocity of jumper's jump is at least 4...
       andi a,15*256                   ; AND 15            ; ...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jhe  _55393                     ; JR NC,55393       ; ...then skip ahead to #R55393
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; Reset jumper's Is Jumping Flag and set current velocity of jump to zero
       movb @bytes+3,@e                ; LD E,3            ; Load E with 3 (jumper's jump velocity less than 4, and back not pressed, i.e. terminate
                                                           ; jumping)
       rt                              ; RET               ; Return
* Current velocity of jumper's jump is at least 4, and Back Bit is reset
_55393:
       movb @_55022,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       mov  a,tmp0                     ; BIT 1,A           ; ...and if Left Bit is reset...
       andi tmp0,2                     ;                   
       jeq  _55404                     ; JR Z,55404        ; ...then skip ahead to #R55404
* Left Bit is set
       movb @bytes+4,@e                ; LD E,4            ; Load E with 4 (jumper's jump velocity at least 4 and Left Control Input Bit set)
       jmp  _55410                     ; JR 55410          ; Decrease current velocity of jumper's jump by two and return
* Left Bit is reset
_55404:
       mov  a,tmp0                     ; BIT 0,A           ; If Right Bit is reset...
       andi tmp0,1                     ;                   
       jeq  _55417                     ; JR Z,55417        ; ...then skip ahead to #R55417
* Right Bit is set
       movb @bytes+5,@e                ; LD E,5            ; Load E with 5 (jumper's jump velocity at least 4 and Right Control Input Bit set)
_55410:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease current velocity of jumper's jump by two...
       sb   one,@12(ix)                ; DEC (IX+12)       ; ...
       rt                              ; RET               ; Return
* Right Bit (and Left and Back bits) reset
_55417:
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (current velocity of jumper's jump is at least 4 and Back, Left and Right
                                                           ; Control Input bits are reset)
       jmp  _55410                     ; JR 55410          ; Decrease current velocity of jumper's jump by two and return

* Increase Current Velocity of Character's Jump if Less Than 7
* 
* See pokes Input:  IX  Address of complex state data (current level) for Berk or Drutt
_55421:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load A with current velocity of character's jump...
       andi a,15*256                   ; AND 15            ; ...
       cb   a,@bytes+7                 ; CP 7              ; ...and if this is 7 or more...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase velocity of character's jump
       rt                              ; RET               ; Return

* Change Entity's Room Up One if Appropriate
* 
* Used by the routines at #R36542, #R48487 and #R55196. Input:  IX  Address of complex state data for an entity
_55433:
       movb @bytes+99,a                ; LD A,99           ; If y-coordinate of top of entity is larger than 99 (i.e. top of entity is below top of
                                                           ; room)...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jhe  !                          ; RET C             ; ...then return
       rt                              ;                   
!
       .push hl                        ; PUSH HL           ; Store HL
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @_34254,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (lower room index) of first entry
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
_55451:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (lower room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  _55512                     ; JR Z,55512        ; ...then skip ahead to #R55512
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  _55467                     ; JR Z,55467        ; ...then skip ahead to #R55467
       inc  iy                         ; INC IY            ; Advance by two bytes to the next entry...
       inc  iy                         ; INC IY            ; ...
       jmp  _55451                     ; JR 55451          ; Loop back to #R55451
_55467:
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (upper room index) of current entry into B
       movb @_34230+1,a                ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @_54480                    ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @_34230+1,a                ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       a    @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Add 22 to y-coordinate of top of entity...
       a    @bytes+22,a                ; ADD A,22          ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Add 22 to y-coordinate of bottom of entity...
       a    @bytes+22,a                ; ADD A,22          ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @_54456                    ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
_55512:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .pop hl                         ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Set Can Fall Flag and Set Initial Velocity Factor of 2 for Entity Defined at Address in IX
* 
* Used by the routines at #R36638, #R39760, #R48417, #R51779, #R52098, #R52193 and #R52243. Input:  IX  Address of
* complex state data for an entity
_55516:
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set entity's "Can Fall" flag
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set entity's initial velocity factor to 2
       rt                              ; RET               ; Return

* Move All Falling Entities Down by Distances Appropriate to their Current Velocity Factors
* 
* If an entity's "velocity factor" is equal to its height in characters plus 3 (a proxy for its mass), then it has
* reached its terminal velocity.
_55525:
       mov  @_34238,ix                 ; LD IX,(34238)     ; Load IX with start address of current level's complex state data
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
_55532:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of entry is 255 (i.e. End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       mov  @10(ix),tmp0               ; BIT 6,(IX+10)     ; If current entity's "Can Fall" flag is reset...
       andi tmp0,64                    ;                   
       jeq  _55592                     ; JR Z,55592        ; ...then skip ahead to #R55592 (advance to next entity)
* Current entity's "Can Fall" Flag is set
       .push de                        ; PUSH DE           ; Store DE
       bl   @_53848                    ; CALL 53848        ; Store room size data for current entity's current room
       .pop de                         ; POP DE            ; Restore DE
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height (of entity defined by entry) + 3...
       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
       a    @bytes+4,a                 ; ADD A,4           ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load B with velocity factor...
       movb a,b                        ; LD B,A            ; ...
       cb   a,@c                       ; CP C              ; If C is less than or equal to this (i.e. "terminal velocity" reached)...
       jhe  _55569                     ; JR NC,55569       ; ...then skip ahead to #R55569
       ab   one,a                      ; INC A             ; Increase velocity factor by one and store for next pass (i.e. acceleration)...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...
_55569:
       srl  b,1                        ; SRL B             ; Divide current (i.e. not increased) velocity factor by 2
_55571:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If sum of y-coordinate of entity's bottom and entity's depth is 122...
       a    @1(ix),a                   ; ADD A,(IX+1)      ; ...(i.e. entity is at ground-level)...
       cb   a,@bytes+122               ; CP 122            ; ...
       jeq  _55596                     ; JR Z,55596        ; ...then skip ahead to #R55596
_55581:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       bl   @_55616                    ; CALL 55616        ; Change entity's room down one if appropriate
       sb   one,b                      ; DJNZ 55571        ; Decrease B (current velocity factor, i.e. remaining number of characters to drop entity) and
       jne  _55571                     ;                   
                                                           ; if non-zero, loop back to #R55571
_55592:
       a    de,ix                      ; ADD IX,DE         ; Advance IX by 13 bytes to next entry
       jmp  _55532                     ; JR 55532          ; Loop back to #R55532
* Entity's position is such that sum of y-coordinate of bottom + depth = 122 (i.e. at ground-level)
_55596:
       bl   @_54768                    ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
_55599:
       joc  _55610                     ; JR C,55610        ; TODO: check code. ...and if no collision occurred, then skip ahead to #R55610
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55581                     ; JR Z,55581        ; ...then jump to #R55581 (entity may fall down into next room)
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that character did collide with
       bl   @_54871                    ; CALL 54871        ; Resume checking entity for collision with another entity at same depth whose Interaction
                                                           ; (11,6) Flag is set...
       jmp  _55599                     ; JR 55599          ; ...
* Entity has landed (i.e. is at ground-level and has not collided with a marker of class 129)
_55610:
       szcb @bits+6,@10(ix)            ; RES 6,(IX+10)     ; Reset entity's "Can Fall" flag as entity has landed
       jmp  _55592                     ; JR 55592          ; Loop back for next entity

* Change Entity's Room Down One if Appropriate
* 
* Used by the routines at #R55196 and #R55525. Input:  IX  Address of complex state data for an entity
_55616:
       movb @bytes+122,a               ; LD A,122          ; If y-coordinate of bottom of entity is smaller than 122 (i.e. bottom of entity is above
                                                           ; bottom of room)...
       cb   a,@6(ix)                   ; CP (IX+6)         ; ...
       jl   !                          ; RET NC            ; ...then return
       rt                              ;                   
!
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @_34254,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
_55631:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (upper room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  _55695                     ; JR Z,55695        ; ...then skip ahead to #R55695
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  _55647                     ; JR Z,55647        ; ...then skip ahead to #R55647
       inc  iy                         ; INC IY            ; Advance by two bytes to the next entry...
       inc  iy                         ; INC IY            ; ...
       jmp  _55631                     ; JR 55631          ; Loop back to #R55631
_55647:
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (lower room index) of current entry into B
       movb @_34230+1,a                ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @_54480                    ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @_34230+1,a                ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       a    @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Subtract 20 from y-coordinate of top of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Subtract 20 from y-coordinate of bottom of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @_54456                    ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       rt                              ; RET               ; Return
_55695:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       rt                              ; RET               ; Return

* Graphic Layout Data Berk Stepping right, right foot out and forward, arm and eye animated
_55698:
       byte 251,_55784%256,_55784/256                                ; Process graphic layout data at #R55784 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_55765%256,_55765/256                                ; Process graphic layout data at #R55765 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 248,_55930%256,_55930/256                                ; Jump to #R55930 (Berk's feet, right foot raised and forward, facing right)
* Stepping right, right foot out, arm and eye animated
_55710:
       byte 251,_55784%256,_55784/256                                ; Process graphic layout data at #R55784 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_55765%256,_55765/256                                ; Process graphic layout data at #R55765 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 248,_55896%256,_55896/256                                ; Jump to #R55896 (Berk's feet, right foot raised and to the side, facing right)
* Facing right, arm and eye animated
_55722:
       byte 251,_55784%256,_55784/256                                ; Process graphic layout data at #R55784 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 251,_56053%256,_56053/256                                ; Process graphic layout data at #R56053 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_55765%256,_55765/256                                ; Jump to #R55765 (Berk's hand, animated, right-facing)
* Walking right, animated
_55734:
       byte 251,_55784%256,_55784/256                                ; Process graphic layout data at #R55784 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_55743%256,_55743/256                                ; Process graphic layout data at #R55743 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_55765%256,_55765/256                                ; Jump to #R55765 (Berk's hand, animated, right-facing)
* Lower half of body, walking right, animated
_55743:
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 243,0,7                                                  ; Increase current state value n (initially 0), up to maximum of 7, resetting to zero
                                                                     ; if maximum reached and jump to n-th address in following list (see trivia):
       byte _55896%256,_55896/256                                    ; #R55896 (Berk's feet, right foot raised and to the side, facing right)
       byte _55930%256,_55930/256                                    ; #R55930 (Berk's feet, right foot raised and forward, facing right)
       byte _55967%256,_55967/256                                    ; #R55967 (lower half of body and feet, facing right, right foot forward)
       byte _56007%256,_56007/256                                    ; #R56007 (lower half of body and feet, facing right, left foot behind)
       byte _56053%256,_56053/256                                    ; #R56053 (lower half of body and feet, facing right, standing)
       byte _56090%256,_56090/256                                    ; #R56090 (lower half of body and feet, facing right, left foot forward)
       byte _56130%256,_56130/256                                    ; #R56130 (lower half of body and feet, facing right, left foot forward, right foot
                                                                     ; behind)
       byte _56167%256,_56167/256                                    ; #R56167 (lower half of body and feet, facing right, left foot forward, right foot
                                                                     ; out and behind)
* Arm, facing right, animated
_55765:
       byte 243,0,7                                                  ; Increase current state value n (initially 0), up to maximum of 7, resetting to zero
                                                                     ; if maximum reached and jump to n-th address in following list (see trivia):
       byte _55825%256,_55825/256                                    ; #R55825 (arm, facing right, up)
       byte _55825%256,_55825/256                                    ; #R55825 (arm, facing right, up)
       byte _55825%256,_55825/256                                    ; #R55825 (arm, facing right, up)
       byte _55825%256,_55825/256                                    ; #R55825 (arm, facing right, up)
       byte _55859%256,_55859/256                                    ; #R55859 (arm, facing right, down)
       byte _55859%256,_55859/256                                    ; #R55859 (arm, facing right, down)
       byte _55859%256,_55859/256                                    ; #R55859 (arm, facing right, down)
       byte _55859%256,_55859/256                                    ; #R55859 (arm, facing right, down)
* Upper body without arm, facing right, eye animated
_55784:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and store
                                                                     ; as new base coordinates
       byte 236,6,1,1,1,1,2,3                                        ; Modify following instruction to display graphic of random index, chosen from 1, 1,
                                                                     ; 1, 1, 2 and 3
       byte 1,7,159,5,65,33
       byte 0,9,30,6,65,33
       byte 0,9,31,7,65,33
       byte 0,9,33,0,9,33
       byte 0,9,33
       byte 255                                                      ; End Marker
* Arm, facing right, up
_55825:
       byte 250,1,1                                                  ; Change cursor's x- and y-coordinates by +1 and +1 characters respectively
       byte 8,65,33,9,65,33
       byte 10,1,29,11,65,161
       byte 12,65,161,13,65,33
       byte 14,1,30,15,65,161
       byte 16,1,33,17,1,32
       byte 255                                                      ; End Marker
* Arm, facing right, down
_55859:
       byte 250,1,1                                                  ; Change cursor's x- and y-coordinates by +1 and +1 characters respectively
       byte 6,129,31,18,65,161
       byte 19,65,33,20,65,33
       byte 21,1,29,89,65,161
       byte 22,65,161,23,65,33
       byte 24,1,30,25,65,161
       byte 26,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, right foot out
_55896:
       byte 27,65,33,28,33,33
       byte 29,33,33,30,65,29
       byte 31,65,33,32,33,33
       byte 33,33,33,34,65,30
       byte 35,1,33,36,1,33
       byte 37,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, right foot out and forward
_55930:
       byte 27,65,33,0,9,33
       byte 38,33,33,39,33,33
       byte 40,4,28,41,65,33
       byte 0,9,33,42,33,33
       byte 43,68,29,53,1,33
       byte 36,1,33,44,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, right foot forward
_55967:
       byte 27,65,33,0,9,33
       byte 45,65,33,46,65,33
       byte 47,1,28,48,65,33
       byte 49,65,33,50,65,33
       byte 51,65,33,52,1,27
       byte 53,1,33,54,1,33
       byte 55,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, left foot behind
_56007:
       byte 27,65,33,0,9,33
       byte 0,9,33,0,9,28
       byte 56,1,33,57,65,33
       byte 0,9,33,45,65,33
       byte 58,65,33,59,65,28
       byte 60,1,33,61,1,33
       byte 62,1,33,54,1,33
       byte 63,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, standing
_56053:
       byte 27,65,33,0,9,33
       byte 0,9,33,0,9,29
       byte 64,65,33,45,65,161
       byte 58,65,161,59,65,29
       byte 65,1,33,62,1,33
       byte 54,1,33,63,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, left foot forward
_56090:
       byte 27,65,33,0,9,33
       byte 0,9,33,0,9,29
       byte 64,65,33,66,65,161
       byte 67,65,161,68,65,33
       byte 69,1,28,65,1,33
       byte 70,1,33,71,1,33
       byte 72,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, left foot forward, right foot behind
_56130:
       byte 27,65,33,0,9,33
       byte 0,9,33,0,9,29
       byte 73,65,33,74,65,161
       byte 0,9,33,75,65,33
       byte 76,1,28,77,1,33
       byte 78,1,33,79,1,32
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing right, left foot forward, right foot out and behind
_56167:
       byte 80,33,33,81,33,33
       byte 0,9,33,30,65,29
       byte 82,68,33,83,33,33
       byte 84,65,33,85,65,33
       byte 59,65,28,86,4,33
       byte 87,4,33,88,1,33
       byte 54,1,33,63,1,32
       byte 255                                                      ; End Marker

* Graphic Layout Data Berk Walking Left Upper body without arm, facing left, eye animated
_56210:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 236,6,1,1,1,1,2,3                                        ; Modify following instruction to display graphic of random index, chosen from 1,
                                                                     ; 1, 1, 1, 2 and 3
       byte 1,135,160,0,9,33
       byte 5,129,32,0,9,33
       byte 6,129,30,0,9,33
       byte 0,9,33,7,193,32
       byte 255                                                      ; End Marker
* Stepping left, left foot out, arm and eye animated
_56248:
       byte 251,_56210%256,_56210/256                                ; Process graphic layout data at #R56210 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56303%256,_56303/256                                ; Process graphic layout data at #R56303 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56393%256,_56393/256                                ; Jump to #R56393 (lower half of body and feet, facing left, left foot out)
* Stepping left, left foot out and forward, arm and eye animated
_56257:
       byte 251,_56210%256,_56210/256                                ; Process graphic layout data at #R56210 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56303%256,_56303/256                                ; Process graphic layout data at #R56303 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56430%256,_56430/256                                ; Jump to #R56430 (lower half of body and feet, facing left, left foot out and
                                                                     ; forward)
* Facing left, arm and eye animated
_56266:
       byte 251,_56210%256,_56210/256                                ; Process graphic layout data at #R56210 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56562%256,_56562/256                                ; Process graphic layout data at #R56562 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56303%256,_56303/256                                ; Jump to #R56303 (Arm, facing left, animated)
* Walking left, animated
_56275:
       byte 251,_56210%256,_56210/256                                ; Process graphic layout data at #R56210 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56284%256,_56284/256                                ; Process graphic layout data at #R56284 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56303%256,_56303/256                                ; Jump to #R56303 (Arm, facing left, animated)
* Lower half of body, walking left, animated
_56284:
       byte 243,0,7                                                  ; Increase current state value n (initially 0), up to maximum of 7, resetting to
                                                                     ; zero if maximum reached and jump to n-th address in following list (see trivia):
       byte _56393%256,_56393/256                                    ; #R56393 (lower half of body and feet, facing left, left foot out)
       byte _56430%256,_56430/256                                    ; #R56430 (lower half of body and feet, facing left, left foot out and forward)
       byte _56470%256,_56470/256                                    ; #R56470 (lower half of body and feet, facing left, left foot forward)
       byte _56513%256,_56513/256                                    ; #R56513 (lower half of body and feet, facing left, right foot behind)
       byte _56562%256,_56562/256                                    ; #R56562 (lower half of body and feet, facing left, standing)
       byte _56602%256,_56602/256                                    ; #R56602 (lower half of body and feet, facing left, right foot forward)
       byte _56645%256,_56645/256                                    ; #R56645 (lower half of body and feet, facing left, right foot forward, left foot
                                                                     ; behind)
       byte _56685%256,_56685/256                                    ; #R56685 (lower half of body and feet, facing left, right foot forward, left foot
                                                                     ; out and behind)
* Arm, facing left, animated
_56303:
       byte 243,0,7                                                  ; Increase current state value n (initially 0), up to maximum of 7, resetting to
                                                                     ; zero if maximum reached and jump to n-th address in following list (see trivia):
       byte _56322%256,_56322/256                                    ; #R56322 (arm, facing left, up)
       byte _56322%256,_56322/256                                    ; #R56322 (arm, facing left, up)
       byte _56322%256,_56322/256                                    ; #R56322 (arm, facing left, up)
       byte _56322%256,_56322/256                                    ; #R56322 (arm, facing left, up)
       byte _56356%256,_56356/256                                    ; #R56356 (arm, facing left, down)
       byte _56356%256,_56356/256                                    ; #R56356 (arm, facing left, down)
       byte _56356%256,_56356/256                                    ; #R56356 (arm, facing left, down)
       byte _56356%256,_56356/256                                    ; #R56356 (arm, facing left, down)
* Arm, facing left, up
_56322:
       byte 250,1,253                                                ; Change cursor's x- and y-coordinates by -3 and +1 characters respectively
       byte 10,129,33,9,129,33
       byte 8,193,30,14,193,33
       byte 13,193,33,12,193,161
       byte 11,193,157,17,129,33
       byte 16,193,33,15,193,161
       byte 255                                                      ; End Marker
* Arm, facing left, down
_56356:
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 6,1,30,21,129,33
       byte 20,193,33,19,193,33
       byte 18,193,157,24,129,33
       byte 23,193,33,22,193,161
       byte 89,193,158,26,129,33
       byte 25,193,161
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, left foot out
_56393:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,29,225,33
       byte 28,225,33,27,193,29
       byte 34,129,33,33,225,33
       byte 32,161,33,31,129,29
       byte 37,129,33,36,1,33
       byte 35,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, left foot out and forward
_56430:
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 40,132,33,39,161,33
       byte 38,225,33,0,9,33
       byte 0,9,29,43,132,33
       byte 42,225,33,0,9,33
       byte 41,193,30,44,129,33
       byte 36,1,33,53,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, left foot forward
_56470:
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 47,129,33,46,193,161
       byte 45,193,161,0,9,33
       byte 27,193,28,52,129,33
       byte 51,193,33,50,193,161
       byte 49,193,161,48,193,159
       byte 55,129,33,54,1,33
       byte 53,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, right foot behind
_56513:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,0,9,33
       byte 0,9,33,27,193,28
       byte 59,193,33,58,193,161
       byte 45,193,161,0,9,33
       byte 57,193,161,56,129,27
       byte 63,129,33,54,1,33
       byte 62,129,33,61,129,33
       byte 60,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, standing
_56562:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,0,9,33
       byte 0,9,33,27,193,29
       byte 59,193,33,58,193,161
       byte 45,193,161,64,193,29
       byte 63,129,33,54,1,33
       byte 62,129,33,65,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, right foot forward
_56602:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,0,9,33
       byte 0,9,33,27,193,28
       byte 69,129,33,68,193,161
       byte 67,193,161,66,193,161
       byte 64,193,29,72,129,33
       byte 71,129,33,70,129,33
       byte 65,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, right foot forward, left foot behind
_56645:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,0,9,33
       byte 0,9,33,27,193,28
       byte 76,129,33,75,193,161
       byte 0,9,33,74,193,161
       byte 73,193,158,79,129,33
       byte 78,129,33,77,129,33
       byte 255                                                      ; End Marker
* Lower half of body and feet, facing left, right foot forward, left foot out and behind
_56685:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 30,193,33,0,9,33
       byte 81,225,33,80,225,28
       byte 59,193,33,85,193,161
       byte 84,193,161,83,225,33
       byte 82,196,28,63,129,33
       byte 54,1,33,88,129,33
       byte 87,132,33,86,132,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Berk Facing Out of Screen Arms outstretched, animated
_56731:
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57607%256,_57607/256                                ; Process graphic layout data at #R57607 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56813%256,_56813/256                                ; Jump to #R56813
* Arms raised, eating, animated
_56743:
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56813%256,_56813/256                                ; Process graphic layout data at #R56813 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,0,254                                                ; Change cursor's x- and y-coordinates by -2 and 0 characters respectively
       byte 172,1,33,217,1,35
       byte 217,129,33,172,129,27
       byte 137,65,33,138,65,163
       byte 138,193,161,137,193,27
       byte 139,1,33,140,65,163
       byte 140,193,161,139,129,28
       byte 147,65,35,147,193,29
       byte 64,65,35,64,193,33
       byte 255                                                      ; End Marker
* With wings, animated
_56801:
       byte 251,_58410%256,_58410/256                                ; Process graphic layout data at #R58410 and upon returning, move cursor to base
                                                                     ; coordinates
_56804:
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57576%256,_57576/256                                ; Process graphic layout data at #R57576 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57545%256,_57545/256                                ; Process graphic layout data at #R57545 and upon returning, move cursor to base
                                                                     ; coordinates
_56813:
       byte 251,_56838%256,_56838/256                                ; Process graphic layout data at #R56838 and upon returning, move cursor to base
                                                                     ; coordinates
_56816:
       byte 250,5,254                                                ; Change cursor's x- and y-coordinates by -2 and +5 characters respectively
_56819:
       byte 59,193,33,58,193,161
       byte 45,193,158,63,129,33
       byte 54,1,33,62,129,33
       byte 255                                                      ; End Marker
* Left foot
_56838:
       byte 250,5,1                                                  ; Change cursor's x- and y-coordinates by +1 and +5 characters respectively
_56841:
       byte 45,65,161,58,65,161
       byte 59,65,30,62,1,33
       byte 54,1,33,63,1,33
       byte 255                                                      ; End Marker
* Middle of body, facing into screen
_56860:
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 244,2                                                    ; Set current graphic set to 2
       byte 93,65,33,93,65,31
       byte 0,9,33,0,9,31
       byte 248,_56976%256,_56976/256                                ; Jump to #R56976
* Middle of body, facing out of screen, eyes and mouth animated
_56880:
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 244,2                                                    ; Set current graphic set to 2
       byte 249,4,1                                                  ; If state n (initially 1) has remaining time of zero then reset its time to
                                                                     ; maximum and randomly select a new state, n, from the 4 in the following list.
                                                                     ; Jump to the address specified in the current state and decrease its remaining
                                                                     ; time:
       byte 10,10,_56931%256,_56931/256                              ; #R56931 (for 10 ticks)
       byte 5,5,_56904%256,_56904/256                                ; #R56904 (for 5 ticks)
       byte 5,5,_56913%256,_56913/256                                ; #R56913 (for 5 ticks)
       byte 3,3,_56922%256,_56922/256                                ; #R56922 (for 3 ticks)
* Middle of body, facing out of screen, mouth animated, eyes looking to left
_56904:
       byte 91,7,161,91,7,159
       byte 248,_56937%256,_56937/256                                ; Jump to #R56937
* Middle of body, facing out of screen, mouth animated, eyes looking to right
_56913:
       byte 92,7,161,92,7,159
       byte 248,_56937%256,_56937/256                                ; Jump to #R56937
* Middle of body, facing out of screen, mouth animated, eyes closed
_56922:
       byte 93,1,33,93,1,31
       byte 248,_56937%256,_56937/256                                ; Jump to #R56937
* Middle of body, facing out of screen, mouth animated, eyes looking ahead
_56931:
       byte 90,7,161,90,7,159
_56937:
       byte 249,3,1                                                  ; If state n (initially 1) has remaining time of zero then reset its time to
                                                                     ; maximum and randomly select a new state, n, from the 3 in the following list.
                                                                     ; Jump to the address specified in the current state and decrease its remaining
                                                                     ; time:
       byte 6,6,_56952%256,_56952/256                                ; #R56952 (for 6 ticks)
       byte 6,6,_56970%256,_56970/256                                ; #R56970 (for 6 ticks)
       byte 2,2,_56961%256,_56961/256                                ; #R56961 (for 2 ticks)
* Middle of body, facing out of screen, mouth 1, no eyes
_56952:
       byte 94,65,161,95,65,159
       byte 248,_56976%256,_56976/256                                ; Jump to #R56976
* Middle of body, facing out of screen, mouth 2, no eyes
_56961:
       byte 98,65,161,99,65,159
       byte 248,_56976%256,_56976/256                                ; Jump to #R56976
* Middle of body, facing out of screen, mouth 3, no eyes
_56970:
       byte 96,65,161,97,65,159
_56976:
       byte 0,9,33,0,9,31
       byte 0,9,33,0,9,31
       byte 0,9,33,0,9,33
       byte 255                                                      ; End Marker
* Stepping forward, frame 1, animated
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57607%256,_57607/256                                ; Process graphic layout data at #R57607 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57576%256,_57576/256                                ; Process graphic layout data at #R57576 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57817%256,_57817/256                                ; Process graphic layout data at #R57817 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56838%256,_56838/256                                ; Jump to #R56838 (left foot)
* Stepping forward, frame 2, animated
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57607%256,_57607/256                                ; Process graphic layout data at #R57607 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57703%256,_57703/256                                ; Process graphic layout data at #R57703 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57740%256,_57740/256                                ; Process graphic layout data at #R57740 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57770%256,_57770/256                                ; Jump to #R57770
* Stepping forward, frame 3, animated
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57545%256,_57545/256                                ; Process graphic layout data at #R57545 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56816%256,_56816/256                                ; Process graphic layout data at #R56816 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57839%256,_57839/256                                ; Jump to #R57839 (left foot raised and part of lower body, facing towards
                                                                     ; screen)
* Stepping forward, frame 4, animated
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57669%256,_57669/256                                ; Process graphic layout data at #R57669 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57795%256,_57795/256                                ; Process graphic layout data at #R57795 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57755%256,_57755/256                                ; Jump to #R57755
* With wings and holding something, animated
_57055:
       byte 251,_58410%256,_58410/256                                ; Process graphic layout data at #R58410 and upon returning, move cursor to base
                                                                     ; coordinates
_57058:
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57118%256,_57118/256                                ; Process graphic layout data at #R57118 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56816%256,_56816/256                                ; Process graphic layout data at #R56816 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56838%256,_56838/256                                ; Jump to #R56838 (left foot)
* Holding something while stepping forward, frame 1
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57118%256,_57118/256                                ; Process graphic layout data at #R57118 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57817%256,_57817/256                                ; Process graphic layout data at #R57817 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_56838%256,_56838/256                                ; Jump to #R56838 (left foot)
* Holding something while stepping forward, frame 2
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57118%256,_57118/256                                ; Process graphic layout data at #R57118 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57740%256,_57740/256                                ; Process graphic layout data at #R57740 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57770%256,_57770/256                                ; Jump to #R57770
* Holding something while stepping forward, frame 3
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57118%256,_57118/256                                ; Process graphic layout data at #R57118 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_56816%256,_56816/256                                ; Process graphic layout data at #R56816 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57839%256,_57839/256                                ; Jump to #R57839 (left foot raised and part of lower body, facing towards
                                                                     ; screen)
* Holding something while stepping forward, frame 4
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57118%256,_57118/256                                ; Process graphic layout data at #R57118 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57795%256,_57795/256                                ; Process graphic layout data at #R57795 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57755%256,_57755/256                                ; Jump to #R57755
* Arms holding something, variable width
_57118:
       byte 253                                                      ; Jump to n-th address in following list where n is the width of the entity
                                                                     ; currently held by Berk:
       byte _57127%256,_57127/256                                    ; #R57127 (arms holding something, width 1)
       byte _57173%256,_57173/256                                    ; #R57173 (arms holding something, width 2)
       byte _57219%256,_57219/256                                    ; #R57219 (arms holding something, width 3)
       byte _57274%256,_57274/256                                    ; #R57274 (arms holding something, width 4)
* Arms holding something, width 1
_57127:
       byte 250,1,254                                                ; Change cursor's x- and y-coordinates by -2 and +1 characters respectively
       byte 101,1,33,135,65,34
       byte 135,193,33,101,129,28
       byte 137,65,33,138,65,162
       byte 138,193,161,137,193,28
       byte 139,1,33,140,65,162
       byte 140,193,161,142,65,29
       byte 141,65,163,0,9,33
       byte 255                                                      ; End Marker
* Arms holding something, width 2
_57173:
       byte 250,1,254                                                ; Change cursor's x- and y-coordinates by -2 and +1 characters respectively
       byte 101,1,33,135,65,35
       byte 135,193,33,101,129,27
       byte 137,65,33,138,65,163
       byte 138,193,161,137,193,27
       byte 139,1,33,140,65,163
       byte 140,193,161,139,129,28
       byte 141,65,163,141,193,163
       byte 255                                                      ; End Marker
* Arms holding something, width 3
_57219:
       byte 250,1,253                                                ; Change cursor's x- and y-coordinates by -3 and +1 characters respectively
       byte 101,1,33,143,65,33
       byte 144,65,35,135,193,33
       byte 101,129,26,137,65,33
       byte 138,65,161,0,9,35
       byte 138,193,161,137,193,26
       byte 139,1,33,140,65,161
       byte 0,9,35,140,193,161
       byte 139,129,28,0,9,35
       byte 141,193,33
       byte 255                                                      ; End Marker
* Arms holding something, width 4
_57274:
       byte 250,1,253                                                ; Change cursor's x- and y-coordinates by -3 and +1 characters respectively
       byte 101,1,33,143,65,33
       byte 144,65,35,144,193,33
       byte 143,193,33,101,129,25
       byte 137,65,33,138,65,161
       byte 0,9,35,0,9,33
       byte 138,193,161,137,193,25
       byte 139,1,33,140,65,161
       byte 0,9,35,0,9,33
       byte 140,193,161,139,129,27
       byte 0,9,35,0,9,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Berk Facing Into Screen Arms out to the sides
_57338:
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57607%256,_57607/256                                ; Process graphic layout data at #R57607 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Arms down
_57353:
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57905%256,_57905/256                                ; Process graphic layout data at #R57905 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57936%256,_57936/256                                ; Process graphic layout data at #R57936 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Stepping into screen, frame 1
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57669%256,_57669/256                                ; Process graphic layout data at #R57669 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57936%256,_57936/256                                ; Process graphic layout data at #R57936 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57861%256,_57861/256                                ; Process graphic layout data at #R57861 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Stepping into screen, frame 2
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57607%256,_57607/256                                ; Process graphic layout data at #R57607 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57967%256,_57967/256                                ; Process graphic layout data at #R57967 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57752%256,_57752/256                                ; Jump to #R57752 (left foot and part of lower body, facing towards screen)
* Stepping into screen, frame 3
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57905%256,_57905/256                                ; Process graphic layout data at #R57905 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57883%256,_57883/256                                ; Jump to #R57883 (right foot raised and part of lower body, facing into screen)
* Stepping into screen, frame 4
       byte 251,_56860%256,_56860/256                                ; Process graphic layout data at #R56860 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_58001%256,_58001/256                                ; Process graphic layout data at #R58001 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57638%256,_57638/256                                ; Process graphic layout data at #R57638 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57737%256,_57737/256                                ; Process graphic layout data at #R57737 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Holding something
_57428:
       byte 251,_57473%256,_57473/256                                ; Process graphic layout data at #R57473 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Holding something while stepping into screen, frame 1
       byte 251,_57473%256,_57473/256                                ; Process graphic layout data at #R57473 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57861%256,_57861/256                                ; Process graphic layout data at #R57861 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Holding something while stepping into screen, frame 2
       byte 251,_57473%256,_57473/256                                ; Process graphic layout data at #R57473 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57752%256,_57752/256                                ; Jump to #R57752 (left foot and part of lower body, facing towards screen)
* Holding something while stepping into screen, frame 3
       byte 251,_57473%256,_57473/256                                ; Process graphic layout data at #R57473 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57883%256,_57883/256                                ; Jump to #R57883 (right foot raised and part of lower body, facing into screen)
* Holding something while stepping into screen, frame 4
       byte 251,_57473%256,_57473/256                                ; Process graphic layout data at #R57473 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57737%256,_57737/256                                ; Process graphic layout data at #R57737 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 248,_57767%256,_57767/256                                ; Jump to #R57767 (right foot and part of lower body, facing into screen)
* Upper body, holding something
_57473:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 93,65,33,93,65,30
       byte 155,65,33,0,9,33
       byte 0,9,33,155,193,28
       byte 158,65,33,167,65,161
       byte 0,9,33,0,9,33
       byte 167,193,161,158,193,27
       byte 168,65,33,169,65,161
       byte 0,9,33,0,9,33
       byte 169,193,161,168,193,28
       byte 0,9,33,0,9,33
       byte 0,9,33,0,9,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Berk Body Parts Right arm
_57545:
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 100,1,30,101,1,33
       byte 102,65,33,103,65,158
       byte 104,1,33,0,9,33
       byte 106,65,159,107,1,33
       byte 108,65,161
       byte 255                                                      ; End Marker
* Left arm
_57576:
       byte 250,1,2                                                  ; Change cursor's x- and y-coordinates by +2 and +1 characters respectively
       byte 100,129,32,103,193,161
       byte 102,193,33,101,129,30
       byte 106,193,161,0,9,33
       byte 104,129,30,108,193,161
       byte 107,129,33
       byte 255                                                      ; End Marker
* Right arm raised
_57607:
       byte 250,0,254                                                ; Change cursor's x- and y-coordinates by -2 and 0 characters respectively
_57610:
       byte 109,1,31,110,65,33
       byte 111,65,33,112,65,30
       byte 113,65,33,114,65,33
       byte 115,65,32,7,65,32
       byte 0,9,33
       byte 255                                                      ; End Marker
* Left arm raised
_57638:
       byte 250,0,3                                                  ; Change cursor's x- and y-coordinates by +3 and 0 characters respectively
_57641:
       byte 109,129,31,112,193,33
       byte 111,193,33,110,193,30
       byte 115,193,33,114,193,33
       byte 113,193,30,7,193,32
       byte 27,193,33
       byte 255                                                      ; End Marker
* Right arm, walking into or out of screen
_57669:
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 100,65,29,116,1,33
       byte 117,1,33,118,65,33
       byte 119,65,157,120,1,33
       byte 121,65,33,122,65,33
       byte 123,65,160,27,65,33
       byte 255                                                      ; End Marker
* Left arm, walking into or out of screen
_57703:
       byte 250,1,2                                                  ; Change cursor's x- and y-coordinates by +2 and +1 characters respectively
       byte 100,193,32,119,193,161
       byte 118,193,33,117,129,33
       byte 116,129,29,123,193,161
       byte 122,193,33,121,193,33
       byte 120,129,29,27,193,33
       byte 255                                                      ; End Marker
* Right foot and part of lower body, facing towards screen
_57737:
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
_57740:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 27,65,33,0,9,30
       byte 248,_56819%256,_56819/256                                ; Jump to #R56819
* Left foot and part of lower body, facing towards screen
_57752:
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
_57755:
       byte 250,4,1                                                  ; Change cursor's x- and y-coordinates by +1 and +4 characters respectively
       byte 0,9,33,27,193,31
       byte 248,_56841%256,_56841/256                                ; Jump to #R56841
* Right foot and part of lower body, facing into screen
_57767:
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
_57770:
       byte 250,4,1                                                  ; Change cursor's x- and y-coordinates by +1 and +4 characters respectively
       byte 0,9,33,124,65,161
       byte 59,1,30,125,65,33
       byte 126,65,33,63,1,33
       byte 255                                                      ; End Marker
* Left foot and part of lower body, facing into screen
_57792:
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
_57795:
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 59,129,33,124,193,161
       byte 0,9,30,63,129,33
       byte 126,193,33,125,193,33
       byte 255                                                      ; End Marker
* Right foot raised and part of lower body, facing towards screen
_57817:
       byte 250,4,255                                                ; Change cursor's x- and y-coordinates by -1 and +4 characters respectively
       byte 80,97,33,81,97,31
       byte 82,68,33,83,97,31
       byte 86,4,33,87,4,33
       byte 255                                                      ; End Marker
* Left foot raised and part of lower body, facing towards screen
_57839:
       byte 250,4,1                                                  ; Change cursor's x- and y-coordinates by +1 and +4 characters respectively
       byte 81,225,33,80,225,31
       byte 83,225,33,82,196,31
       byte 87,132,33,86,132,33
       byte 255                                                      ; End Marker
* Left foot raised and part of lower body, facing into screen
_57861:
       byte 250,4,254                                                ; Change cursor's x- and y-coordinates by -2 and +4 characters respectively
       byte 130,65,32,131,65,33
       byte 132,65,161,0,9,31
       byte 133,1,33,125,193,33
       byte 255                                                      ; End Marker
* Right foot raised and part of lower body, facing into screen
_57883:
       byte 250,4,3                                                  ; Change cursor's x- and y-coordinates by +3 and +4 characters respectively
       byte 130,193,30,0,9,33
       byte 132,193,161,131,193,30
       byte 125,65,33,133,129,33
       byte 255                                                      ; End Marker
* Left arm down, facing into screen
_57905:
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 100,65,30,101,1,33
       byte 102,65,33,127,65,158
       byte 104,1,33,0,9,33
       byte 128,65,159,107,65,33
       byte 129,65,161
       byte 255                                                      ; End Marker
* Right arm down, facing into screen
_57936:
       byte 250,1,2                                                  ; Change cursor's x- and y-coordinates by +2 and +1 characters respectively
       byte 100,193,32,127,193,161
       byte 102,193,33,101,129,30
       byte 128,193,161,0,9,33
       byte 104,129,30,129,193,161
       byte 107,193,33
       byte 255                                                      ; End Marker
* Right arm raised, facing into screen
_57967:
       byte 250,1,2                                                  ; Change cursor's x- and y-coordinates by +2 and +1 characters respectively
       byte 100,193,32,127,193,161
       byte 118,193,33,117,129,33
       byte 116,129,29,128,193,161
       byte 122,193,33,105,1,33
       byte 134,129,29,0,9,33
       byte 255                                                      ; End Marker
* Left arm raised, facing into screen
_58001:
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 100,65,29,116,1,33
       byte 117,1,33,118,65,33
       byte 127,65,157,134,1,33
       byte 105,1,33,122,65,33
       byte 128,65,160,0,9,33
       byte 255                                                      ; End Marker
* Upper body, pushing to the right
       byte 244,2                                                    ; Set current graphic set to 2
       byte 254,0,4                                                  ; Change cursor's x- and y-coordinates by +4 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 250,1,1                                                  ; Change cursor's x- and y-coordinates by +1 and +1 characters respectively
       byte 236,4,1,1,2,3                                            ; Modify following instruction to display graphic of random index, chosen from 1,
                                                                     ; 1, 2 and 3
       byte 1,7,157,172,1,33
       byte 173,65,33,174,65,33
       byte 175,1,157,176,65,33
       byte 0,9,33,177,1,161
       byte 178,1,161
       byte 255                                                      ; End Marker
* Upper body, pushing to the left
       byte 244,2                                                    ; Set current graphic set to 2
       byte 254,0,1                                                  ; Change cursor's x- and y-coordinates by +1 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 250,1,255                                                ; Change cursor's x- and y-coordinates by -1 and +1 characters respectively
       byte 236,4,1,1,2,3                                            ; Modify following instruction to display graphic of random index, chosen from 1,
                                                                     ; 1, 2 and 3
       byte 1,135,160,175,129,161
       byte 174,129,161,173,193,33
       byte 172,129,29,178,129,161
       byte 177,129,161,0,9,33
       byte 176,193,33
       byte 255                                                      ; End Marker

* Graphic Layout Data Berk in Action Facing out of screen, bending down (see bugs)
_58119:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 145,1,33,136,15,33
       byte 136,15,33,145,129,28
       byte 146,1,33,171,65,161
       byte 0,9,33,0,9,33
       byte 171,193,161,146,129,27
       byte 137,65,33,138,65,161
       byte 0,9,33,0,9,33
       byte 138,193,161,137,65,27
       byte 147,65,33,140,65,161
       byte 45,193,161,45,65,161
       byte 140,193,161,147,193,27
       byte 65,1,33,148,1,33
       byte 62,129,33,62,1,33
       byte 148,129,33,65,129,33
       byte 255                                                      ; End Marker
* Facing into screen, bending down
_58209:
       byte 254,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively and
                                                                     ; store as new base coordinates
       byte 244,2                                                    ; Set current graphic set to 2
       byte 251,_57792%256,_57792/256                                ; Process graphic layout data at #R57792 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_57767%256,_57767/256                                ; Process graphic layout data at #R57767 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 161,1,33,161,129,30
       byte 162,1,33,163,65,33
       byte 163,193,33,162,129,28
       byte 164,1,33,165,65,161
       byte 0,9,33,0,9,33
       byte 165,193,161,164,129,27
       byte 166,65,33,0,9,33
       byte 0,9,33,0,9,33
       byte 0,9,33,166,129,27
       byte 255                                                      ; End Marker
* Facing into screen, stretching upwards
_58278:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,253,1                                                ; Change cursor's x- and y-coordinates by +1 and -3 characters respectively
       byte 170,1,33,149,1,33
       byte 149,129,33,170,129,29
       byte 150,65,33,151,1,33
       byte 151,129,33,150,129,29
       byte 152,65,33,153,121,33
       byte 153,121,33,152,193,29
       byte 154,1,33,0,9,33
       byte 0,9,33,154,129,29
       byte 6,1,33,0,9,33
       byte 0,9,33,6,129,29
       byte 7,65,33,0,9,33
       byte 0,9,33,7,193,29
       byte 0,9,33,0,9,33
       byte 0,9,33,0,9,29
       byte 27,193,33,0,9,33
       byte 0,9,33,27,193,28
       byte 156,65,33,157,65,33
       byte 125,193,33,125,65,33
       byte 157,193,33,156,193,27
       byte 159,1,33,160,1,35
       byte 160,129,33,159,129,33
       byte 255                                                      ; End Marker
* Wings, animated
_58410:
       byte 244,6                                                    ; Set current graphic set to 6
       byte 243,0,2                                                  ; Increase current state value n (initially 0), up to maximum of 2, resetting to
                                                                     ; zero if maximum reached and jump to n-th address in following list:
       byte _58419%256,_58419/256                                    ; #R58419 (wings, raised)
       byte _58516%256,_58516/256                                    ; #R58516 (wings, lowered)
* Wings, raised
_58419:
       byte 250,254,254                                              ; Change cursor's x- and y-coordinates by -2 and -2 characters respectively
       byte 52,5,33,53,69,33
       byte 54,5,30,34,5,33
       byte 55,69,161,56,69,161
       byte 57,69,29,58,5,33
       byte 59,5,33,60,69,161
       byte 61,69,159,62,69,161
       byte 0,45,32,63,69,32
       byte 64,69,33
       byte 250,251,3                                                ; Change cursor's x- and y-coordinates by +3 and -5 characters respectively
       byte 54,133,33,53,197,33
       byte 52,133,29,57,133,33
       byte 56,197,161,55,197,161
       byte 34,133,29,61,197,161
       byte 60,197,161,59,133,33
       byte 58,133,29,0,45,33
       byte 62,197,159,63,197,32
       byte 64,197,33
       byte 255                                                      ; End Marker
* Wings, lowered
_58516:
       byte 41,5,29,42,5,33
       byte 43,69,33,44,69,161
       byte 45,69,161,46,69,29
       byte 47,5,33,48,69,33
       byte 49,69,161,0,45,31
       byte 50,5,33,51,69,33
       byte 250,253,3                                                ; Change cursor's x- and y-coordinates by +3 and -3 characters respectively
       byte 41,133,31,46,197,33
       byte 45,197,161,44,197,161
       byte 43,197,33,42,133,28
       byte 0,45,33,49,197,161
       byte 48,197,33,47,133,29
       byte 51,197,33,50,133,33
       byte 255                                                      ; End Marker
* Facing right, falling, arms forward
_58592:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 5,1,33,183,1,33
       byte 184,1,33,2,7,28
       byte 6,1,33,0,9,33
       byte 0,9,33,18,1,33
       byte 19,65,33,20,1,33
       byte 21,1,26,7,65,33
       byte 0,9,33,0,9,33
       byte 89,65,161,22,65,161
       byte 23,65,33,24,1,25
       byte 4,1,33,58,65,161
       byte 179,65,33,0,9,33
       byte 43,1,33,182,1,33
       byte 26,1,26,62,1,33
       byte 54,1,33,63,1,33
       byte 180,1,33
       byte 255                                                      ; End Marker
* Facing left, falling, arms forward
_58685:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 2,135,33,184,129,33
       byte 183,129,33,5,129,27
       byte 21,129,33,20,129,33
       byte 19,193,33,18,129,33
       byte 0,9,33,0,9,33
       byte 6,129,26,24,129,33
       byte 23,129,33,22,193,33
       byte 89,193,33,0,9,33
       byte 0,9,33,7,193,27
       byte 26,129,33,182,129,33
       byte 43,129,33,0,9,33
       byte 179,193,33,58,193,33
       byte 4,129,29,180,129,33
       byte 63,129,33,54,129,33
       byte 62,129,33
       byte 255                                                      ; End Marker
* Facing right, falling, arms to sides
_58778:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 188,1,33,189,65,33
       byte 190,65,33,2,7,28
       byte 6,1,33,191,65,161
       byte 192,65,161,193,65,161
       byte 186,1,28,7,65,161
       byte 194,65,161,195,65,161
       byte 0,9,33,187,1,27
       byte 4,1,33,58,65,161
       byte 179,65,33,0,9,33
       byte 43,1,28,62,1,33
       byte 54,1,33,63,1,33
       byte 180,1,33
       byte 255                                                      ; End Marker
* Facing left, falling, arms to sides
_58853:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,1                                                  ; Change cursor's x- and y-coordinates by +1 and +2 characters respectively
       byte 2,135,33,190,193,33
       byte 189,193,33,188,193,29
       byte 186,193,33,193,193,33
       byte 192,193,33,191,193,33
       byte 6,129,28,187,129,33
       byte 0,9,33,195,193,33
       byte 194,193,33,7,193,29
       byte 43,129,33,0,9,33
       byte 179,193,33,58,193,33
       byte 4,129,29,180,129,33
       byte 63,129,33,54,129,33
       byte 62,129,33
       byte 255                                                      ; End Marker
* Being thrown right
_58928:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 109,1,34,215,7,33
       byte 215,7,28,110,1,33
       byte 111,65,33,112,65,33
       byte 98,65,161,99,65,161
       byte 186,1,33,109,129,26
       byte 113,1,33,196,65,33
       byte 197,65,161,0,9,33
       byte 0,9,33,198,65,33
       byte 111,193,33,110,129,26
       byte 7,65,33,0,9,33
       byte 0,9,33,0,9,33
       byte 115,193,33,114,1,33
       byte 113,129,25,199,1,33
       byte 74,65,161,0,9,33
       byte 0,9,33,0,9,33
       byte 34,1,27,77,1,33
       byte 71,1,33,200,1,33
       byte 201,1,33,202,65,161
       byte 156,193,31,160,129,33
       byte 159,129,33
       byte 255                                                      ; End Marker
* Being thrown left
_59048:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,0,2                                                  ; Change cursor's x- and y-coordinates by +2 and 0 characters respectively
       byte 215,135,33,215,135,34
       byte 109,129,27,109,1,33
       byte 186,129,33,99,193,33
       byte 98,193,33,112,193,33
       byte 111,193,33,110,129,25
       byte 110,1,33,111,65,33
       byte 198,193,33,0,9,33
       byte 0,9,33,197,193,33
       byte 196,193,33,113,129,25
       byte 113,1,33,114,1,33
       byte 115,65,33,0,9,33
       byte 0,9,33,0,9,33
       byte 7,193,28,34,129,33
       byte 238,3                                                    ; Set Repeat Counter A to 3
_59133:
       byte 0,9,33
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R59133 if not zero
       byte 74,193,33,199,129,27
       byte 156,65,33,202,193,33
       byte 201,193,33,200,129,33
       byte 71,129,33,77,129,27
       byte 159,1,33,160,1,33
       byte 255                                                      ; End Marker
* Floating / starting to fall, animated
_59168:
       byte 251,_56880%256,_56880/256                                ; Process graphic layout data at #R56880 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_59223%256,_59223/256                                ; Process graphic layout data at #R59223 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 251,_59231%256,_59231/256                                ; Process graphic layout data at #R59231 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,5,253                                                ; Change cursor's x- and y-coordinates by -3 and +5 characters respectively
       byte 40,132,33,39,161,33
       byte 38,161,33,0,9,33
       byte 0,9,33,38,33,33
       byte 39,33,33,40,4,26
       byte 43,132,33,42,225,33
       byte 61,1,33,61,129,33
       byte 42,33,33,43,4,33
       byte 255                                                      ; End Marker
* Right arm, animated
_59223:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _57545%256,_57545/256                                    ; #R57545 (right arm)
       byte _57607%256,_57607/256                                    ; #R57607 (right arm raised)
       byte _57669%256,_57669/256                                    ; #R57669 (right arm, walking into or out of screen)
* Right arm, animated
_59231:
       byte 247,3                                                    ; Jump to one of the 3 addresses in the following list, chosen at random:
       byte _57576%256,_57576/256                                    ; #R57576 (left arm)
       byte _57638%256,_57638/256                                    ; #R57638 (left arm raised)
       byte _57703%256,_57703/256                                    ; #R57703 (left arm, walking into or out of screen)
* Falling downwards
_59239:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,2,0                                                  ; Change cursor's x- and y-coordinates by 0 and +2 characters respectively
       byte 251,_57610%256,_57610/256                                ; Process graphic layout data at #R57610 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,2,5                                                  ; Change cursor's x- and y-coordinates by +5 and +2 characters respectively
       byte 251,_57641%256,_57641/256                                ; Process graphic layout data at #R57641 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,2,2                                                  ; Change cursor's x- and y-coordinates by +2 and +2 characters respectively
       byte 207,1,33,207,129,31
       byte 185,15,33,185,15,31
       byte 98,65,161,99,65,157
       byte 203,1,33,204,65,161
       byte 0,9,33,0,9,33
       byte 204,193,161,203,129,27
       byte 205,1,33,206,65,161
       byte 201,129,33,201,1,33
       byte 206,193,161,205,129,33
       byte 255                                                      ; End Marker
* Lying on floor, animated
_59311:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,6,2                                                  ; Change cursor's x- and y-coordinates by +2 and +6 characters respectively
       byte 251,_59367%256,_59367/256                                ; Process graphic layout data at #R59367 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,5,0                                                  ; Change cursor's x- and y-coordinates by 0 and +5 characters respectively
       byte 208,1,33,209,65,161
       byte 183,65,33,183,193,33
       byte 209,193,33,208,129,26
       byte 236,2,210,211                                            ; Modify following instruction to display graphic of random index, chosen from
                                                                     ; 210 and 211
       byte 210,1,33,212,65,33
       byte 213,65,35,213,193,33
       byte 212,193,33
       byte 236,2,210,211                                            ; Modify following instruction to display graphic of random index, chosen from
                                                                     ; 210 and 211
       byte 210,129,33
       byte 255                                                      ; End Marker
* Stunned eyes, animated
_59367:
       byte 238,2                                                    ; Set Repeat Counter A to 2
       byte 236,4,91,92,214,215                                      ; Modify following instruction to display graphic of random index, chosen from
                                                                     ; 91, 92, 214 and 215
_59375:
       byte 91,15,33
       byte 239                                                      ; Decrement Repeat Counter A and loop back to #R59375 if not zero
       byte 255                                                      ; End Marker
* Getting up, frame 1, animated
_59380:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,4,2                                                  ; Change cursor's x- and y-coordinates by +2 and +4 characters respectively
       byte 251,_59367%256,_59367/256                                ; Process graphic layout data at #R59367 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,3,2                                                  ; Change cursor's x- and y-coordinates by +2 and +3 characters respectively
       byte 207,1,33,207,129,30
       byte 100,1,35,100,129,26
       byte 116,1,33,117,1,33
       byte 118,65,33,119,65,161
       byte 98,65,161,99,65,161
       byte 119,193,33,118,193,33
       byte 117,129,33,116,129,23
       byte 120,1,33,121,1,33
       byte 122,1,33,216,65,33
       byte 125,65,33,125,193,33
       byte 216,193,33,122,129,33
       byte 121,129,33,120,129,33
       byte 255                                                      ; End Marker
* Getting up, frame 2 / banging head
_59464:
       byte 244,2                                                    ; Set current graphic set to 2
       byte 250,1,0                                                  ; Change cursor's x- and y-coordinates by 0 and +1 characters respectively
       byte 251,_57610%256,_57610/256                                ; Process graphic layout data at #R57610 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,5                                                  ; Change cursor's x- and y-coordinates by +5 and +1 characters respectively
       byte 251,_57641%256,_57641/256                                ; Process graphic layout data at #R57641 and upon returning, move cursor to base
                                                                     ; coordinates
       byte 250,1,2                                                  ; Change cursor's x- and y-coordinates by +2 and +1 characters respectively
       byte 207,1,33,207,129,31
       byte 214,15,33,214,15,31
       byte 94,65,161,95,65,159
       byte 0,9,33,0,9,29
       byte 4,1,33,48,65,161
       byte 49,65,161,49,193,161
       byte 48,193,161,4,129,27
       byte 53,1,33,54,1,33
       byte 53,129,33,53,1,33
       byte 54,129,33,53,129,33
       byte 255                                                      ; End Marker

* Unused
       byte 175

* Unused routine
* 
* This routine appears to have been set up to load visual data into the Display and Attribute files and then to load
* the game code and data into RAM, from address #R27000 onwards. This routine was probably used during development.
* Input:  A  New value for system variable DF SZ
_59543:
       mov  a,@23659                   ; LD (23659),A      ; Set System Variable DF SZ to value in A
       li   de,6912                    ; LD DE,6912        ; Set data length to 6912
       li   ix,_40000                  ; LD IX,40000       ; Set base address for load to 40000
       movb @bytes+255,a               ; LD A,255          ; Load A with 255 to denote a data block
       ; SCF                           ; SCF               ; Set Carry Flag as we are LOADing, not VERIFYing
       bl   @1366                      ; CALL 1366         ; Call ROM routine to load game data
       li   hl,_40000                  ; LD HL,40000       ; Copy data just loaded to Display File / Attribute File...
       li   de,16384                   ; LD DE,16384       ; ...
       li   bc,6912                    ; LD BC,6912        ; ...
       .ldir                           ; LDIR              ; ...
       li   de,_32334+526              ; LD DE,32860       ; Set data length to 32860
       li   ix,_27000                  ; LD IX,27000       ; Set base address for load to 27000
       movb @bytes+255,a               ; LD A,255          ; Load A with 255 to denote a data block
       ; SCF                           ; SCF               ; Set Carry Flag as we are LOADing, not VERIFYing
       bl   @1366                      ; CALL 1366         ; Call ROM routine to load game data
       b    @_34200                    ; JP 34200          ; Jump to code entry point

* Unused
       byte 0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0

* If Current Character is in Same Room as Target Entity at IX then Set Pending Sound to A
* 
* If the requested sound has a lower index than the sound already pending then the requested sound overrides the
* pending sound (i.e. lower index has higher priority). Input:  A  Index of requested sound IX  Address of complex
* state data for target entity
_59601:
       .push af                        ; PUSH AF           ; Store AF (A = index of requested sound)
       movb @_34218,a                  ; LD A,(34218)      ; If current character's current room is the same as current room of target entity...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  _59612                     ; JR Z,59612        ; ...then skip ahead to #R59612
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       rt                              ; RET               ; Return
_59612:
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
* At this point, A will hold the index of a requested sound, and RAM address #R34273 will contain the index of a
* pending sound. If the index of the requested sound is lower than the index of the pending sound, then the pending
* sound's index at #R34273 will be overwritten by the index of the requested sound in A. Sounds with lower indices
* therefore take priority over sounds with higher indices. This entry point is used by the routines at #R46284,
* #R55196 and #R59722.
_59613:
       socb a,a                        ; OR A              ; If index of requested sound is zero...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       .push de                        ; PUSH DE           ; Store DE
       movb a,@e                       ; LD E,A            ; Load E with index of requested sound
       movb @_34273,a                  ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero (i.e. no sound pending)...
       jeq  _59628                     ; JR Z,59628        ; ...then skip ahead to #R59628
       cb   a,@e                       ; CP E              ; If index of requested sound is less than or equal to index of pending sound...
       jhe  _59628                     ; JR NC,59628       ; ...then skip ahead to #R59628
       .pop de                         ; POP DE            ; Restore DE
       rt                              ; RET               ; Return
_59628:
       movb @e,a                       ; LD A,E            ; Set requested sound to be new pending sound...
       mov  a,@_34273                  ; LD (34273),A      ; ...
       .pop de                         ; POP DE            ; Restore DE
       rt                              ; RET               ; Return

* Table of Sound Parameters
* 
* #TABLE(default,centre,:w)
* { =h Offset | =h Meaning }
* { 0 | Index (unused) }
* { 1 | Outer repeat counter }
* { 2 | Inner repeat counter }
* { 3 | Delay constant (controls speed, higher value is slower) }
* { 4 | Delay constant (controls speed / pitch, higher value is slower / lower) }
* { 5 | Increment for delay constant D }
* { 6 | Increment for delay constant E }
* { 7 | Most significant byte of pseudo-random address plus No Pause Flag }
* TABLE#
       byte 1,4,168,29,167,254,3,1                                   ; (01) - Out of time
       byte 2,3,160,57,6,1,0,128                                     ; (02) - Main Menu sound (three blips)
       byte 3,15,141,214,46,1,253,128                                ; (03) - Unused
       byte 4,1,40,82,59,253,1,6                                     ; (04) - Explosion
_59666:
       byte 5,1,84,93,115,4,251,11                                   ; (05) - Berk landing
       byte 6,1,190,58,25,0,250,128                                  ; (06) - Berk/Drutt banging head on ceiling
       byte 7,1,30,180,12,0,252,128                                  ; (07) - Spider sound
       byte 8,1,134,55,58,251,4,128                                  ; (08) - Drutt eating a worm
       byte 9,1,10,60,187,253,247,128                                ; (09) - Drutt hopping
       byte 10,1,68,160,79,254,254,128                               ; (10) - Unused
       byte 11,1,122,123,102,205,0,128                               ; (11) - Unused

* Set Sound of Index A as Pending if Appropriate, then Play and Clear Pending Sound
* 
* The sound with index A will become the pending sound if the currently pending sound index is either zero, or of
* higher index than A (i.e. lower priority). Input:  A  Sound index L  Undefined, pseudo-random value
_59722:
       bl   @_59613                    ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
* This entry point is used by the routine at #R34438.
_59725:
       movb @_34273,a                  ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero...
       jne  !                          ; RET Z             ; ...then return
       rt                              ;                   
!
       sb   one,a                      ; DEC A             ; Decrease A to give zero-based sound index
       .push ix                        ; PUSH IX           ; Store IX
       li   ix,_59628+7                ; LD IX,59635       ; Point IX at second byte of first entry in Sound Parameters Table
       a    a,a                        ; ADD A,A           ; Multiply sound index by eight...
       a    a,a                        ; ADD A,A           ; ...as sound data entries in table at #R59634 are eight bytes wide...
       a    a,a                        ; ADD A,A           ; ...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       movb @bytes+0,b                 ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Add BC to IX as offset to point to sound data for pending sound
       movb b,a                        ; LD A,B            ; Set index of pending sound to zero...
       mov  a,@_34273                  ; LD (34273),A      ; ...
       movb *ix,@c                     ; LD C,(IX+0)       ; Load outer repeat count into C
_59752:
       movb @1(ix),b                   ; LD B,(IX+1)       ; Load inner repeat count into B
       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load delay constant E into E
       movb @3(ix),d                   ; LD D,(IX+3)       ; Load delay constant D into D
       movb @6(ix),h                   ; LD H,(IX+6)       ; Load most significant byte of pseudo-random address into H
_59764:
       .push bc                        ; PUSH BC           ; Store BC (B = inner repeat count, C = outer repeat count)
       movb @_34217,a                  ; LD A,(34217)      ; Load current border colour into A
       socb @bits+4,a                  ; SET 4,A           ; Set Speaker Bit
       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
       movb d,b                        ; LD B,D            ; Apply delay based upon delay constant D...
_59773:
       nop                             ; NOP               ; ...
       sb   one,b                      ; DJNZ 59773        ; ...
       jne  _59773                     ;                   
       mov  h,tmp0                     ; BIT 7,H           ; If No Pause Flag is set...
       andi tmp0,128                   ;                   
       jne  _59794                     ; JR NZ,59794       ; ...then skip ahead to #R59794
       movb *hl,b                      ; LD B,(HL)         ; Load B with value from pseudo-random address
       inc  hl                         ; INC HL            ; Advance HL
_59782:
       mov  *ix,tmp0                   ; BIT 0,(IX+0)      ; Do nothing (pause) for period B...
       andi tmp0,1                     ;                   
       nop                             ; NOP               ; ...
       nop                             ; NOP               ; ...
       nop                             ; NOP               ; ...
       nop                             ; NOP               ; ...
       nop                             ; NOP               ; ...
       nop                             ; NOP               ; ...
       sb   one,b                      ; DJNZ 59782        ; ...
       jne  _59782                     ;                   
_59794:
       szcb @bits+4,a                  ; RES 4,A           ; Reset Speaker Bit
       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
       movb @e,b                       ; LD B,E            ; Do nothing for E cycles...
_59799:
       nop                             ; NOP               ; ...
       sb   one,b                      ; DJNZ 59799        ; ...
       jne  _59799                     ;                   
       movb @4(ix),a                   ; LD A,(IX+4)       ; Adjust value of delay constant D...
       a    d,a                        ; ADD A,D           ; ...
       movb a,d                        ; LD D,A            ; ...
       movb @5(ix),a                   ; LD A,(IX+5)       ; Adjust value of delay constant E...
       a    @e,a                       ; ADD A,E           ; ...
       movb a,@e                       ; LD E,A            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = inner repeat count, C = outer repeat count)
       sb   one,b                      ; DJNZ 59764        ; Loop back to #R59764
       jne  _59764                     ;                   
       sb   one,@c                     ; DEC C             ; Decrease outer repeat count
       jne  _59752                     ; JR NZ,59752       ; If non-zero (i.e. more repeats to process) then loop back to #R59752
       .pop ix                         ; POP IX            ; Restore IX
       rt                              ; RET               ; Return

* Table of Initial-State Data for Complex Entities
* 
* This table is used to store the initial states of the various entities in the game, so that they can be reset when
* a new game is started.
_59821:
       byte 49,50,51,52,53,54,55,56,57,48

* Do nothing
* 
* Used by the routine at #R34428
_59831:
       rt                              ; RET               ; Return

* Unused
       ; DEFS 1480                     ; DEFS 1480         

* Display Buffer 1
* 
* Three bytes per entry, 32 x 22 entries, one for each cell of Attribute File within play area. Bytes are in order:
_61312:
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

* Load loading screen and main game code The following instructions set the system variable DF SZ to zero. This
* prevents a press of the break key returning us to basic while the game is loading.
_63000:
       sb   a,a                        ; XOR A             ; Set system variable DF SZ to zero
       mov  a,@23659                   ; LD (23659),A      ; 
       li   de,6912                    ; LD DE,6912        ; Load loading screen to 40000 and copy into Display File
       li   ix,_40000                  ; LD IX,40000       ; 
       movb @bytes+255,a               ; LD A,255          ; 
       ; SCF                           ; SCF               ; 
       bl   @1366                      ; CALL 1366         ; 
       li   hl,_40000                  ; LD HL,40000       ; 
       li   de,16384                   ; LD DE,16384       ; 
       li   bc,6912                    ; LD BC,6912        ; 
       .ldir                           ; LDIR              ; 
       li   de,_32334+526              ; LD DE,32860       ; Load 32860 bytes to 27000
       li   ix,_27000                  ; LD IX,27000       ; 
       movb @bytes+255,a               ; LD A,255          ; 
       ; SCF                           ; SCF               ; 
       bl   @1366                      ; CALL 1366         ; 
       b    @_34200                    ; JP 34200          ; Jump to start-up code

* The remaining display buffer #1 bytes
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

* Display Buffer 2
* 
* Three bytes per entry, 32 x 22 entries, one for each cell of Attribute File within play area. Bytes are in order:
_63424:
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
       byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
