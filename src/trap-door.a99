* SkoolKit disassembly for Through the Trap Door
* 
* Copyright (c) 2017 Philip M. Anderson (this disassembly)
* Copyright (c) 1987 Don Priestley / Piranha / Alternative Software Ltd (Through the Trap Door)

* Set Up Random Seed and Disable Interrupts
*
start:
       limi 0                           ; DI                ; Disable interrupts
       lwpi wrksp
       mov @rndsd,@rnd_seed             ; LD A,(23672)      ; Store the least significant byte of the system variable FRAMES...
                                        ; LD (54219),A      ; ...at 54219 as the seed for the pseudo-random number generator
       li   one,>0100
       li   sp,stack                   ; LD SP,34426       ; Set Stack Pointer
       bl   @graphics_mode

* Display Main Menu and Handle Main Game Loop
main:
       li   sp,stack                   ; LD SP,34426       ; Set Stack Pointer
       bl   @reset_initial_state_data  ; CALL 34695        ; Copy State Data for all resettable complex entities into Table of Initial-State Data
       movb one,@current_level         ; LD A,1            ; Set current level to 1...
                                       ; LD (34207),A      ; ...
       bl   @main_menu                 ; CALL 46830        ; Display and handle Main Menu
       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
       bl   @set_border_color          ; OUT (254),A       ; Set border colour
       bl   @init_level_data           ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @draw_timer_bar            ; CALL 47241        ; Reset Show Score Flag and draw timer figures bar
* Start of main loop
main_loop:
       bl   @check_berk_killed         ; CALL 53723        ; If Berk has been killed then reset his state, flash screen and decrease time / lives
       bl   @update_berk_state         ; CALL 35689        ; Update state of Berk and store current position in script data
       bl   @update_drutt_worm_state   ; CALL 51739        ; Update states of Drutt and worm and store current positions in script data
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 1...
       cb   a,one                      ; CP 1              ; ...
       jne  main_check_level_2         ; JR NZ,34527       ; ...then skip ahead to #R34527
* Level 1
       bl   @update_level_1_entities   ; CALL 36791        ; Update states of all Level 1 entities
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       movb @10(ix),tmp0               ; BIT 2,(IX+10)     ; If "Back to Level 1" Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  main_all_levels            ; JR Z,34557        ; ...then skip ahead to #R34557
* Back to Level 1 Flag is set
       movb @bonis_state_data_1+6,a    ; LD A,(43612)      ; If y-coordinate of Boni's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1+6,a   ; LD A,(43677)      ; If y-coordinate of Drutt's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1,a     ; LD A,(43671)      ; If Drutt's room is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @bytes+2,a                 ; LD A,2            ; Set depth of "Home Sweet Home" brickwork to 2...
       movb a,@state_data_simple_1+13  ; LD (43159),A      ; ...
       socb @bits+3,@10(ix)            ; SET 3,(IX+10)     ; Set "All Home" Flag
       jmp  main_all_levels            ; JR 34557          ; Skip ahead to #R34557
main_check_level_2:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  main_check_level_3         ; JR NZ,34537       ; ...then skip ahead to #R34537
* Level 2
       bl   @update_level_2_entities   ; CALL 38009        ; Update states of all Level 2 entities
main_check_level_3:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 3...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jne  main_check_level_4         ; JR NZ,34547       ; ...then skip ahead to #R34547
* Level 3
       bl @update_level_3_entities     ; CALL 39137        ; Update states of all Level 3 entities
main_check_level_4:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
* Level 4
       bl   @update_level_4_entities   ; CALL 41211        ; Update states of all Level 4 entities
* All levels
main_all_levels:
       bl   @check_control_input       ; CALL 47893        ; Check for control input and store at #R34219
       bl   @move_falling_entities     ; CALL 55525        ; Move all falling entities down by distances appropriate to their current velocity factors
       bl   @swap_characters           ; CALL 34916        ; If Fire Pressed, or Character Swap Pending Flag set, then swap characters
       bl   @clear_prim_disp_buf_area  ; CALL 53782        ; Set each value in Primary Display Buffer within play area to zero
       bl   @populate_prim_disp_buf    ; CALL 45899        ; Populate Primary Display Buffer with layout data for current character's current room
       bl   @draw_display_buffer       ; CALL 54034        ; Draw contents of Primary Display Buffer to display
       bl   @play_sound              ; CALL 59725        ; Play and clear pending sound (index as stored at #R34273)
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
       socb a,a                        ; OR A              ; If no time / lives are left...
       jeq  time_out                   ; JR Z,34645        ; ...then jump to #R34645
       movb @berks_state_data_1+10,a   ; LD A,(43603)      ; If "All Home" Flag is set...
       movb a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8*256                 ;
       jne  all_home                     ; JR NZ,34658       ; ...then skip ahead to #R34658
       bl   @update_timer              ; CALL 47363        ; Update eyes of a randomly selected timer figure, increase Timer Tick Counter and process
                                                           ; timer figure blinking
       li   hl,game_flags              ; LD HL,34208       ; If Update Scores and Display Flag is reset...
       movb *hl,tmp0                   ; BIT 5,(HL)        ; ...
       andi tmp0,32*256                ;
       jeq  skip_update_score          ; JR Z,34606        ; ...then skip ahead to #R34606
       szcb @bits+5,*hl                ; RES 5,(HL)        ; Reset Update Scores and Display Flag
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
skip_update_score:
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a     ; LD A,(34271)      ; Invert "Display Buffer 2 is Primary" Flag...
       xor  one,a                      ; XOR 1             ; ...
       movb a,@display_buffer_flag     ; LD (34271),A      ; ...
       jeq  skip_swap_buffers          ; JR Z,34623        ; If "Display Buffer 2 is Primary" Flag is reset then skip ahead to #R34623 (Display Buffer 1
                                                           ; is Primary, Display Buffer 2 is Secondary)
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
skip_swap_buffers:
       mov  hl,@prim_disp_buffer_addr  ; LD (34279),HL     ; Store address of Primary Display Buffer at #R34279
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 6,A           ; If Restart hasn't been pressed...
       andi tmp0,64*256                ;
       jne  restart                    ; JP Z,34466        ; ...then jump to #R34466 (start of main loop)
       jmp  main_loop                  ;
* Restart has been pressed
restart:
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound                   ; CALL 59722        ; ...
       .call @_34751                   ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
* No time/lives left
time_out:
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
       bl   @print_times_up           ; CALL 47185        ; Print "SORRY BERK,  BUT YOUR TIME IS UP" string
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound                   ; CALL 59722        ; ...
       jmp  wait_key_and_restart       ; JR 34666          ; Skip ahead to #R34666
* "All Home" Flag is set
all_home:
       .call @print_home_sweet_home    ; CALL 47213        ; Print "HOME SWEET HOME" string
       movb @bytes+3,a                 ; LD A,3            ; Set sound 3 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound                   ; CALL 59722        ; ...
wait_key_and_restart:
       .call @_47942                   ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
       .call @_34751                   ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438            ; Jump back to #R34438 (return to Main Menu)

* Pause
* 
* Used by the routine at #R53649. Input:  B  Repeat count for outer loop C  Additional repeat count for inner loop
_34675:
       .push bc                        ; PUSH BC           ; Store BC
       movb @bytes+10,b                ; LD B,10           ; Set B to 10
_34678:
       dec  bc                         ; DEC BC            ; Decrease BC
       movb b,a                        ; LD A,B            ; If BC is not zero...
       socb @c,a                       ; OR C              ; ...
       jne  _34678                     ; JR NZ,34678       ; ...then loop back to #R34678
       .pop bc                         ; POP BC            ; Restore BC
       sb   one,b                      ; DJNZ 34675        ; Loop back for next pass
       jne  _34675                     ;                   
       .ret                            ; RET               ; Return

* Copy State Data for all Resettable Complex Entities into Table of Initial-State Data for Complex Entities
* 
* Used by the routine at #R34438.
reset_initial_state_data:
       .proc
       li   iy,level_state_data_table  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   de,initial_entity_states   ; LD DE,59821       ; Point DE at start of Table of Initial-State Data for Complex Entities
       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (as there are 4 levels)
reset_initial_state_data_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       mov  *iy+,ix                    ; LD L,(IY+0)       ; Load start address of current level's complex state data into HL...
                                       ; LD H,(IY+1)       ; ...
                                       ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
                                       ; INC IY            ; ...
                                       ; PUSH HL           ; Transfer start address of current level's complex state data into IX...
                                       ; POP IX            ; ...
reset_initial_state_data_2:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  reset_initial_state_data_4                     ; JR Z,34747        ; ...then skip ahead to #R34747
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  reset_initial_state_data_3                     ; JR Z,34740        ; ...then advance IX by 13 bytes to next entry and loop back to #R34718
       mov  ix,hl                      ; PUSH IX           ; Transfer start address of current entry in complex state data into HL...
                                       ; POP HL            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in complex state data into Table of Initial-State Data for Complex
                                                           ; Entities at #R59821
reset_initial_state_data_3:
       ai   ix,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
                                       ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  reset_initial_state_data_2                     ; JR 34718          ; Loop back to #R34718
reset_initial_state_data_4:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       sb   one,b                      ; DJNZ 34704        ; Decrease B and loop back to #R34704 to process next level
       jne  reset_initial_state_data_1                     ;
       .endproc                        ; RET               ; Return

* Reset All Game Data in Preparation for New Game
* 
* Used by the routine at #R34438.
_34751:
       li   iy,level_state_data_table  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   hl,initial_entity_states   ; LD HL,59821       ; Point HL at start of Table of Initial-State Data for Complex Entities
       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (as there are 4 levels)
_34760:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load start address of current level's complex state data into DE...
       movb @1(iy),d                   ; LD D,(IY+1)       ; ...
       inc  iy                         ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
       inc  iy                         ; INC IY            ; ...
       .push de                        ; PUSH DE           ; Transfer start address of current level's complex state data into IX...
       .pop ix                         ; POP IX            ; ...
_34774:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  _34803                     ; JR Z,34803        ; ...then skip ahead to #R34803
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  _34796                     ; JR Z,34796        ; ...then advance IX by 13 bytes to next entry and loop back to #R34774
       .push ix                        ; PUSH IX           ; Transfer start address of current entry in complex state data into DE...
       .pop de                         ; POP DE            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in Table of Initial-State Data for Complex Entities at #R59821 into
                                                           ; complex state data
_34796:
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       a    bc,ix                      ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  _34774                     ; JR 34774          ; Loop back to #R34774
_34803:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       sb   one,b                      ; DJNZ 34760        ; Decrease B and loop back to #R34760 to process next level
       jne  _34760                     ;                   
       li   hl,_34298                  ; LD HL,34298       ; Point HL at Joystick Mode Flag
       li   de,current_level           ; LD DE,34207       ; Point DE at store for current level number
       sb   a,a                        ; XOR A             ; Set A to zero and reset Carry Flag
       s    de,hl                      ; SBC HL,DE         ; Subtract DE from HL to leave HL = 91
       movb @l,b                       ; LD B,L            ; Load B with 91
       li   hl,current_level           ; LD HL,34207       ; Point HL at store for current level number...
_34819:
       movb a,*hl                      ; LD (HL),A         ; ...and set 91 bytes from here onwards to zero...
       inc  hl                         ; INC HL            ; ...
       sb   one,b                      ; DJNZ 34819        ; ...
       jne  _34819                     ;                   
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       movb a,@time_left               ; LD (34210),A      ; ...
       movb one,a                      ; LD A,1            ; Set current level to Level 1...
       movb a,@current_level           ; LD (34207),A      ; ...
       .call @_36778                   ; CALL 36778        ; Initialise script data positions for Flying Skeleton Creature and Bat (Level 1)
       .call @_38468                   ; CALL 38468        ; Reset current positions in apebeasts' script data to initial values
       .call @_41354                   ; CALL 41354        ; Reset Skeleton to initial state
       .call @_51732                   ; CALL 51732        ; Reset Drutt to initial state
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" and impassable marker to 1 (i.e. starting room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       movb a,@_43450                  ; LD (43450),A      ; ...
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of current character to 1 (blue, Berk)
       sb   one,a                      ; DEC A             ; Set room of "Open Trap Door" and "Home Sweet Home" brickwork to 0...
       movb a,@_43437                  ; LD (43437),A      ; ...i.e. remove from game...
       movb a,@state_data_simple_1+13               ; LD (43159),A      ; ...
       .ret                            ; RET               ; Return

* Copy Start Addresses of Current Level's Data Blocks to 34236 and Clean Up Old Data
* 
* Used by the routines at #R34438 and #R36753.
init_level_data:
       .proc
       .push de                        ; PUSH DE           ; Store DE
       .push hl                        ; PUSH HL           ; Store HL
       mov  @worm_state_addr,hl        ; LD HL,(34244)     ; Load HL with address of complex state data (current level) for worm
       movb @bytes+0,*hl               ; LD (HL),0         ; Set worm's current room to zero
       clr  hl
       movb @current_level,@l          ; LD A,(34207)      ; Load current level into A
       dec  hl
       sla  hl,1                       ; LD HL,34281       ; Point HL at position 20 bytes before start of list of start addresses of level 1's data
       mov  @level_data_table(hl),hl                       ; blocks
                                       ; LD BC,20          ; Set data length to 20, as there are 10 data blocks per level (so 10 addresses)

                                       ; ADD HL,BC         ; Advance HL to start of data block address list for next level
                                       ; DEC A             ; Decrease level counter
                                       ; JR NZ,34880       ; Loop back if we have not reached data for required level
* At this point, HL points to the start of the list of start addresses of the current level's data blocks
       li   de,current_data_addrs      ; LD DE,34236       ; Copy this level's data block start addresses to #R34236...
       .ldir                           ; LDIR              ; ...
       li   bc,6                       ; LD B,9            ; Clear Store for Script Instruction Loop Data...
       li   hl,script_23_24_loop_count ; LD HL,34285       ; ...
init_level_data_2:
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       dec  bc                         ; DJNZ 34894        ; ...
       jne  init_level_data_2                     ;
       .pop hl                         ; POP HL            ; Restore HL
       .pop de                         ; POP DE            ; Restore DE
       .endproc                        ; RET               ; Return

* Script Routine (48, 49) Return
* 
* This script routine terminates the script data currently under execution until the next game cycle.
script_routine_48_49:
       .ret                            ; RET               ; Return

* Unused routine
* 
* This routine floods the Attribute File with value 9 (Blue INK, Blue PAPER)
;       li   hl,22528                   ; LD HL,22528       ; Set all Attribute File contents to blue INK, blue PAPER...
;       li   de,22529                   ; LD DE,22529       ; ...
;       movb @bytes+9,*hl               ; LD (HL),9         ; ...
;       li   bc,767                     ; LD BC,767         ; ...
;       .ldir                           ; LDIR              ; ...
;       .ret                            ; RET               ; Return

* If Fire Pressed, or Character Swap Pending Flag Set, then Swap Characters
* 
* Used by the routine at #R34438.
swap_characters:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; If Character Swap Pending Flag is reset...
       movb *hl,tmp0                   ; BIT 6,(HL)        ; ...
       andi tmp0,64*256                ;                   
       jeq  swap_characters_1          ; JR Z,34927        ; ...then skip ahead to #R34927
       szcb @bits+6,*hl                ; RES 6,(HL)        ; Reset Character Swap Pending Flag
       jmp  swap_characters_4                     ; JR 34944          ; Skip ahead to #R34944
swap_characters_1:
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 4,A           ; If fire was pressed...
       andi tmp0,16*256                ;                   
       jne  swap_characters_3          ; JR NZ,34940       ; ...then skip ahead to #R34940
       szcb @bits+1,*hl                ; RES 1,(HL)        ; Reset Characters Already Swapped Flag
swap_characters_2:
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .endproc                        ; RET               ; Return
* [Fire pressed]
swap_characters_3:
       movb *hl,tmp0                   ; BIT 1,(HL)        ; If Characters Already Swapped Flag set (i.e. FIRE hasn't been released since last swap)...
       andi tmp0,2*256                 ;                   
       jne  swap_characters_2          ; JR NZ,34936       ; ...then jump back to #R34936
swap_characters_4:
       socb @bits+1,*hl                ; SET 1,(HL)        ; Set Characters Already Swapped Flag
       movb *hl,a                      ; LD A,(HL)         ; Load Game Flags into A
       xor  one,a                      ; XOR 1             ; Flip bit 7 (Berk / Drutt flag)...
       movb a,*hl                      ; LD (HL),A         ; ...
       movb *hl,tmp0                   ; BIT 0,(HL)        ; If current character is now Berk (0)...
       andi tmp0,1*256                 ;                   
       jeq  swap_characters_5          ; JR Z,34958        ; ...then jump ahead to #R34958
       movb @bytes+6,a                 ; LD A,6            ; Load A with 6 (attribute for Drutt's timer indicator figures)
       jmp  swap_characters_6          ; JR 34960          ; Skip ahead to #R34960
swap_characters_5:
       movb one,a                      ; LD A,1            ; Load A with 1 (attribute for Berk's timer indicator figures)
swap_characters_6:
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of timer indicator figures to value in A
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       li   hl,game_flags              ; LD HL,34208       ; If Show Score Flag is set...
       movb *hl,tmp0                   ; BIT 7,(HL)        ; ...
       andi tmp0,128*256               ;                   
       jeq  !                          ; JP NZ,47628       ; ...then print SCORE / TOTAL / HI-SC string in current character's colours and return
       b    @print_score_strings_0     ;
!
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, draw timer figures bar and return

* Change Direction Berk is Facing Depending Upon Relative Position of Drutt
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
change_berk_direction:
       movb @current_characters_room,a                  ; LD A,(34218)      ; If Drutt's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's current room...
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
       movb @11(ix),a                  ; LD A,(IX+11)      ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags...
       andi a,240*256                  ; AND 240           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       movb @9(ix),@e                  ; LD E,(IX+9)       ; Load Berk's Flags into E
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of complex state data (current level) for Drutt
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with x-coordinate of Drutt's right side...
       ab   one,a                      ; INC A             ; ...and increase by one
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of Berk's left side is greater than this (i.e. Drutt is to the left of
                                                           ; Berk)...
       jl   _35653                     ; JR C,35653        ; ...then skip ahead to #R35653
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right side
       ab   one,a                      ; INC A             ; Increase A by one
       cb   a,@5(iy)                   ; CP (IY+5)         ; If x-coordinate of Drutt's left side is greater than this (i.e. Drutt is to the right of
                                                           ; Berk)...
       jl   _35670                     ; JR C,35670        ; ...then skip ahead to #R35670
* Drutt is between Berk's left and right sides
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Drutt's depth is 1...
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; JP Z,35642        ; ...then skip ahead to #R35642
       b    @_35642                    ;                   
!
* Drutt is behind Berk
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,14*256                   ; AND 14            ; If Berk's Facing into Screen, Facing Left and Facing Right flags are all reset...
       jne  !                          ; JP Z,35636        ; ...then skip ahead to #R35636
       b    @_35636                    ;                   
!
* Drutt is behind Berk and at least one of Berk's Facing into Screen, Facing Left and Facing Right flags is set
       b    @_35815                    ; JP 35815          ; Point HL at script data for Berk facing into screen, ready to respond to control input and
                                                           ; execute
* Drutt is behind Berk and Berk's Facing into Screen, Facing Left and Facing Right flags are all reset
_35636:
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is in front of Berk
_35642:
       movb @e,tmp0                    ; BIT 1,E           ; If Berk's Facing into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jne  !                          ; JP Z,35821        ; ...then point HL at script data for Berk facing out of screen, ready to respond to control
       b    @_35821                    ;                   
!
                                                           ; input and execute
* Drutt is in front of Berk and Berk's Facing into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk
_35653:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,6*256                    ; AND 6             ; If either of Berk's Facing into Screen or Facing Left flags are set...
       jne  _35664                     ; JR NZ,35664       ; ...then skip ahead to #R35664
* Drutt is to the left of Berk, and Berk's Facing into Screen and Facing Left flags are both reset
       li   hl,_34977                  ; LD HL,34977       ; Point HL at script data for Berk turning to face left...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk and either of Berk's Facing into Screen or Facing Left flags are set
_35664:
       li   hl,_34985                  ; LD HL,34985       ; Point HL at script data for Berk facing left...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk
_35670:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,10*256                   ; AND 10            ; If either of Berk's Facing into Screen or Facing Right flags are set...
       jne  _35681                     ; JR NZ,35681       ; ...then skip ahead to #R35681
* Drutt is to the right of Berk, and Berk's Facing into Screen and Facing Right flags are both reset
       li   hl,_34997                  ; LD HL,34997       ; Point HL at script data for Berk turning to face right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk and either of Berk's Facing into Screen or Facing Right flags are set
_35681:
       li   hl,_35005                  ; LD HL,35005       ; Point HL at script data for Berk facing right...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Update State of Berk and Store Current Position in Script Data
* 
* Used by the routine at #R34438.
update_berk_state:
       .proc
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Berk's current room
       movb @9(ix),tmp0                ; BIT 5,(IX+9)      ; If Berk's "Do Not Update State" Flag is set...
       andi tmp0,32*256                ;                   
       jne  update_berk_state_1        ; RET NZ            ; ...then return
       mov  @berk_script_pos,hl        ; LD HL,(35687)     ; Load current position in Berk's script data from #R35687 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .call @update_berk_state_2      ; CALL 35735        ; Update state of Berk depending upon currently selected character, control input and currently
                                                           ; active power
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@berk_script_pos        ; LD (35687),HL     ; ...at #R35687 as current position in Berk's script data
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk's current power is not invisibility (level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jne  update_berk_state_1        ; RET NZ            ; ...then return
* Current power is invisibility (Level 3)
       li   bc,_50800                  ; LD BC,50800       ; Load BC with address of blank graphic layout data...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as Berk's current graphic layout data address...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       .call @_48388                   ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
update_berk_state_1:
       .endproc                        ; RET               ; Return

* Update State of Berk Depending Upon Currently Selected Character, Control Input and Currently Active Power
* 
* Used by the routine at #R35689. Input:  IX  Address of complex state data (current level) for Berk
update_berk_state_2:
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If Berk's Moving Upwards Flag (floating power) is set...
       andi tmp0,128*256               ;                   
       jeq  !                          ; JP NZ,36542       ; ...then jump to #R36542 (update state of Berk,  floating power active)
       b    @update_berk_floating_power                    ;
!
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is set...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,35577       ; ...then jump to #R35577 (change direction Berk is facing depending upon relative position of
       b    @change_berk_direction                    ;
!
                                                           ; Drutt)
* Drutt Mode Flag is reset (i.e. Berk Mode)
       movb @control_input,a                  ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,36214       ; ...then skip ahead to #R36214 (move Berk right if appropriate)
       b    @_36214                    ;                   
!
       movb a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,36137       ; ...then skip ahead to #R36137 (move Berk left if appropriate)
       b    @_36137                    ;                   
!
       bl   @move_into_new_room        ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; JP NZ,36036       ; ...then skip ahead to #R36036 (update state of Berk, forward pressed)
       b    @_36036                    ;                   
!
       movb a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8*256                 ;                   
       jeq  !                          ; JP NZ,35827       ; ...then skip ahead to #R35827
       b    @_35827                    ;                   
!
* At this point, no control has been pressed. This entry point is used by the routines at #R35577, #R36036 and
* #R36116.
_35786:
       equ  $
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is not flying...
       andi tmp0,64*256                ;                   
       jeq  _35802                     ; JR Z,35802        ; ...then skip ahead to #R35802
* Berk is flying
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset Berk's Is Flying Flag
       li   hl,_35359                  ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script                    ; JP 48098          ; ...and execute
* No control pressed and Berk not flying
_35802:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _35821                     ; JR Z,35821        ; ...then skip ahead to #R35821
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is set
       movb @11(ix),tmp0               ; BIT 3,(IX+11)     ; If Berk's Unused (11,3) Flag is reset...
       andi tmp0,8*256                 ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
* No control pressed, Berk not flying, Berk's Facing Into Screen and Unused (11,3) flags are set This entry point is
* used by the routine at #R35577.
_35815:
       equ  $
       li   hl,_35113                  ; LD HL,35113       ; Point HL at script data for Berk facing into screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is reset This entry point is used by the
* routine at #R35577.
_35821:
       li   hl,_35081                  ; LD HL,35081       ; Point HL at script data for Berk facing out of screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* Back Pressed
_35827:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       .call @_36008                   ; CALL 36008        ; If Berk is holding an edible entity them make him eat it, process appropriate script data
                                                           ; and return to calling routine
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Temporarily decrease y-coordinate of Berk's top edge
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                       ; into screen whose Interaction (11,7) Flag is set
       stst tmp0                       ; PUSH AF           ; Store AF
       ab   one,@4(ix)                 ; INC (IX+4)        ; Restore y-coordinate of Berk's top edge
       andi tmp0,>1000                 ; POP AF            ; Restore AF
       jne  _35953                     ; JR C,35953        ; If no collision occurred, then skip ahead to #R35953
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  _35870                     ; JR NZ,35870       ; ...then skip ahead #R35870
* Collision with door
       .call @_36116                   ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       .call @_36367                   ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of complex state data for door at #R34256
       li   hl,_35017                  ; LD HL,35017       ; Point HL at script data for Berk interacting with a door behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
_35870:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  _35924                     ; JR NC,35924       ; ...then skip ahead to #R35924
* Collision with entity that can be picked up
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is already carrying something...
       andi tmp0,16*256                ;                   
       jeq  !                          ; JP NZ,35953       ; ...then skip ahead to #R35953
       b    @_35953                    ;                   
!
       .call @_36116                   ; CALL 36116        ; If Berk is not horizontally aligned with entity then move him closer and exit this routine
* Berk is now horizontally aligned with entity pointed to by IY
       .call @_36367                   ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of complex state data for entity at #R34256
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Berk's bottom edge...
       sb   one,b                      ; DEC B             ; ...minus 1 (to take into account different depth)
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of entity's bottom edge...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...and if this is less than the y-coordinate of Berk's top edge...
       jl   _35918                     ; JR C,35918        ; ...then skip ahead to #R35918
* Entity is not above Berk
       cb   a,b                        ; CP B              ; If entity's bottom edge is level with Berk's (taking into account different depth)...
       jeq  _35912                     ; JR Z,35912        ; ...then skip ahead to #R35912
* Entity is above floor and below Berk's top edge
       li   hl,_35163                  ; LD HL,35163       ; Point HL at script data for Berk picking up an entity that is above floor and below Berk's
                                                           ; top edge and behind him...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Entity is on floor behind Berk
_35912:
       li   hl,_35135                  ; LD HL,35135       ; Point HL at script data for Berk picking up an entity on floor behind him...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Entity is above Berk
_35918:
       li   hl,_35149                  ; LD HL,35149       ; Point HL at script data for Berk picking up an entity above and behind him...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Collision with something that can't be picked up
_35924:
       cb   a,@bytes+32                ; CP 32             ; If collision was not with entity of class 32 (coloured creatures' slots, Level 3)...
       jne  _35953                     ; JR NZ,35953       ; ...then skip ahead to #R35953
* Collision with a coloured creature slot
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jeq  _35953                     ; JR Z,35953        ; ...then skip ahead to #R35953
* Berk is carrying something
       .call @_36116                   ; CALL 36116        ; If Berk is not horizontally aligned with coloured creature slot then move him closer and
                                                           ; exit this routine
* Berk is now horizontally aligned with coloured creature slot and carrying something
       .call @_36367                   ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       movb @4(iy),a                   ; LD A,(IY+4)       ; Load A with y-coordinate of top edge of coloured creature slot... (see trivia)
       sb   one,a                      ; DEC A             ; ...minus 1...
       movb a,@_34222                  ; LD (34222),A      ; ...and store at #R34222
       li   hl,_35235                  ; LD HL,35235       ; Point HL at script data for Berk putting an entity down above floor behind him...
       b    @execute_script                    ; JP 48098          ; ...and execute
* No collision, collision with non-interactive entity or interaction conditions not met
_35953:
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  _35969                     ; JR Z,35969        ; ...then skip ahead to #R35969
       cb   a,@bytes+4                 ; CP 4              ; If Berk's current power is 1-3 (jumping)...
       jhe  !                          ; JP C,35995        ; ...then skip ahead to #R35995
       b    @_35995                    ;                   
!
       cb   a,@bytes+9                 ; CP 9              ; If Berk's current power is 4-8 (flying)...
       jhe  !                          ; JP C,35985        ; ...then skip ahead to #R35985
       b    @_35985                    ;                   
!
* Berk has neither jumping nor flying power
_35969:
       equ  $
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen
       b    @_35786                    ;                   
!
                                                           ; as appropriate)
* Berk is carrying something
       .call @_36367                   ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       li   hl,_35219                  ; LD HL,35219       ; Point HL at script data for Berk putting an entity down on floor behind him...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Berk's current power is flying
_35985:
       socb @bits+6,@9(ix)             ; SET 6,(IX+9)      ; Set Berk's Is Flying Flag
       li   hl,_35417                  ; LD HL,35417       ; Point HL at script data for Berk starting to fly...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Berk's current power is jumping
_35995:
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @bytes+129,@12(ix)         ; LD (IX+12),129    ; Set Berk's Is Jumping Flag and set initial jump velocity to 1
       li   hl,_35441                  ; LD HL,35441       ; Point HL at script data for Berk starting to jump straight up...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Make Berk Eat the Entity He is Holding, if Edible, and Exit Calling Routine
* 
* Used by the routine at #R35735.
_36008:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       cb   a,@bytes+12                ; CP 12             ; If class value of entity held by Berk is greater than 12...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       .call @_48710                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move entity up one character to level of Berk's mouth...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       li   hl,_35493                  ; LD HL,35493       ; Point HL at script data for Berk eating an entity...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Update State of Berk (Forward Pressed)
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_36036:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jne  !                          ; JP Z,36049        ; ...then skip ahead to #R36049
       b    @_36049                    ;                   
!
* Berk's Facing Into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Berk's Facing Into Screen Flag is reset
_36049:
       li   de,0                       ; LD DE,0           ; Clear pointer to complex state data for entity involved in last collision check...
       mov  de,@coll_entity_addr       ; LD (34258),DE     ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _36103                     ; JR C,36103        ; ...and if no collision occurred, then skip ahead to #R36103
* Collision occurred
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  _36078                     ; JR NZ,36078       ; ...then skip ahead to #R36078
* Collision with door
       .call @_36116                   ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of door's complex state data at #R34256
       li   hl,_35045                  ; LD HL,35045       ; Point HL at script data for Berk interacting with a door in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
_36078:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is set...
       andi tmp0,16*256                ;                   
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; JP NC,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
* At this point, Berk is not carrying anything, and the entity he is colliding with is one which can be picked up
       .call @_36116                   ; CALL 36116        ; If Berk is not horizontally aligned with entity at IY then move him closer and exit this
                                                           ; routine
* Berk is now horizontally aligned with entity pointed to by IY
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of entity's complex state data at #R34256
       li   hl,_35187                  ; LD HL,35187       ; Point HL at script data for Berk picking up an entity on floor in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision occurred
_36103:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @_35786                    ;                   
!
                                                           ; appropriate)
* Berk is carrying something
       li   hl,_35205                  ; LD HL,35205       ; Point HL at script data for Berk putting an entity down on floor in front of him...
       b    @execute_script                    ; JP 48098          ; ...and execute

* If Berk is Not Horizontally Aligned with Entity at IY then Move Berk Closer and Exit Calling Routine
* 
* Used by the routines at #R35735 and #R36036. Input:  IX  Address of complex state data (current level) for Berk IY
* Address of complex state data for entity with which Berk has collided
_36116:
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of entity at IY, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; ...divide value by 2...
       sb   @bytes+2,a                 ; SUB 2             ; ...and subtract 2
       ab   @5(iy),a                   ; ADD A,(IY+5)      ; Add result to x-coordinate of entity's left edge
* At this point, A holds the x-coordinate of the middle of the entity at IY, minus two
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate in A is the same as Berk's left side x-coordinate...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       cb   a,@5(ix)
       jl   _36137                     ; JP NC,36214       ; If x-coordinate in A is the less than Berk's left side x-coordinate then skip ahead to
       b    @_36214                    ;                   ; #R36214

* This entry point is used by the routine at #R35735. Attempt to move Berk left
_36137:
       equ  $
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jne  _36200                     ; JR NZ,36200       ; ...then skip ahead to #R36200
* Attempt to move Berk left (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  _36171                     ; JR NC,36171       ; ...and if a collision occurred, then skip ahead to #R36171
* No collision
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk into room to the left, if appropriate...
       joc  !                          ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @_35786                    ;                   
!
                                                           ; him (turn to) face out of screen as appropriate)
_36158:
       equ  $
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is already set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_35263                  ; LD HL,35263       ; Point HL at script data for Berk starting to walk left...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Collision occurred with entity to the left
_36171:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  _36184                     ; JR NZ,36184       ; ...then skip ahead to #R36184
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   hl,_35291                  ; LD HL,35291       ; Point HL at script data for Berk starting to fall to the left...
       b    @execute_script                    ; JP 48098          ; ...and execute
_36184:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   _36158                     ; JR C,36158        ; ...then jump back to #R36158
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _36158                     ; JR Z,36158        ; ...then jump back to #R36158
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk left (flying)
_36200:
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* This entry point is used by the routine at #R35735. Attempt to move Berk right
_36214:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jeq  !                          ; JP NZ,36282       ; ...then skip ahead to #R36282
       b    @_36282                    ;                   
!
* Attempt to move Berk right (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _36249                     ; JR NC,36249       ; ...and if a collision occurred, then skip ahead to #R36249
* No collision
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk into room to the right, if appropriate...
       joc  !                          ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @_35786                    ;                   
!
                                                           ; him (turn to) face out of screen as appropriate)
_36236:
       equ  $
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is already set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_35251                  ; LD HL,35251       ; Point HL at script data for Berk starting to walk right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Collision occurred with entity to the right
_36249:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  _36266                     ; JR NZ,36266       ; ...then skip ahead to #R36266
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk (see trivia)
       li   hl,_35327                  ; LD HL,35327       ; Point HL at script data for Berk starting to fall to the right...
       b    @execute_script                    ; JP 48098          ; ...and execute
_36266:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   _36236                     ; JR C,36236        ; ...then jump back to #R36236
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _36236                     ; JR Z,36236        ; ...then jump back to #R36236
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk right (flying)
_36282:
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script                    ;                   
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       b    @_35786                    ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)

* Make Berk Drop the Entity He is Holding and Load IY with its Complex State Data Address
* 
* Used by the routines at #R35735, #R36116, #R36390, #R36638, #R39151, #R39278, #R39776, #R48920 and #R53723. Input:
* IX  Address of complex state data (current level) for Berk Output: IY  Address of complex state data for entity
* dropped by Berk
_36296:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       movb a,@_34221                  ; LD (34221),A      ; ...
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set this dropped entity's velocity factor to 2...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...reset its Is Being Carried Flag...
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; ...and set its Can Fall Flag
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is reset...
       andi tmp0,1*256                 ;                   
       jeq  _36339                     ; JR Z,36339        ; ...then skip ahead to #R36339
_36331:
       ab   one,@7(iy)                 ; INC (IY+7)        ; Move dropped entity right one character...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...
       jmp  _36351                     ; JR 36351          ; Skip ahead to #R36351
_36339:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _36351                     ; JR Z,36351        ; ...then skip ahead to #R36351
_36345:
       sb   one,@7(iy)                 ; DEC (IY+7)        ; Move dropped entity left one character...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...
_36351:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If entity at IY has the x-coordinate of its left side less than 100...
       cb   a,@bytes+100               ; CP 100            ; ...
       jl   _36331                     ; JR C,36331        ; ...then move right until left x-coordinate is 100
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 99
       cb   a,@7(iy)                   ; CP (IY+7)         ; If entity at IY has the x-coordinate of its right side greater than the width of the current
                                                           ; room...
       jl   _36345                     ; JR C,36345        ; ...then move right until left x-coordinate is less than room width
       .ret                            ; RET               ; Return

* If Berk is Neither Facing into the Screen nor Walking then Exit Calling Routine and Have Berk Turn into Screen
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
_36367:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @11(ix),a                  ; LD A,(IX+11)      ; If either of Berk's Walking Left or Walking Right flags is set...
       andi a,3*256                    ; AND 3             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (59) Have Berk Interact Appropriately with a Door Behind Him Output: BC  Address of script data to
* execute upon arrival of new level
script_routine_59:
       li   bc,_35113                  ; LD BC,35113       ; Load BC with address of script data for Berk facing into screen, ready to respond to control
                                                           ; input
       jmp  _36393                     ; JR 36393          ; Have Berk interact appropriately with a door

* Script Routine (58) Have Berk Interact Appropriately with a Door in Front of Him Input:  BC  (entry at #R36393
* only) Address of script data to execute upon arrival of new level
script_routine_58:
       li   bc,_35081                  ; LD BC,35081       ; Load BC with address of script data for Berk facing out of screen, ready to respond to
                                                           ; control input
* This entry point is used by the routine at #R36385.
_36393:
       mov  bc,@_34266                 ; LD (34266),BC     ; Store script data address in BC at #R34266
       movb @game_flags,a              ; LD A,(34208)      ; Load E with Game Flags...
       movb a,@e                       ; LD E,A            ; ...
       movb @_34221,a                  ; LD A,(34221)      ; Load A with class of entity currently held by Berk...
       cb   a,@bytes+17                ; CP 17             ; ... and if this is not 17 (Key)...
       jne  _36429                     ; JR NZ,36429       ; ...then skip ahead to #R36429
* Berk is holding a key
       movb @bytes+7,a                 ; LD A,7            ; Set door colour to 7 (white, i.e. unlocked)...
       movb a,@_50711+1                ; LD (50712),A      ; ...
       .call @_36296                   ; CALL 36296        ; Make Berk drop the key and load IY with its complex state data address
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set depth of key to 0 (i.e. out of display)
       socb @bits+4,@e                 ; SET 4,E           ; Set Level Exit Door Unlocked Flag...
       movb @e,a                       ; LD A,E            ; ...
       movb a,@game_flags                  ; LD (34208),A      ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
* Berk is not holding a key
_36429:
       movb @e,tmp0                    ; BIT 4,E           ; If Level Exit Door Unlocked Flag is reset...
       andi tmp0,16*256                ;                   
       jeq  _36462                     ; JR Z,36462        ; ...then skip ahead to #R36462
       movb a,d                        ; LD D,A            ; Load D with class of entity currently held by Berk
       movb @current_level,a           ; LD A,(34207)      ; Set Zero Flag if current level is Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       movb d,a                        ; LD A,D            ; Load A with class of entity currently held by Berk
       jne  _36446                     ; JR NZ,36446       ; If Zero Flag is not set (i.e. we are not on Level 4) then skip ahead to #R36446
* Level 4
       cb   a,@bytes+19                ; CP 19             ; Set Zero Flag if class of entity currently held by Berk is 19 (Boni)
       jmp  _36448                     ; JR 36448          ; Skip ahead to #R36448
* Not Level 4
_36446:
       cb   a,@bytes+18                ; CP 18             ; Set Zero Flag if class of entity currently held by Berk is 18 (Drutt)
_36448:
       jne  _36462                     ; JR NZ,36462       ; If Zero Flag is not set (i.e. Berk is not holding Drutt on Levels 1-3 or Boni on Level 4)
                                                           ; then skip ahead to #R36462
* Berk is holding the correct character
       .call @_48417                   ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       .call @_36638                   ; CALL 36638        ; Advance to next level and if back to Level 1 then exit this routine and make Berk start
                                                           ; falling
* New level is not Level 1
       mov  @_34266,hl                 ; LD HL,(34266)     ; Load HL with script data address stored at #R34266...
       b    @execute_script            ; JP 48098          ; ...and execute
* Door is locked or Berk is not holding the correct character
_36462:
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (56) Give Berk Power Corresponding to Entity Eaten Input:  IX  Address of complex state data
* (current level) for Berk
script_routine_56:
       .call @_48417                   ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original state
       movb @_34221,a                  ; LD A,(34221)      ; Set current power value to class of entity currently held by Berk...
       movb a,@berks_current_power                  ; LD (34220),A      ; ...
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. none)...
       movb a,@_34221                  ; LD (34221),A      ; ...
       movb a,@remaining_power_cycles  ; LD (34224),A      ; Set number of elapsed game-cycles in current block to zero
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       mov  @bert_held_state,iy                 ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       movb a,@1(iy)                   ; LD (IY+1),A       ; ...and set its depth to zero (i.e. outside room)
       movb @10(iy),a                  ; LD A,(IY+10)      ; Initialise remaining duration of power to value encoded entity's complex state data (bits
                                                           ; 0-4)...
       andi a,31*256                   ; AND 31            ; ...
       movb a,@remaining_power_groups  ; LD (34225),A      ; ...
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk's current power is not floating (Level 3)...
       cb   a,@bytes+10                ; CP 10             ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
* Power is floating
       movb @bytes+12,@12(ix)          ; LD (IX+12),12     ; Set distance Berk will be pushed by Drutt while floating to 12
       socb @bits+7,@9(ix)             ; SET 7,(IX+9)      ; Set Berk's Moving Upwards Flag
       movb @bytes+240,@11(ix)         ; LD (IX+11),240    ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags, and set his
                                                           ; Impassable Leftwards, Impassable Rightwards, Interaction (11,6) and Interaction (11,7) flags
       socb @bits+7,@8(ix)             ; SET 7,(IX+8)      ; Set bit 7 of Berk's class value (i.e. set "Spans Full Depth" Flag)
       ab   one,@6(ix)                 ; INC (IX+6)        ; Increase y-coordinate of Berk's bottom edge by two characters...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
_36536:
       li   hl,_35515                  ; LD HL,35515       ; Point HL at script data for Berk gaining floating power...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Update State of Berk (Floating Power Active)
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
update_berk_floating_power:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jeq  _36558                     ; JR Z,36558        ; ...then skip ahead to #R36558
* No collision with entity of class 130
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move Berk up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       .call @change_room_up                   ; CALL 55433        ; Change Berk's room up one if appropriate
_36558:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is set...
       andi tmp0,2*256                 ;                   
       jne  _36587                     ; JR NZ,36587       ; ...then skip ahead to #R36587
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is set...
       andi tmp0,1*256                 ;                   
       jne  _36576                     ; JR NZ,36576       ; ...then skip ahead to #R36576
       .call @_48388                   ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
* Berk's Walking Right Flag is set (i.e. Drutt has pushed Berk right)
_36576:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk's left and right sides right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk at IX into room to the right, if appropriate
       jmp  _36596                     ; JR 36596          ; Skip ahead to #R36596
* Berk's Walking Left Flag is set (i.e. Drutt has pushed Berk left)
_36587:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk's left and right sides left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk at IX into room to the left, if appropriate
_36596:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining horizontal distance from Drutt's push...
       jeq  !                          ; JP NZ,48096       ; ...and if not zero then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       movb one,a                      ; LD A,1            ; Set remaining power duration to 1...
       movb a,@remaining_power_groups  ; LD (34225),A      ; ...
       b    @script_routine_10         ; JP 48212          ; Reset Berk's Walking Left and Walking Right flags, advance HL to next script instruction and
                                                           ; execute

* Script Routine (57) Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
script_routine_57:
       .call @_36616                   ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Cycle Attributes (Full-Screen), Clear Display Buffers and Paint Red Areas Outside Current Room
* 
* Used by the routines at #R36610, #R39584 and #R39760.
_36616:
       .push hl                        ; PUSH HL           ; Store HL
       bl   @cycle_attributes_short    ; CALL 53581        ; Cycle Attributes (Full-Screen) and Clear Display Buffers
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
       .ret                            ; RET               ; Return

* Advance to Next Level and if Back to Level 1 then Exit Calling Routine and Make Berk Start Falling
* 
* Used by the routine at #R36390.
_36638:
       movb @game_flags,a              ; LD A,(34208)      ; Set Update Scores and Display Flag...
       socb @bits+5,a                  ; SET 5,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       mov  @bert_interaction_state,iy ; LD IY,(34256)     ; Load IY with address of complex state data for Door just interacted with
       movb @9(iy),a                   ; LD A,(IY+9)       ; Load A with destination level from Door's state data...
       movb a,@current_level           ; LD (34207),A      ; ...and set current level to this value
       cb   a,one                      ; CP 1              ; If destination level is not Level 1...
       jne  _36725                     ; JR NZ,36725       ; ...then skip ahead to #R36725
* Destination level is Level 1 (i.e. Level 4 completed)
       .call @_36753                   ; CALL 36753        ; Load IX with address of Berk's complex state data and set his horizontal position to match
                                                           ; Level 1's entry door
       socb @bits+2,@10(ix)            ; SET 2,(IX+10)     ; Set "Back to Level 1" Flag
       movb @bytes+10,*ix              ; LD (IX+0),10      ; Set Berk's room to 10
       movb @bytes+103,@4(ix)          ; LD (IX+4),103     ; Set y-coordinate of Berk's top edge to 103
       movb @bytes+109,@6(ix)          ; LD (IX+6),109     ; Set y-coordinate of Berk's bottom edge to 109
       li   iy,bonis_state_data_1                  ; LD IY,43606       ; Load IY with address of Boni's entry in Level 1's State Data for Complex Entities...
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       .call @_48850                   ; CALL 48850        ; Have Berk hold Boni, and position him appropriately between Berk's hands
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       movb @bytes+10,*iy              ; LD (IY+0),10      ; Set Boni's room to 10
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       .call @_55516                   ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
       .call @_36739                   ; CALL 36739        ; Lock Level 1's exit door and cycle attributes (full-screen)
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,init_drutts_state_data_1 ; LD HL,36625       ; Overwrite Drutt's entry in Level 1's State Data for Complex Entities with data at #R36625...
       li   de,drutts_state_data_1     ; LD DE,43671       ; ...
       li   bc,13                      ; LD BC,13          ; ...
       .ldir                           ; LDIR              ; ...
       li   hl,_35359                  ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script            ; JP 48098          ; ...and execute
* Destination level is not Level 1
_36725:
       .call @_36753                   ; CALL 36753        ; Set Berk's horizontal position to match Level 1's entry door
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt...
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       .call @_48850                   ; CALL 48850        ; Have Berk hold Drutt, and position him appropriately between Berk's hands
_36739:
       li   hl,game_flags              ; LD HL,34208       ; Reset Level Exit Door Unlocked Flag...
       szcb @bits+4,*hl                ; RES 4,(HL)        ; ...
       movb @bytes+5,a                 ; LD A,5            ; Set door colour to 5 (cyan, i.e. locked)...
       movb a,@_50711+1                ; LD (50712),A      ; ...
       .call @_36616                   ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       .ret                            ; RET               ; Return

* Set Berk's Horizontal Position to Match Level 1's Entry Door
* 
* Used by the routine at #R36638.
_36753:
       bl   @init_level_data           ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       movb @bytes+33,a                ; LD A,33           ; Load IY with address of complex state data for first entity that has class of 33 (Entry
                                                           ; Door)...
       .call @_54019                   ; CALL 54019        ; ...
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with start address of current level's complex state data for Berk
       movb @5(iy),a                   ; LD A,(IY+5)       ; Load A with x-coordinate of left of Entry Door...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@5(ix)                   ; LD (IX+5),A       ; Adjust Berk's horizontal position so that his left side is at coordinate in A...
       ab   @bytes+5,a                 ; ADD A,5           ; ...and his right side is 5 characters to the right of this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       .ret                            ; RET               ; Return

* Initialise Script Data Positions for Flying Skeleton Creature and Bat (Level 1)
* 
* Used by the routine at #R34751.
_36778:
       li   hl,boni_kidnap_script      ; LD HL,36803       ; Load HL with start address of script data for Boni's kidnap...
       mov  hl,@boni_kidnap_script_pos ; LD (36801),HL     ; ...and store this as the current script data position at #R36801
       li   hl,bat_script              ; LD HL,37018       ; Load HL with start address of script data for Bat (not attacking)...
       mov  hl,@bat_script_pos         ; LD (37016),HL     ; ...and store this as the current script data position at #R37016
       .ret                            ; RET               ; Return

* Update States of All Level 1 Entities
* 
* Used by the routine at #R34438.
update_level_1_entities:
       .proc
       .call @execute_bonis_kidnap     ; CALL 36887        ; Execute script data for Boni's kidnap and handle Trap Door opening and closing
       .call @_37062                   ; CALL 37062        ; Update state of Bat (Level 1) and store current position in script data
       .call @_37586                   ; CALL 37586        ; Update states of the Spiders (Level 1) and store current positions in script data
       .endproc                        ; RET               ; Return

* Execute Script Data for Boni's Kidnap and Handle Trap Door Opening and Closing
* 
* Used by the routine at #R36791.
execute_bonis_kidnap:
       li   ix,_43619                  ; LD IX,43619       ; Load IX with address of complex state data for Flying Skeleton Creature
       movb @_43619+9,a                ; LD A,(43628)      ; If Berk and Drutt Through Trap Door Flag is set...
       movb a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb a,tmp0                     ; BIT 2,A           ; If Trap Door Opened Flag is set...
       andi tmp0,4*256                 ;                   
       jne  _36966                     ; JR NZ,36966       ; ...then jump to #R36966 (close the Trap Door if Berk is not in room 1 and Drutt is in room 4)
       movb a,tmp0                     ; BIT 1,A           ; If creature's Inactive Flag is set...
       andi tmp0,2*256                 ;                   
       jne  _36921                     ; JR NZ,36921       ; ...then jump to #R36921 (open the Trap Door if Berk is near the left side of the Trap Door
                                                           ; room)
       mov  @boni_kidnap_script_pos,hl ; LD HL,(36801)     ; Load current position in script data for Boni's kidnap from #R36801 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .call @_36947                   ; CALL 36947        ; Advance HL to next script instruction and start executing
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@boni_kidnap_script_pos ; LD (36801),HL     ; ...at #R36801 as current position in script data for Boni's kidnap
       .ret                            ; RET               ; Return

* Open Trap Door if Berk is Near the Left Side of the Trap Door Room
* 
* Used by the routine at #R36887. Input:  IX  Address of complex state data for Flying Skeleton Creature (Level 1)
_36921:
       li   iy,berks_state_data_1                  ; LD IY,43593       ; Load IY with address of complex state data for Berk (Level 1)
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of Berk's left side is 104 or greater...
       cb   a,@bytes+104               ; CP 104            ; ...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Trap Door Opened Flag
       sb   a,a                        ; XOR A             ; Set room of "Closed Trap Door" to 0 (i.e. remove from Trap Door Room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       ab   one,a                      ; INC A             ; Increase A to 1 (index of Trap Door Room)...
       movb a,@_43437                  ; LD (43437),A      ; ...and set this as the current room of "Open Trap Door"...
       movb a,@_43450                  ; LD (43450),A      ; ...and marker (preventing Berk and Drutt passing door lid)
       .ret                            ; RET               ; Return

* Advance HL to Next Script Instruction and Start Executing
* 
* Used by the routine at #R36887.
_36947:
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (36) Remove Boni from Level 1
script_routine_36:
       sb   a,a                        ; XOR A             ; Set Boni's room (Level 1) to zero...
       movb a,@bonis_state_data_1                  ; LD (43606),A      ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (37) Remove Flying Skeleton Creature from Level 1, and Terminate Script Processing Input:  IX
* Address of complex state data for an entity
script_routine_37:
       sb   a,a                        ; XOR A             ; Set current room of Flying Skeleton Creature (Level 1) to zero...
       movb a,@_43619                  ; LD (43619),A      ; ...
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Flying Skeleton Creature's Inactive Flag
       .ret                            ; RET               ; Return (i.e. terminate further script processing)

* Close the Trap Door if Berk is Not in Room 1 and Drutt is in Room 4 (Level 1)
* 
* See bugs.
_36966:
       movb @berks_state_data_1,a                  ; LD A,(43593)      ; If Berk's current room (Level 1) is 1 (i.e. Trap Door Room)...
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       movb @drutts_state_data_1,a                  ; LD A,(43671)      ; If Drutt's current room is not 4 (room at bottom of Trap Door Shaft)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       socb @bits+3,@9(ix)             ; SET 3,(IX+9)      ; Set Berk and Drutt Through Trap Door Flag
       jmp  _36996                     ; JR 36996          ; Close the Trap Door and return

* Script Routine (38) Close the Trap Door
script_routine_38:
       .call @_36996                   ; CALL 36996        ; Close the Trap Door
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (39) Open the Trap Door
script_routine_39:
       .call @_37004                   ; CALL 37004        ; Open the Trap Door
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Close the Trap Door
* 
* Used by the routines at #R36966 and #R36984.
_36996:
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" to 1 (i.e. Trap Door Room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       sb   one,a                      ; DEC A             ; Decrease A to zero
       jmp  _37009                     ; JR 37009          ; Set room of "Open Trap Door" to 0

* Open the Trap Door
* 
* Used by the routine at #R36990.
_37004:
       sb   a,a                        ; XOR A             ; Set room of "Closed Trap Door" to 0 (i.e. remove from Trap Door Room)...
       movb a,@_43188                  ; LD (43188),A      ; ...
       ab   one,a                      ; INC A             ; Increase A to 1 (index of Trap Door Room)
* This entry point is used by the routine at #R36996.
_37009:
       movb a,@_43437                  ; LD (43437),A      ; Set value in A as the current room of "Open Trap Door"...
       movb a,@_43450                  ; LD (43450),A      ; ...and marker (preventing Berk and Drutt passing door lid)
       .ret                            ; RET               ; Return

* Update State of Bat (Level 1) and Store Current Position in Script Data
* 
* Used by the routine at #R36791.
_37062:
       li   ix,_43463                  ; LD IX,43463       ; Point IX at position data for Bat (Level 1)
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Bat's room
       mov  @bat_script_pos,hl         ; LD HL,(37016)     ; Load current position in Bat's script data from #R37016 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .call @_37085                   ; CALL 37085        ; Update state of Bat
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@bat_script_pos         ; LD (37016),HL     ; ...at #R37016 as current position in Bat's script data
       .ret                            ; RET               ; Return

* Update State of Bat (Level 1)
* 
* Used by the routine at #R37062. Input:  IX  (always #R43463, entry in Level 1 complex state data for Bat) HL
* Current position in Bat's script data
_37085:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _37104                     ; JR C,37104        ; ...and if no collision occurred, then skip ahead to #R37104
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _37100                     ; JR NZ,37100       ; ...then skip ahead to #R37100
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_37100:
       cb   a,@bytes+18                ; CP 18             ; If collision was with entity of class 18 (Drutt)...
       jeq  _37111                     ; JR Z,37111        ; ...then skip ahead to #R37111
_37104:
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                                           ; into screen whose Interaction (11,7) Flag is set...
       cb   a,@bytes+18                ; CP 18             ; ...and if collision was not with entity of class 18 (Drutt)...
       jne  _37128                     ; JR NZ,37128       ; ...then skip ahead to #R37128
_37111:
       movb @10(iy),tmp0               ; BIT 6,(IY+10)     ; If Drutt's Can Fall Flag is set...
       andi tmp0,64*256                ;                   
       jne  _37128                     ; JR NZ,37128       ; ...then skip ahead to #R37128
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set Drutt's Can Fall Flag
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set Drutt's Velocity Factor to 2
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
_37128:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Bat's Paralysed Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is set...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jne  _37148                     ; JR NZ,37148       ; ...then skip ahead to #R37148
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       jmp  _37152                     ; JR 37152          ; Skip ahead to #R37152
_37148:
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt
* At this point, IY points to the complex state data entry for the current character.
_37152:
       movb *iy,a                      ; LD A,(IY+0)       ; If current character's current room is not the same as the Bat's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the current character's right side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the Bat's left side...
       jl   _37194                     ; JR C,37194        ; ...then skip ahead to #R37194
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the Bat's right side...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the current character's left side...
       jl   _37183                     ; JR C,37183        ; ...then skip ahead to #R37183
       li   hl,_37024                  ; LD HL,37024       ; Point HL at script data for Bat attacking...
       b    @execute_script                    ; JP 48098          ; ...and execute
_37183:
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the x-coordinate of the Bat's right side is less than 130...
       cb   a,@bytes+130               ; CP 130            ; ...
       jhe  !                          ; JP C,48615        ; ...then move Bat right by one character
       b    @script_routine_03                    ;                   
!
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
_37194:
       movb @bytes+101,a               ; LD A,101          ; If the x-coordinate of the Bat's left side is greater than 101...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jhe  !                          ; JP C,48660        ; ...then move Bat left by one character
       b    @script_routine_02                    ;                   
!
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Update the States of the Spiders (Level 1) and Store Current Positions in Script Data
* 
* Used by the routine at #R36791.
_37586:
       li   ix,_43749                  ; LD IX,43749       ; Load IX with address of complex state data for Spider 1 (Level 1)
       li   iy,_37580                  ; LD IY,37580       ; Load IY with start address of Table of Current Positions in Spiders' Script Data
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 as there are 3 spiders
_37596:
       movb *iy,@l                     ; LD L,(IY+0)       ; Load HL with current position in script data for current spider...
       movb @1(iy),h                   ; LD H,(IY+1)       ; ...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .push ix                        ; PUSH IX           ; Store IX
       .push iy                        ; PUSH IY           ; Store IY
       .push bc                        ; PUSH BC           ; Store BC
       .call @_37639                   ; CALL 37639        ; Update the state of the current spider (Level 1)
       .pop bc                         ; POP BC            ; Restore BC
       .pop iy                         ; POP IY            ; Restore IY
       .pop ix                         ; POP IX            ; Restore IX
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data for current spider) stored at #R34277...
       movb @l,*iy                     ; LD (IY+0),L       ; ...in table at #R37580 as current position in this spider's script data...
       movb h,@1(iy)                   ; LD (IY+1),H       ; ...
       inc  iy                         ; INC IY            ; Advance IY to next entry in table (i.e. position in next spider's script data)...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX by 13 bytes (i.e. to entry for next spider)...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 37596        ; Decrease B (remaining number of spiders to process) and loop back to #R37596
       jne  _37596                     ;                   
       .ret                            ; RET               ; Return

* Update the State of a Spider (Level 1)
* 
* Used by the routine at #R37586. Input:  IX  Address of complex state data for a (Level 1) spider (#R43749, #R43762
* or #R43775)
_37639:
       movb @game_flags,a                  ; LD A,(34208)      ; If "Reset Spiders to Initial State" Flag is reset...
       movb a,tmp0                     ; BIT 3,A           ; ...
       andi tmp0,8*256                 ;                   
       jeq  _37662                     ; JR Z,37662        ; ...then skip ahead to #R37662
       movb @bytes+27,a                ; LD A,27           ; Reset complex state data for right-hand spider to that stored in Initial-State Table...
       .call @_53987                   ; CALL 53987        ; ...
       movb @bytes+28,a                ; LD A,28           ; Reset complex state data for middle spider to that stored in Initial-State Table...
       .call @_53987                   ; CALL 53987        ; ...
       movb @bytes+29,a                ; LD A,29           ; Reset complex state data for left-hand spider to that stored in Initial-State Table...
       .call @_53987                   ; CALL 53987        ; ...
       .ret                            ; RET               ; Return
_37662:
       movb a,tmp0                     ; BIT 2,A           ; If Berk Has Been Killed Flag is set...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       bl   @chk_coll_next_depth       ; CALL 54764        ; Check entity at IX for collision with another entity at next depth level out of screen whose
                                                           ; Interaction (11,6) Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _37685                     ; JR NZ,37685       ; ...then skip ahead to #R37685
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       movb @_34223,a                  ; LD A,(34223)      ; Increase count of number of times a spider has killed Berk...
       ab   one,a                      ; INC A             ; ...
       movb a,@_34223                  ; LD (34223),A      ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_37685:
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If spider's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If the spider and Berk are in different rooms...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with the x-coordinate of the spider's right side...
       ab   @bytes+4,a                 ; ADD A,4           ; ...plus 4...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...and if the x-coordinate of Berk's left side is greater than this...
       jhe  !                          ; RET C             ; ...then return
       .ret                            ;                   
!
       li   hl,_37800                  ; LD HL,37800       ; Point HL at script data for spider moving down...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (41) Move Spider Up One Character and, if Home, Reset its Timer and Make it Wait Input:  IX Address
* of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_41:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of bottom of entity IX (spider) is not 106...
       cb   a,@bytes+106               ; CP 106            ; ...
       jeq  !                          ; JP NZ,48541       ; ...then move entity up one character and return
       b    @script_routine_34                    ;                   
!
       movb @bytes+20,@c               ; LD C,20           ; Load C with 20
       movb @8(ix),a                   ; LD A,(IX+8)       ; If entity class is not 27 (right-most spider, Level 1)...
       cb   a,@bytes+27                ; CP 27             ; ...
       jne  _37744                     ; JR NZ,37744       ; ...then skip ahead to #R37744
* The following code affects the behaviour of the right-most spider depending upon how many times Berk has been
* killed by a spider. See (trivia) and (pokes).
       movb @_34223,a                  ; LD A,(34223)      ; Load number of times Berk has been killed by a spider into A...
       srl  a,1                        ; SRL A             ; ...and divide by four, discarding remainder...
       srl  a,1                        ; SRL A             ; ...
       ab   @c,a                       ; ADD A,C           ; Add this value to C, in C...
       movb a,@c                       ; LD C,A            ; ...
_37744:
       movb @c,@12(ix)                 ; LD (IX+12),C      ; Load spider's timer with this value
       li   hl,_37792                  ; LD HL,37792       ; Point HL at script data for spider waiting...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (42) Decrease Remaining Time Until Spider Next Descends and if Zero, Start Descent Input:  IX
* Address of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_42:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If spider's Must Process Current Script Data Flag is reset...
       andi tmp0,1*256                 ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If Spider's timer is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _37772                     ; JR Z,37772        ; ...then skip ahead to #R37772
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining time on spider's timer
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
_37772:
       li   hl,_37800                  ; LD HL,37800       ; Point HL at script data for spider moving down...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (40) Move Spider Down One Character, and if at Bottom, Advance it to Bounce / Climb Up Mode Input:
* IX  Address of complex state data for an entity Output: HL  Address of next script instruction to execute
script_routine_40:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If entity's bottom y-coordinate is less than 119...
       cb   a,@bytes+119               ; CP 119            ; ...
       jhe  !                          ; JP C,48567        ; ...then move entity down one character and process next script data
       b    @script_routine_35                    ;                   
!
       li   hl,_37816                  ; LD HL,37816       ; Point HL at script data for bounce / climb up mode...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Update States of All Level 2 Entities
* 
* Used by the routine at #R34438.
update_level_2_entities:
       .proc
       .call @_38592                   ; CALL 38592        ; Update states of stalactites (Level 2)
       .call @_38480                   ; CALL 38480        ; Update states of apebeasts (Level 2) and store current positions in script data
       .call @_38054                   ; CALL 38054        ; Update state of Bubo (Level 2) and store current position in script data
       .call @_38219                   ; CALL 38219        ; Update state of Bubo's projectile
       .endproc                        ; RET               ; Return

* Update State of Bubo (Level 2) and Store Current Position in Script Data
* 
* Used by the routine at #R38009.
_38054:
       li   ix,_44227                  ; LD IX,44227       ; Load IX with address of complex state data for Bubo (Level 2)
       mov  @bubo_script_pos,hl        ; LD HL,(38022)     ; Load HL with current position in Bubo's script data from #R38022...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .call @_38074                   ; CALL 38074        ; Update state of Bubo
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@bubo_script_pos        ; LD (38022),HL     ; ...at #R38022 as current position in Bubo's script data
       .ret                            ; RET               ; Return

* Update State of Bubo
* 
* Used by the routine at #R38054. Input:  IX  Address of complex state data for Bubo (Level 2)
_38074:
       movb @9(ix),tmp0                ; BIT 3,(IX+9)      ; If Bubo's Harmless Flag is set...
       andi tmp0,8*256                 ;                   
       jne  _38101                     ; JR NZ,38101       ; ...then skip ahead to #R38101
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk's current power is not immunity to Bubo (Level 2)...
       cb   a,@bytes+9                 ; CP 9              ; ...
       jne  _38093                     ; JR NZ,38093       ; ...then skip ahead to #R38093
       socb @bits+3,@9(ix)             ; SET 3,(IX+9)      ; Set Bubo's Harmless Flag
       jmp  _38101                     ; JR 38101          ; Skip ahead to #R38101
_38093:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
_38101:
       equ  $
       li   iy,_44214                  ; LD IY,44214       ; Load IY with address of complex state data for Bubo's Projectile (Level 2)
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Bubo's Must Process Current Script Data Flag is set (Bubo firing)...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @9(iy),tmp0                ; BIT 1,(IY+9)      ; If Projectile's Fired Flag is set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
_38119:
       equ  $
       movb @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Bubo is not being carried...
       andi tmp0,32*256                ;                   
       jeq  _38132                     ; JR Z,38132        ; ...then skip ahead to #R38132
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Bubo's Waiting to Fire Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
* The code block below is only entered if Bubo's Must Process Current Script Data Flag is reset (i.e. he is not
* firing), the Projectile's Fired Flag is reset and Bubo is not being carried.
_38132:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Bubo has a depth of 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Bubo's Waiting to Fire Flag is set, i.e. he has just been dropped...
       andi tmp0,4*256                 ;                   
       jne  _38155                     ; JR NZ,38155       ; ...then skip ahead to #R38155 (make Bubo fire)
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @rnd_no                   ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (59 in 60 chance)...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
_38155:
       equ  $
       szcb @bits+2,@9(ix)             ; RES 2,(IX+9)      ; Reset Bubo's Waiting to Fire Flag
       li   hl,_38032                  ; LD HL,38032       ; Point HL at script data for Bubo firing...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (61) Fire Bubo's Projectile
* 
* Note that Bubo normally can't fire when being carried (see instructions at #R38119), however if he starts to fire
* immediately before being picked up, then his Being Carried Flag will be set by the time execution reaches this
* routine. Input:  IX  Address of complex state data for Bubo (Level 2) IY  Address of complex state data for Bubo's
* projectile
script_routine_61:
       socb @bits+1,@9(iy)             ; SET 1,(IY+9)      ; Set projectile's Fired Flag
       movb @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Bubo is being carried...
       andi tmp0,32*256                ;                   
       jne  _38181                     ; JR NZ,38181       ; ...then skip ahead to #R38181
       movb @bytes+251,@12(iy)         ; LD (IY+12),251    ; Set projectile's Velocity Factor to -5
       jmp  _38185                     ; JR 38185          ; Skip ahead to #R38185
_38181:
       movb @bytes+246,@12(iy)         ; LD (IY+12),246    ; Set projectile's Velocity Factor to -10
_38185:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set projectile's x-coordinate to one more than Bubo's...
       ab   one,a                      ; INC A             ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set projectile's y-coordinate to be three less than Bubo's...
       sb   @bytes+3,a                 ; SUB 3             ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Set projectile's room to be same as Bubo's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set projectile's depth to zero
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Update State of Bubo's Projectile
* 
* Used by the routine at #R38009.
_38219:
       li   ix,_44214                  ; LD IX,44214       ; Load IX with address of complex state data for Bubo's Projectile (Level 2)
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If projectile's Fired Flag is reset...
       andi tmp0,2*256                 ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       movb @9(ix),tmp0                ; BIT 2,(IX+9)      ; If projectile's Has Hit Target Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  _38252                     ; JR Z,38252        ; ...then update position of projectile and knock key down if appropriate
       li   bc,_39131                  ; LD BC,39131       ; Point BC at graphic layout data for Bubo's Projectile...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as the Graphic Lookup Address for the projectile's complex state data
                                                           ; entry...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       movb @bytes+0,@9(ix)            ; LD (IX+9),0       ; Reset projectile's Has Hit Target Flag and Fired Flag
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set projectile's depth to zero
       .ret                            ; RET               ; Return
_38252:
       li   iy,_44227                  ; LD IY,44227       ; Point IY at complex state data for Bubo (Level 2)
       movb @12(ix),a                  ; LD A,(IX+12)      ; If projectile's velocity factor is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _38267                     ; JR NZ,38267       ; ...then skip ahead to #R38267
       .call @_38377                   ; CALL 38377        ; Start level 2 key falling if Bubo's projectile is in place below it
       jmp  _38361                     ; JR 38361          ; Jump to #R38361 (increase velocity and handle landing if appropriate)
_38267:
       movb a,tmp0                     ; BIT 7,A           ; If bit 7 of projectile's velocity factor is set (i.e. negative, moving upwards)...
       andi tmp0,128*256               ;                   
       jne  _38336                     ; JR NZ,38336       ; ...then skip ahead to #R38336
       cb   a,@bytes+6                 ; CP 6              ; If projectile's velocity factor is less than 6...
       jl   _38277                     ; JR C,38277        ; ...then skip ahead to #R38277
       movb @bytes+5,a                 ; LD A,5            ; Load A with 5 (terminal velocity)
_38277:
       movb a,b                        ; LD B,A            ; Load B with velocity value
_38278:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining velocity value)
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _38328                     ; JR C,38328        ; ...and if no collision occurred, then skip ahead to #R38328
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _38293                     ; JR NZ,38293       ; ...then skip ahead to #R38293
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       jmp  _38328                     ; JR 38328          ; Skip ahead to #R38328
_38293:
       cb   a,@bytes+25                ; CP 25             ; If collision was not with entity of class 25 (Green Apebeast, Level 2)...
       jne  _38328                     ; JR NZ,38328       ; ...then skip ahead to #R38328
       movb @current_characters_room,a                  ; LD A,(34218)      ; Load A with current character's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...and if this is not the same as the projectile's room...
       jne  _38328                     ; JR NZ,38328       ; ...then skip ahead to #R38328
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set Ape Beast's depth to zero
       movb @bytes+0,@11(iy)           ; LD (IY+11),0      ; Reset Ape Beast's flags
       li   bc,_51483                  ; LD BC,51483       ; Point BC at graphic layout data for Explosion (Bubo's Projectile / Fallen Drips, Level 4)...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as the Graphic Lookup Address for the projectile's complex state data
                                                           ; entry...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set projectile's Has Hit Target Flag
       .pop bc                         ; POP BC            ; Restore BC (B = current velocity factor)
       .ret                            ; RET               ; Return
_38328:
       .call @_38756                   ; CALL 38756        ; Move projectile down one character
       .pop bc                         ; POP BC            ; Restore BC (B = current velocity factor)
       sb   one,b                      ; DJNZ 38278        ; Decrease remaining velocity value and loop back to #R38278 if not zero
       jne  _38278                     ;                   
       jmp  _38361                     ; JR 38361          ; Skip ahead to #R38361 (increase velocity and handle landing if appropriate)
* Projectile moving upwards
_38336:
       neg a                           ; NEG               ; Multiply projectile's velocity factor by -1
       cb   a,@bytes+6                 ; CP 6              ; If projectile's velocity factor is now less than 6...
       jl   _38344                     ; JR C,38344        ; ...then skip ahead to #R38344 (change projectile's y-coordinate based upon velocity)
       movb @bytes+5,a                 ; LD A,5            ; Load A with 5 (i.e. cap velocity magnitude at 5)
_38344:
       neg a                           ; NEG               ; Multiply value in A by -1...
       movb a,@e                       ; LD E,A            ; ...and load value (capped velocity) into E
       movb @4(ix),a                   ; LD A,(IX+4)       ; Decrease projectile's y-coordinate by value in E...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
_38361:
       movb @4(ix),a                   ; LD A,(IX+4)       ; If projectile's y-coordinate is at least 124...
       cb   a,@bytes+124               ; CP 124            ; ...
       jhe  _38372                     ; JR NC,38372       ; ...then skip ahead to #R38372 (reset projectile's Fired Flag and return)
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase projectile's velocity factor by one
       .ret                            ; RET               ; Return
_38372:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset projectile's Fired Flag
       .ret                            ; RET               ; Return

* Start Level 2 Key Falling if Bubo's Projectile is in Place Below it
* 
* Used by the routine at #R38219. Input:  IX  Address of complex state data for Bubo's projectile (Level 2)
_38377:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of projectile is not 1...
       cb   a,one                      ; CP 1              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If projectile's left-side has an x-coordinate less than 114...
       cb   a,@bytes+114               ; CP 114            ; ...
       jhe  !                          ; RET C             ; ...then return
       .ret                            ;                   
!
       cb   a,@bytes+118               ; CP 118            ; If projectile's left-side has an x-coordinate of 118 or more...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       li   iy,_44240                  ; LD IY,44240       ; Load IY with address of complex state data for Key (Level 2)
       movb *iy,a                      ; LD A,(IY+0)       ; If key's room is not 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @10(iy),tmp0               ; BIT 6,(IY+10)     ; If key's Is Falling Flag is set...
       andi tmp0,64*256                ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set key's Is Falling Flag
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set key's velocity factor to 2
       .ret                            ; RET               ; Return

* Reset Current Positions in Apebeasts' Script Data to Initial Values
* 
* Used by the routine at #R34751.
_38468:
       li   de,_38424                  ; LD DE,38424       ; Point DE at Table of Current Positions in Apebeasts' Script Data
       li   hl,_38416                  ; LD HL,38416       ; Point HL at Table of Initial Positions in Apebeasts' Script Data
       li   bc,8                       ; LD BC,8           ; Load BC with 8 (as there are eight bytes to copy)
       .ldir                           ; LDIR              ; Overwrite addresses in Table of Current Positions with those from Table of Initial Positions
       .ret                            ; RET               ; Return

* Update States of Apebeasts (Level 2) and Store Current Positions in Script Data
* 
* Used by the routine at #R38009.
_38480:
       li   ix,_44162                  ; LD IX,44162       ; Load IX with address of complex state data for Green Apebeast 1 (Level 2)
       li   iy,_38424                  ; LD IY,38424       ; Point IY at Table of Current Positions in Apebeasts' Script Data
_38488:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If depth of Apebeast is zero (i.e. Apebeast killed by Bubo)...
       socb a,a                        ; OR A              ; ...
       jeq  _38523                     ; JR Z,38523        ; ...then skip ahead to #R38523 (i.e. move onto next apebeast)
       movb *iy,@l                     ; LD L,(IY+0)       ; Load HL with current position in script data for current apebeast...
       movb @1(iy),h                   ; LD H,(IY+1)       ; ...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .push ix                        ; PUSH IX           ; Store IX
       .push iy                        ; PUSH IY           ; Store IY
       .call @_38540                   ; CALL 38540        ; Update the state of the current apebeast
       .pop iy                         ; POP IY            ; Restore IY
       .pop ix                         ; POP IX            ; Restore IX
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data for current apebeast) stored at #R34277...
       movb @l,*iy                     ; LD (IY+0),L       ; ...in table at #R38424 as current position in this apebeast's script data...
       movb h,@1(iy)                   ; LD (IY+1),H       ; ...
_38523:
       inc  iy                         ; INC IY            ; Advance IY to next entry in table (i.e. position in next apebeast's script data)...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX by 13 bytes (i.e. to entry for next apebeast)...
       a    de,ix                      ; ADD IX,DE         ; ...
       movb @8(ix),a                   ; LD A,(IX+8)       ; If class of this next entry is 25 (i.e. Apebeast)...
       cb   a,@bytes+25                ; CP 25             ; ...
       jeq  _38488                     ; JR Z,38488        ; ...then loop back to #R38488
       .ret                            ; RET               ; Return

* Update State of an Apebeast
* 
* Used by the routine at #R38480.
_38540:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       jnc  !                          ; JP C,48096        ; ...and if no collision occurred, then jump to #R48096 (advance HL to next script instruction
       b    @inct_execute_script                    ;                   
!
                                                           ; and execute)
       cb   a,@bytes+31                ; CP 31             ; If collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (60) Check Position of Apebeast and Turn If Appropriate Input:  IX  Address of complex state data
* for an entity Output: HL  Address of next script instruction to execute
script_routine_60:
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Apebeast's Walking Right Flag is set...
       andi tmp0,1*256                 ;                   
       jne  _38575                     ; JR NZ,38575       ; ...then skip ahead to #R38575
* Apebeast walking left
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is less than x-coordinate of left edge of Apebeast...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_38432                  ; LD HL,38432       ; Point HL at script data for Apebeast walking right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Apebeast walking right
_38575:
       movb @12(ix),a                  ; LD A,(IX+12)      ; If minimum allowed x-coordinate of Apebeast...
       ab   @bytes+13,a                ; ADD A,13          ; ...plus 13...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...is equal to or greater than x-coordinate of right edge of Apebeast...
       jl   !                          ; JP NC,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_38450                  ; LD HL,38450       ; Point HL at script data for Apebeast walking left...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Update States of Stalactites (Level 2)
* 
* Used by the routine at #R38009.
_38592:
       li   ix,_44305                  ; LD IX,44305       ; Load IX with address of complex state data for first of seven falling stalactites (Level 2)
_38596:
       movb @8(ix),a                   ; LD A,(IX+8)       ; If current entity class is not 34 (Stalactite, Level 2)...
       cb   a,@bytes+34                ; CP 34             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If velocity factor of stalactite is not zero (i.e. it is falling)...
       socb a,a                        ; OR A              ; ...
       jne  _38635                     ; JR NZ,38635       ; ...then skip ahead to #R38635
       movb @bytes+40,a                ; LD A,40           ; Load A with a random number, 0-39...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (39 in 40 chance)...
       jeq  !                          ; JP NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
       b    @_38748                    ;                   
!
       .call @_38756                   ; CALL 38756        ; Move stalactite down one character and load A with new top y-coordinate
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load A with top y-coordinate of stalactite (see trivia)
       cb   a,@bytes+101               ; CP 101            ; If new top y-coordinate is not 101
       jeq  !                          ; JP NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
       b    @_38748                    ;                   
!
       movb one,@12(ix)                ; LD (IX+12),1      ; Set stalactite's velocity factor to 1
       b    @_38748                    ; JP 38748          ; Advance IX to next entry in complex state data and loop back to #R38596
_38635:
       cb   a,one                      ; CP 1              ; If velocity factor is not 1...
       jne  _38707                     ; JR NZ,38707       ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
       movb @5(ix),@e                  ; LD E,(IX+5)       ; Load E with x-coordinate of left of stalactite
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is not the same as the stalactite's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jne  _38679                     ; JR NZ,38679       ; ...then skip ahead to #R38679 to check Drutt's position
       movb @11(iy),a                  ; LD A,(IY+11)      ; If Berk's Walking Left Flag is set...
       movb a,tmp0                     ; BIT 1,A           ; ...
       andi tmp0,2*256                 ;                   
       jne  _38673                     ; JR NZ,38673       ; ...then skip ahead to #R38673
       movb a,tmp0                     ; BIT 0,A           ; If Berk's Walking Right Flag is not set...
       andi tmp0,1*256                 ;                   
       jeq  _38679                     ; JR Z,38679        ; ...then skip ahead to #R38679 to check Drutt's position
       movb @7(iy),a                   ; LD A,(IY+7)       ; If Berk's right-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@e                       ; CP E              ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
       jmp  _38679                     ; JR 38679          ; Skip ahead to #R38679 to check Drutt's position
_38673:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Berk's left-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@e                       ; CP E              ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
_38679:
       li   iy,drutts_state_data_2                  ; LD IY,44396       ; Load IY with address of complex state data for Drutt (Level 2)
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt's current room is not the same as the stalactite's...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jne  _38699                     ; JR NZ,38699       ; ...then skip ahead to #R38699
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Drutt's left-side x-coordinate is the same as the stalactite's left-side x-coordinate...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jeq  _38707                     ; JR Z,38707        ; ...then check for collision with Berk killing him if so, ensure stalactite is falling and
                                                           ; update its vertical position (#R38707)
_38699:
       movb @bytes+200,a               ; LD A,200          ; Load A with a random number, 0-199...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is not zero (199 in 200 chance)...
       jne  _38748                     ; JR NZ,38748       ; ...then advance IX to next entry in complex state data and loop back to #R38596
_38707:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _38718                     ; JR NZ,38718       ; ...then skip ahead to #R38718 (start stalactite falling)
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       .ret                            ; RET               ; Return
_38718:
       movb @12(ix),b                  ; LD B,(IX+12)      ; Load B with stalactite's velocity factor...
_38721:
       .call @_38756                   ; CALL 38756        ; ...and move stalactite down by this many characters...
       sb   one,b                      ; DJNZ 38721        ; ...
       jne  _38721                     ;                   
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase stalactite's velocity factor by one
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of top of stalactite is less than 150...
       cb   a,@bytes+150               ; CP 150            ; ...
       jl   _38748                     ; JR C,38748        ; ...then advance IX to next entry in complex state data and loop back to #R38596
       movb @bytes+98,@4(ix)           ; LD (IX+4),98      ; Move stalactite back to top of room...
       movb @bytes+100,@6(ix)          ; LD (IX+6),100     ; ...
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; ...and set its velocity factor to zero
_38748:
       li   bc,13                      ; LD BC,13          ; Advance IX by 13 bytes to move to next complex state data entry...
       a    bc,ix                      ; ADD IX,BC         ; ...
       b    @_38596                    ; JP 38596          ; ...and loop back to #R38596 for next entity

* Move Entity at IX Down One Character
* 
* Used by the routines at #R38219 and #R38592. Input:  IX  Address of complex state data for an entity Output: A New
* y-coordinate of entity's top
_38756:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase y-coordinates of top and bottom of entity by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load new y-coordinate of entity's top into A
       .ret                            ; RET               ; Return

* Update States of All Level 3 Entities
* 
* Used by the routine at #R34438.
update_level_3_entities:
       .proc
       .call @_39776                   ; CALL 39776        ; Update state of Large Yellow Creature
       .call @_39601                   ; CALL 39601        ; Update states of coloured creatures
       .call @_39278                   ; CALL 39278        ; Update state of Clawed Foot
       .call @_39151                   ; CALL 39151        ; Update state of Hatch
       .endproc                        ; RET               ; Return

* Update State of Hatch (Level 3)
* 
* Used by the routine at #R39137.
_39151:
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       li   hl,_39150                  ; LD HL,39150       ; If Hatch State Index is zero...
       movb *hl,a                      ; LD A,(HL)         ; ...
       socb a,a                        ; OR A              ; ...
       jeq  _39176                     ; JR Z,39176        ; ...then skip ahead to #R39176
* Hatch State Index is not zero
       ab   one,*hl                    ; INC (HL)          ; Increase Hatch State Index
       cb   a,@bytes+2                 ; CP 2              ; If Hatch State Index is 2 (Berk was thrown 1 cycle ago)...
       jeq  _39264                     ; JR Z,39264        ; ...then skip ahead to #R39264
       cb   a,@bytes+10                ; CP 10             ; If Hatch State Index is 10 (Berk was thrown 9 cycles ago)...
       jeq  _39259                     ; JR Z,39259        ; ...then skip ahead to #R39259
       cb   a,@bytes+11                ; CP 11             ; If Hatch State Index is 11 (Berk was thrown 10 cycles ago)...
       jeq  _39269                     ; JR Z,39269        ; ...then skip ahead to #R39269
       .ret                            ; RET               ; Return
* Hatch State Index is zero
_39176:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is not 4 (Hatch Room)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Berk's left edge is less than 109...
       cb   a,@bytes+109               ; CP 109            ; ...
       jhe  !                          ; RET C             ; ...then return
       .ret                            ;                   
!
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Berk's right edge is 120 or greater...
       cb   a,@bytes+120               ; CP 120            ; ...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
* At this point, Berk is standing on the hatch
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is holding the weight...
       cb   a,@bytes+12                ; CP 12             ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Increase Hatch State Index to 1
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk's current power is not invisibility (Level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jne  _39225                     ; JR NZ,39225       ; ...then skip ahead to #R39225
       .call @_48417                   ; CALL 48417        ; Remove Berk's invisibility and reset corresponding edible eyes to their original position
_39225:
       movb @bytes+4,b                 ; LD B,4            ; Move Berk up four characters...
_39227:
       .call @_39442                   ; CALL 39442        ; ...
       sb   one,b                      ; DJNZ 39227        ; ...
       jne  _39227                     ;                   
       movb @bytes+107,@5(ix)          ; LD (IX+5),107     ; Set x-coordinate of Berk's left edge to 107
       movb @bytes+112,@7(ix)          ; LD (IX+7),112     ; Set x-coordinate of Berk's right edge to 112
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Berk's Must Process Current Script Data Flag
       li   hl,_59048                  ; LD HL,59048       ; Set Berk's graphic layout data address to #R59048...
       movb @l,@2(ix)                  ; LD (IX+2),L       ; ...(Berk being thrown left)...
       movb h,@3(ix)                   ; LD (IX+3),H       ; ...
       li   hl,_35523                  ; LD HL,35523       ; Set current position in Berk's script data to #R35523...
       mov  hl,@berk_script_pos        ; LD (35687),HL     ; (Berk being thrown left by Hatch)
* Hatch State Index is 10 (Berk was thrown 9 cycles ago)
_39259:
       li   hl,_41115                  ; LD HL,41115       ; Load HL with graphic layout data address of Hatch half open with Bat (Animated)
       jmp  _39274                     ; JR 39274          ; Skip ahead to #R39274 (set Hatch's GLD address to value in HL and return)
* Hatch State Index is 2 (Berk was thrown 1 cycle ago)
_39264:
       li   hl,_41099                  ; LD HL,41099       ; Load HL with graphic layout data address of Hatch fully open With Bat (Animated)
       jmp  _39274                     ; JR 39274          ; Skip ahead to #R39274 (set Hatch's GLD address to value in HL and return)
* Hatch State Index is 11 (Berk was thrown 10 cycles ago)
_39269:
       movb @bytes+0,*hl               ; LD (HL),0         ; Set Hatch State Index to zero
       li   hl,_41090                  ; LD HL,41090       ; Load HL with graphic layout data address of Hatch closed
_39274:
       movb @l,@hatch+2                ; LD (44792),HL     ; Set Hatch's graphic layout data address to value in HL
       movb h,@hatch+3
       .ret                            ; RET               ; Return

* Update State of Clawed Foot (Level 3)
* 
* Used by the routine at #R39137.
_39278:
       movb @_34228,a                  ; LD A,(34228)      ; If Clawed Foot's Attack Timer is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _39289                     ; JR Z,39289        ; ...then skip ahead to #R39289
       sb   one,a                      ; DEC A             ; Decrease Clawed Foot's Attack Timer...
       movb a,@_34228                  ; LD (34228),A      ; ...
       .ret                            ; RET               ; Return
* Clawed Foot is attacking
_39289:
       li   iy,_44881                  ; LD IY,44881       ; Load IY with address of complex state data for Clawed Foot (Level 3)
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Berk's current room
       movb @_44881+9,a                ; LD A,(44890)      ; Load A with Clawed Foot's flags...
       socb a,a                        ; OR A              ; ...and if any are set...
       jne  _39337                     ; JR NZ,39337       ; ...then skip ahead to #R39337
* Clawed Foot attack not yet started
       movb *iy,a                      ; LD A,(IY+0)       ; If the Clawed Foot's room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's room...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @11(ix),a                  ; LD A,(IX+11)      ; If Berk's Walking Left Flag or Walking Right Flag is set...
       andi a,3*256                    ; AND 3             ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set the Clawed Foot's left edge...
       ab   one,a                      ; INC A             ; ...to be one character to the right of Berk's left edge...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       ab   @bytes+2,a                 ; ADD A,2           ; Set the Clawed Foot's right edge...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...to be two characters to the right of its left edge
       socb @bits+1,@9(iy)             ; SET 1,(IY+9)      ; Set Clawed Foot's Moving Down Flag
       jmp  _39341                     ; JR 39341          ; Skip ahead to #R39341
* Clawed Foot attack underway
_39337:
       movb a,tmp0                     ; BIT 1,A           ; If Clawed Foot's Moving Down Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _39420                     ; JR Z,39420        ; ...then skip ahead to #R39420
_39341:
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as the Clawed Foot moves down three characters at time)
_39343:
       ab   one,@4(iy)                 ; INC (IY+4)        ; Advance Clawed Foot one character down...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of bottom edge of Clawed Foot is 115...
       cb   a,@bytes+115               ; CP 115            ; ...
       jeq  _39359                     ; JR Z,39359        ; ...then skip ahead to #R39359
       sb   one,b                      ; DJNZ 39343        ; Decrease remaining number of characters to move and loop back to #R39343 if not zero
       jne  _39343                     ;                   
       .ret                            ; RET               ; Return
* Clawed Foot attempting to grab Berk
_39359:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jne  _39386                     ; JR NZ,39386       ; ...then skip ahead to #R39386 (set Clawed Foot's Moving Up Flag and return)
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If Berk is falling...
       andi tmp0,64*256                ;                   
       jne  _39386                     ; JR NZ,39386       ; ...then skip ahead to #R39386 (set Clawed Foot's Moving Up Flag and return)
       movb @5(iy),a                   ; LD A,(IY+5)       ; If Clawed Foot's left edge...
       sb   one,a                      ; DEC A             ; ...is one character to the right of Berk's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jeq  _39391                     ; JR Z,39391        ; ...then skip ahead to #R39391
       sb   one,a                      ; DEC A             ; If Clawed Foot's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is two characters to the right of Berk's left edge...
       jeq  _39391                     ; JR Z,39391        ; ...then skip ahead to #R39391
* Berk is flying or falling, or Clawed Foot has missed
_39386:
       movb @bytes+4,@9(iy)            ; LD (IY+9),4       ; Set Clawed Foot's Moving Up Flag
       .ret                            ; RET               ; Return
* Make Clawed Foot grab Berk (Clawed Foot is one or two characters to the right of Berk's left edge)
_39391:
       li   bc,_35515                  ; LD BC,35515       ; Set current position in Berk's script data to...
       mov  bc,@berk_script_pos        ; LD (35687),BC     ; ...Berk in floating position
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Berk's Must Process Current Script Data Flag
       movb @bytes+12,a                ; LD A,12           ; Set Clawed Foot's Moving Up Flag and Holding Berk Flag...
       movb a,@9(iy)                   ; LD (IY+9),A       ; ...
       li   bc,_40368                  ; LD BC,40368       ; Set Clawed Foot's graphic layout data address to point to #R40368 (Reaching, Closed)...
_39410:
       movb @c,@2(iy)                  ; LD (IY+2),C       ; ...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       .ret                            ; RET               ; Return
* Check Clawed Foot's Moving Up Flag
_39420:
       movb a,tmp0                     ; BIT 2,A           ; If Clawed Foot's Moving Up Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  _39532                     ; JR Z,39532        ; ...then skip ahead to #R39532
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move Clawed Foot up one character...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of bottom of Clawed Foot...
       cb   a,@bytes+95                ; CP 95             ; ...is 95...
       jeq  _39449                     ; JR Z,39449        ; ...then skip ahead to #R39449
       movb @9(iy),tmp0                ; BIT 3,(IY+9)      ; If Clawed Foot's Holding Berk Flag is reset...
       andi tmp0,8*256                 ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
* This entry point is used by the routine at #R39151.
_39442:
       equ  $
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move entity at IX (Berk) up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       .ret                            ; RET               ; Return
_39449:
       movb @9(iy),tmp0                ; BIT 3,(IY+9)      ; If Clawed Foot's Holding Berk Flag is reset...
       andi tmp0,8*256                 ;                   
       jeq  _39527                     ; JR Z,39527        ; ...then skip ahead to #R39527 (Reset Clawed Foot to inactive state and return)
       movb @_34229,a                  ; LD A,(34229)      ; Increase Clawed Foot's Action Index...
       ab   one,a                      ; INC A             ; ...
_39459:
       movb a,@_34229                  ; LD (34229),A      ; ...
       cb   a,@bytes+7                 ; CP 7              ; ...and if less than 7...
       jl   _39470                     ; JR C,39470        ; ...then skip ahead to #R39470
       movb one,a                      ; LD A,1            ; Set Clawed Foot's Action Index to 1...
       jmp  _39459                     ; JR 39459          ; ...and jump to #R39470 (via #R39459)
_39470:
       cb   a,@bytes+3                 ; CP 3              ; If Clawed Foot's Action Index is less than 3...
       jl   _39501                     ; JR C,39501        ; ...then skip ahead to #R39501 (i.e. make clawed foot release Berk, and return)
       cb   a,@bytes+5                 ; CP 5              ; If Clawed Foot's Action Index is less than 5...
       jl   _39482                     ; JR C,39482        ; ...then skip ahead to #R39482
       movb @bytes+112,@e              ; LD E,112          ; Load E with 112 (prepare to set Clawed Foot's destination x-coordinate)
       jmp  _39484                     ; JR 39484          ; Skip ahead to #R39484
_39482:
       movb @bytes+122,@e              ; LD E,122          ; Load E with 122 (prepare to set Clawed Foot's destination x-coordinate)
_39484:
       movb @e,@12(ix)                 ; LD (IX+12),E      ; Store destination x-coordinate in byte 12 of Berk's complex state data
       movb a,tmp0                     ; BIT 0,A           ; If Clawed Foot's Action Index is even...
       andi tmp0,1*256                 ;                   
       jeq  _39496                     ; JR Z,39496        ; ...then skip ahead to #R39496
       movb @bytes+16,@9(iy)           ; LD (IY+9),16      ; Set Clawed Foot's Move Left Flag
       .ret                            ; RET               ; Return
_39496:
       movb @bytes+32,@9(iy)           ; LD (IY+9),32      ; Set Clawed Foot's Move Right Flag
       .ret                            ; RET               ; Return
* The instructions between #R39501 and #R39531 make the Clawed Foot release Berk.
_39501:
       movb @bytes+100,a               ; LD A,100          ; Set Clawed Foot's Attack Timer to 100...
       movb a,@_34228                  ; LD (34228),A      ; ...i.e. Clawed Foot will attack again in 100 cycles
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set Berk's "Can Fall" flag
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set Berk's velocity factor to 2
       li   bc,_35359                  ; LD BC,35359       ; Set current position in Berk's script data to...
       mov  bc,@berk_script_pos        ; LD (35687),BC     ; ...Berk starting to fall downwards
       li   bc,_40320                  ; LD BC,40320       ; Set Clawed Foot's graphic layout data address to point to #R40320 (Reaching, Open)...
       .call @_39410                   ; CALL 39410        ; ...make Berk drop the entity he is holding and load IY with its complex state data address
* Reset Clawed Foot to inactive state
_39527:
       movb @bytes+0,@9(iy)            ; LD (IY+9),0       ; Reset Clawed Foot's Flags
_39531:
       .ret                            ; RET               ; Return
* Check Clawed Foot's Moving Left Flag
_39532:
       movb a,tmp0                     ; BIT 4,A           ; If Clawed Foot's Move Left Flag is reset...
       andi tmp0,16*256                ;                   
       jeq  _39552                     ; JR Z,39552        ; ...then skip ahead to #R39552
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk one character left...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk into room to the left, if appropriate
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is 5 (room to the left of the Coloured Creatures' Room)...
       cb   a,@bytes+5                 ; CP 5              ; ...then set Zero Flag
       jmp  _39569                     ; JR 39569          ; Skip ahead to #R39569
* Check Clawed Foot's Moving Right Flag
_39552:
       movb a,tmp0                     ; BIT 5,A           ; If Clawed Foot's Move Right Flag is reset...
       andi tmp0,32*256                ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk one character right...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk into room to the right, if appropriate
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's room is 7 (room to the right of the Coloured Creatures' Room)...
       cb   a,@bytes+7                 ; CP 7              ; ...then set Zero Flag
_39569:
       jeq  !                          ; RET NZ            ; If Zero Flag is not set (i.e. Berk is not in Room 5 or Room 7) then return
       .ret                            ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If the x-coordinate of Berk's left edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not the same as the Clawed Foot's destination x-coordinate...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       li   iy,_44881                  ; LD IY,44881       ; Load IY with address of complex state data for Clawed Foot (Level 3)
       b    @_39501                    ; JP 39501          ; Make Clawed Foot release Berk, and return

* Update States of Coloured Creatures
* 
* Used by the routine at #R39137.
_39601:
       movb @_44894+9,a                ; LD A,(44903)      ; Load A with first coloured creature's flags
       movb a,tmp0                     ; BIT 2,A           ; If Coloured Creatures' Reward Given Flag is set...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb a,tmp0                     ; BIT 1,A           ; If All Coloured Creatures Home Flag is set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,39760       ; ...then present reward for getting coloured creatures home, and return
       b    @_39760                    ;                   
!
       .call @_39699                   ; CALL 39699        ; Count coloured creatures in slots and return if all are home
       movb @l,a                       ; LD A,L            ; If all three coloured creatures are in slots...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       movb @current_characters_room,a                  ; LD A,(34218)      ; If current character's current room is not 6 (coloured creatures' room)...
       cb   a,@bytes+6                 ; CP 6              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       li   hl,_39600                  ; LD HL,39600       ; Increase cycles elapsed since last swap of creatures...
       ab   one,*hl                    ; INC (HL)          ; ...
       movb *hl,a                      ; LD A,(HL)         ; ...
       cb   a,@bytes+100               ; CP 100            ; ...and if less than 100...
       jhe  !                          ; RET C             ; ...then return
       .ret                            ;                   
!
       movb @bytes+0,*hl               ; LD (HL),0         ; Set cycles elapsed since last swap of creatures to zero
       .call @_36616                   ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       li   hl,_39599                  ; LD HL,39599       ; Point HL at current Sequence ID
_39641:
       movb @bytes+3,a                 ; LD A,3            ; Load A with a random number, 0-2...
       bl   @rnd_no                    ; CALL 54222        ; ...
       cb   a,*hl                      ; CP (HL)           ; ...and if this is the same as the current Sequence ID...
       jeq  _39641                     ; JR Z,39641        ; ...then jump back to #R39641 to generate a new random number
       movb a,*hl                      ; LD (HL),A         ; Set new Sequence ID to generated number
       ab   a,a                        ; ADD A,A           ; Load BC with three times Sequence ID...
       ab   *hl,a                      ; ADD A,(HL)        ; ...
       movb a,@c                       ; LD C,A            ; ...
       sb   b,b                        ; LD B,0            ; ...
       li   iy,_39584                  ; LD IY,39584       ; Load IY with start address of Table of Coloured Creatures' Properties...
       a    bc,iy                      ; ADD IY,BC         ; ...and add three times Sequence ID to get address of first entry in new sequence
       li   ix,_44894                  ; LD IX,44894       ; Load IX with address of complex state data for first coloured creature (Level 3)
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as there are three coloured creatures)
_39667:
       movb *iy,a                      ; LD A,(IY+0)       ; Set class of current coloured creature...
       movb a,@8(ix)                   ; LD (IX+8),A       ; ...
       movb @1(iy),a                   ; LD A,(IY+1)       ; ...and address of graphic layout data...
       movb a,@2(ix)                   ; LD (IX+2),A       ; ...
       movb @2(iy),a                   ; LD A,(IY+2)       ; ...
       movb a,@3(ix)                   ; LD (IX+3),A       ; ...to values in current record in Table of Coloured Creatures' Properties
       inc  iy                         ; INC IY            ; Advance IY to next entry in properties table...
       inc  iy                         ; INC IY            ; ...
       inc  iy                         ; INC IY            ; ...
       li   de,13                      ; LD DE,13          ; Advance IX to next coloured creature's properties...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 39667        ; Decrease remaining number of coloured creatures to update and loop back to #R39667 if not
       jne  _39667                     ;                   
                                                           ; zero
       .ret                            ; RET               ; Return

* Count Coloured Creatures in Slots and Return if All Are Home
* 
* Used by the routine at #R39601. Output: H  Number of coloured creatures in correct slots L  Number of coloured
* creatures in slots
_39699:
       li   ix,_44894                  ; LD IX,44894       ; Load IX with address of complex state data for first coloured creature (Level 3)
       li   hl,0                       ; LD HL,0           ; Load HL with zero
       movb @bytes+3,b                 ; LD B,3            ; Load B with 3 (as there are 3 creatures)
_39708:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of bottom of current creature is not 114...
       cb   a,@bytes+114               ; CP 114            ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       ab   one,@l                     ; INC L             ; Increase L (number of creatures in slots)
       movb @8(ix),a                   ; LD A,(IX+8)       ; If current entity class is not 13 (Red Coloured Creature, Level 3)...
       cb   a,@bytes+13                ; CP 13             ; ...
       jne  _39726                     ; JR NZ,39726       ; ...then skip ahead to #R39726
       movb @bytes+108,a               ; LD A,108          ; Load A with 108 (x-coordinate of left-most slot)
       jmp  _39736                     ; JR 39736          ; Skip ahead to #R39736
_39726:
       cb   a,@bytes+14                ; CP 14             ; If current entity class is not 14 (Yellow Coloured Creature, Level 3)...
       jne  _39734                     ; JR NZ,39734       ; ...then skip ahead to #R39734
       movb @bytes+115,a               ; LD A,115          ; Load A with 115 (x-coordinate of middle slot)
       jmp  _39736                     ; JR 39736          ; Skip ahead to #R39736
_39734:
       movb @bytes+122,a               ; LD A,122          ; Load A with 122 (x-coordinate of right-most slot)
_39736:
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of slot in A is not the same as x-coordinate of current creature's left...
       jne  _39742                     ; JR NZ,39742       ; ...then skip ahead to #R39742
       ab   one,h                      ; INC H             ; Increase H (number of creatures at correct x-coordinate for their respective coloured slots)
_39742:
       li   de,13                      ; LD DE,13          ; Advance IX to next entity...
       a    de,ix                      ; ADD IX,DE         ; ...
       sb   one,b                      ; DJNZ 39708        ; Loop back to #R39708 for next creature
       jne  _39708                     ;                   
       movb h,a                        ; LD A,H            ; If H is not 3 (i.e. at least one creature not at correct x-coordinates)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @bytes+2,a                 ; LD A,2            ; Set All Coloured Creatures Home Flag
       movb a,@_44894+9                ; LD (44903),A      ; ...
       .pop bc                         ; POP BC            ; Return to routine that called the calling routine...
       .ret                            ; RET               ; ...

* Present Reward for Getting Coloured Creatures Home
* 
* Used by the routine at #R39601.
_39760:
       .call @_36616                   ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       li   ix,_44972                  ; LD IX,44972       ; Load IX with address of complex state data for edible eyes (normally hidden off-screen)...
       .call @_55516                   ; CALL 55516        ; ...and set their "Can Fall" Flag and set initial velocity factor to 2
       movb @bytes+4,a                 ; LD A,4            ; Set Coloured Creatures' Reward Given Flag...
       movb a,@_44894+9                ; LD (44903),A      ; ...
       .ret                            ; RET               ; Return

* Update State of Large Yellow Creature (Level 3)
* 
* Used by the routine at #R39137.
_39776:
       li   iy,_44868                  ; LD IY,44868       ; Load IY with address of complex state data for Large Yellow Creature (Level 3)
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       li   hl,_44868+9                ; LD HL,44877       ; Load HL with address of Large Yellow Creature's flags...
       movb *hl,a                      ; LD A,(HL)         ; ...and load flags into A
       cb   a,@bytes+2                 ; CP 2              ; If creature is in "Rising From Floor" mode...
       jeq  _39831                     ; JR Z,39831        ; ...then skip ahead to #R39831
       cb   a,@bytes+4                 ; CP 4              ; If creature is in "Hunting" mode...
       jeq  _39845                     ; JR Z,39845        ; ...then skip ahead to #R39845
       cb   a,@bytes+8                 ; CP 8              ; If creature is in "Attacking" mode...
       jeq  _39918                     ; JR Z,39918        ; ...then skip ahead to #R39918
       cb   a,@bytes+16                ; CP 16             ; If creature is in "Just Attacked" mode...
       jne  !                          ; JP Z,39934        ; ...then set creature's mode to "Returning Home", set Berk's "Has Been Killed" Flag and return
       b    @_39934                    ;                   
!
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is not 3 (Yellow Creature's Room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
* "Returning Home" mode
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of creature's left side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is the same as that of Berk's left side...
       jeq  _39828                     ; JR Z,39828        ; ...then skip ahead to #R39828
       ab   one,a                      ; INC A             ; If x-coordinate of creature's left side...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not one character to the right of Berk's left side...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
_39828:
       equ  $
       movb @bytes+2,a                 ; LD A,2            ; Set creature's mode to "Rising from Floor"...
       movb a,*hl                      ; LD (HL),A         ; ...
* "Rising from Floor" mode
_39831:
       .call @_39971                   ; CALL 39971        ; Move creature such that its left edge is up to two characters closer to Berk's
       .call @_39961                   ; CALL 39961        ; Move creature up by two characters
       movb @4(iy),a                   ; LD A,(IY+4)       ; If y-coordinate of creature's top...
       cb   a,@bytes+108               ; CP 108            ; ...is 108 or greater...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       movb @bytes+4,*hl               ; LD (HL),4         ; Set creature's mode to "Hunting"
* "Hunting" mode
_39845:
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is not 3 (Yellow Creature's Room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,39998       ; ...then set creature's mode to "Returning Home", move one step closer to home and return
       b    @_39998                    ;                   
!
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk's current power is invisibility (Level 3)...
       cb   a,@bytes+11                ; CP 11             ; ...
       jeq  _39909                     ; JR Z,39909        ; ...then skip ahead to #R39909 ("confused" mode)
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of Berk's top...
       cb   a,@bytes+103               ; CP 103            ; ...is less than 103...
       jl   _39909                     ; JR C,39909        ; ...then skip ahead to #R39909 ("confused" mode)
       .call @_39971                   ; CALL 39971        ; Move creature such that its left edge is up to two characters closer to Berk's
       movb @4(iy),a                   ; LD A,(IY+4)       ; If creature's top...
       ab   @bytes+4,a                 ; ADD A,4           ; ...is four characters above Berk's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jeq  _39890                     ; JR Z,39890        ; ...then skip ahead to #R39890 (set "Attacking" mode)
       jhe  _39961                     ; JR NC,39961       ; If creature's top is less than 4 characters above Berk's top then move creature up by two
                                                           ; characters and return
       ab   one,a                      ; INC A             ; If creature's top is five characters above Berk's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jeq  _39890                     ; JR Z,39890        ; ...then skip ahead to #R39890 (set "Attacking" mode)
       jl   _39951                     ; JR C,39951        ; If creature's top is more than five characters above Berk's top then move creature down two
                                                           ; characters and return
_39890:
       movb @bytes+8,*hl               ; LD (HL),8         ; Set creature's mode to "Attacking"
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set creature's depth to 1
       socb @bits+5,@9(ix)             ; SET 5,(IX+9)      ; Set Berk's "Do Not Update State" Flag
       li   bc,_40442                  ; LD BC,40442       ; Set graphic layout data address for creature to #R40442 (Large Yellow Creature with mouth
                                                           ; open)...
       .call @_39944                   ; CALL 39944        ; ...
       b    @_36296                    ; JP 36296          ; Make Berk drop the entity he is holding, load IY with its complex state data address and
                                                           ; return
* "Confused" mode
_39909:
       li   bc,_40485                  ; LD BC,40485       ; Set graphic layout data address for creature to #R40485 (Large Yellow Creature, animated,
                                                           ; confused)...
       .call @_39944                   ; CALL 39944        ; ...
       b    @_40008                    ; JP 40008          ; Move creature one step closer to x (left) = 113, y (top) > 111 if not already there, and
                                                           ; return
* "Attacking" mode
_39918:
       .call @_39951                   ; CALL 39951        ; Move creature down two characters
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Berk's depth to zero
       movb @bytes+16,*hl              ; LD (HL),16        ; Set creature's mode to "Just Attacked"
       li   bc,_40451                  ; LD BC,40451       ; Set graphic layout data address for creature to #R40451 (Large Yellow Creature with mouth
                                                           ; closed)...
       b    @_39944                    ; JP 39944          ; ...and return

* Unused routine
       .ret                            ; RET               ; Return

* Set Large Yellow Creature's Mode to "Returning Home", and Set Berk's "Has Been Killed" Flag
* 
* Used by the routine at #R39776.
_39934:
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       szcb @bits+5,@9(ix)             ; RES 5,(IX+9)      ; Reset Berk's "Do Not Update State" Flag
       movb @bytes+0,*hl               ; LD (HL),0         ; Set creature's mode to "Returning Home"
       .ret                            ; RET               ; Return

* Set Graphic Layout Data Address for Entity at IY to BC
* 
* Used by the routine at #R39776. Input:  BC  Graphic layout data address IY  Address of complex state data for an
* entity
_39944:
       movb @c,@2(iy)                  ; LD (IY+2),C       ; Set graphic layout data address for entity to address in BC...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       .ret                            ; RET               ; Return

* Move Entity at IY Down Two Characters
* 
* Used by the routine at #R39776. Input:  IY  Address of complex state data for an entity
_39951:
       .call @_39954                   ; CALL 39954        ; Move entity at IY down one character
* This entry point is used by the routine at #R40008.
_39954:
       ab   one,@4(iy)                 ; INC (IY+4)        ; Increase y-coordinates of entity's top and bottom edges...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       .ret                            ; RET               ; Return

* Move Entity at IY Up Two Characters
* 
* Used by the routine at #R39776. Input:  IY  Address of complex state data for an entity
_39961:
       .call @_39964                   ; CALL 39964        ; Move entity at IY up one character
_39964:
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Decrease y-coordinates of entity's top and bottom edges...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       .ret                            ; RET               ; Return

* Move Entity IY Such that its Left Edge is Up to Two Characters Closer to Entity IX's
* 
* Used by the routine at #R39776. Input:  IX  Address of complex state data for Entity A IY  Address of complex
* state data for Entity B
_39971:
       .call @_39975                   ; CALL 39975        ; Move Entity B one character closer (horizontally) to Entity A...
       jne  !                          ; RET Z             ; ...and if left edges now both at same x-coordinate then return
       .ret                            ;                   
!
* If entities' left edges are not at the same x-coordinate, then proceed into the code block below and move entity B
* by one additional character.
_39975:
       equ  $
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinates of both entities' left edges are the same...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       jl   _39991                     ; JR C,39991        ; If Entity B's left edge is to the right of Entity A's then move Entity B left by one
                                                           ; character
       ab   one,@5(iy)                 ; INC (IY+5)        ; Move Entity B right by one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       .ret                            ; RET               ; Return
_39991:
       sb   one,@5(iy)                 ; DEC (IY+5)        ; Move Entity B left by one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       .ret                            ; RET               ; Return

* Set Large Yellow Creature's Mode to "Returning Home", Move One Step Closer to Home and Return
* 
* Used by the routine at #R39776. Input:  HL  Address of creature's flags IY  Address of complex state data for
* creature
_39998:
       movb @bytes+0,*hl               ; LD (HL),0         ; Set creature's mode to "Returning Home"
_40000:
       movb @bytes+2,@1(iy)            ; LD (IY+1),2       ; Set creature's depth to 2
       movb @bytes+122,a               ; LD A,122          ; Move creature one step closer to x (Left) = 113, y (Top) > 122...
       jmp  _40010                     ; JR 40010          ; ...and return

* Move Entity at IY One Step Closer to Home Position
* 
* This routine moves an entity (whose complex state data is pointed to by IY) one character left or right, if such a
* move would take the x-coordinate of that entity's left edge closer to a value of 113. The entity will also be
* moved down by one character if the y-coordinate of its top edge is less than or equal to 111 (or the input value
* in A if we are entering this routine via #R40010). Input:  A  (Entry at #R40010 only) Minimum allowed y-coordinate
* for entity's top edge IY  Address of complex state data for an entity
_40008:
       movb @bytes+111,a               ; LD A,111          ; Load A with 111 (minimum allowed y-coordinate)
* This entry point is used by the routine at #R39998.
_40010:
       cb   a,@4(iy)                   ; CP (IY+4)         ; If y-coordinate of entity's top edge is greater than value in A...
       jl   _40018                     ; JR C,40018        ; ...then skip ahead to #R40018
       .call @_39954                   ; CALL 39954        ; Move entity at IY down one character
_40018:
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of entity's left edge...
       cb   a,@bytes+113               ; CP 113            ; ...is 113...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       jl   _40033                     ; JR C,40033        ; ...else if greater than 113 then skip ahead to #R40033
       sb   one,@5(iy)                 ; DEC (IY+5)        ; Move entity left one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       .ret                            ; RET               ; Return
_40033:
       ab   one,@5(iy)                 ; INC (IY+5)        ; Move entity right one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       .ret                            ; RET               ; Return

* Update States of All Level 4 Entities
* 
* Used by the routine at #R34438.
update_level_4_entities:
       .proc
       .call @_42266                   ; CALL 42266        ; Update state of Flying Skeleton Creature
       .call @_42381                   ; CALL 42381        ; Update state of Snake
       .call @_42064                   ; CALL 42064        ; Update states of drips
       .call @_41767                   ; CALL 41767        ; Update state of Cannon and Projectile
       .call @_41633                   ; CALL 41633        ; Update state of Ghost
       .call @_41381                   ; CALL 41381        ; Update state of Skeleton (Level 4) and store current position in script data
       .endproc                        ; RET               ; Return

* Reset Skeleton to Initial State
* 
* Used by the routine at #R34751.
_41354:
       li   hl,skeleton_idling_script  ; LD HL,41232       ; Set current position in Skeleton's script data...
       mov  hl,@skeleton_script_pos    ; LD (41230),HL     ; ...to #R41232 (Skeleton Idling)
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
_41366:
       movb *ix,@l                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       movb @bytes+7,*hl               ; LD (HL),7         ; Set the attribute value to 7 (white)
       inc  ix                         ; INC IX            ; Advance IX to next address...
       inc  ix                         ; INC IX            ; ...
       sb   one,b                      ; DJNZ 41366        ; Decrease remaining number of blocks to modify and loop back to #R41366 if not zero
       jne  _41366                     ;                   
       .ret                            ; RET               ; Return

* Update State of Skeleton (Level 4) and Store Current Position in Script Data
* 
* Used by the routine at #R41211.
_41381:
       li   ix,_45404                  ; LD IX,45404       ; Load IX with address of complex state data for Skeleton (Level 4)
       movb @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Skeleton's Removed From Game Flag is set...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Skeleton's Is Dying Flag is set...
       andi tmp0,2*256                 ;                   
       jne  _41424                     ; JR NZ,41424       ; ...then update state of Skeleton (dying) and return
       mov  @skeleton_script_pos,hl    ; LD HL,(41230)     ; Load current position in Skeleton's script data from #R41230 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       .call @_41498                   ; CALL 41498        ; Kill Berk if he collides with Skeleton
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@skeleton_script_pos    ; LD (41230),HL     ; ...at #R41230 as current position in Skeleton's script data
       .ret                            ; RET               ; Return

* Update State of Skeleton (Dying)
* 
* Used by the routine at #R41381. Input:  IX  Address of complex state data for Skeleton (Level 4)
_41424:
       movb @_42910+1,a                ; LD A,(42911)      ; If current attribute in Skeleton's graphic layout data is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _41473                     ; JR NZ,41473       ; ...then skip ahead to #R41473
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Skeleton's room to 0
       li   iy,_45417                  ; LD IY,45417       ; Load IY with address of complex state data for Boni (Level 4)
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set y-coordinate of Boni's top edge...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...to same as that of skeleton
       ab   @bytes+3,a                 ; ADD A,3           ; Set y-coordinate of Boni's bottom edge...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...to three characters below this
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set x-coordinate of Boni's left edge...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...to same as that of skeleton
       ab   one,a                      ; INC A             ; Set x-coordinate of Boni's right edge...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...to one to the right of this
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; Set Boni's Can Fall Flag
       socb @bits+2,@9(ix)             ; SET 2,(IX+9)      ; Set Skeleton's Removed From Game Flag
       .ret                            ; RET               ; Return
* Current attribute in Skeleton's graphic layout data is not 1
_41473:
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
_41479:
       movb *ix,@l                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
       movb @1(ix),h                   ; LD H,(IX+1)       ; ...
       sb   one,*hl                    ; DEC (HL)          ; Decrease the attribute value
       inc  ix                         ; INC IX            ; Advance IX to next address...
       inc  ix                         ; INC IX            ; ...
       sb   one,b                      ; DJNZ 41479        ; Decrease remaining number of blocks to modify and loop back to #R41479 if not zero
       jne  _41479                     ;                   
       movb @bytes+11,a                ; LD A,11           ; Set sound 11 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound                   ; CALL 59722        ; ...
       .ret                            ; RET               ; Return

* Kill Berk if He Collides with Skeleton
* 
* See trivia Input:  IX  Address of complex state data for Skeleton (Level 4) (#R45404)
_41498:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _41513                     ; JR C,41513        ; ...and if no collision occurred, then skip ahead to #R41513
       cb   a,@bytes+31                ; CP 31             ; If collision was not with entity of class 31 (Berk)...
       jne  _41513                     ; JR NZ,41513       ; ...then skip ahead to #R41513
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
* The instructions below do a "manual" check for a collision between the Skeleton and Berk. See trivia
_41513:
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is not 3 (Skeleton's room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge...
       sb   @bytes+5,a                 ; SUB 5             ; ...is at least five characters to the right of Berk's right edge...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...
       jl   !                          ; JP NC,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @6(iy),a                   ; LD A,(IY+6)       ; If y-coordinate of Berk's bottom edge...
       cb   a,@bytes+116               ; CP 116            ; ...is less than 116...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (63) Have Skeleton Advance or Retreat Based Upon Positions of Berk and Fake Boni
* 
* The skeleton will step forward once, and then step back, if Berk is close enough and Fake Boni is in a room to the
* right. If Fake Boni is in the Skeleton's room, or a room to the left of this, then the Skeleton will step forward
* repeatedly while Berk is close enough and will only back off when Berk moves out of range. The range is nine, so
* if the distance between Berk's right edge and the Skeleton's left edge is less than nine then the Skeleton will
* advance. A distance of nine or more will see the Skeleton retreat. Note that the calculated range is based upon
* the Skeleton's state data at #R45404, in which the x-coordinates of his left and right edges do not match his
* apparent position or width graphically. Input:  IX  Address of complex state data for an entity Output: HL Address
* of next script instruction to execute
script_routine_63:
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's current room is 3 (Skeleton's room)...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jeq  _41580                     ; JR Z,41580        ; ...then jump to #R41580
* Berk is not in Skeleton's room, or Fake Boni is in a room right of the Skeleton's room
_41561:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge is at least 128...
       cb   a,@bytes+128               ; CP 128            ; ...
       jhe  _41574                     ; JR NC,41574       ; ...then skip ahead to #R41574
       li   hl,_41318                  ; LD HL,41318       ; Point HL at script data for Skeleton stepping back (right)...
       b    @execute_script            ; JP 48098          ; ...and execute
_41574:
       li   hl,skeleton_idling_script  ; LD HL,41232       ; Point HL at script data for Skeleton Idling...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk is in Skeleton's room
_41580:
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Skeleton's Must Process Current Script Data Flag is reset...
       andi tmp0,1*256                 ;                   
       jeq  _41597                     ; JR Z,41597        ; ...then skip ahead to #R41597
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Skeleton's Must Process Current Script Data Flag
       movb @_45430,a                  ; LD A,(45430)      ; If Fake Boni is in a room with index of 4 or more (room above Pit, or Pit)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
_41597:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Skeleton's left edge...
       sb   @bytes+9,a                 ; SUB 9             ; ...is at least nine characters to the right of Berk's right edge...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...
       jhe  _41561                     ; JR NC,41561       ; ...then jump back to #R41561 (move Skeleton back)
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Skeleton's Must Process Current Script Data Flag
       li   hl,_41280                  ; LD HL,41280       ; Point HL at script data for Skeleton stepping forward (left)...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (64) Set Random (1 to 10) Number of Iterations in Following Loop Script Instruction
script_routine_64:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 1-10...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       .push hl                        ; PUSH HL           ; Store HL (current position in script data)
       li   bc,4                       ; LD BC,4           ; Advance HL by four bytes...
       a    bc,hl                      ; ADD HL,BC         ; ...to number of iterations in next (loop) instruction...
       movb a,*hl                      ; LD (HL),A         ; ...and set number of iterations to number generated
       .pop hl                         ; POP HL            ; Restore HL (current position in script data)
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Update State of Ghost
* 
* Used by the routine at #R41211.
_41633:
       li   ix,_45794                  ; LD IX,45794       ; Load IX with address of complex state data for Ghost (Level 4)
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _41653                     ; JR NZ,41653       ; ...then skip ahead to #R41653
* If collision was with Berk, then IY will point to Berk's complex state data
       movb @9(iy),tmp0                ; BIT 6,(IY+9)      ; If Berk is not flying...
       andi tmp0,64*256                ;                   
       jeq  _41653                     ; JR Z,41653        ; ...then skip ahead to #R41653
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
_41653:
       movb @current_characters_room,a                  ; LD A,(34218)      ; Load E with current character's current room index...
       movb a,@e                       ; LD E,A            ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with Ghost's current room index
       movb @4(ix),@c                  ; LD C,(IX+4)       ; Load C with y-coordinate of Ghost's top edge
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Ghost's bottom edge
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Ghost's Moving Upwards Flag is set...
       andi tmp0,1*256                 ;                   
       jne  _41716                     ; JR NZ,41716       ; ...then skip ahead to #R41716
       cb   a,@bytes+4                 ; CP 4              ; If Ghost's current room is 4 (room above pit)...
       jeq  _41687                     ; JR Z,41687        ; ...then skip ahead to #R41687
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+119               ; CP 119            ; ...is not 119...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Ghost's Moving Upwards Flag
       .ret                            ; RET               ; Return
* Ghost's current room is 4 (room above pit)
_41687:
       cb   a,@e                       ; CP E              ; If current character is in the same room as the Ghost...
       jeq  _41703                     ; JR Z,41703        ; ...then skip ahead to #R41703
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+119               ; CP 119            ; ...is not 119...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       ab   one,*ix                    ; INC (IX+0)        ; Increase index of Ghost's current room (to 5, pit)
       movb @bytes+94,a                ; LD A,94           ; Position Ghost such that the y-coordinate of its top edge is 115...
       jmp  _41758                     ; JR 41758          ; ...and return
* Current character and Ghost in same room (room above pit)
_41703:
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+121               ; CP 121            ; ...is not 121...
       jeq  !                          ; JP NZ,42360       ; ...then move Ghost down one character and return
       b    @_42360                    ;                   
!
       ab   one,*ix                    ; INC (IX+0)        ; Increase index of Ghost's current room (to 5, pit)
       movb @bytes+100,a               ; LD A,100          ; Position Ghost such that the y-coordinate of its top edge is 100...
       jmp  _41758                     ; JR 41758          ; ...and return
* Ghost's Moving Upwards Flag is set
_41716:
       cb   a,@bytes+5                 ; CP 5              ; If Ghost's current room is 5 (pit)...
       jeq  _41731                     ; JR Z,41731        ; ...then skip ahead to #R41731
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+101               ; CP 101            ; ...is not 101...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Ghost's Moving Upwards Flag (i.e. moving downwards)
       .ret                            ; RET               ; Return
* Ghost's current room is 5 (pit)
_41731:
       cb   a,@e                       ; CP E              ; If current character is in the same room as the Ghost...
       jeq  _41747                     ; JR Z,41747        ; ...then skip ahead to #R41747
       movb @c,a                       ; LD A,C            ; If y-coordinate of Ghost's top edge...
       cb   a,@bytes+101               ; CP 101            ; ...is not 101...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease index of Ghost's current room (to 4, room above pit)
       movb @bytes+121,a               ; LD A,121          ; Position Ghost such that the y-coordinate of its top edge is 121...
       jmp  _41758                     ; JR 41758          ; ...and return
* Current character and Ghost in same room (pit)
_41747:
       movb b,a                        ; LD A,B            ; If y-coordinate of Ghost's bottom edge...
       cb   a,@bytes+100               ; CP 100            ; ...is not 100...
       jeq  !                          ; JP NZ,42374       ; ...then move Ghost up one character and return
       b    @_42374                    ;                   
!
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease index of Ghost's current room (to 4, room above pit)
       movb @bytes+115,a               ; LD A,115          ; Prepare to set y-coordinate of Ghost's top edge to 115
_41758:
       movb a,@4(ix)                   ; LD (IX+4),A       ; Set y-coordinate of Ghost's top edge to value in A
       ab   @bytes+6,a                 ; ADD A,6           ; Add 6 to value in A (as Ghost is 6 characters tall)...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and set y-coordinate of Ghost's bottom edge to value in A
       .ret                            ; RET               ; Return

* Update State of Cannon and Projectile
* 
* Used by the routine at #R41211.
_41767:
       .call @_41961                   ; CALL 41961        ; Update State of Cannon's Projectile
       li   ix,_45508                  ; LD IX,45508       ; Load IX with address of complex state data for Cannon (Level 4)
       movb @9(ix),tmp0                ; BIT 2,(IX+9)      ; If Cannon's Just Loaded Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  _41805                     ; JR Z,41805        ; ...then skip ahead to #R41805
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease Cannon's Fire Timer...
       jeq  _41791                     ; JR Z,41791        ; ...and if now zero then skip ahead to #R41791
       li   bc,_42519                  ; LD BC,42519       ; Set Cannon's graphic layout data address to point to graphic layout data for Cannon
                                                           ; (Rocking) and return...
       b    @_42512                    ; JP 42512          ; ...
_41791:
       szcb @bits+2,@9(ix)             ; RES 2,(IX+9)      ; Reset Cannon's Just Loaded Flag
       movb @bytes+50,@12(ix)          ; LD (IX+12),50     ; Set Cannon's Fire Timer to 50
_41799:
       li   bc,_42530                  ; LD BC,42530       ; Set Cannon's graphic layout data address to point to graphic layout data for Cannon
                                                           ; (Dormant) and return...
       b    @_42512                    ; JP 42512          ; ...
* Cannon's Just Loaded Flag is reset, so Cannon has finished its rocking phase.
_41805:
       movb @_34209,a                  ; LD A,(34209)      ; If Cannon has no ammunition...
       socb a,a                        ; OR A              ; ...
       jeq  _41799                     ; JR Z,41799        ; ...then jump to #R41799 (Cannon dormant)
       movb @10(ix),tmp0               ; BIT 5,(IX+10)     ; If Cannon has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  _41799                     ; JR NZ,41799       ; ...then jump to #R41799 (Cannon dormant)
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *ix,a                      ; LD A,(IX+0)       ; If Berk's current room is the same as the Cannon's room...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  _41833                     ; JR Z,41833        ; ...then skip ahead to #R41833
       jl   _41860                     ; JR C,41860        ; If index of Berk's current room is greater than the index of the Cannon's room then skip
                                                           ; ahead to #R41860
       jmp  _41871                     ; JR 41871          ; Skip ahead to #R41871
* Berk and Cannon in same room
_41833:
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Cannon's right side is smaller than x-coordinate of Berk's left side
                                                           ; (i.e. Cannon is to left of Berk)...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...
       jl   _41860                     ; JR C,41860        ; ...then skip ahead to #R41860
       movb @7(iy),a                   ; LD A,(IY+7)       ; If x-coordinate of Berk's right side is smaller than x-coordinate of Cannon's left side
                                                           ; (i.e. Cannon is to right of Berk)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   _41871                     ; JR C,41871        ; ...then skip ahead to #R41871
* Berk and Cannon overlapping horizontally
       movb one,@e                     ; LD E,1            ; Load E with 1 (as Projectile will appear one character to the right of the Cannon's
                                                           ; coordinate position)
       movb @bytes+0,@9(ix)            ; LD (IX+9),0       ; Prepare to set Projectile's state to zero (fired vertically)
       li   bc,_42530                  ; LD BC,42530       ; Load BC with graphic layout data address for Cannon (Upright)
       jmp  _41880                     ; JR 41880          ; Skip ahead to #R41880
* Berk is to the right of the Cannon
_41860:
       movb one,@9(ix)                 ; LD (IX+9),1       ; Prepare to set Projectile's state to 1 (fired left)
       movb @bytes+2,@e                ; LD E,2            ; Load E with 2 (as Projectile will appear two characters to the right of the Cannon's
                                                           ; coordinate position)
       li   bc,_42556                  ; LD BC,42556       ; Load BC with graphic layout data address for Cannon (Tilted Right)
       jmp  _41880                     ; JR 41880          ; Skip ahead to #R41880
* Berk is to the left of the Cannon
_41871:
       movb @bytes+2,@9(ix)            ; LD (IX+9),2       ; Prepare to set Projectile's state to 2 (fired right)
       li   bc,_42594                  ; LD BC,42594       ; Load BC with graphic layout data address for Cannon (Tilted Left)
       movb @bytes+0,@e                ; LD E,0            ; Load E with 0 (as Projectile will appear at the same x-coordinate as in the Cannon's
                                                           ; coordinate position)
_41880:
       .call @_42512                   ; CALL 42512        ; Set Cannon's graphic layout data address to value in BC
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Cannon's depth is 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  !                          ; RET Z             ; ...then return (Cannon won't fire if it is placed behind Berk)
       .ret                            ;                   
!
       movb @12(ix),a                  ; LD A,(IX+12)      ; If Cannon's Fire Timer is at zero...
       socb a,a                        ; OR A              ; ...
       jeq  _41899                     ; JR Z,41899        ; ...then skip ahead to #R41899
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease Cannon's Fire Timer
       .ret                            ; RET               ; Return
* Cannon's Fire Timer is at zero
_41899:
       li   hl,_34209                  ; LD HL,34209       ; Decrease ammunition level of Cannon (Level 4) by one...
       sb   one,*hl                    ; DEC (HL)          ; ...
       movb @bytes+50,@12(ix)          ; LD (IX+12),50     ; Set Cannon's Fire Timer to 50
       li   iy,_45599                  ; LD IY,45599       ; Load IY with address of complex state data for Cannon's Projectile
       movb @5(ix),a                   ; LD A,(IX+5)       ; Set x-coordinate of Projectile's left and right sides to E plus x-coordinate of Cannon's
                                                           ; left side...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Set y-coordinates of top and bottom of Projectile to be one less than Cannon's top
                                                           ; y-coordinate...
       sb   one,a                      ; DEC A             ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; Set Projectile's room to same as Cannon's Room...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Projectile's depth to 1
       movb @9(ix),a                   ; LD A,(IX+9)       ; Set Projectile's state to value prepared previously...
       movb a,@9(iy)                   ; LD (IY+9),A       ; ...
       movb @bytes+251,@12(iy)         ; LD (IY+12),251    ; Set Projectile's y-velocity to -5
       li   bc,_51483                  ; LD BC,51483       ; Set Projectile's graphic layout data address to that for Explosion (Bubo's Projectile /
                                                           ; fallen drips, Level 4)...
       movb @c,@2(iy)                  ; LD (IY+2),C       ; ...as Projectile is launched from Cannon in an explosion...
       movb b,@3(iy)                   ; LD (IY+3),B       ; ...
       .ret                            ; RET               ; Return

* Update State of Cannon's Projectile
* 
* Used by the routine at #R41767.
_41961:
       li   ix,_45599                  ; LD IX,45599       ; Load IX with address of complex state data for Cannon's Projectile
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Projectile's depth is zero...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       li   bc,_49699                  ; LD BC,49699       ; Set Projectile's graphic layout data address to that of drip stage 8, disconnected and
                                                           ; falling (ball)...
       .call @_42512                   ; CALL 42512        ; ...
       movb @9(ix),a                   ; LD A,(IX+9)       ; If Projectile's state is zero (fired vertically)...
       socb a,a                        ; OR A              ; ...
       jeq  _42015                     ; JR Z,42015        ; ...then skip ahead to #R42015
       cb   a,@bytes+8                 ; CP 8              ; If Projectile's state is not 8 (finished)...
       jne  _41991                     ; JR NZ,41991       ; ...then skip ahead to #R41991
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set Projectile's depth to 0
       .ret                            ; RET               ; Return
_41991:
       cb   a,@bytes+2                 ; CP 2              ; If Projectile's state is not 2 (fired right)...
       jne  _42006                     ; JR NZ,42006       ; ...then skip ahead to #R42006
* Projectile flying left
       .call @_42447                   ; CALL 42447        ; Move entity left two characters...
       .call @_42447                   ; CALL 42447        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; Move entity at IX into room to the left, if appropriate
       jmp  _42015                     ; JR 42015          ; Skip ahead to #R42015
* Projectile flying right
_42006:
       .call @_42505                   ; CALL 42505        ; Move entity right two characters...
       .call @_42505                   ; CALL 42505        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; Move entity at IX into room to the right, if appropriate
* Update Projectile's vertical velocity
_42015:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load Projectile's velocity into A and E...
       movb a,@e                       ; LD E,A            ; ...
       ab   @4(ix),a                   ; ADD A,(IX+4)      ; Add velocity to y-coordinates of top and bottom of projectile...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase velocity by one (initially negative so will accelerate downwards)
       movb @e,a                       ; LD A,E            ; If velocity (before increase) was not 5...
       cb   a,@bytes+5                 ; CP 5              ; ...i.e. projectile has not yet fallen back to floor-level...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @bytes+8,@9(ix)            ; LD (IX+9),8       ; Set Projectile's state to 8 (finished)
       li   bc,_51483                  ; LD BC,51483       ; Set Projectile's graphic layout data address to that of explosion (Bubo's Projectile / fallen
                                                           ; drips, Level 4)...
       .call @_42512                   ; CALL 42512        ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       jnc  !                          ; RET C             ; ...and if no collision occurred, then return
       .ret                            ;                   
!
       cb   a,@bytes+36                ; CP 36             ; If collision was not with entity of class 36 (skeleton, Level 4)...
       jne  _42058                     ; JR NZ,42058       ; ...then skip ahead to #R42058
       li   hl,_45404+9                ; LD HL,45413       ; Set Skeleton's Is Dying Flag...
       socb @bits+1,*hl                ; SET 1,(HL)        ; ...
_42058:
       cb   a,@bytes+31                ; CP 31             ; If collision was with entity of class 31 (Berk)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
       .ret                            ; RET               ; Return

* Update States of Drips (Level 4)
* 
* Used by the routine at #R41211.
_42064:
       li   ix,_45521                  ; LD IX,45521       ; Load IX with address of complex state data for first drip (Level 4)
       movb @bytes+6,b                 ; LD B,6            ; Load B with 6 (as there are 6 drips to process)
_42070:
       .push bc                        ; PUSH BC           ; Store BC (B = Remaining number of drips to process)
       movb @12(ix),a                  ; LD A,(IX+12)      ; If current drip's velocity factor is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _42128                     ; JR NZ,42128       ; ...then skip ahead to #R42128 (handle drip's fall)
       movb @9(ix),a                   ; LD A,(IX+9)       ; If current drip's stage is not 8...
       cb   a,@bytes+8                 ; CP 8              ; ...
       jne  _42092                     ; JR NZ,42092       ; ...then skip ahead to #R42092
_42084:
       movb @8(ix),a                   ; LD A,(IX+8)       ; Reset current drip's complex state data to values stored in Table of Initial-State Data...
       .call @_53994                   ; CALL 53994        ; ...
       jmp  _42119                     ; JR 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42092:
       cb   a,@bytes+7                 ; CP 7              ; If drip's stage is not 7...
       jne  _42102                     ; JR NZ,42102       ; ...then skip ahead to #R42102
       movb one,@12(ix)                ; LD (IX+12),1      ; Set current drip's velocity factor to 1
       jmp  _42119                     ; JR 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42102:
       movb a,@c                       ; LD C,A            ; Load drip's stage into C
       movb @bytes+15,a                ; LD A,15           ; Load A with a random number, 0-14...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (14 in 15 chance)...
       jne  _42119                     ; JR NZ,42119       ; ...then advance IX to next entry in complex state data and loop back to #R42070
       movb @c,a                       ; LD A,C            ; Load drip's stage back into A...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@9(ix)                   ; LD (IX+9),A       ; Store updated drip stage value
       .call @_42251                   ; CALL 42251        ; Set drip's graphic layout data pointer to stage A graphic
_42119:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries are 13 bytes wide)
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next drip's complex state data
       .pop bc                         ; POP BC            ; Restore BC (B = Remaining number of drips to process)
       sb   one,b                      ; DJNZ 42070        ; Loop back to #R42070
       jne  _42070                     ;                   
       .ret                            ; RET               ; Return
* Drip's velocity factor is not zero
_42128:
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase drip's velocity factor
       movb one,@1(ix)                 ; LD (IX+1),1       ; Set drip's depth to 1
       li   iy,_45508                  ; LD IY,45508       ; Load IY with address of complex state data for Cannon (Level 4)
       movb a,b                        ; LD B,A            ; Load B with drip's velocity factor
_42140:
       movb *iy,a                      ; LD A,(IY+0)       ; Load Cannon's current room
       cb   a,*ix                      ; CP (IX+0)         ; If Cannon is in a different room to the drip...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Cannon's depth is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @5(iy),a                   ; LD A,(IY+5)       ; If x-coordinate of Cannon's left side...
       ab   one,a                      ; INC A             ; ...plus one...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is not the same as the x-coordinate of the drip's left side...
       jne  _42190                     ; JR NZ,42190       ; ...then skip ahead to #R42190
       movb @4(iy),a                   ; LD A,(IY+4)       ; If y-coordinate of top Cannon's top...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is not the same as the y-coordinate of the drip's top...
       jne  _42215                     ; JR NZ,42215       ; ...then skip ahead to #R42215
       movb @_34209,a                  ; LD A,(34209)      ; Increase Cannon's ammunition level by 10...
       ab   @bytes+10,a                ; ADD A,10          ; ...
       movb a,@_34209                  ; LD (34209),A      ; ...
       socb @bits+2,@9(iy)             ; SET 2,(IY+9)      ; Set Cannon's Just Loaded Flag
       movb @bytes+20,@12(iy)          ; LD (IY+12),20     ; Set Cannon's Fire Timer to 20
       jmp  _42084                     ; JR 42084          ; Reset current drip's state and loop back to #R42070 for next drip
_42190:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _42215                     ; JR NZ,42215       ; ...then skip ahead to #R42215
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
_42200:
       movb @bytes+8,a                 ; LD A,8            ; Set drip's graphical stage to 8 (exploding on contact)...
       movb a,@9(ix)                   ; LD (IX+9),A       ; ...and also set drip's stage to 8...
       .call @_42251                   ; CALL 42251        ; ...
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; Set drip's velocity factor to zero
       b    @_42119                    ; JP 42119          ; Advance IX to next entry in complex state data and loop back to #R42070
_42215:
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of top of drip is 120...
       cb   a,@bytes+120               ; CP 120            ; ...
       jeq  _42200                     ; JR Z,42200        ; ...then loop back to #R42200 (make drip explode and process next drip)
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move drip down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       sb   one,b                      ; DJNZ 42140        ; Decrease B (velocity factor) and loop back to #R42140 if not zero
       jne  _42140                     ;                   
       b    @_42119                    ; JP 42119          ; Advance IX to next entry in complex state data and loop back to #R42070

* Set a Drip's (Level 4) Stage to A
* 
* Used by the routine at #R42064. Input:  A  Index of drip state (0-8) IX  Address of complex state data for a drip
* (level 4)
_42251:
       ab   a,a                        ; ADD A,A           ; Double index of drip state...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       li   hl,_42233                  ; LD HL,42233       ; Point HL at start of table of Addresses of Graphic Layout Data for Drips (Level 4)
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL as offset
       movb *hl,@c                     ; LD C,(HL)         ; Load address (of graphic layout data) at this location into BC...
       inc  hl                         ; INC HL            ; ...
       movb *hl,b                      ; LD B,(HL)         ; ...
       .call @_42512                   ; CALL 42512        ; Set drip's graphic layout data address to BC
       .ret                            ; RET               ; Return

* Update State of Flying Skeleton Creature (Level 4)
* 
* Used by the routine at #R41211.
_42266:
       li   ix,_45482                  ; LD IX,45482       ; Load IX with address of complex state data for Flying Skeleton Creature (Level 4)
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jne  _42285                     ; JR NZ,42285       ; ...then skip ahead to #R42285
       movb @berks_state_data_4+10,a               ; LD A,(45401)      ; If Berk's Can Fall Flag is reset...
       movb a,tmp0                     ; BIT 6,A           ; ...
       andi tmp0,64*256                ;                   
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       .call @_53667                   ;                   
!
_42285:
       equ  $
       li   hl,_45482+9                ; LD HL,45491       ; Load HL with address of Flying Skeleton Creature's flags
       movb *hl,tmp0                   ; BIT 0,(HL)        ; If creature's Horizontal Direction Flag is set (moving left)...
       andi tmp0,1*256                 ;                   
       jne  _42320                     ; JR NZ,42320       ; ...then skip ahead to #R42320
* Horizontal Direction Flag reset (moving right)
       movb *ix,a                      ; LD A,(IX+0)       ; If creature's room is not 4 (Fake Boni's Room)...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jne  _42309                     ; JR NZ,42309       ; ...then skip ahead to #R42309
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of creature's right edge is less than 126...
       cb   a,@bytes+126               ; CP 126            ; ...
       jl   _42309                     ; JR C,42309        ; ...then skip ahead to #R42309
       socb @bits+0,*hl                ; SET 0,(HL)        ; Set creature's Horizontal Direction Flag (moving left)
       .ret                            ; RET               ; Return
_42309:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move creature right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; ...and move into room to the right, if appropriate
       jmp  _42346                     ; JR 42346          ; Skip ahead to #R42346
* Horizontal Direction Flag set (moving left)
_42320:
       movb *ix,a                      ; LD A,(IX+0)       ; If creature's room is not 1 (Door Room)...
       cb   a,one                      ; CP 1              ; ...
       jne  _42337                     ; JR NZ,42337       ; ...then skip ahead to #R42337
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of creature's left edge is at least 108...
       cb   a,@bytes+108               ; CP 108            ; ...
       jhe  _42337                     ; JR NC,42337       ; ...then skip ahead to #R42337
       szcb @bits+0,*hl                ; RES 0,(HL)        ; Reset creature's Horizontal Direction Flag (moving right)
       .ret                            ; RET               ; Return
_42337:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move creature left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; ...and move into room to the left, if appropriate
_42346:
       movb @4(ix),a                   ; LD A,(IX+4)       ; Load A with y-coordinate of creature's top edge
       movb *hl,tmp0                   ; BIT 1,(HL)        ; If creature's Vertical Direction Flag is set (moving up)...
       andi tmp0,2*256                 ;                   
       jne  _42367                     ; JR NZ,42367       ; ...then skip ahead to #R42367
* Vertical Direction Flag reset, moving down
       cb   a,@bytes+108               ; CP 108            ; If y-coordinate of creature's top edge is not 108...
       jne  _42360                     ; JR NZ,42360       ; ...then skip ahead to #R42360
       socb @bits+1,*hl                ; SET 1,(HL)        ; Set creature's Vertical Direction Flag (moving up)
       .ret                            ; RET               ; Return
* This entry point is used by the routine at #R41633.
_42360:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move creature down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       .ret                            ; RET               ; Return
* Vertical Direction Flag set, moving up
_42367:
       cb   a,@bytes+100               ; CP 100            ; If y-coordinate of creature's top edge is not 100...
       jne  _42374                     ; JR NZ,42374       ; ...then skip ahead to #R42374
       szcb @bits+1,*hl                ; RES 1,(HL)        ; Reset creature's Vertical Direction Flag (moving down)
       .ret                            ; RET               ; Return
* This entry point is used by the routine at #R41633.
_42374:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move creature up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       .ret                            ; RET               ; Return

* Update State of Snake (Level 4)
* 
* Used by the routine at #R41211.
_42381:
       li   ix,_45495                  ; LD IX,45495       ; Point IX at start of state data for Snake (Level 4)
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       li   hl,_45495+12               ; LD HL,45507       ; Load HL with address of Snake's Attack Progress Index
       movb *hl,a                      ; LD A,(HL)         ; If Snake's Attack Progress Index is not zero...
       socb a,a                        ; OR A              ; ...
       jne  _42415                     ; JR NZ,42415       ; ...then skip ahead to #R42415
* Snake's Attack Progress Index is zero
       movb *iy,a                      ; LD A,(IY+0)       ; If Berk's room is not 5 (Snake's room)...
       cb   a,@bytes+5                 ; CP 5              ; ...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @12(iy),tmp0               ; BIT 7,(IY+12)     ; If Berk's Is Jumping Flag is set...
       andi tmp0,128*256               ;                   
       jne  _42413                     ; JR NZ,42413       ; ...then skip ahead to #R42413
       movb @9(iy),tmp0                ; BIT 0,(IY+9)      ; If Snake's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
_42413:
       equ  $
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       .ret                            ; RET               ; Return
* Snake's Attack Progress Index is not zero
_42415:
       cb   a,@bytes+8                 ; CP 8              ; If Snake's Attack Progress Index is less than 8...
       jl   _42454                     ; JR C,42454        ; ...then jump to #R42454 (Snake moving right)
       cb   a,@bytes+15                ; CP 15             ; If Snake's Attack Progress Index is less than 15...
       jl   _42459                     ; JR C,42459        ; ...then jump to #R42459 (Snake preparing to pounce)
       cb   a,@bytes+17                ; CP 17             ; If Snake's Attack Progress Index is less than 17...
       jl   _42461                     ; JR C,42461        ; ...then jump to #R42461 (Snake pouncing)
       jeq  _42480                     ; JR Z,42480        ; If Snake's Attack Progress Index is 17 then jump to #R42480 (Snake finished pouncing)
* Snake's Attack Progress Index is greater than 17
_42429:
       movb @bytes+20,*hl              ; LD (HL),20        ; Set Snake's Attack Progress Index to 20
       li   bc,_42648                  ; LD BC,42648       ; Set Snake's graphic layout data address to #R42648...
       .call @_42512                   ; CALL 42512        ; ...(Snake, mouth closed, with animated tongue)
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of Snake's left edge is not 83...
       cb   a,@bytes+83                ; CP 83             ; ...
       jne  _42447                     ; JR NZ,42447       ; ...then move Snake left one character and return
       movb @bytes+0,*hl               ; LD (HL),0         ; Set Snake's Attack Progress Index to 0
       .ret                            ; RET               ; Return
* This entry point is used by the routine at #R41961.
_42447:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Decrease x-coordinates of left and right edges of entity at IX by one...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       .ret                            ; RET               ; Return
* Snake's Attack Progress Index is less than 8
_42454:
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       .call @_42505                   ; CALL 42505        ; Move Snake right one character
       .ret                            ; RET               ; Return
* Snake's Attack Progress Index is 8 or more, but less than 15
_42459:
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       .ret                            ; RET               ; Return
* Snake's Attack Progress Index is 15 or more, but less than 17
_42461:
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the y-coordinate of Berk's bottom edge is less than 116...
       cb   a,@bytes+116               ; CP 116            ; ...
       jl   _42429                     ; JR C,42429        ; ...then jump back to #R42429
       .call @_42486                   ; CALL 42486        ; Open Snake's mouth and set Berk Has Been Killed Flag if Snake and Berk have collided
       movb @bytes+4,b                 ; LD B,4            ; Move Snake right four characters...
_42473:
       .call @_42505                   ; CALL 42505        ; ...
       sb   one,b                      ; DJNZ 42473        ; ...
       jne  _42473                     ;                   
       ab   one,*hl                    ; INC (HL)          ; Increase Snake's Attack Progress Index
       .ret                            ; RET               ; Return
* Snake's Attack Progress Index is 17
_42480:
       .call @_42486                   ; CALL 42486        ; Open Snake's mouth and set Berk Has Been Killed Flag if Snake and Berk have collided
       movb @bytes+20,*hl              ; LD (HL),20        ; Set Snake's Attack Progress Index to 20
       .ret                            ; RET               ; Return

* Open Snake's Mouth and Set Berk Has Been Killed Flag if Snake and Berk Have Collided
* 
* Used by the routine at #R42381. Input:  HL  Address of Snake's Attack Progress Index IX  Address of complex state
* data for Snake (Level 4)
_42486:
       li   bc,_42703                  ; LD BC,42703       ; Set Snake's graphic layout data address to #R42703...
       .call @_42512                   ; CALL 42512        ; ...(Snake, mouth open, attacking)
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+31                ; CP 31             ; ...and if collision was not with entity of class 31 (Berk)...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       movb @bytes+18,*hl              ; LD (HL),18        ; Set Snake's Attack Progress Index to 18
       .call @_53667                   ; CALL 53667        ; Set "Berk Has Been Killed" Flag
       .ret                            ; RET               ; Return

* Move Entity at IX Right One Character
* 
* Used by the routines at #R41961 and #R42381.
_42505:
       ab   one,@7(ix)                 ; INC (IX+7)        ; Increase x-coordinates of left and right edges of entity at IX by one...
       ab   one,@5(ix)                 ; INC (IX+5)        ; ...
       .ret                            ; RET               ; Return

* Set Graphic Layout Data Address for Entity at IX to BC
* 
* Used by the routines at #R41767, #R41961, #R42251, #R42381 and #R42486. Input:  BC  Holds address of graphic
* layout data
_42512:
       movb @c,@2(ix)                  ; LD (IX+2),C       ; Set current entity's graphic layout data address to BC...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       .ret                            ; RET               ; Return

* Populate Primary Display Buffer with Layout Data for Current Character's Current Room
* 
* Used by the routine at #R34438.
populate_prim_disp_buf:
       .proc
       ; LD HL,(34279)                 ; Modify instruction at #R46045 with address of Primary Display Buffer..
                                       ; LD (46046),HL     ; ...
       movb @tmp_room_dim_data,@c      ; LD A,(34230)      ; Load C with depth of current character's current room...
                                       ; LD C,A            ; ...
       movb @current_characters_room,b ; LD A,(34218)      ; Load B with index of current character's current room...
                                       ; LD B,A            ; ...
       sb   d,d                        ; LD D,0            ; Load D with zero
* Start drawing simple entities
populate_prim_disp_buf_1:
       mov  @current_data_addrs,ix     ; LD IX,(34236)     ; Load IX with start address of current level's simple state data
       movb @bytes+6,@e                ; LD E,6            ; Load DE with 6 (as simple state data entries are 6 bytes wide)
populate_prim_disp_buf_2:
       movb *ix,a                      ; LD A,(IX+0)       ; Load first byte of current simple state data entry into A
       cb   a,@bytes+255               ; CP 255            ; If this is 255 (end marker for complex state data)...
       jeq  populate_prim_disp_buf_5   ; JR Z,45961        ; ...then skip ahead to #R45961
       cb   a,@bytes+254               ; CP 254            ; If it is not 254 (end marker for level's simple state data)...
       jne  populate_prim_disp_buf_3   ; JR NZ,45939       ; ...then skip ahead to #R45939
* At this point, we have passed the end marker for the simple state data block and are now at the start of the
* complex state data block whose entries are 13 bytes wide.
       movb @bytes+13,@e               ; LD E,13           ; Load DE with 13
       inc  ix                         ; INC IX            ; Advance IX to start of complex state data block
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with entity's room index
* At this point, A holds the index of the room to which the simple or complex entity belongs
populate_prim_disp_buf_3:
       cb   a,b                        ; CP B              ; If entity's room is not the same as the current character's current room...
       jne  populate_prim_disp_buf_4   ; JR NZ,45957       ; ...then skip ahead to #R45957
       movb @c,a                       ; LD A,C            ; If entity's depth is not the same as current depth in C...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  populate_prim_disp_buf_4   ; JR NZ,45957       ; ...then skip ahead to #R45957
       .exx                            ; EXX               ; Switch registers
       .push ix                        ; PUSH IX           ; Store IX (pointer to current entry in simple/complex state data)
       bl   @populate_disp_buf_with_entity ; CALL 45965   ; Load Primary Display Buffer with graphic layout data for current entity
       .pop ix                         ; POP IX            ; Restore IX (pointer to current entry in simple/complex state data)
       .exx                            ; EXX               ; Switch registers
populate_prim_disp_buf_4:
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next entity's state data
       jmp  populate_prim_disp_buf_2   ; JR 45921          ; Loop back to #R45921
populate_prim_disp_buf_5:
       sb   one,@c                     ; DEC C             ; Decrease current depth (i.e. closer to screen)
       jne  populate_prim_disp_buf_1   ; JR NZ,45915       ; If depth is not zero (i.e. still depth levels to process) then loop back to #R45915
       .endproc                        ; RET               ; Return

* Populate Primary Display Buffer with Graphic Layout Data for Entity Whose Simple / Complex State Data is at
* Address in IX
* 
* Used by the routine at #R45899. Input:  IX  Address of complex state data for an entity IX  (Entry at #R45999,
* #R46001 or #R46003 only) Address of graphic layout data to draw B  (Entry at #R45999, #R46001 or #R46003 only) 0
* if current position in Display Buffer needs to be recalculated. 1 otherwise.
populate_disp_buf_with_entity:
       .proc
       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load DE with address of graphic layout data for entity...
       movb @3(ix),d                   ; LD D,(IX+3)       ; ...
       movb @tmp_room_dim_data+3,a     ; LD A,(34233)      ; Load A with y-coordinate of top edge of current character's current room...
       ab   @4(ix),a                   ; ADD A,(IX+4)      ; ...add y-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,@l                       ; LD L,A            ; ...and load into L
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load A with x-coordinate of left edge of current character's current room...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...add x-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,h                        ; LD H,A            ; ...and load into H
       swpb hl                         ; Big endian
       mov  hl,@draw_coordinates       ; LD (34281),HL     ; Store x- and y-coordinates at #R34281
       swpb hl                         ; Little endian
       mov  de,ix                      ; PUSH DE           ; Transfer address of graphic layout data in simple/complex state data from DE...
                                       ; POP IX            ; ...into IX
       sb   b,b                        ; LD B,0            ; Reset Do Not Recalculate Display Buffer Address Flag, as address not yet calculated
       jmp  process_data_in_ix         ; JR 46003          ; Jump to #R46003 (read / process data at address in IX)
* This entry point is used by the routines at #R46427, #R46442, #R46460 and #R46599.
inct_and_process_data:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46284, #R46295 and #R46306.
inc_and_process_data:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46317, #R46347, #R46363, #R46460, #R46481, #R46495, #R46611,
* #R46628, #R46647 and #R46664.
process_data_in_ix:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of graphic layout data entry is at least 236...
       cb   a,@bytes+236               ; CP 236            ; ...i.e. IX points to an instruction...
       jl   draw_graphics              ; JP NC,46218       ; ...then jump to appropriate graphic layout routine
       b    @jump_to_graphics_routine                    ;
* At this point, the graphic layout data pointed to by IX is graphical data, not an instruction. We only draw the
* graphics if they lie within the display area (i.e. have x- and y-coordinates less than 32 and 24 respectively, see
* trivia).
draw_graphics:
                                       ; LD A,H            ; If x-coordinate of graphic to draw is 32 or more...
       cb   h,@bytes+32                ; CP 32             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
                                       ; LD A,L            ; If y-coordinate of graphic to draw is 24 or more...
       cb   @l,@bytes+22               ; CP 24             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
       .push hl                        ; PUSH HL           ; Store HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
       sb   one,b                      ; DEC B             ; Decrease value of Don't Recalculate Display Buffer Address Flag
       jeq  draw_graphics_1            ; JP Z,46051        ; If B is zero (i.e. we don't need to recalculate current position in display buffer), then
                                       ;                   ; skip ahead to #R46051
* If B was 1, then we need to load DE with the address of the current position in the Primary Display Buffer.
       clr  de
       movb h,@e
       mov  de,tmp0
       a    tmp0,tmp0
       a    tmp0,de
       movb @l,@r0lb
       mpy  @w96,tmp0
       a    tmp1,de
;       movb h,a                        ; LD A,H            ; Load C with three times entity's x-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   h,a                        ; ADD A,H           ; ...
;       movb a,@c                       ; LD C,A            ; ...
;       movb @l,a                       ; LD A,L            ; Load DE with double entity's y-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       sb   d,d                        ; LD D,0            ; ...
;       movb d,b                        ; LD B,D            ; Set B to zero (BC now holds three times x-coordinate)
;       li   hl,multiples_of_96         ; LD HL,46170       ; Point HL at start of Table of Multiples of 96
;       a    de,hl                      ; ADD HL,DE         ; Add double y-coordinate as offset
;       mov  *hl,de                     ; LD E,(HL)         ; Load DE with corresponding multiple of 96...
;                                       ; INC HL            ; ...
;                                       ; LD D,(HL)         ; ...
* The operand of the instruction at #R46045 represents the address of the Primary Display Buffer. This is modified
* by the instruction at #R45902.
       a    @prim_disp_buffer_addr,de
;       li   hl,0                       ; LD HL,0           ; Load HL with start address of Primary Display Buffer
;       a    de,hl                      ; ADD HL,DE         ; Move HL to position in Primary Display Buffer corresponding to x- and y-coordinates of
;                                                           ; entity...
;       a    bc,hl                      ; ADD HL,BC         ; ...
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now points to position in Primary Display Buffer for current entity) and HL
draw_graphics_1:
       movb *de,a                      ; LD A,(DE)         ; Load A with Graphic Set Index plus one from this entry in Primary Display Buffer...
                                       ; INC A             ; ...and if value is now zero (i.e. old value was 255 corresponding to a block outside
                                                           ; dimensions of room)...
       jlt  draw_graphics_8            ; JP Z,46150        ; ...then skip ahead to #R46150
       movb @graphic_set_index,*de+    ; LD A,(34268)      ; Load current Graphic Set Index into this location in Primary Display Buffer...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to Graphic Index in current character block's entry in Primary Display Buffer
       movb *ix,*de+                   ; LD A,(IX+0)       ; Load Graphic Index into current Display Buffer location...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to next byte in current character block's display buffer entry (Attribute)
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_2            ; JR NZ,46077       ; ...then skip ahead to #R46077
* Current Attribute is zero (i.e. not set) so DE points to attribute data
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)...
       movb *ix,a                      ; LD A,(IX+0)       ; ...and load into A
* At this point, A holds an attribute value either from the graphic layout data, or the Current Attribute as stored
* at #R34270. This attribute is to be applied to the current display buffer location. IX (current position in
* graphic layout data) is pointing to either the graphic index (if the Current Attribute at #R34270 is set) or the
* attribute data (if the Current Attribute is not set). In either case, IX+1 is the address of the Cursor Shift
* byte. Bit 7 of the Cursor Shift byte is the Override Attribute Flag.
draw_graphics_2:
       movb @1(ix),tmp0                ; BIT 7,(IX+1)      ; If bit 7 (Override Attribute Flag) is set...
                                       ;
       jlt  draw_graphics_4            ; JP NZ,46111       ; ...then skip ahead to #R46111
* Override Attribute Flag reset
       movb a,tmp0                     ; LD L,A            ; Load L with attribute value
       czc  @paper_bits,a
                                       ; AND 56            ; Check PAPER bits
                                       ; LD A,L            ; Restore attribute value to A
       jne  draw_graphics_4            ; JP NZ,46111       ; If PAPER is not zero (i.e. black) then skip ahead to #R46111
* The instructions between #R46091 and #R46110 (inclusive) are executed only when the PAPER component of the
* attribute in A (and L) is black. If the Preserve INK Flag is reset in the attribute value loaded (at #R46098) from
* the Display Buffer, then the instruction at #R46107 will leave the reset (i.e. black) PAPER bits in A. If the
* Preserve INK Flag is set, then the instructions between #R46104 and #R46106 (inclusive) will shift the bits used
* for INK into the PAPER positions and this PAPER colour (originally INK colour) will be preserved when the
* instruction at #R46107 is executed.
       andi a,192*256                  ; AND 192           ; Reset all bits except Preserve INK and Mirror flags
       movb a,b                        ; LD B,A            ; Load B with Preserve INK and Mirror flags
                                       ; LD A,L            ; Restore attribute value to A
       andi tmp0,63*256                ; AND 63            ; Reset bits Preserve INK and Mirror flags
                                       ; LD C,A            ; Load C with INK and PAPER bits of attribute value
       movb *de,a                      ; LD A,(DE)         ; Load value currently in Display Buffer into A...
       czc  @preserve_ink_flag,a       ; BIT 6,A           ; ...and if Preserve INK Flag is reset...
                                       ;
       jeq  draw_graphics_3            ; JP Z,46107        ; ...then skip ahead to #R46107
* Preserve INK Flag set in Display Buffer
       sla  a,3                        ; ADD A,A           ; Shift INK bits into PAPER bits...
                                       ; ADD A,A           ; ...
                                       ; ADD A,A           ; ...
draw_graphics_3:
       andi a,56*256                   ; AND 56            ; Reset all except PAPER bits
       socb b,a                        ; OR B              ; (Re)set Preserve INK and Mirror flags as stored in B previously
       socb tmp0,a                     ; OR C              ; Set INK bits as stored in C previously (PAPER was black)
draw_graphics_4:
       movb a,*de                      ; LD (DE),A         ; Load attribute in A into Display Buffer
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
* Read Cursor Shift byte. Bits 0-6 of this byte control where the cursor to write to Primary Display Buffer is moved
* to after writing the current character block. A value of 33 advances the cursor right by one character. A value,
* n, less than 33 moves the cursor down a character row, and left by 33-(n+1) characters. A value greater than 33
* moves the cursor right by (n+1)-33 characters. Bit 7 is the Override Attribute Flag.
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (End Marker)...
       jne  draw_graphics_4a           ; JP Z,46418        ; ...then jump to #R46418 (load HL with stored coordinates from #R34281 and return from
       b    @graphics_routine_255                          ; drawing)
draw_graphics_4a:
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33, and if remaining value is 0 (i.e. original value was 33)...
       jeq  draw_graphics_7            ; JP Z,46140        ; ...then skip ahead to #R46140...
draw_graphics_5:
       cb   tmp0,@bytes+33
       jhe  draw_graphics_6            ; JP NC,46132       ; ...else, if value was greater than 33 then skip ahead to #R46132
* Cursor Shift byte was less than 33 (move the cursor down a character row, and left by 33-(n+1) characters)
       inc  hl                         ; INC L             ; Increase y-coordinate
draw_graphics_6:
       ab   one,a                      ; INC A             ; Increase A (x-coordinate offset) and add to x-coordinate...
       ab   h,a                        ; ADD A,H           ; ...
       movb a,h                        ; LD H,A            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address as change in coordinates is non-trivial
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* Cursor Shift byte was 33 (move the cursor right by one character)
draw_graphics_7:
       inc  de                         ; INC DE            ; Advance pointer to start of next entry in Primary Display Buffer
       ab   one,h                      ; INC H             ; Increase x-coordinate by one
                                       ; JP Z,46135        ; If x-coordinate is zero then jump back to #R46135 (see trivia)
       movb one,b                      ; LD B,1            ; Prepare to skip over recalculation of Display Buffer address as we moved right one character
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* First byte in Primary Display Buffer entry for current position is 255 (i.e. outside dimensions of room)
draw_graphics_8:
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
draw_graphics_9:
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_10           ; JP NZ,46160       ; ...then skip ahead to #R46160
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)
draw_graphics_10:
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0                     ; required
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33...
       jmp  draw_graphics_5            ; JP 46128          ; ...and jump back to #R46128 to update current drawing position

* Jump to Appropriate Graphic Layout Routine
* 
* Used by the routine at #R45965. Input:  A  Index of graphic layout data instruction IX  Address of current graphic
* layout data instruction
jump_to_graphics_routine:
       inc  ix                         ; INC IX            ; Advance IX to first parameter byte in graphic layout data
       sb   @bytes+236,a               ; SUB 236           ; Subtract 236 to get zero-based index of required instruction
       ab   a,a                        ; ADD A,A           ; Load double index of graphic layout data instruction into BC...
       movb a,@c                       ; LD C,A            ; ...
       sb   b,b                        ; LD B,0            ; ...
                                       ; PUSH HL           ; Store HL
       mov  @graphic_routines_jmp_tbl(bc),bc ; LD HL,46244       ; Point HL at start of Table of Addresses of Graphic Layout Data Handling Routines
       b    *bc                        ; ADD HL,BC         ; Add doubled instruction index as offset to HL to point to address of required routine
                                       ; LD A,(HL)         ; Modify JP instruction at #R46241 with this address...
                                       ; LD (46242),A      ; ...
                                       ; INC HL            ; ...
                                       ; LD A,(HL)         ; ...
                                       ; LD (46243),A      ; ...
                                       ; POP HL            ; Restore HL
* The operand of the instruction at #R46241 represents the addresses of the required graphic layout data handling
* routine. This is modified by the instruction at #R46232.
self_mod_instr_2:
;       b    0                          ; JP 0              ;


* Graphic Layout Routine (237) Set New Pending Sound Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_237:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
       .call @request_sound            ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inc_and_process_data      ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (242) Set Current Attribute Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_242:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       movb a,@current_attr            ; LD (34270),A      ; ...and set as current Attribute
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inc_and_process_data      ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (244) Set Current Graphic Set Index Input:  IX  Address of first parameter in current
* graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_244:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       movb a,@graphic_set_index       ; LD (34268),A      ; ...and set as current Graphic Set Index
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inc_and_process_data      ; JP 46001          ; Advance graphic layout data pointer by one byte and read / process next data

* Graphic Layout Routine (236) Set Graphic Index in Next Instruction to Value Randomly Selected from List
* 
* Read Current Byte (n, random number cap), generate random number m (1 to n inclusive) and copy the m-th byte in
* following list into position after end of list bytes (i.e. the graphic index field of the next graphic layout data
* entry), then advance current position to this location. Input:  IX  Address of first parameter in current graphic
* layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic
* layout data instruction to process
graphics_routine_236:
       .push ix                        ; PUSH IX           ; Store current position in graphic layout data
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte (Random Number Cap) from graphic layout data into A...
       movb a,@e                       ; LD E,A            ; ...and copy into E
       bl   @rnd_no                    ; CALL 54222        ; Load BC with a random number, 1-A...
       ab   one,a                      ; INC A             ; ...
       movb a,@c                       ; LD C,A            ; ...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by number of bytes stored in BC
       movb *ix,a                      ; LD A,(IX+0)       ; Load byte at this location into A
       .pop ix                         ; POP IX            ; Restore previous position in graphic layout data
       movb @e,@c                      ; LD C,E            ; Load Random Number Cap into BC...
       ab   one,@c                     ; INC C             ; ...and add one
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by this number of bytes
       movb a,*ix                      ; LD (IX+0),A       ; Store byte previously read at current position
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (245) Decrease Timer Value, and if Zero, Reset and Write Random Graphic Index from List
* into Next Instruction
* 
* Decrease timer value (1st parameter). If now zero, then reset timer to value in 2nd parameter, then load one of
* the n (3rd parameter) following values chosen at random into the Graphic Index field of the next instruction.
* Input:  IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate
* Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
graphics_routine_245:
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease timer value
       jne  _46370                     ; JR NZ,46370       ; If timer is not zero, then advance IX to start of next instruction and process
       bl  @reset_timer                ; CALL 46385        ; Reset timer to maximum, advance IX to start of next instruction and set value here (graphic
                                                           ; index) to random value from sequence of data following previous instruction...
       movb @e,*ix                     ; LD (IX+0),E       ; ...
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (246) Decrease Timer Value, and if Zero, Reset and Write Random Attribute from List into
* Next Instruction
* 
* Decrease timer value (1st parameter). If now zero, then reset timer to value in 2nd parameter, then load one of
* the n (3rd parameter) following values chosen at random into the Attribute field of the next instruction. Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
graphics_routine_246:
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease timer value
       jeq  _46376                     ; JR Z,46376        ; If timer is zero, then reset timer, advance to next instruction and set that instruction's
                                                           ; attribute to random value from sequence
* This entry point is used by the routine at #R46347.
_46370:
       bl   @reset_timer_1             ; CALL 46409        ; Advance to next instruction and process...
       b    @process_data_in_ix        ; JP 46003          ; ...
_46376:
       bl   @reset_timer               ; CALL 46385        ; Reset timer to maximum, advance IX to start of next instruction and set second value here
                                                           ; (attribute) to random value from sequence of data following previous instruction...
       movb @e,@1(ix)                  ; LD (IX+1),E       ; ...
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Reset Timer to Initial Value then Load E with Random Value from Sequence (in Graphic Layout Data)
* 
* Used by the routines at #R46347 and #R46363. Input:  B  Always zero IX  Current address in graphic layout data
reset_timer:
       movb @1(ix),a                   ; LD A,(IX+1)       ; Set current timer value to maximum...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       movb @2(ix),a                   ; LD A,(IX+2)       ; Load A with number of states
       bl   @rnd_no                    ; CALL 54222        ; Set C to a random number between 3 and (number of states + 2)...
       ab   @bytes+3,a                 ; ADD A,3           ; ...
       movb a,@c                       ; LD C,A            ; ...
       .push ix                        ; PUSH IX           ; Store IX (current position in graphic layout data)
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by C bytes (BC = C, as B = 0)
       movb *ix,@e                     ; LD E,(IX+0)       ; Load E with value at this position
       .pop ix                         ; POP IX            ; Restore IX (old position in graphic layout data)
* This entry point is used by the routine at #R46363.
reset_timer_1:
       movb @2(ix),a                   ; LD A,(IX+2)       ; Advance IX by number of states + 3 bytes to arrive at start of next data...
       ab   @bytes+3,a                 ; ADD A,3           ; ...
       movb a,@c                       ; LD C,A            ; ...
       a    bc,ix                      ; ADD IX,BC         ; ...
       rt                              ; RET               ; Return

* Graphic Layout Routine (255) Load HL with Stored Coordinates from 34281 and Return from Drawing
* 
* Note that when returning from another block of graphic layout data, the Current Attribute stored at #R34270 (and
* set in the called block) is not preserved. Upon returning, the Current Attribute value is cleared. Output: B  Do
* Not Recalculate Display Buffer Address Flag (0) H  Current x-coordinate L  Current y-coordinate
graphics_routine_255:
       sb   a,a                        ; XOR A             ; Set Current Attribute to zero...
       movb a,@current_attr            ; LD (34270),A      ; ...
       mov  @draw_coordinates,hl       ; LD HL,(34281)     ; Load HL with base x- and y-coordinates
       swpb hl                         ; Little endian
       movb a,b                        ; LD B,A            ; Set B to zero
       .ret                            ; RET               ; Return

* Graphic Layout Routine (250) Adjust x- and y-Coordinates for Drawing Without Storing
* 
* Read following two bytes in graphic layout data and adjust y- and x-coordinates by these amounts respectively,
* without storing. These new coordinates will be lost on the next draw operation, being overwritten by the values
* stored at #R34281. Input:  IX  Address of first parameter in current graphic layout data instruction Output: B  Do
* Not Recalculate Display Buffer Address Flag (0)
graphics_routine_250:
       movb *ix,a                      ; LD A,(IX+0)       ; Read delta-y into A...
       ab   @l,a                       ; ADD A,L           ; ...and adjust y-coordinate by this amount...
       movb a,@l                       ; LD L,A            ; ...
       movb @1(ix),a                   ; LD A,(IX+1)       ; Read delta-x into A...
       ab   h,a                        ; ADD A,H           ; ...and adjust x-coordinate by this amount...
       movb a,h                        ; LD H,A            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (254) Adjust x- and y-Coordinates for Drawing and Set as New Base Coordinates
* 
* Read following two bytes in graphic layout data and adjust y- and x-coordinates by these amounts respectively,
* storing at #R34281 as base coordinates. These new coordinates will be used as the starting position on the next
* draw operation. Input:  H  Current x-coordinate L  Current y-coordinate IX  Address of first parameter in current
* graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_254:
       movb *ix,a                      ; LD A,(IX+0)       ; Read delta-y into A...
       ab   @l,a                       ; ADD A,L           ; ...and adjust y-coordinate by this amount...
       movb a,@l                       ; LD L,A            ; ...
       movb @1(ix),a                   ; LD A,(IX+1)       ; Read delta-x into A...
       ab   h,a                        ; ADD A,H           ; ...and adjust x-coordinate by this amount...
       movb a,h                        ; LD H,A            ; ...
       swpb hl                         ; Big endian
       mov  hl,@draw_coordinates       ; LD (34281),HL     ; Store new coordinates at #R34281
       swpb  hl                        ; Little endian
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (251) Process Graphic Layout Data at Following Address and Return When Complete
* 
* Functionally equivalent to "CALL" instruction. Read current WORD (address) from graphic layout data, load graphic
* layout data at that address into Primary Display Buffer and return to previous position. Upon returning (via
* routine at #R46418 when a 255 is encountered), the position of the cursor (i.e. the value in HL) is reset to the
* base coordinates as stored at #R34281 - see instruction at #R46422. Input:  IX  Address of first parameter in
* current graphic layout data instruction Output: B  Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_251:
       movb *ix,@c                     ; LD C,(IX+0)       ; Load BC with destination graphic layout data address...
       movb @1(ix),b                   ; LD B,(IX+1)       ; ...
       .push ix                        ; PUSH IX           ; Store IX (current position in graphic layout data)
       mov  bc,ix                      ; PUSH BC           ; Transfer address just read into BC into IX...
                                       ; POP IX            ; ...
       .call @process_data_in_ix       ; CALL 46003        ; Load graphic layout data from this new location into Primary Display Buffer (recursive call)
       .pop ix                         ; POP IX            ; Restore IX (previously stored position in graphic layout data)
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (248) Jump to Graphic Layout Data Address
* 
* Read current WORD (address) from graphic layout data and move graphic layout data Pointer to this address. Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
graphics_routine_248:
       movb *ix,@c                     ; LD C,(IX+0)       ; Load next two bytes as a WORD into IX...
       movb @1(ix),b                   ; LD B,(IX+1)       ; ...
       mov  bc,ix                      ; PUSH BC           ; ...
                                       ; POP IX            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (249) Jump to Time-Weighted, Randomly Selected Graphic Layout Data Address in List Input:
* IX  Address of first parameter in current graphic layout data instruction Output: B  Do Not Recalculate Display
* Buffer Address Flag (0) IX  Address of next graphic layout data instruction to process
graphics_routine_249:
       .push ix                        ; PUSH IX           ; Store IX (pointer to first parameter in graphic layout data)
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with current state number
       ab   a,a                        ; ADD A,A           ; Multiply A by four and add two...
       ab   a,a                        ; ADD A,A           ; ...to give number of bytes of data to skip over...
       ab   @bytes+2,a                 ; ADD A,2           ; ...
       movb a,@c                       ; LD C,A            ; Load BC with value in A...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; ...and add to IX to advance to start of data for current state
       sb   one,*ix                    ; DEC (IX+0)        ; Decrease the timer value for this state...
       jne  _46544                     ; JR NZ,46544       ; ...and if not zero, skip ahead to #R46544
       .pop ix                         ; POP IX            ; Restore (pointer to first parameter in graphic layout data)
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with random number...
       bl   @rnd_no                    ; CALL 54222        ; ...from zero to one less than number of states...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and set this as the index of the current state
       ab   a,a                        ; ADD A,A           ; Multiply A by four and add two...
       ab   a,a                        ; ADD A,A           ; ...to give number of bytes of data to skip over...
       ab   @bytes+2,a                 ; ADD A,2           ; ...
       movb a,@c                       ; LD C,A            ; Load BC with value in A
       a    bc,ix                      ; ADD IX,BC         ; Advance IX to start of data for (new) current state
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with random number...
       bl   @rnd_no                    ; CALL 54222        ; ...from one to maximum timer value for state...
       ab   one,a                      ; INC A             ; ...
       movb a,*ix                      ; LD (IX+0),A       ; ...and set as current timer value for this state
       jmp  _46545                     ; JR 46545          ; Skip ahead to #R46545
_46544:
       .pop bc                         ; POP BC            ; Restore BC (graphic layout data position, was previously in IX)
_46545:
       movb @2(ix),@c                  ; LD C,(IX+2)       ; Load IX with graphic layout data address...
       movb @3(ix),b                   ; LD B,(IX+3)       ; ...in current state's data...
       .push bc                        ; PUSH BC           ; ...
       .pop ix                         ; POP IX            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @process_data_in_ix                    ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (243) Increment Index, n, and Jump to n-th Address in Following List
* 
* Read first parameter (n) from graphic layout data, increment (resetting to zero if it is equal to the length of
* the list of addresses as specified by the second parameter) and jump to n-th address. Input:  IX  Address of first
* parameter in current graphic layout data instruction Output: A  Number of bytes in graphic layout data to skip
* over
graphics_routine_243:
       movb *ix,a                      ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
       ab   one,a                      ; INC A             ; Increase by one
       cb   a,@1(ix)                   ; CP (IX+1)         ; If following byte (cap value) is greater than current byte...
       jl   _46569                     ; JR C,46569        ; ...then skip ahead to #R46569
       sb   a,a                        ; XOR A             ; Reset current value to zero as cap value reached
_46569:
       movb a,*ix                      ; LD (IX+0),A       ; Load current value back into current position in graphic layout data
       ab   a,a                        ; ADD A,A           ; Load double current value + 2 (as we're skipping over first two bytes and subsequent data are
                                                           ; WORD addresses) into A...
       ab   @bytes+2,a                 ; ADD A,2           ; ...
       jmp  _46586                     ; JR 46586          ; Jump to #R46586

* Graphic Layout Routine (247) Jump to Randomly Selected Graphic Layout Data Address from List
* 
* Read current byte value (n) from graphic layout data, generate random number m (0 - n-1) then jump to address in
* m-th WORD after current position. Input:  A  (Entry at #R46585) Number of words in graphic layout data to skip
* over A  (Entry at #R46586) Number of bytes in graphic layout data to skip over IX  Address of first parameter in
* current graphic layout data instruction Output: IX  Address of next graphic layout data instruction to process
graphics_routine_247:
       movb *ix+,a                     ; LD A,(IX+0)       ; Load current byte of graphic layout data into A
                                       ; INC IX            ; Advance pointer to next byte
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number between 0 and (A-1)
* This entry point is used by the routine at #R46594.
_46585:
       ab   a,a                        ; ADD A,A           ; Double the number
* This entry point is used by the routine at #R46559.
_46586:
       movb a,@c                       ; LD C,A            ; Load BC with offset value in A...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Advance IX by offset value
       b    @graphics_routine_248      ; JP 46481          ; Jump to #R46481 (set current position in graphic layout data to value of WORD at this
                                                           ; address)

* Graphic Layout Routine (253) Jump to Graphic Layout Data Address Selected from List, Based Upon Width of Berk's
* Carried Entity Output: A  Number of words in graphic layout data to skip over
graphics_routine_253:
       movb @carried_entity_width,a                  ; LD A,(34272)      ; Load A with width of entity (characters) carried by Berk, minus 1
       jmp  _46585                     ; JR 46585          ; Set current position in graphic layout data to value of A-th word in list

* Unused routine
* 
* Graphic layout routine (252): if Berk is holding nothing then jump to address. Input:IX Address of first parameter
* in current graphic layout data instruction Output:B Do Not Recalculate Display Buffer Address Flag (0)
graphics_routine_252:
       movb @_34221,a                  ; LD A,(34221)      ; If Berk is not holding anything...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,46481        ; ...then jump to #R46481 (set current position in graphic layout data to value of WORD at this
       b    @graphics_routine_248                    ;
!
                                                           ; address)
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @inct_and_process_data     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data

* Graphic Layout Routine (238) Start Loop (1 / 2)
* 
* Start a loop in graphic layout data. The parameter is the repeat count. The current value of the repeat counter is
* stored at #R34274 and the address of the next instruction (i.e. the first instruction that is processed in each
* loop) is stored at #R34294. Input:  IX  Address of first parameter in current graphic layout data instruction
* Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction
* to process
graphics_routine_238:
       movb *ix+,a                     ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       movb a,@loop_counter_value_1    ; LD (34274),A      ; ...into #R34274 (repeat counter)
                                       ; INC IX            ; Advance IX to next position in graphic layout data...
       mov  ix,@loop_address           ; LD (34294),IX     ; ...and store at #R34294
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (239) End Loop (1 / 2) Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX
* Address of next graphic layout data instruction to process
graphics_routine_239:
       movb @loop_counter_value_1,a    ; LD A,(34274)      ; Decrement repeat counter...
       sb   one,a                      ; DEC A             ; ...
       movb a,@loop_counter_value_1    ; LD (34274),A      ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       movb a,a
       jeq  !                          ; JP Z,46003        ; If repeat counter is zero, then exit loop and process subsequent bytes...
       mov  @loop_address,ix           ; LD IX,(34294)     ; ...else, restore stored position in graphic layout data (start of loop)...
!      b    @process_data_in_ix        ; JP 46003          ; ...and continue processing data from this point

* Graphic Layout Routine (240) Start Loop (2 / 2)
* 
* Start a loop in graphic layout data. The parameter is the repeat count. The current value of the repeat counter is
* stored at #R34275 and the address of the next instruction (i.e. the first instruction that is processed in each
* loop) is stored at #R34296. Input:  IX  Address of first parameter in current graphic layout data instruction
* Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX  Address of next graphic layout data instruction
* to process
graphics_routine_240:
       movb *ix+,a                     ; LD A,(IX+0)       ; Load current byte of graphic layout data...
       movb a,@loop_counter_value_2    ; LD (34275),A      ; ...into #R34275 (repeat counter)
                                       ; INC IX            ; Advance IX to next position in graphic layout data...
       mov  ix,@loop_start             ; LD (34296),IX     ; ...and store at #R34296
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       b    @process_data_in_ix        ; JP 46003          ; Read / process data at address in IX

* Graphic Layout Routine (241) End Loop (2 / 2) Output: B  Do Not Recalculate Display Buffer Address Flag (0) IX
* Address of next graphic layout data instruction to process
graphics_routine_241:
       movb @loop_counter_value_2,a    ; LD A,(34275)      ; Decrement repeat counter...
       sb   one,a                      ; DEC A             ; ...
       movb a,@loop_counter_value_2    ; LD (34275),A      ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address
       movb a,a
       jeq  !                          ; JP Z,46003        ; If repeat counter is zero, then exit loop and process subsequent bytes...
       mov  @loop_start,ix             ; LD IX,(34296)     ; ...else, restore stored position in graphic layout data (start of loop)...
!      b    @process_data_in_ix        ; JP 46003          ; ...and continue processing data from this point

* Display and Handle Main Menu
* 
* Used by the routine at #R34438.
main_menu:
       .proc
       movb one,a                      ; LD A,1            ; Load A with 1 (blue)
       movb a,@border_color            ; LD (34217),A      ; Store at #R34217 and...
       bl   @set_border_color          ; OUT (254),A       ; ...set border to this value (blue)
       movb @bytes+9,a                 ; LD A,9            ; Fill top 22 rows of Attribute File with blue PAPER & blue INK...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @print_title               ; CALL 47140        ; Print "THROUGH the TRAPDOOR" string
       bl   @print_score_strings       ; CALL 47628        ; Print SCORE / TOTAL / HI-SC string in current character's colours
       li   ix,_46690                  ; LD IX,46690       ; Point IX at Table of Attribute File Addresses for Main Menu Strings
       li   iy,main_menu_strings       ; LD IY,46710       ; Point IY at start of Table of Main Menu Strings
       movb @bytes+112,a               ; LD A,112          ; Load A with 112 (black INK on yellow PAPER)
       movb a,@print_attr              ; LD (34269),A      ; Store at #R34269
       movb @bytes+10,b                ; LD B,10           ; Load B with 10 as there are 10 strings to print (loop counter)
_46863:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of strings to print)
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address at which to print text into HL...
                                       ; LD H,(IX+1)       ; ...
       movb @bytes+12,b                ; LD B,12           ; Load B with 12 as there are 12 characters to print (loop counter)
_46872:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining characters to print)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load E with text character to print
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  iy                         ; INC IY            ; Advance IY to next character in text to print
       inc  hl                         ; INC HL            ; Advance to next Attribute File location
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining characters to print)
       sb   one,b                      ; DJNZ 46872        ; Loop back for next character
       jne  _46872                     ;                   
       inct ix                         ; INC IX            ; Advance IX to next entry in list of Attribute File addresses to print to...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of strings to print)
       sb   one,b                      ; DJNZ 46863        ; Loop back for next string
       jne  _46863                     ;
       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
* This entry point is used by the routine at #R46968.
_46900:
       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
       cb   a,@bytes+83                ; CP 83             ; If pressed key was not 83 (S)...
       jne  _46915                     ; JR NZ,46915       ; ...then skip ahead to #R46915
       movb @bytes+2,a                 ; LD A,2            ; Set current border colour to red...
       movb a,@border_color            ; LD (34217),A      ; ...
       bl   @set_border_color          ; OUT (254),A       ; ...
       .endproc                        ; RET               ; Return
_46915:
       cb   a,@bytes+74                ; CP 74             ; If pressed key was not 74 (J)...
       jne  _46968                     ; JR NZ,46968       ; ...then jump to #R46968 (if "K" pressed then redefine controls)
       movb @_34298,a                  ; LD A,(34298)      ; If we are in Joystick Mode...
       socb a,a                        ; OR A              ; ...
       jne  _46937                     ; JR NZ,46937       ; ...then skip ahead to #R46937
       .call @_47043                   ; CALL 47043        ; If Kempston Interface not present, or Kempston Joystick moved / fire pressed...
       joc  _46900                     ; JR C,46900        ; TODO: check code. ...then jump to #R46900
       movb one,a                      ; LD A,1            ; Set Joystick Mode to On...
       movb a,@_34298                  ; LD (34298),A      ; ...(see trivia)
       jmp  _46938                     ; JR 46938          ; Skip ahead to #R46938
_46937:
       sb   one,a                      ; DEC A             ; Set Joystick Mode to Off...
_46938:
       movb a,@_34298                  ; LD (34298),A      ; ...
       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       jmp  _46900                     ; JR 46900          ; Loop back to #R46900

* Draw Joystick "J" (Main Menu) in Colour Depending Upon Joystick Mode
* 
* Used by the routine at #R46830.
draw_joystick_j:
       .proc
       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode Flag is set...
                                       ; OR A              ; ...
       jne  _46956                     ; JR NZ,46956       ; ...then skip ahead to #R46956
       movb @bytes+112,a               ; LD A,112          ; Load A with attribute value for black INK, yellow PAPER, BRIGHT
       jmp  _46958                     ; JR 46958          ; Skip ahead to #R46958
_46956:
       movb @bytes+114,a               ; LD A,114          ; Load A with attribute value for red INK, yellow PAPER, BRIGHT
_46958:
       movb @bytes+74,@e               ; LD E,74           ; Load E with 74 (index for character "J")
       li   ix,_46694                  ; LD IX,46694       ; Point IX at entry for "J +KEMPSTON " in table of Attribute File addresses at which to print
                                                           ; menu strings
       bl   @set_and_print_dbl_height  ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
       .endproc                        ; RET               ; Return

* If "K" Pressed then Redefine Controls
* 
* Used by the routine at #R46830. Input:  A  ASCII code of pressed key
_46968:
       cb   a,@bytes+75                ; CP 75             ; If pressed key was not 75 (K)...
       jne  _46900                     ; JR NZ,46900       ; ...then jump to Main Menu handling routine at #R46900
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at start of Table of Current Keyboard Controls
_46977:
       movb @bytes+63,*hl              ; LD (HL),63        ; Set current entry in table to 63 (ASCII code for "?")
       inc  hl                         ; INC HL            ; Advance HL to next entry
       sb   one,b                      ; DJNZ 46977        ; Decrease remaining number of controls to change and loop back to #R46977 if not zero
       jne  _46977                     ;                   
       movb @bytes+112,a               ; LD A,112          ; Load A with the attribute value for black INK, yellow PAPER, BRIGHT
       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       li   ix,_46696                  ; LD IX,46696       ; Point IX at entry for "RIGHT" text in table of Attribute File addresses at which to
                                                           ; print for main menu
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
_46997:
       .push bc                        ; PUSH BC           ; Store BC (remaining number of controls to define)
       movb @bytes+198,a               ; LD A,198          ; Load A with 198 (yellow INK, black PAPER, BRIGHT, FLASH)
       movb @bytes+32,@e               ; LD E,32           ; Load E with 32 (" ")
       bl  @set_and_print_dbl_height   ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
_47005:
       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
       .call @_47060                   ; CALL 47060        ; If key pressed matches a direction, or the Berk / Drutt key...
       jeq  _47005                     ; JR Z,47005        ; ...then loop back to #R47005
       movb a,@e                       ; LD E,A            ; Load keycode of pressed control into E...
       movb @e,*iy+                    ; LD (IY+0),E       ; ...and store in Table of Current Keyboard Controls
                                       ; INC IY            ; Advance IY to next control
       movb @bytes+113,a               ; LD A,113          ; Load A with 113 (blue INK, yellow PAPER, BRIGHT)
       bl @set_and_print_dbl_height    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
       inct ix                         ; INC IX            ; Advance IX to next entry in table of Attribute File addresses...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (remaining number of controls to define)
       sb   one,b                      ; DJNZ 46997        ; Decrease remaining number of controls to define and loop back to #R46997 if not zero
       jne  _46997                     ;                   
       sb   a,a                        ; XOR A             ; Switch Joystick Mode to Off...
       movb a,@_34298                  ; LD (34298),A      ; ...
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl @print_keyboard_controls     ; CALL 47084        ; Print keyboard controls on main menu
       b    @_46900                    ; JP 46900          ; Jump to Main Menu handling routine at #R46900

* Set Carry Flag if Kempston Interface not Present, or Kempston Joystick Moved / Fire Pressed
* 
* Used by the routine at #R46830. Output: F  Carry Flag set if Kempston Interface not present, Kempston Joystick
* moved or fire pressed, reset otherwise
_47043:
       sb   b,b                        ; LD B,0            ; Set B to zero (to repeat check loop 256 times)
_47045:
       ; IN A,(31)                     ; IN A,(31)         ; Read value from Port 31 into A (Kempston Interface)
       socb a,a                        ; OR A              ; If retrieved value is not zero (i.e. Kempston Interface not present, or Kempston Joystick not
                                                           ; centred / fire button pressed)...
       jne  _47053                     ; JR NZ,47053       ; ...then skip ahead to #R47053
       sb   one,b                      ; DJNZ 47045        ; Decrease B (loop counter) and loop back to #R47045 to check Kempston status again if counter
       jne  _47045                     ;                   
                                                           ; not zero
       .ret                            ; RET               ; Return
_47053:
       movb @bytes+6,a                 ; LD A,6            ; Set sound 6 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound           ; CALL 59722        ; ...
       ; SCF                           ; SCF               ; Set Carry Flag
       .ret                            ; RET               ; Return

* Set Zero Flag if Key Whose Index is in A Matches a Direction, or the Berk / Drutt Key
* 
* Used by the routine at #R46968. Input:  A  Index of pressed key Output: F  Zero Flag set if input key index
* matches an entry in table at #R46683, reset otherwise HL  Address of matching entry in table at #R46683 (if match
* found)
_47060:
       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
       movb @bytes+5,b                 ; LD B,5            ; Load B with 5 (as we are checking the first five defined keys, see bugs)
_47065:
       cb   a,*hl                      ; CP (HL)           ; If character code at current HL position matches the key we are checking...
       jne  !                          ; RET Z             ; ...then return with Zero Flag set
       .ret                            ;                   
!
       inc  hl                         ; INC HL            ; Advance HL to next character in keyboard controls table
       sb   one,b                      ; DJNZ 47065        ; Loop back to #R47065 to check next control
       jne  _47065                     ;                   
       .ret                            ; RET               ; Return

* Set Attribute and Location and Print Double-Height Character in E
* 
* Used by the routines at #R46946 and #R46968. Input:  A  Attribute for character to print E  Character to print IX
* Points to memory location holding Attribute File address at which to print character
set_and_print_dbl_height:
       .proc
       movb a,@print_attr              ; LD (34269),A      ; Set text printing attribute to value in A
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address to print character to into HL...
                                       ; LD H,(IX+1)       ; ...
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       .endproc                            ; RET               ; Return

* Print Keyboard Controls on Main Menu
* 
* Used by the routines at #R46830 and #R46968. Input:  A  Attribute for printing text
print_keyboard_controls:
       .proc
       movb a,@print_attr              ; LD (34269),A      ; Set attribute for printing text
       li   ix,_46696                  ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
                                                           ; print
       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7, as there are 7 keyboard controls (loop counter)
_47097:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining control keys)
       mov  *ix+,hl                    ; LD L,(IX+0)       ; Load HL with Attribute File address at which to print character...
                                       ; LD H,(IX+1)       ; ...
       movb *iy+,@e                    ; LD E,(IY+0)       ; Load E with character to print (current keyboard control)
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IY            ; Advance IY to next keyboard control
                                       ; INC IX            ; Advance IX to next entry in list of Attribute File addresses...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining control keys)
       sb   one,b                      ; DJNZ 47097        ; Loop back to #R47097 for next keyboard control
       jne  _47097                     ;                   
       .endproc                        ; RET               ; Return

* Print "THROUGH the TRAPDOOR" String
* 
* Used by the routine at #R46830.
print_title:
       .proc
       movb @bytes+20,b                ; LD B,20           ; Load B with 20 (length of string to print)
       li   hl,22566                   ; LD HL,22566       ; Point HL at position to start printing text in Attribute File
       movb @bytes+79,a                ; LD A,79           ; Load A with 79, for blue PAPER, white INK, BRIGHT
       li   ix,title_text              ; LD IX,47120       ; Point IX to text to print
       jmp  print_text                 ; JR 47224          ; Print the text and return

* Print "SORRY BERK,  BUT YOUR TIME IS UP" String
* 
* Used by the routine at #R34438.
print_times_up:
       .proc
       movb @bytes+32,b                ; LD B,32           ; Load B with 32 (length of string to print)
       movb @bytes+199,a               ; LD A,199          ; Load A with 199, for black PAPER, white INK, BRIGHT, FLASH
       li   ix,_47153                  ; LD IX,47153       ; Point IX to text to print
       li   hl,23232                   ; LD HL,23232       ; Point HL at position at which to start printing text in Attribute File (start of second-last
                                                           ; row)
       jmp  print_text                 ; JR 47224          ; Print the text and return

* Print "HOME SWEET HOME" String
* 
* Used by the routine at #R34438.
print_home_sweet_home:
       movb @bytes+15,b                ; LD B,15           ; Set string length to 15
       movb @bytes+68,a                ; LD A,68           ; Set attribute to green INK on black PAPER, BRIGHT
       li   ix,_47198                  ; LD IX,47198       ; Point IX at "HOME SWEET HOME" text
       li   hl,22792                   ; LD HL,22792       ; Point HL at Attribute File address at which to print text
* This entry point is used by the routines at #R47140 and #R47185.
print_text:
       movb a,@print_attr              ; LD (34269),A      ; Store attribute at #R34269
print_text_1:
       .push bc                        ; PUSH BC           ; Store BC (B=remaining length of text)
       movb *ix+,@e                    ; LD E,(IX+0)       ; Load character of text to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IX            ; Advance IX to next text character to print
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address at which to print
       .pop bc                         ; POP BC            ; Restore BC (B = remaining length of text)
       sb   one,b                      ; DJNZ 47227        ; Decrease remaining length of text by one and repeat loop for next character
       jne  print_text_1               ;
       .endproc                        ; RET               ; Return

* Reset Show Score Flag and Draw Timer Figures Bar
* 
* Used by the routines at #R34438, #R34916 and #R47468.
draw_timer_bar:
       .proc
draw_timer_bar_0:
       movb @game_flags,a              ; LD A,(34208)      ; Reset Show Score Flag...
       szcb @bits+7,a                  ; RES 7,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       li   ix,zx_attributes+(22*32)   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
                                       ; OR A              ; ...and if zero...
       jeq  draw_timer_bar_2           ; JR Z,47267        ; ...then skip ahead 47267
       movb a,b                        ; LD B,A            ; Load number of lives into B
draw_timer_bar_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of open eyes to draw)
       bl   @draw_open_eyes            ; CALL 47315        ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of open eyes to draw)
       sb   one,b                      ; DJNZ 47260        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47260 if not
       jne  draw_timer_bar_1           ;                   ; zero          
                                                           
draw_timer_bar_2:
       movb @time_left,@e              ; LD A,(34210)      ; Load remaining time / lives into E...
                                       ; LD E,A            ; ...
       movb @bytes+16,a                ; LD A,16           ; Load A with number of lives lost by subtracting E from 16...
       sb   @e,a                       ; SUB E             ; ...
       jeq  draw_timer_bar_4           ; JR Z,47284        ; If zero, then skip ahead to #R47284
       movb a,b                        ; LD B,A            ; Load number of lost lives into B as counter for loop
draw_timer_bar_3:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of closed eyes to draw)
       bl   @draw_closed_eyes         ; CALL 47302         ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of closed eyes to draw)
       sb   one,b                      ; DJNZ 47277        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47277 if not
       jne  draw_timer_bar_3           ;                   ; zero
                                                           
draw_timer_bar_4:
       movb @bytes+27,@c               ; LD C,27           ; Set graphic index to 27 (timer figures' bodies)
       movb @current_character_attr,a  ; LD A,(34226)      ; Load attribute of current character into A
       movb @bytes+16,b                ; LD B,16           ; Load B with 16 (as 16 timer figures' bodies to draw)
draw_timer_bar_5:
       .push bc                        ; PUSH BC           ; Store B (remaining number of timer figure bodies to draw)
       bl   @draw_timer_part          ; CALL 47333         ; Draw left half of timer figure's body and invert mirror flag on attribute
       bl   @draw_timer_part          ; CALL 47333         ; Draw right half of timer figure's body
       .pop bc                         ; POP BC            ; Restore B (remaining number of timer figure bodies to draw)
       sb   one,b                      ; DJNZ 47291        ; Decrease B and loop back to #R47291
       jne  draw_timer_bar_5           ;                   
       .endproc                        ; RET               ; Return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Closed) at Attribute File Address IX and Advance IX
* by Two Bytes
* 
* Used by the routines at #R47241 and #R47363. Input:  IX  Pointer to a location in Attribute File
draw_closed_eyes:
       .proc
       bl   @ret_if_show_score_flag    ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47305
       movb @current_character_attr,a  ; LD A,(34226)      ; Load A with the attribute of the current character
       movb @bytes+28,@c               ; LD C,28           ; Load C with 28 (graphic index of timer figures' closed eyes)
       bl   @draw_timer_part           ; CALL 47333        ; Draw the left (closed) eye at Attribute File address in IX and advance IX by one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw the right (closed) eye at Attribute File address in IX, advance IX by one byte and
                                                           ; return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Open, Random Frame) at Attribute File Address IX and
* Advance IX by Two Bytes
* 
* Used by the routines at #R47241, #R47363 and #R47431. Input:  IX  Attribute File address at which to draw pair of
* eyes Output: IX  Attribute File address two bytes on from initial IX
draw_open_eyes:
       .proc
draw_open_eyes_0:
       bl  @ret_if_show_score_flag     ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47318
       bl  @draw_eye                   ; CALL 47323        ; Draw Timer Figure's left eye (random frame) at Attribute File address in IX and advance IX by
                                                           ; one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw Timer Figure's right eye (same frame as above), advance IX by one byte then return

* Draw a Timer Figure's Eye (Random Frame) at Attribute File Address in IX and Advance IX by One Byte
* 
* Used by the routine at #R47315. Input:  IX  (Entry at #R47323 and #R47333) Pointer to a location in Attribute File
* A  (Entry at #R47333 only) Attribute C  (Entry at #R47333 only) Graphic Index (e.g. 27 for timer figures' bodies)
* Output: A  Attribute (including inverted mirror flag) IX  Pointer to next location in Attribute File
draw_eye:
       .proc
       movb @bytes+5,a                 ; LD A,5            ; Load A with a random number, 0-4...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   @bytes+29,a                ; ADD A,29          ; Add 29 (as 29 is the index of the first of five eye direction graphics) in C...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+7,a                 ; LD A,7            ; Set attribute for timer indicator figures' eyes to white INK on black PAPER
       jmp  draw_timer_part_0

* This entry point is used by the routines at #R47241, #R47302 and #R47315.
draw_timer_part:
       .proc
draw_timer_part_0:
       movb @bytes+4,b                 ; LD B,4            ; Set Graphic Set Index to 4
       .push af                        ; PUSH AF           ; Store AF (A = attribute)
       .push bc                        ; PUSH BC           ; Store BC (B = graphic set index, C = graphic index)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
       .pop bc                         ; POP BC            ; Restore BC (B = graphic set index, C = graphic index)
       movb @c,a                       ; LD A,C            ; Load Graphic Index into A
       cb   a,@bytes+32                ; CP 32             ; If graphic index is less than 32 (i.e. we're not dealing with #32 - eyes looking right or #33
                                                           ; - eyes looking left and don't need to cancel inversion at 47350)...
       jl   _47348                     ; JR C,47348        ; ...then skip ahead to #R47348
       xor  one,a                      ; XOR 1             ; Add or subtract 1 if Graphic Index is 32 or 33 respectively (Timer Figures' Eyes looking
                                                           ; right or left respectively) to cancel out inversion at 47350
_47348:
       movb a,@c                       ; LD C,A            ; Load Graphic Index into C
       .pop af                         ; POP AF            ; Restore AF (A = attribute)
       li   tmp0,128*256               ; XOR 128           ; Flip mirror flag to prepare to draw mirror image of just-drawn character block
       xor  tmp0,a                     ;                   
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return

* If Show Score Flag is Reset then Return to Calling Routine, else Return to Routine that Called Calling Routine
* 
* Used by the routines at #R47302 and #R47315.
ret_if_show_score_flag:
       movb @game_flags,a              ; LD A,(34208)      ; If Show Score Flag is reset...
       movb a,tmp0                     ; BIT 7,A           ; ...
       andi tmp0,128*256               ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;
!
       .pop bc                         ; POP BC            ; Remove return address from stack...
       rt                              ; RET               ; ...and return to routine that called the calling routine

* Update Eyes of a Randomly Selected Timer Figure, Increase Timer Tick Counter and Process Timer Figure Blinking
* 
* Used by the routine at #R34438.
update_timer:
       .proc
       bl   @update_rnd_timer_figure   ; CALL 47431        ; Select a remaining Timer Figure at random and update its eyes to a random (open-eyed) frame
       bl   @reduce_remaining_time     ; CALL 47468        ; Increase Timer Tick Counter and reduce remaining time if Counter > 767
       movb @blink_duration_counter,a  ; LD A,(34227)      ; If Blink Duration Counter is zero...
                                       ; OR A              ; ...
       jeq  update_timer_1             ; JR Z,47388        ; ...then skip ahead to #R47388
       sb   one,a                      ; DEC A             ; Decrease Blink Duration Counter by one...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
                                       ; OR A              ; If decreased Blink Duration Counter is not zero...
       jne  update_timer_2             ; RET NZ            ; ...then return
       mov  @blinking_eye_attr_addr,ix ; LD IX,(34264)     ; Restore Attribute File address of eyes of currently blinking timer figure into IX
       b    @draw_open_eyes_0          ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
* Make a randomly chosen timer figure blink
update_timer_1:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 0-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (9 in 10 chance)...
       jne  update_timer_2             ; RET NZ            ; ...then return
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
       cb   a,@bytes+2                 ; CP 2              ; If less than two time / lives remain...
       jl   update_timer_2             ; RET C             ; ...then return
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(x-1) (where x is remaining time / lives)
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. point to a random "awake" timer figure)
       mov  ix,@blinking_eye_attr_addr ; LD (34264),IX     ; Store Attribute File address of eyes of currently blinking timer figure at 34264
       bl   @draw_closed_eyes          ; CALL 47302        ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address IX and advance IX by two bytes
       movb @bytes+10,a                ; LD A,10           ; Set Blink Duration Counter to a random number, 1-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
update_timer_2:
       .endproc                        ; RET               ; Return

* Select a Remaining Timer Figure at Random and Update its Eyes to a Random (Open-Eyed) Frame
* 
* Used by the routine at #R47363.
update_rnd_timer_figure:
       .proc
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
       socb a,a                        ; OR A              ; ...and if none remain...
       jeq  update_rnd_timer_figure_1  ; RET Z             ; ...then return
       movb a,@e                       ; LD E,A            ; Load remaining time / lives into E
       movb @bytes+18,a                ; LD A,18           ; Load A with 18 minus remaining time / lives (i.e. number in range 2 to 18)...
       sb   @e,a                       ; SUB E             ; ...
* As the value of x (Remaining Time / Lives) decreases, the probability that a randomly generated number between 0
* and (18-x) is 2 or more increases. This probability is used to ensure that the rate at which each timer figure is
* updated remains roughly constant.
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(17 minus remaining time / lives)
       cb   a,@bytes+2                 ; CP 2              ; If generated number is 2 or more...
       jhe  update_rnd_timer_figure_1  ; RET NC            ; ...then return
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @e,a                       ; LD A,E            ; Load remaining time / lives into A
* If remaining time / lives is one, then there is only one Timer Figure to update
       cb   a,one                      ; CP 1              ; If this is 1...
       jne  !                          ; JP Z,47315        ; ...then jump to #R47315 (If Show Score Flag reset then draw pair of Timer Figure eyes and
       b    @draw_open_eyes_0          ;                   ; return)
!
* Otherwise, randomly select one of the remaining Timer Figures to update
       bl   @rnd_no                    ; CALL 54222        ; Load A with random number between 0 and (x-1) where x is remaining time / lives
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. advance IX to point to left eye of randomly chosen Timer Figure)
       b    @draw_open_eyes_0          ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
update_rnd_timer_figure_1:
       .endproc

* Increase Timer Tick Counter and Reduce Remaining Time if Counter > 767
* 
* Used by the routine at #R47363.
reduce_remaining_time:
       .proc
       mov  @timer_tick,hl             ; LD HL,(34211)     ; Increase Timer Tick Counter by one...
       inc  hl                         ; INC HL            ; ...
       mov  hl,@timer_tick             ; LD (34211),HL     ; ...
       ci   hl,768                     ; LD A,H            ; If Timer Tick Counter is less than 768 (i.e. 3 x 256)...
                                       ; CP 3              ; ...
       jl   reduce_remaining_time_1    ; RET C             ; ...then return
       clr  @timer_tick                ; LD HL,0           ; Reset Timer Tick Counter to zero...
                                       ; LD (34211),HL     ; ...
* This entry point is used by the routine at #R53723.
_47485:
       movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,47241        ; ...then reset Show Score Flag, draw timer figures bar and return
       b    @draw_timer_bar_0          ;
!
       sb   one,a                      ; DEC A             ; Decrease current time / lives by one...
       movb a,@time_left               ; LD (34210),A      ; ...
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, and draw timer figures bar and return
reduce_remaining_time_1:
       .endproc

* Update Scores and Display
* 
* Used by the routine at #R34438.
update_and_print_score:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; Set Show Score Flag...
       socb @bits+7,*hl                ; SET 7,(HL)        ; ...
       li   hl,0                       ; LD HL,0           ; Set HL to zero
       movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jeq  update_and_print_score_2 ; JR Z,47526          ; ...then skip ahead to #R47526
       movb a,b                        ; LD B,A            ; Load HL with 1000 x current remaining time / lives...
       li   de,1000                    ; LD DE,1000        ; ...
update_and_print_score_1:
       a    de,hl                      ; ADD HL,DE         ; ...
       sb   one,b                      ; DJNZ 47517        ; ...
       jne  update_and_print_score_1                       ;                   
       mov  @timer_tick,de             ; LD DE,(34211)     ; Subtract value of Timer Tick Counter (i.e. Score Penalty) from current level's score...
       s    de,hl                      ; SBC HL,DE         ; ...
update_and_print_score_2:
       mov  hl,@score_level            ; LD (34213),HL     ; Set score for current level
       mov  @score_total,de            ; LD DE,(34215)     ; Load DE with current total score
       a    de,hl                      ; ADD HL,DE         ; Add score for current level to total score...
       mov  hl,@score_total            ; LD (34215),HL     ; ...and store
       mov  @high_score,de             ; LD DE,(34299)     ; Load current high score into DE
       s    de,hl                      ; SBC HL,DE         ; Subtract high score from current total score...
       jlt  update_and_print_score_3   ; JR C,47551        ; ...and if this is less than zero (i.e. high score is higher than current total score) then
                                                           ; skip ahead to #R47551
       mov  @score_total,hl            ; LD HL,(34215)     ; Load current total score into HL...
       mov  hl,@high_score             ; LD (34299),HL     ; ...and store as new high score
update_and_print_score_3:
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       movb a,@time_left               ; LD (34210),A      ; ...
       li   iy,score_text+7            ; LD IY,47596       ; Point IY at "numeric (score)" part of string at 47589
       mov  @score_level,hl            ; LD HL,(34213)     ; Load HL with current score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+20           ; LD IY,47609       ; Point IY at "numeric (total)" part of string at 47589
       mov  @score_total,hl            ; LD HL,(34215)     ; Load HL with current total score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+33           ; LD IY,47622       ; Point IY at "numeric (high score)" part of string at 47589
       mov  @high_score,hl             ; LD HL,(34299)     ; Load HL with current high score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       b    @print_score_strings_0     ; JP 47628          ; Print SCORE / TOTAL / HI-SC string in current character's colours and return

* Print Score / Total / High Score String in Current Character's Colours
* 
* Used by the routines at #R34916, #R46830 and #R47499.
print_score_strings:
       .proc
print_score_strings_0
       li   iy,score_text                  ; LD IY,47589       ; Point IY at SCORE / TOTAL / HI-SC text
       li   hl,23232                   ; LD HL,23232       ; Set Attribute File address at which to print text to start of second-last character row
print_score_strings_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load a character from the string into A
       cb   a,@bytes+36                ; CP 36             ; If the character is 36 (end marker)...
       jeq  print_score_strings_6      ; RET Z             ; ...then return
       cb   a,@bytes+42                ; CP 42             ; If character is not 42 ("set attribute to current character's colours" marker)...
       jne  print_score_strings_3      ; JR NZ,47660       ; ...then skip ahead to #R47660
       movb @current_character_attr,a  ; LD A,(34226)      ; Load current character's attribute into A (blue for Berk, yellow for Drutt)
       cb   a,one                      ; CP 1              ; If blue (Berk)...
       jeq  print_score_strings_2      ; JR Z,47656        ; ...then skip ahead to #R47656
       movb @bytes+112,a               ; LD A,112          ; Load A with value for black INK, yellow PAPER, BRIGHT (Drutt's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_2:
       movb @bytes+79,a                ; LD A,79           ; Load A with value for white INK, blue PAPER, BRIGHT (Berk's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_3:
       cb   a,@bytes+35                ; CP 35             ; If character is not 35 ("set attribute to standard" marker)...
       jne  print_score_strings_5      ; JR NZ,47673       ; ...then skip ahead to #R47673
       movb @bytes+71,a                ; LD A,71           ; Load A with value for white INK, black PAPER, BRIGHT
print_score_strings_4:
       movb a,@print_attr              ; LD (34269),A      ; Store this value as the attribute to print text
       inc  iy                         ; INC IY            ; Advance IY to next character in string to print
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_5:
       movb a,@e                       ; LD E,A            ; Load character to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address
       inc  iy                         ; INC IY            ; Advance IY to next character to process
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_6
       .endproc

* Print a Double-Height Text Character
* 
* Used by the routines at #R46830, #R47071, #R47084, #R47213 and #R47628. Input:  HL  Attribute File address at
* which to print character E  Character to print
print_dbl_height:
       .proc
       li   bc,32                      ; LD BC,32          ; Load BC with 32 (width of a row in Attribute File)
       .push hl                        ; PUSH HL           ; Store HL (Attribute File address at which to print character)
       sb   d,d                        ; LD D,0            ; Set D to zero
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now Attribute File address at which to print character) and HL (now H = 0, L =
                                                           ; character to print)
       sla  hl,3                       ; ADD HL,HL         ; Multiply index of character to print by eight in HL, as each character's graphic data is
                                                           ; eight bytes long...
                                       ; ADD HL,HL         ; ...
                                       ; ADD HL,HL         ; ...
       li   de,font-(32*8)             ; LD DE,15360       ; Add eight times character index to 15360 in HL, to point to graphic of character in ROM...
       a    de,hl                      ; ADD HL,DE         ; ...
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to graphic of character in ROM) and HL (now 15360)
       .pop hl                         ; POP HL            ; Restore HL (Attribute File address at which to print character)
       bl   @print_half_dbl_height     ; CALL 47709        ; Print top half of a double-height text character
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL to advance down a character row
       bl   @print_half_dbl_height     ; CALL 47709        ; Print bottom half of a double-height text character
       ; AND A                         ; AND A             ; Reset Carry Flag
       s    bc,hl                      ; SBC HL,BC         ; Subtract 32 from HL to restore to value it had upon starting this routine
       .endproc                        ; RET               ; Return

* Print Half of a Double-Height Text Character
* 
* The most significant byte of the Attribute File address starts off as 88 for the top third of the screen. In the
* middle third it becomes 89 and in the lower third it reaches 90. The most significant byte of the Display File
* address (for the top pixel row of each character row) is 64 in the top third, 72 in the middle third and 80 in the
* lower third. Generally speaking, therefore, the most significant byte in the Display File address increases by
* eight for every increase of one in the attribute address most significant byte, so multiplying the latter by eight
* (giving 192, 200 or 208, values roll over 255-0 boundary with excess truncated) would put it on the same scale as
* the former (64, 72 or 80). Input:  DE  15360 + 8 x character index [+4 for second run-through] (i.e. points to ROM
* graphic data for the character of interest) HL  Attribute File address at which to print character
print_half_dbl_height:
       .proc
       mov  hl,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
       movb *de,*tmp2                  ; de must be advanced
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
*      Draw attribute
       movb @print_attr,a
       mov  hl,tmp0
       bl   @draw_attribute
;       .push hl                        ; PUSH HL           ; Store HL
;       .push bc                        ; PUSH BC           ; Store BC
;       movb @print_attr,a              ; LD A,(34269)      ; Load stored attribute into A
;       movb a,*hl                      ; LD (HL),A         ; Write this to Attribute File
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       a    a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       a    a,a                        ; ADD A,A           ; ...
;       a    a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File
;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (loop counter)
;_47724:
;       movb *de,a                      ; LD A,(DE)         ; Load a byte from the graphic data into C...
;       movb a,@c                       ; LD C,A            ; ...
;       ; SRL C                         ; SRL C             ; Shift bitmap data left one pixel in C
;       socb @c,a                       ; OR C              ; Merge this into bitmap data already in A to give a "bold" typeface appearance
;       andi a,127*256                  ; AND 127           ; Drop the leftmost bit to prevent one character touching the next (space between letters)
;       movb a,*hl                      ; LD (HL),A         ; Load the bitmap data into two consecutive rows to provide double-height (2 chars) text...
;       ab   one,h                      ; INC H             ; ...
;       movb a,*hl                      ; LD (HL),A         ; ...
;       ab   one,h                      ; INC H             ; ...
;       inc  de                         ; INC DE            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 47724        ; Repeat for next row of graphic data
;       jne  _47724                     ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop hl                         ; POP HL            ; Restore HL
        .endproc                        ; RET               ; Return

* Convert Number in HL to String at IY
* 
* Used by the routine at #R47499. Input:  HL  A number to convert to string IY  A location in memory to store a
* number converted to a string
num_to_str:
       .proc
       li   de,10000                   ; LD DE,10000       ; Convert the ten thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,1000                    ; LD DE,1000        ; Convert the thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,100                     ; LD DE,100         ; Convert the hundreds to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,10                      ; LD DE,10          ; Convert the tens to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       movb @l,a                       ; LD A,L            ; Load remainder (units) into L
       ab   @bytes+48,a                ; ADD A,48          ; Add as offset to 48 (ASCII code for "0")
       movb a,*iy                      ; LD (IY+0),A       ; Load ASCII character code into units position in string
       .endproc                        ; RET               ; Return

* Convert a Digit of Numeric Data to its String Equivalent
* 
* Used by the routine at #R47741. Input:  DE  Current power of ten HL  A number to convert to string IY  A location
* in memory to store a current digit converted to a string
digit_to_str:
       movb @bytes+47,*iy              ; LD (IY+0),47      ; Set character in string to "/" (character immediately before "0")
                                       ; AND A             ; Reset Carry Flag
digit_to_str_1:
       ab   one,*iy                    ; INC (IY+0)        ; Advance character at current string position to next numeric character up
       s    de,hl                      ; SBC HL,DE         ; Subtract current power of ten from number to convert
       jgt  digit_to_str_1             ; JR NC,47777       ; TODO: check code. If number to convert has not dropped below 0 (i.e. we have not yet subtracted too many of the
                                                           ; current power of ten) then loop back to #R47777
       a    de,hl                      ; ADD HL,DE         ; We have subtracted one too many of the current power of ten, so add it back to make the
                                                           ; remainder positive
       inc  iy                         ; INC IY            ; Advance to next character in the string as we are finished dealing with the current power of
                                                           ; ten
       rt                              ; RET               ; Return

* Read Keyboard and Load Pressed Key Character into A
* 
* Used by the routines at #R47893 and #R47942. Output: A  Index of the key that was pressed
_47788:
       .exx                            ; EXX               ; Swap registers
       li   bc,65278                   ; LD BC,65278       ; Load B and C with 254
       li   hl,_47853                  ; LD HL,47853       ; Point HL at list of return values
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard) [IN 65278 reads the half row CAPS SHIFT to V]
       socb @bits+0,a                  ; SET 0,A           ; Set bit 0 of A (i.e. clear pressing of CAPS SHIFT)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
       xor  tmp0,a                     ;                   
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       li   de,5                       ; LD DE,5           ; Advance HL by five characters in list of return values string...
       a    de,hl                      ; ADD HL,DE         ; ...
       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 as there are 6 keyboard half-rows to test (loop counter)
_47811:
       sra  b,1                        ; RLC B             ; With each loop, change BC from 65278 -> 65022 -> 64510 -> 63486 -> 61438 -> 57342 -> 49150
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
       xor  tmp0,a                     ;                   
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       inc  hl                         ; INC HL            ; Advance HL by five characters in list of return values string...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       sb   one,@e                     ; DEC E             ; Decrease number of remaining keyboard half-rows to check
       jne  _47811                     ; JR NZ,47811       ; If there are any more half rows to check then loop back to #R47811
       sra  b,1                        ; RLC B             ; Set BC to 32766 for final keyboard half-row
       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
       socb @bits+1,a                  ; SET 1,A           ; Set bit 1 of A (i.e. clear pressing of SYMBOL SHIFT)
       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
       xor  tmp0,a                     ;                   
       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
       .exx                            ; EXX               ; Swap registers
       .ret                            ; RET               ; Return [no key pressed]
_47843:
       srl  a,1                        ; SRL A             ; Shift bits right
       mov  af,tmp0
       andi tmp0,>0080
       jne  _47850                     ; JR C,47850        ; If carry flag is set, then this is the key that was pressed, so skip ahead to #R47850
       inc  hl                         ; INC HL            ; Advance HL to check next character
       jmp  _47843                     ; JR 47843          ; Loop back to #R47843
_47850:
       movb *hl,a                      ; LD A,(HL)         ; Load current character in list of return values string into A as this is the key that was
                                                           ; pressed
       .exx                            ; EXX               ; Swap registers
       .ret                            ; RET               ; Return [key pressed]

* Check for Control Key Press and Store at 34219
* 
* Used by the routine at #R34438.
check_control_input:
       .proc
       sb   a,a                        ; XOR A             ; Clear previously stored control input...
       li   r0,JOY_RT
       bl   @check_key
       jeq  !
       socb @bits+0,a
!      li   r0,JOY_LT
       bl   @check_key
       jeq  !
       socb @bits+1,a
!      li   r0,JOY_DN
       bl   @check_key
       jeq  !
       socb @bits+2,a
!      li   r0,JOY_UP
       bl   @check_key
       jeq  !
       socb @bits+3,a
!      li   r0,JOY_FI
       bl   @check_key
       jeq  !
       socb @bits+4,a
!
;       movb a,@control_input           ; LD (34219),A      ; ...
;       .call @_47788                   ; CALL 47788        ; Read keyboard and load character of pressed key into A
;       socb a,a                        ; OR A              ; If no key was pressed...
;       jeq  _47930                     ; JR Z,47930        ; ...then read joystick input and return
;       movb one,@e                     ; LD E,1            ; Set least significant bit of E as we are testing the first keyboard control first
;       movb @bytes+7,b                 ; LD B,7            ; Set B to 7 as there are 7 keyboard controls to check (loop counter)
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
;_47910:
;       cb   a,*hl                      ; CP (HL)           ; If pressed key is the same as the current keyboard control...
;       jeq  _47921                     ; JR Z,47921        ; ...then skip ahead to #R47921
;       inc  hl                         ; INC HL            ; Advance HL to next keyboard control
;       ; SLA E                         ; SLA E             ; Shift E left
;       sb   one,b                      ; DJNZ 47910        ; Loop back to #R47910 for next keyboard control
;       jne  _47910                     ;
;       sb   a,a                        ; XOR A             ; Set A to zero
;       jmp  _47926                     ; JR 47926          ; Skip ahead to #R47926
;_47921:
;       movb @e,a                       ; LD A,E            ; Load input bitmap into A (bit that is set represents the control that has been pressed)
;       movb a,tmp0                     ; BIT 5,A           ; If bit 5 is set (i.e. Berk / Drutt key has been pressed)...
;       andi tmp0,32*256                ;
;       jne  _47942                     ; JR NZ,47942       ; ...then jump to #R47942 (Wait for current key to be released and another to be pressed,
;                                                           ; storing in A) and return
;* This entry point is used by the routine at #R47930.
;_47926:
       movb a,@control_input           ; LD (34219),A      ; Store control input at #R34219
       .endproc                        ; RET               ; Return

* If Joystick Mode is On, then Read Joystick Input
* 
* Used by the routine at #R47893.
_47930:
;       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode is Off...
;       socb a,a                        ; OR A              ; ...
;       jne  !                          ; RET Z             ; ...then return
;       .ret                            ;
;!
;       ; IN A,(31)                     ; IN A,(31)         ; Read state of Kempston joystick into A
;       andi a,31*256                   ; AND 31            ; If joystick input is non-zero...
;       jne  _47926                     ; JR NZ,47926       ; ...then jump to #R47926
;       .ret                            ; RET               ; Return

* Wait for Current Key to Be Released and Another to Be Pressed, Storing in A
* 
* Used by the routines at #R34438, #R47893 and #R47955.
_47942:
       .call @_47788                   ; CALL 47788        ; Read keyboard and load character of pressed key into A
       socb a,a                        ; OR A              ; If a key is pressed...
       jne  _47942                     ; JR NZ,47942       ; ...then loop back to #R47942
_47948:
       .call @_47788                   ; CALL 47788        ; Read keyboard and load character of pressed key into A
       socb a,a                        ; OR A              ; If a key is not pressed...
       jeq  _47948                     ; JR Z,47948        ; ...then loop back to #R47948
       .ret                            ; RET               ; Return

* Wait for Key-Press, Store Pressed Key Code in A and Play Main Menu Sound
* 
* Used by the routines at #R46830 and #R46968. Output: A  code of pressed key
wait_keypress:
       .proc
!      li   r0,KEY_S
       bl   @check_key
       jeq  -!
       movb @bytes+83,a                ; Key S
;       .call @_47942                   ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
;       .push af                        ; PUSH AF           ; Store AF (A = last pressed key)
;       movb @bytes+2,a                 ; LD A,2            ; Set sound 2 as pending if appropriate, then play and clear pending sound...
;       bl   @request_sound_a                   ; CALL 59722        ; ...
;       .pop af                         ; POP AF            ; Restore AF (A = last pressed key)
       .endproc                        ; RET               ; Return

* Advance HL to Next Script Instruction and Execute
* 
* Used by the routines at #R35735, #R36116, #R36390, #R36471, #R36542, #R36610, #R36947, #R36950, #R36984, #R36990,
* #R37085, #R37639, #R37753, #R38074, #R38165, #R38540, #R38554, #R41498, #R41617, #R48133, #R48142, #R48148,
* #R48158, #R48220, #R48246, #R48260, #R48267, #R48274, #R48307, #R48336, #R48365, #R48487, #R48567, #R48593,
* #R48641, #R48686, #R48692, #R48698, #R48704, #R48920, #R49010, #R51765, #R52029, #R52038, #R52047, #R52142,
* #R52243, #R52309, #R52860, #R52870, #R52889 and #R52967. Input:  IX  (Entry at #R48096 and #R48098) Address of
* complex state data for an entity Output: HL  Current position in script data
inct_execute_script:                   ; Always branch here
       inct hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
                                       ; INC HL            ; ...
* This entry point is used by the routines at #R35577, #R35735, #R36008, #R36036, #R36116, #R36367, #R36390,
* #R36471, #R36638, #R37085, #R37639, #R37718, #R37753, #R37778, #R38074, #R38554, #R41550, #R48285, #R48295,
* #R48307, #R48324, #R48336, #R48353, #R48365, #R48388, #R48934, #R48976, #R49010, #R51765, #R51779, #R51904,
* #R51924, #R51944, #R51954, #R51960, #R52053, #R52148, #R52243, #R52908, #R52914, #R52967 and #R53083.
execute_script:                        ; Always branch here
       inc  hl                         ; INC HL            ; Advance Script Data Pointer by one byte
       movb *hl,a                      ; LD A,(HL)         ; Load byte at this location into A
       dec  hl                         ; DEC HL            ; Move HL back one byte
       socb a,a                        ; OR A              ; If byte loaded into A was zero (i.e. a script instruction)...
       jeq  execute_script_1           ; JR Z,48117        ; ...then skip ahead to #R48117
* HL pointing to a graphic layout data address, rather than a script instruction
       mov  hl,@current_script_addr    ; LD (34277),HL     ; Store address in HL at #R34277 as position in script currently running
       movb *hl+,@2(ix)                ; LD A,(HL)         ; Load word at location HL into Graphic Layout Address in current entity's complex state data
                                                           ; entry (IX)...
                                       ; LD (IX+2),A       ; ...
                                       ; INC HL            ; ...
       movb *hl,@3(ix)                 ; LD A,(HL)         ; ...
                                       ; LD (IX+3),A       ; ...
       jmp  execute_script_2           ; RET               ; Return
* HL pointing to a script instruction
execute_script_1:
       movb *hl,a                      ; LD A,(HL)         ; Load script "instruction" into A
       .push hl                        ; PUSH HL           ; Store HL (pointer to current position in script data)
       li   hl,script_routines_jmp_table   ; LD HL,47966       ; Point HL at Table of Script Routine Start Addresses
       ab   a,a                        ; ADD A,A           ; Load double index of script instruction into BC...
       clr  bc                         ; LD C,A            ; ...
       movb a,@c                       ; LD B,0            ; ...
       a    bc,hl                      ; ADD HL,BC         ; ...and add as offset in HL to point to start address of required script routine
       mov  *hl,bc                     ; LD C,(HL)         ; Load address at this location into BC...
                                       ; INC HL            ; ...
                                       ; LD B,(HL)         ; ...
       .pop hl                         ; POP HL            ; Restore HL (pointer to current position in script data)
       .push bc                        ; PUSH BC           ; Push address in BC onto stack...
execute_script_2:
       .endproc                        ; RET               ; ...and RET to this address

* Script Routine (04) If Current Character and Target Entity are in the Same Room then Set Pending Sound Input:  HL
* Current position in script data IX  Address of complex state data for an entity
script_routine_04:
       inc  hl                         ; INC HL            ; Advance HL to parameter (sound index)...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load A with sound index
       bl   @request_entity_sound      ; CALL 59601        ; If current character is in same room as target entity at IX then set pending sound to A
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (62) Move Entity at IX into Room to the Left, if Appropriate
script_routine_62:
       bl   @move_into_left_room       ; CALL 54348        ; Move entity at IX into room to the left, if appropriate
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (16) Have Berk Hold an Entity, and Position it Appropriately Between his Hands
script_routine_16:
       .call @_48850                   ; CALL 48850        ; Have Berk hold an entity, and position it appropriately between his hands
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (17) Have Berk Put Down an Entity in Front of Him, if Appropriate Output: D  Depth offset for
* entity being put down
script_routine_17:
       movb @bytes+0,d                 ; LD D,0            ; Load D with depth offset of 0 (as Berk is putting down an entity in front of him)
       jmp  _48160                     ; JR 48160          ; Have Berk put down an entity, if appropriate

* Script Routine (18) Have Berk Put Down an Entity Behind Him, if Appropriate Input:  D  (Entry at #R48160 only)
* Depth offset for entity being put down IX  Address of complex state data (current level) for Berk
script_routine_18:
       movb @bytes+255,d               ; LD D,255          ; Load D with depth offset of -1 (as Berk is putting down an entity behind him)
* This entry point is used by the routine at #R48154.
_48160:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is reset...
       andi tmp0,16*256                ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
* Berk is carrying something
       szcb @bits+4,@9(ix)             ; RES 4,(IX+9)      ; Reset Berk's Carrying Something Flag
       sb   a,a                        ; XOR A             ; Set class of entity held by Berk to zero (i.e. nothing)...
       movb a,@_34221                  ; LD (34221),A      ; ...
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk...
       szcb @bits+5,@10(iy)            ; RES 5,(IY+10)     ; ...and reset its Is Being Carried Flag
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load E with height of entity minus one...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       movb @_34222,a                  ; LD A,(34222)      ; Load A with y-coordinate minus one of top edge of coloured creature slot Berk is interacting
                                                           ; with...
       socb a,a                        ; OR A              ; ...and if this is not zero...
       jne  _48198                     ; JR NZ,48198       ; ...then skip ahead to #R48198
* Value at #R34222 is zero (i.e. Berk not interacting with a coloured creature slot on Level 3)
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load A with y-coordinate of Berk's bottom edge...
       ab   d,a                        ; ADD A,D           ; ...plus depth offset...
* At this point, A holds either the y-coordinate of Berk's bottom edge plus depth offset, or the y-coordinate minus
* one of the top edge of (actually the y-coordinate of the bottom of the space within) a coloured creature slot on
* Level 3. This value in A is the y-coordinate that the carried entity's bottom edge will take on when that entity
* is put down.
_48198:
       movb a,@6(iy)                   ; LD (IY+6),A       ; Set the y-coordinate of the bottom edge of the put-down entity to value in A
       sb   @e,a                       ; SUB E             ; Set the y-coordinate of the top edge of the put-down entity...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...to that of the bottom edge, minus the height as appropriate
       sb   a,a                        ; XOR A             ; Set value at #R34222 to zero...
       movb a,@_34222                  ; LD (34222),A      ; ...as Berk is not (any longer) interacting with a coloured creature slot on Level 3
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (10) Reset Walking Left and Walking Right Flags
* 
* Used by the routine at #R36542. Output: E  Combination of flags to (re)set
script_routine_10:
       movb @bytes+0,@e                ; LD E,0            ; Reset Entity Walking Left and Entity Walking Right flags...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

* Script Routine (12) Reset Walking Left Flag and Set Walking Right Flag Output: E  Combination of flags to (re)set
script_routine_12:
       movb one,@e                     ; LD E,1            ; Set Entity Walking Right Flag, reset Entity Walking Left Flag...
       jmp  _48222                     ; JR 48222          ; ...and advance HL to next script instruction and execute

* Script Routine (11) Set Walking Left Flag and Reset Walking Right Flag Input:  E  (Entry at #R48222 only)
* Combination of flags to (re)set IX  Address of complex state data for an entity
script_routine_11:
       movb @bytes+2,@e                ; LD E,2            ; Prepare to set Entity Walking Left Flag and reset Entity Walking Right Flag
* This entry point is used by the routines at #R48212 and #R48216.
_48222:
       movb @11(ix),a                  ; LD A,(IX+11)      ; (Re)set Walking Left and Walking Right flags as prepared in E...
       andi a,240*256                  ; AND 240           ; ...and reset Unused (11,2) and Unused (11,3) flags...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (07) Reset Berk's Facing Into Screen, Facing Left and Facing Right Flags Output: B  Combination of
* flags to (re)set
script_routine_07:
       sb   b,b                        ; LD B,0            ; Reset Berk's Facing Into Screen, Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (06) Set Berk's Facing Into Screen Flag, and Reset his Facing Left and Facing Right Flags Output: B
* Combination of flags to (re)set
script_routine_06:
       movb @bytes+2,b                 ; LD B,2            ; Set Berk's Facing Into Screen Flag, and reset his Facing Left and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (13) Set Berk's Facing Left Flag, and Reset his Facing Into Screen and Facing Right Flags Output: B
* Combination of flags to (re)set
script_routine_13:
       movb @bytes+4,b                 ; LD B,4            ; Set Berk's Facing Left Flag, and reset his Facing Into Screen and Facing Right flags...
       jmp  _48248                     ; JR 48248          ; ...and advance HL to next script instruction and execute

* Script Routine (14) Set Berk's Facing Right Flag, and Reset his Facing Into Screen and Facing Left Flags Input:  B
* (Entry at #R48248 only) Combination of flags to (re)set IX  Address of complex state data (current level) for Berk
script_routine_14:
       movb @bytes+8,b                 ; LD B,8            ; Prepare to set Berk's Facing Right Flag, and reset his Facing Into Screen and Facing Left
                                                           ; flags
* This entry point is used by the routines at #R48234, #R48238 and #R48242.
_48248:
       movb @9(ix),a                   ; LD A,(IX+9)       ; Load A with Berk's flags...
       andi a,241*256                  ; AND 241           ; ...clearing Facing Into Screen, Facing Left and Facing Right flags
       ab   b,a                        ; ADD A,B           ; Combine with flags in B...
       movb a,@9(ix)                   ; LD (IX+9),A       ; ...and store
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (09) Reset Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
script_routine_09:
       szcb @bits+0,@9(ix)             ; RES 0,(IX+9)      ; Reset Must Process Current Script Data Flag
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (08) Set Must Process Current Script Data Flag for Entity at IX Input:  IX  Address of complex
* state data for an entity
script_routine_08:
       socb @bits+0,@9(ix)             ; SET 0,(IX+9)      ; Set Must Process Current Script Data Flag
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (15) Jump to New Address if Berk Is Carrying Something Input:  HL  Current position in script data
* IX  Address of complex state data for an entity
script_routine_15:
       inc  hl                         ; INC HL            ; Advance HL to parameter for current instruction...
       inc  hl                         ; INC HL            ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is carrying an entity...
       andi tmp0,16*256                ;                   
       jne  _48287                     ; JR NZ,48287       ; ...then read parameter address into HL and execute next script instruction at that address
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (01) Load HL (Script Data Pointer) with New Address
* 
* Functionality analogous to JP instruction. Input:  HL  Address in script data Output: HL  New address in script
* data
script_routine_01:
       inc  hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
       inc  hl                         ; INC HL            ; ...
* This entry point is used by the routine at #R48274.
_48287:
       movb *hl,@c                     ; LD C,(HL)         ; Read WORD at this location into HL...
       inc  hl                         ; INC HL            ; ...(i.e. update Script Data Pointer to this address)...
       movb *hl,b                      ; LD B,(HL)         ; ...
       .push bc                        ; PUSH BC           ; ...
       .pop hl                         ; POP HL            ; ...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (23) Start Loop (1 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34285 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34285. Output: HL  Address of next
* script instruction to execute
script_routine_23:
       .call @_48382                   ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_23_24_loop_count ; LD (34285),A      ; Store repeat count at #R34285
       mov  hl,@script_23_24_loop_addr ; LD (34286),HL     ; Store address to return to (i.e. first instruction in loop) at #R34285...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (24) End Loop (1 / 3) Output: HL  Address of next script instruction to execute
script_routine_24:
       movb @script_23_24_loop_count,a ; LD A,(34285)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_23_24_loop_count ; LD (34285),A      ; ...and store
       mov  @script_23_24_loop_addr,hl ; LD HL,(34286)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (25) Start Loop (2 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34288 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34288. Output: HL  Address of next
* script instruction to execute
script_routine_25:
       .call @_48382                   ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_25_26_loop_count ; LD (34288),A      ; Store repeat count at #R34288
       mov  hl,@script_25_26_loop_addr ; LD (34289),HL     ; Store address to return to (i.e. first instruction in loop) at #R34288...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (26) End Loop (2 / 3) Output: HL  Address of next script instruction to execute
script_routine_26:
       movb @script_25_26_loop_count,a ; LD A,(34288)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script        ;
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_25_26_loop_count ; LD (34288),A      ; ...and store
       mov  @script_25_26_loop_addr,hl ; LD HL,(34289)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (27) Start Loop (3 / 3)
* 
* Start a loop in script data. The first of the following two bytes is the repeat count and the second is
* disregarded. The current value of the repeat counter is stored at #R34291 and the address of the next instruction
* (i.e. the first instruction that is processed in each loop) is stored at #R34291. Output: HL  Address of next
* script instruction to execute
script_routine_27:
       .call @_48382                   ; CALL 48382        ; Load A with script instruction parameter, and advance HL to next instruction
       movb a,@script_27_28_loop_count ; LD (34291),A      ; Store repeat count at #R34291
       mov  hl,@script_27_28_loop_addr ; LD (34292),HL     ; Store address to return to (i.e. first instruction in loop) at #R34291...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Script Routine (28) End Loop (3 / 3) Output: HL  Address of next script instruction to execute
script_routine_28:
       movb @script_27_28_loop_count,a ; LD A,(34291)      ; Load A with current repeat count
       socb a,a                        ; OR A              ; If repeat count is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease repeat count...
       movb a,@script_27_28_loop_count ; LD (34291),A      ; ...and store
       mov  @script_27_28_loop_addr,hl ; LD HL,(34292)     ; Load HL with address of first instruction in loop...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Load A with Script Instruction Parameter then Advance HL to Next Instruction
* 
* Used by the routines at #R48295, #R48324 and #R48353.
_48382:
       inc  hl                         ; INC HL            ; Advance HL by two bytes, beyond end of current instruction...
       inc  hl                         ; INC HL            ; ...
       movb *hl,a                      ; LD A,(HL)         ; Load value here into A
       inc  hl                         ; INC HL            ; Advance HL by two more bytes to start of next instruction...
       inc  hl                         ; INC HL            ; ...
       .ret                            ; RET               ; Return

* Decrease Remaining Time for Current Power and if Zero, Exit Calling Routine and Run Script Data for Removal of
* Power
* 
* Used by the routines at #R35689, #R36542 and #R48487.
_48388:
       mov  @remaining_power_cycles,de ; LD DE,(34224)     ; Load remaining power time into DE
       swpb de                         ; Little endian
       movb @e,a                       ; LD A,E            ; Increase E (number of game-cycles power has been in use in current block)...
       ab   one,a                      ; INC A             ; ...
       movb a,@e                       ; LD E,A            ; ...
       cb   a,@bytes+15                ; CP 15             ; If 16 game-cycles of power use have not yet elapsed...
       jne  _48402                     ; JR NZ,48402       ; ...then skip ahead to #R48402
       movb @bytes+0,@e                ; LD E,0            ; Reset number of game-cycles power has been in use to zero...
       sb   one,d                      ; DEC D             ; ...and decrease remaining number of 16-game-cycles
_48402:
       swpb de                         ; Big endian
       mov  de,@remaining_power_cycles ; LD (34224),DE     ; Store updated remaining power time...
       jeq  !                          ; RET NZ            ; ...and return if this is not zero
       .ret                            ;                   
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       .call @_48417                   ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original position
       li   hl,_35275                  ; LD HL,35275       ; Point HL at script data for Berk's power expiring...
       b    @execute_script            ; JP 48098          ; ...and execute

* Remove Berk's Current Power and Reset Sweet / Mushroom / Edible Eyes / Sausage to its Original Position
* 
* Used by the routines at #R36390, #R36471, #R39151 and #R48388.
_48417:
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       .push ix                        ; PUSH IX           ; Store IX
       cb   a,@bytes+6                 ; CP 6              ; If Berk's current power is not 6 (flying, level 3, 2)...
       jne  _48445                     ; JR NZ,48445       ; ...then skip ahead to #R48445
       movb @bytes+13,a                ; LD A,13           ; Reset complex state data for Red Coloured Creature to that stored in Initial-State Table...
       .call @_53987                   ; CALL 53987        ; ...
       movb @bytes+14,a                ; LD A,14           ; Reset complex state data for Yellow Coloured Creature to that stored in Initial-State
                                                           ; Table...
       .call @_53987                   ; CALL 53987        ; ...
       movb @bytes+15,a                ; LD A,15           ; Reset complex state data for White Coloured Creature to that stored in Initial-State
                                                           ; Table...
       .call @_53987                   ; CALL 53987        ; ...
       jmp  _48474                     ; JR 48474          ; Skip ahead to #R48474
_48445:
       cb   a,@bytes+10                ; CP 10             ; If Berk's current power is not 10 (floating)...
       jne  _48474                     ; JR NZ,48474       ; ...then skip ahead to #R48474
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       szcb @bits+7,@9(ix)             ; RES 7,(IX+9)      ; Reset Berk's Moving Upwards Flag
       movb @bytes+192,@11(ix)         ; LD (IX+11),192    ; Reset Berk's Walking Right, Walking Left, Unused (11,2), Unused (11,3), Impassable Leftwards
                                                           ; and Impassable Rightwards flags and set his Interaction (11,6) and Interaction (11,7) flags
       szcb @bits+7,@8(ix)             ; RES 7,(IX+8)      ; Reset bit 7 of Berk's class value (change from 159 to 31)
       sb   one,@6(ix)                 ; DEC (IX+6)        ; Decrease Berk's bottom y-coordinate by two...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       .call @_55516                   ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
_48474:
       movb @berks_current_power,a                  ; LD A,(34220)      ; Reset complex state data for entity responsible for Berk's current power to that stored in
                                                           ; Initial-State Table...
       .call @_53987                   ; CALL 53987        ; ...
       sb   a,a                        ; XOR A             ; Clear Berk's current power...
       movb a,@berks_current_power                  ; LD (34220),A      ; ...
       .pop ix                         ; POP IX            ; Restore IX
       .ret                            ; RET               ; Return

* Script Routine (32) Update Berk's Position and State (Flying) Depending Upon Control Input
* 
* See pokes Input:  IX  (Entry at #R48487 only) Address of complex state data (current level) for Berk IX  (Entry at
* #R48541 only) Address of complex state data for an entity Output: HL  Address of next script instruction to
* execute
script_routine_32:
       .call @_48388                   ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was not with entity of class 130 (causes Berk and Drutt to bounce off or
                                                           ; bang head)...
       jne  _48507                     ; JR NZ,48507       ; ...then skip ahead to #R48507
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset entity's Is Flying Flag
       li   hl,_35359                  ; LD HL,35359       ; Load HL with script data address for Berk starting to fall downwards
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
_48507:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is 121 or greater...
       cb   a,@bytes+121               ; CP 121            ; ...
       jhe  _48527                     ; JR NC,48527       ; ...then skip ahead to #R48527
       movb @control_input,a                  ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right pressed...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48593       ; ...then move Berk right one character, and into new room if appropriate
       b    @_48593                    ;                   
!
       movb a,tmp0                     ; BIT 1,A           ; If left pressed...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48641       ; ...then move Berk left one character, and into new room if appropriate
       b    @_48641                    ;                   
!
_48527:
       equ  $
       movb @6(ix),a                   ; LD A,(IX+6)       ; If y-coordinate of Berk's bottom edge is less than 98...
       cb   a,@bytes+98                ; CP 98             ; ...
       jhe  !                          ; JP C,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       .call @change_room_up                   ; CALL 55433        ; Change Berk's room up one if appropriate
       .call @_48710                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37718. It is also the start of the routine triggered by instruction
* 34 in script data.
script_routine_34:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease y-coordinates of entity's top and bottom edges by one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@4(iy)                 ; DEC (IY+4)        ; ...and decrease its top and bottom y-coordinates by one character...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (35) Move Entity at IX (and if Berk, Carried Entity) Down One Character
* 
* Used by the routine at #R37778. Input:  IX  Address of complex state data for an entity
script_routine_35:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase y-coordinates of entity's top and bottom edges by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@4(iy)                 ; INC (IY+4)        ; ...and increase its top and bottom y-coordinates by one character...
       ab   one,@6(iy)                 ; INC (IY+6)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Right One Character, and Into New Room if Appropriate
* 
* Used by the routine at #R48487. Input:  IX  (Entry at #R48593 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48615 only) Address of complex state data for an entity
_48593:
       movb @_34235,a                  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of Berk's right side is less than x-coordinate of right of current room...
       cb   a,@e                       ; CP E              ; ...
       jl   script_routine_03                     ; JR C,48615        ; ...then skip ahead to #R48615 (move Berk right by one character
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the right, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   ; instruction and execute)
!
       bl    @do_move_into_right_room  ; CALL 54383        ; Move Berk into room to right of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       .call @_48710                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 03 in script data.
script_routine_03:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Increase x-coordinates of entity's left and right edges by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       ab   one,@5(iy)                 ; INC (IY+5)        ; ...and increase its left and right x-coordinates by one character...
       ab   one,@7(iy)                 ; INC (IY+7)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Entity Left One Character, and Into New Room if Appropriate
* 
* Used by the routine at #R48487. Input:  IX  (Entry at #R48641 only) Address of complex state data (current level)
* for Berk IX  (Entry at #R48660 only) Address of complex state data for an entity
_48641:
       movb @bytes+100,a               ; LD A,100          ; If Berk's left-side x-coordinate is greater than 100 (x-coordinate of left side of room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   script_routine_02                     ; JR C,48660        ; ...then skip ahead to #R48660 (move Berk left by one character)
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room...
       jne  !                          ; JP Z,48096        ; ...and if there is no room to the left, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   ; instruction and execute)              
!
       bl   @do_move_into_left_room   ; CALL 54419        ; Move Berk into room to left of its current room and update position of carried entity if
                                                           ; moving entity is Berk
       .call @_48710                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
* This entry point is used by the routine at #R37085. It is also the start of the routine triggered by instruction
* 02 in script data.
script_routine_02:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Decrease x-coordinates of entity's left and right edges by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity is Berk and his Carrying Something Flag is reset...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk...
       sb   one,@5(iy)                 ; DEC (IY+5)        ; ...and decrease its left and right x-coordinates by one character...
       sb   one,@7(iy)                 ; DEC (IY+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (22) Move Carried Entity Behind Berk as he Faces Into Screen
script_routine_22:
       .call @_48715                   ; CALL 48715        ; Move carried entity behind Berk as he faces into screen
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (21) Move Carried Entity in Front of Berk as he Faces Out of Screen
script_routine_21:
       .call @_48710                   ; CALL 48710        ; Move carried entity in front of Berk as he faces out of screen
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (19) Move Carried Entity to Berk's Left as he Faces Left
script_routine_19:
       .call @_48738                   ; CALL 48738        ; Move carried entity to Berk's left as he faces left
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (20) Move Carried Entity to Berk's Right as he Faces Right
script_routine_20:
       .call @_48727                   ; CALL 48727        ; Move carried entity to Berk's right as he faces right
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Carried Entity in Front of Berk as he Faces Out of Screen
* 
* Used by the routines at #R36008, #R48487, #R48593, #R48641 and #R48692.
_48710:
       .call @_48760                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       jmp  _48719                     ; JR 48719          ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850) and return

* Move Carried Entity Behind Berk as he Faces into Screen
* 
* Used by the routine at #R48686.
_48715:
       .call @_48760                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routine at #R48710.
_48719:
       xor  one,a                      ; XOR 1             ; Move carried entity into horizontal position appropriate to its width (see notes in routine
                                                           ; at #R48850)...
       ab   one,a                      ; INC A             ; ...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...
       jmp  _48749                     ; JR 48749          ; Set carried entity's horizontal position and depth and return

* Move Carried Entity to Berk's Right as he Faces Right
* 
* Used by the routines at #R48704 and #R54383.
_48727:
       .call @_48760                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
       neg a                           ; NEG               ; Subtract width of carried entity minus one divided by two...
       ab   @7(ix),a                   ; ADD A,(IX+7)      ; ...from Berk's right-side x-coordinate and load into A
       jmp  _48749                     ; JR 48749          ; Set carried entity's calculated horizontal position and depth and return

* Move Carried Entity to Berk's Left as he Faces Left
* 
* Used by the routines at #R48698 and #R54419. Input:  IY  Address of complex state data for an entity carried by
* Berk
_48738:
       .call @_48760                   ; CALL 48760        ; If Berk is carrying an entity then load A with its width minus one divided by two and D with
                                                           ; Berk's depth, else return
       ab   a,a                        ; ADD A,A           ; Double A to give width minus one... (see bugs)
       ab   one,a                      ; INC A             ; ...and add one to get width of entity
       neg a                           ; NEG               ; Subtract width of carried entity...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...from Berk's left-side x-coordinate and load into A
       ab   one,d                      ; INC D             ; Increase the depth (as carried entity has moved deeper into the screen)
* This entry point is used by the routines at #R48715 and #R48727.
_48749:
       movb a,@5(iy)                   ; LD (IY+5),A       ; Set carried entity's horizontal position and depth...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
       movb d,@1(iy)                   ; LD (IY+1),D       ; ...
       .ret                            ; RET               ; Return

* Load A, D and E with Positional Data for a Carried Entity or Return
* 
* Used by the routines at #R48710, #R48715, #R48727 and #R48738. Input:  IX  Address of complex state data for an
* entity Output: A  Width of carried entity (characters) minus 1, divided by two D  Depth of entity at IX (Berk) E
* Width of carried entity (characters) minus 1 IY  Address of complex state data for entity held by Berk
_48760:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If entity IX is Berk and his Carrying Something Flag is set...
       andi tmp0,16*256                ;                   
       jne  _48768                     ; JR NZ,48768       ; ...then skip ahead to #R48768
       .pop bc                         ; POP BC            ; Pop top value (return address) off stack...
       .ret                            ; RET               ; ...and return to routine that called the calling routine
_48768:
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       movb *ix,a                      ; LD A,(IX+0)       ; Set this entity's room to be same as Berk's...
       movb a,*iy                      ; LD (IY+0),A       ; ...
       .call @_48897                   ; CALL 48897        ; Move carried entity into vertical position appropriate to its height
       movb @carried_entity_width,a                  ; LD A,(34272)      ; Load A and E with width of entity (characters) carried by Berk, minus 1...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; Divide A by two, removing remainder
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load carried entity's depth into D
       .ret                            ; RET               ; Return

* Unused routine
* 
* Assuming that IX and IY contain the addresses of two entities' complex state data, this routine will position the
* entity at IX such that it is horizontally centred with respect to, and B characters below the entity at IY. Input:
* IX  Address of complex state data for Entity 1 (assumed) IY  Address of complex state data for Entity 2 (assumed)
* B  Vertical offset (assumed)
;_48791:
;       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height of Entity 1 minus one...
;       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
;       movb a,@c                       ; LD C,A            ; ...
;       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of bottom edge of Entity 2 plus B...
;       ab   b,a                        ; ADD A,B           ; ...
;       movb a,@6(ix)                   ; LD (IX+6),A       ; Set y-coordinate of bottom edge of Entity 1 to A
;       sb   @c,a                       ; SUB C             ; Update y-coordinate of top edge of Entity 1 accordingly...
;       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
;       movb @7(ix),a                   ; LD A,(IX+7)       ; Load B with width of Entity 1 minus one...
;       sb   @5(ix),a                   ; SUB (IX+5)        ; ...
;       movb a,b                        ; LD B,A            ; ...
;       srl  a,1                        ; SRL A             ; Load C with half of width of Entity 1 minus one...
;       movb a,@c                       ; LD C,A            ; ...
;       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with half of width of Entity 2 minus one...
;       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
;       srl  a,1                        ; SRL A             ; ...
;       ab   @5(iy),a                   ; ADD A,(IY+5)      ; ...and add x-coordinate of left edge of Entity 2
;* At this point, A holds the x-coordinate of the mid-point of Entity 2
;       sb   @c,a                       ; SUB C             ; Subtract half of width of Entity 1 minus one...
;       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set as x-coordinate of left edge of Entity 1
;       ab   b,a                        ; ADD A,B           ; Update x-coordinate of right edge of entity 2 accordingly...
;       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
;       movb @8(ix),a                   ; LD A,(IX+8)       ; If Entity 1 is not Berk...
;       cb   a,@bytes+31                ; CP 31             ; ...
;       jeq  !                          ; RET NZ            ; ...then return
;       .ret                            ;
;!
;       .push hl                        ; PUSH HL           ; Store HL
;       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
;       .pop hl                         ; POP HL            ; Restore HL
;       .ret                            ; RET               ; Return

* Have Berk Hold an Entity, and Position it Appropriately Between his Hands
* 
* The instruction blocks #R48872-#R48894 and #R48897-#R48916 move the entity that Berk is carrying into position
* (i.e. between Berk's hands), at a horizontal or vertical position appropriate to the height / width of that
* entity. These instructions result in the following x- or y-coordinates (left or top of carried entity relative to
* left or top of carrier, i.e. Berk): Input:  IX  Address of complex state data (current level) for Berk IY  (entry
* at #R48897) Address of complex state data for an entity carried by Berk Output: IY  Address of complex state data
* for entity held by Berk
_48850:
       mov  @bert_interaction_state,iy ; LD IY,(34256)     ; Load IY with address of complex state data for entity to be held by Berk...
       mov  iy,@bert_held_state        ; LD (34260),IY     ; ...and store at #R34260 as address of state data for entity held by Berk
       socb @bits+5,@10(iy)            ; SET 5,(IY+10)     ; Set the entity's Is Being Carried Flag
       socb @bits+4,@9(ix)             ; SET 4,(IX+9)      ; Set Berk's Carrying Something Flag
       movb @8(iy),a                   ; LD A,(IY+8)       ; Set class of entity held by Berk to be this entity's class...
       movb a,@_34221                  ; LD (34221),A      ; ...
_48872:
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with the width of the entity, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       movb a,@carried_entity_width                  ; LD (34272),A      ; ...and store at #R34272
       movb a,@e                       ; LD E,A            ; Load E with width of entity, minus 1
       srl  a,1                        ; SRL A             ; Move entity defined at IY into horizontal position appropriate to its height (see notes
                                                           ; above)...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...
       movb a,@5(iy)                   ; LD (IY+5),A       ; ...
       ab   @e,a                       ; ADD A,E           ; ...
_48894:
       movb a,@7(iy)                   ; LD (IY+7),A       ; ...
* This entry point is used by the routine at #R48760.
_48897:
       movb @6(iy),a                   ; LD A,(IY+6)       ; Move entity defined at IY into vertical position appropriate to its height (see notes
                                                           ; above)...
       sb   @4(iy),a                   ; SUB (IY+4)        ; ...
       movb a,@e                       ; LD E,A            ; ...
       srl  a,1                        ; SRL A             ; ...
       xor  one,a                      ; XOR 1             ; ...
       ab   one,a                      ; INC A             ; ...
       ab   @4(ix),a                   ; ADD A,(IX+4)      ; ...
       movb a,@4(iy)                   ; LD (IY+4),A       ; ...
       ab   @e,a                       ; ADD A,E           ; ...
_48916:
       movb a,@6(iy)                   ; LD (IY+6),A       ; ...
       .ret                            ; RET               ; Return

* Script Routine (29) Make Berk Start Falling, and Drop his Carried Entity if Appropriate Input:  IX  Address of
* complex state data for an entity
script_routine_29:
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set Berk's initial velocity factor to 2
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set Berk's "Can Fall" flag
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (30) Check Berk's Fall Velocity, and React to Landing
* 
* See trivia and pokes Input:  IX  Address of complex state data (current level) for Berk Output: HL  Address of
* next script instruction to execute
script_routine_30:
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If Berk's "Can Fall" Flag is reset (i.e. Berk has landed)...
       andi tmp0,64*256                ;                   
       jeq  _48958                     ; JR Z,48958        ; ...then skip ahead to #R48958
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;                   
       jne  _48952                     ; JR NZ,48952       ; ...then skip ahead to #R48952
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       b    @execute_script                    ; JP 48098          ; ...and execute
_48952:
       li   hl,_35367                  ; LD HL,35367       ; Point HL at script data for Berk falling rapidly (horizontal, arms outstretched)...
       b    @execute_script                    ; JP 48098          ; ...and execute
_48958:
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;                   
       jne  _48970                     ; JR NZ,48970       ; ...then skip ahead to #R48970
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @execute_script                    ; JP 48098          ; ...and execute
_48970:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (31) React to Berk's Landing
* 
* See trivia Input:  IX  Address of complex state data for an entity Output: HL  Address of next script instruction
* to execute
script_routine_31:
       movb @12(ix),tmp0               ; BIT 3,(IX+12)     ; If bit 3 of Berk's velocity factor is set (i.e. Berk has a velocity factor of 8)...
       andi tmp0,8*256                 ;                   
       jne  _48988                     ; JR NZ,48988       ; ...then skip ahead to #R48988
       li   hl,_35457                  ; LD HL,35457       ; Point HL at script data for Berk landing (after jump)
       b    @execute_script            ; JP 48098          ; ...and execute
_48988:
       li   hl,_35371                  ; LD HL,35371       ; Point HL at script data for Berk lying on floor stunned and getting up
       b    @execute_script            ; JP 48098          ; ...and execute

* Script Routine (33) Advance Berk's Jump and Select Next Phase if Current Phase Complete Output: HL  Address of
* next script instruction to execute
script_routine_33:
       .call @_55041                   ; CALL 55041        ; Handle Berk's jump, and load A with Jump State Index as appropriate...
       movb @e,a                       ; LD A,E            ; ...
       socb a,a                        ; OR A              ; If Jump State Index is zero...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       sb   one,a                      ; DEC A             ; Decrease Jump State Index
       li   de,_48994                  ; LD DE,48994       ; Load DE with start address of Table of Addresses of Berk's Jump Script Data
       bl   @load_table_addr           ; CALL 53814        ; Advance DE by 2xA Bytes, load WORD at this location into HL...
       .ex_de_hl                       ; EX DE,HL          ; ...
       b    @execute_script            ; JP 48098          ; ...and execute script instruction at this location

* Reset Drutt to Initial State
* 
* Used by the routine at #R34751.
_51732:
       li   hl,drutt_facing_out_script ; LD HL,51524       ; Set current position in Drutt's script data...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...to #R51524 (Drutt facing out of screen)
       .ret                            ; RET               ; Return

* Update States of Drutt and Worm and Store Current Positions in Script Data
* 
* Used by the routine at #R34438.
update_drutt_worm_state:
       .proc
       bl   @update_worm_state         ; CALL 52837        ; Update state of Worm and store current position in script data
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Drutt's current room
       mov  @drutts_script_pos,hl      ; LD HL,(51518)     ; Load current position in Drutt's script data from #R51518 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_drutt_state        ; CALL 51765        ; Update state of Drutt
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...at #R51518 as current position in Drutt's script data
       .endproc                        ; RET               ; Return
*// update_drutt_worm_state

* Update State of Drutt
* 
* If Drutt is being carried or falling, then he should be prevented from doing anything. This is accomplished by
* constantly resetting his current script data position to be #R51520. This does nothing except redraw Drutt. Input:
* IX  Address of complex state data (current level) for Drutt Output: HL  Address of next script instruction to
* execute
update_drutt_state:
       .proc
       movb @10(ix),a                  ; LD A,(IX+10)      ; If both Drutt's Being Carried and Can Fall flags are reset...
       andi a,96*256                   ; AND 96            ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @execute_script            ; JP 48098          ; ...and execute
*// update_drutt_state

* Script Routine (43) Select Next Action for Drutt Depending Upon Control Input Input:  IX  Address of complex state
* data (current level) for Drutt Output: HL  Address of next script instruction to execute
script_routine_43:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check Drutt for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
       cb   a,@bytes+129               ; CP 129            ; ...and if collision was not with entity of class 129 (causes other entities to start
                                                           ; falling)...
       jne  _51792                     ; JR NZ,51792       ; ...then skip ahead to #R51792
       .call @_55516                   ; CALL 55516        ; Set Drutt's Can Fall Flag and initial velocity factor to 2
       b    @script_routine_45                    ; JP 52038          ; Move Drutt down one character, advance HL to next script instruction and execute
_51792:
       mov  @worm_state_addr,iy        ; LD IY,(34244)     ; Load IY with address of current level's complex state data for worm
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  _51841                     ; JR Z,51841        ; ...then skip ahead to #R51841
* Drutt Mode Flag is set (i.e. Drutt Mode)
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set Drutt's Under Player Control Flag
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1*256                 ;                   
       jne  _51904                     ; JR NZ,51904       ; ...then randomly select script data for rightward hop of size three or four, and execute
       movb a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2*256                 ;                   
       jne  _51924                     ; JR NZ,51924       ; ...then randomly select script data for leftward hop of size three or four, and execute
       movb a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; JP NZ,51954       ; ...then point HL at script data for Drutt swapping depth levels and execute
       b    @_51954                    ;                   
!
       movb a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8*256                 ;                   
       jeq  !                          ; JP NZ,51944       ; ...then jump to #R51944 (start Drutt jumping)
       b    @_51944                    ;                   
!
* At this point, no control has been pressed, so Drutt is effectively not under player control
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is zero (i.e. not in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51960                    ; JP 51960          ; Move Drutt closer to the worm and eat it if close enough
* Drutt Mode Flag is reset (i.e. Berk Mode)
_51841:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Drutt's Under Player Control Flag
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is not zero (i.e. is in play area)...
       socb a,a                        ; OR A              ; ...
       jeq  !                          ; JP NZ,51960       ; ...then move Drutt closer to the worm and eat it if close enough
       b    @_51960                    ;                   
!
       mov  @berk_state_addr,iy        ; LD IY,(34240)     ; Load IY with address of current level's complex state data for Berk
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt is in the same room as Berk...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  _51875                     ; JR Z,51875        ; ...then randomly select an action for Drutt and execute
* The following code will make Drutt move closer to the target (a worm, or Berk if in Berk Mode) if the target's
* room is directly to the left or right of Drutt's room (i.e. no vertical separation). Otherwise, Drutt will perform
* a random action. This entry point is used by the routine at #R51960.
_51864:
       bl   @find_direction_to_room    ; CALL 53194        ; Load A with value indicating which direction room A lies relative to Drutt's current room
       cb   a,one                      ; CP 1              ; If target room is to the right...
       jeq  _51904                     ; JR Z,51904        ; ...then randomly select script data for rightward hop of size three or four, and execute
       cb   a,@bytes+2                 ; CP 2              ; If target room is to the left...
       jeq  _51924                     ; JR Z,51924        ; ...then randomly select script data for leftward hop of size three or four, and execute
* This entry point is used by the routine at #R51960.
_51875:
       movb @bytes+7,a                 ; LD A,7            ; Load A with a random number, 0-6...
       bl   @rnd_no                    ; CALL 54222        ; ...
       li   de,_51890                  ; LD DE,51890       ; Point DE at Table of Addresses of Script Data for Drutt's Actions...
       bl   @load_table_addr           ; CALL 53814        ; ...and load DE with entry of index A in this table
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (now contains address of randomly selected script data)
       b    @execute_script                    ; JP 48098          ; Execute script data at address in HL

* Randomly Select Script Data for Rightward Hop of Size Three or Four, and Execute
* 
* Used by the routine at #R51779.
_51904:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51918                     ; JR Z,51918        ; ...then skip ahead to #R51918
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @execute_script                    ; JP 48098          ; ...and execute
_51918:
       li   hl,_51562                  ; LD HL,51562       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size
                                                           ; three...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Randomly Select Script Data for Leftward Hop of Size Three or Four, and Execute
* 
* Used by the routine at #R51779.
_51924:
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if this is zero (1 in 2 chance)...
       jeq  _51938                     ; JR Z,51938        ; ...then skip ahead to #R51938
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @execute_script                    ; JP 48098          ; ...and execute
_51938:
       li   hl,_51608                  ; LD HL,51608       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size three...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Start Drutt Jumping
* 
* Used by the routine at #R51779.
_51944:
       movb @bytes+130,@12(ix)         ; LD (IX+12),130    ; Set Drutt's Is Jumping Flag and set initial Jump Velocity to 2
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Point HL at Script Data for Drutt Swapping Depth Levels and Execute
* 
* Used by the routine at #R51779.
_51954:
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Move Drutt Closer to the Worm and Eat it if Close Enough
* 
* Used by the routine at #R51779. Input:  IX  Address of complex state data (current level) for Drutt IY  Address of
* complex state data (current level) for Worm
_51960:
       movb *iy,a                      ; LD A,(IY+0)       ; If Drutt and worm are not in the same room...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  !                          ; JP NZ,51864       ; ...then move Drutt closer to worm if appropriate, otherwise make Drutt perform random action
       b    @_51864                    ;                   
!
       movb @5(ix),a                   ; LD A,(IX+5)       ; If Drutt's left edge...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the worm's...
       jl   _52017                     ; JR C,52017        ; ...then skip ahead to #R52017
       movb @7(iy),a                   ; LD A,(IY+7)       ; If worm's right edge...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of Drutt's left edge...
       jl   _52023                     ; JR C,52023        ; ...then skip ahead to #R52023
       movb @4(ix),a                   ; LD A,(IX+4)       ; If y-coordinate of Drutt's top edge...
       cb   a,@bytes+120               ; CP 120            ; ...is less than 120...
       jhe  !                          ; JP C,51875        ; ...then randomly select an action for Drutt and execute
       b    @_51875                    ;                   
!
       movb @1(iy),a                   ; LD A,(IY+1)       ; If worm's depth is the same as Drutt's...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jeq  _52007                     ; JR Z,52007        ; ...then skip ahead to #R52007
* Drutt and worm in same room, at different depth and same x-coordinate
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt and worm in same room, at same depth and same x-coordinate
_52007:
       movb @bytes+0,@1(iy)            ; LD (IY+1),0       ; Set worm's depth to zero (i.e. remove from play)
       li   hl,_51706                  ; LD HL,51706       ; Point HL at script data for Drutt eating a worm...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt's left edge to left of worm's
_52017:
       li   hl,_51538                  ; LD HL,51538       ; Point HL at script data for moving Drutt and any pushed entity right by a hop of size four...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Worm's right edge to left of Drutt's left edge
_52023:
       li   hl,_51584                  ; LD HL,51584       ; Point HL at script data for moving Drutt and any pushed entity left by a hop of size four...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (44) Move Entity Up One Character
* 
* Used by the routine at #R48026. Input:  IX  Address of complex state data for an entity
script_routine_44:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move entity up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (45) Move Entity Down One Character
* 
* Used by the routine at #R51779. Input:  IX  Address of complex state data for an entity
script_routine_45:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (46) Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if
* Appropriate
script_routine_46:
       .call @_52053                   ; CALL 52053        ; Move Drutt, or entity he is pushing left one character and start pushed entity falling if
                                                           ; appropriate
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Drutt, or Entity he is Pushing Left One Character and Start Pushed Entity Falling if Appropriate
* 
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
_52053:
       bl    @chk_coll_left            ; CALL 54666        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; left...
       joc  _52087                     ; JR C,52087        ; ...and if a collision has not occurred, then skip ahead to #R52087
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  _52076                     ; JR NC,52076       ; ...then skip ahead to #R52076
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _52087                     ; JR Z,52087        ; ...then skip ahead to #R52087 (move Drutt left without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       .call @_52098                   ; CALL 52098        ; Advance position of entity pushed left by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       .ret                            ; RET               ; Return
* Collision with entity of class 22 or greater
_52076:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52087                     ; JR Z,52087        ; ...then skip ahead to #R52087
* At this point, the entity to Drutt's left is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
_52087:
       bl   @move_into_left_room       ; CALL 54348        ; Move Drutt into room to the left, if appropriate...
       joc  !                          ; RET NC            ; ...and if Drutt can't enter new room then return
       .ret                            ;                   
!
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Drutt left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       .ret                            ; RET               ; Return

* Advance Position of Entity Pushed Left by Drutt
* 
* Used by the routine at #R52053. Input:  IY  Address of complex state data for entity pushed by Drutt
_52098:
       .push iy                        ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
       .pop ix                         ; POP IX            ; ...to IX
       bl    @chk_coll_left            ; CALL 54666        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the left...
       joc  _52112                     ; JR C,52112        ; ...and if a collision has not occurred, then skip ahead to #R52112
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52134                     ; JR Z,52134        ; ...then skip ahead to #R52134
       .ret                            ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
_52112:
       movb @5(ix),a                   ; LD A,(IX+5)       ; If x-coordinate of left edge of pushed entity is at least 103...
       cb   a,@bytes+103               ; CP 103            ; ...i.e. not yet at left edge of room...
       jhe  _52127                     ; JR NC,52127       ; ...then skip ahead to #R52127
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of current character's current room...
       jne  !                          ; RET Z             ; ...and if there is no room to the left then return
       .ret                            ;                   
!
       bl   @move_into_left_room       ; CALL 54348        ; Move pushed entity into room to the left, if appropriate...
       joc  !                          ; RET NC            ; ...and if pushed entity can't enter new room then return
       .ret                            ;                   
!
_52127:
       equ  $
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move pushed entity left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       .ret                            ; RET               ; Return
_52134:
       .call @_55516                   ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       .call @_52127                   ; CALL 52127        ; Move pushed entity left two characters...
       jmp  _52127                     ; JR 52127          ; ...and return

* Script Routine (47) Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if
* Appropriate
script_routine_47:
       .call @_52148                   ; CALL 52148        ; Move Drutt, or entity he is pushing right one character and start pushed entity falling if
                                                           ; appropriate
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Move Drutt, or Entity he is Pushing Right One Character and Start Pushed Entity Falling if Appropriate
* 
* Drutt will only push other entities when he is under player control. If he is not, then he will just pass through
* pushable entities. Input:  IX  Address of complex state data (current level) for Drutt
_52148:
       bl   @chk_coll_right            ; CALL 54569        ; Check Drutt for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       joc  _52182                     ; JR C,52182        ; ...and if a collision has not occurred, then skip ahead to #R52182
* At this point, a collision has occurred, so IY points to the complex state data entry of the entity with which
* Drutt has collided
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class 22 or greater (can't be picked up)...
       jhe  _52171                     ; JR NC,52171       ; ...then skip ahead to #R52171
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Drutt's Under Player Control Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _52182                     ; JR Z,52182        ; ...then skip ahead to #R52182 (move Drutt right without pushing anything)
       .push ix                        ; PUSH IX           ; Store IX (address of current level's complex state data for Drutt)
       .call @_52193                   ; CALL 52193        ; Advance position of entity pushed right by Drutt
       .pop ix                         ; POP IX            ; Restore IX (address of current level's complex state data for Drutt)
       .ret                            ; RET               ; Return
* Collision with entity of class 22 or greater
_52171:
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52182                     ; JR Z,52182        ; ...then skip ahead to #R52182
* At this point, the entity to Drutt's right is neither passable nor pushable.
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_51630                  ; LD HL,51630       ; Point HL at script data for Drutt swapping depth levels...
       b    @execute_script                    ; JP 48098          ; ...and execute
* No collision, not under player control or collision with entity of class 129
_52182:
       bl   @move_into_right_room      ; CALL 54313        ; Move Drutt into room to the right, if appropriate...
       joc  !                          ; RET NC            ; ...and if Drutt can't enter new room then return
       .ret                            ;                   
!
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Drutt right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       .ret                            ; RET               ; Return

* Advance Position of Entity Pushed Right by Drutt
* 
* Used by the routine at #R52148. Input:  IY  Address of complex state data for entity pushed by Drutt
_52193:
       .push iy                        ; PUSH IY           ; Transfer address of complex state data for pushed entity from IY...
       .pop ix                         ; POP IX            ; ...to IX
       bl   @chk_coll_right            ; CALL 54569        ; Check pushed entity for collision with another impassable / pushable entity immediately to
                                                           ; the right...
       joc  _52207                     ; JR C,52207        ; ...and if a collision has not occurred, then skip ahead to #R52207
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _52235                     ; JR Z,52235        ; ...then skip ahead to #R52235
       .ret                            ; RET               ; Return (as Drutt can't push two entities)
* No knock-on collision
_52207:
       movb @_34235,a                  ; LD A,(34235)      ; Load E with width of current room (chars) + 99...
       sb   @bytes+2,a                 ; SUB 2             ; ...minus 2...
       movb a,@e                       ; LD E,A            ; ...
       movb @7(ix),a                   ; LD A,(IX+7)       ; ...and if x-coordinate of right edge of pushed entity is less than this...
       cb   a,@e                       ; CP E              ; ...i.e. not yet at right edge of room...
       jl   _52227                     ; JR C,52227        ; ...then skip ahead to #R52227
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room...
       jne  !                          ; RET Z             ; ...and if there is no room to the right then return
       .ret                            ;                   
!
       bl   @move_into_right_room      ; CALL 54313        ; Move pushed entity into room to the right, if appropriate...
       joc  !                          ; RET NC            ; ...and if pushed entity can't enter new room then return
       .ret                            ;                   
!
_52227:
       equ  $
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move pushed entity right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       sb   a,a                        ; XOR A             ; Load A with zero (see trivia)
       .ret                            ; RET               ; Return
_52235:
       .call @_55516                   ; CALL 55516        ; Set Can Fall Flag and set initial velocity factor of 2 for pushed entity
       .call @_52227                   ; CALL 52227        ; Move pushed entity right two characters...
       jmp  _52227                     ; JR 52227          ; ...and return

* Script Routine (50) Advance Drutt's Jump and Select Next Phase if Current Phase Complete
* 
* The CALL at #R52243 will be RETurned from if Drutt's Is Jumping Flag is reset. Otherwise, E will be loaded with
* Drutt's jump state index (see #R55041). Output: HL  Address of next script instruction to execute
script_routine_50:
       .call @_55023                   ; CALL 55023        ; Handle Drutt's jump, and load A with Jump State Index as appropriate
       movb @e,a                       ; LD A,E            ; If jump state index is zero...
       socb a,a                        ; OR A              ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       cb   a,one                      ; CP 1              ; If jump state index is 1...
       jeq  _52259                     ; JR Z,52259        ; ...then skip ahead to #R52259
       cb   a,@bytes+2                 ; CP 2              ; If jump state index is not 2...
       jne  _52265                     ; JR NZ,52265       ; ...then skip ahead to #R52265
* Jump state index is 1 (landed on floor / platform and Back (control input) bit set) or 2 (unused)
_52259:
       li   hl,_51674                  ; LD HL,51674       ; Point HL at script data for Drutt starting to jump straight up...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Jump state index is not 2
_52265:
       cb   a,@bytes+3                 ; CP 3              ; If jump state index is not 3...
       jne  _52275                     ; JR NZ,52275       ; ...then skip ahead to #R52275
* Jump state index is 3 (Drutt's jump velocity less than 4, and back not pressed, i.e. terminate jumping)
       li   hl,drutt_facing_out_script ; LD HL,51524       ; Point HL at script data for Drutt facing out of screen...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 3
_52275:
       cb   a,@bytes+4                 ; CP 4              ; If jump state index is not 4...
       jne  _52285                     ; JR NZ,52285       ; ...then skip ahead to #R52285
* Jump state index is 4 (bounced off an obstruction to the right or Left (control input) Bit set)
       li   hl,_51686                  ; LD HL,51686       ; Point HL at script data for Drutt Jumping Left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 4
_52285:
       cb   a,@bytes+5                 ; CP 5              ; If jump state index is not 5...
       jne  _52295                     ; JR NZ,52295       ; ...then skip ahead to #R52295
* Jump state index is 5 (bounced off an obstruction to the left or Right (control input) Bit set)
       li   hl,_51696                  ; LD HL,51696       ; Point HL at script data for Drutt Jumping Right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Jump state index is not 5
_52295:
       cb   a,@bytes+6                 ; CP 6              ; If jump state index is not 6...
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
* Jump state index is 6 (Drutt has banged his head on something above him)
       .call @_55516                   ; CALL 55516        ; Set Drutt's Can Fall Flag and set initial velocity factor of 2
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Script Routine (51) Swap Drutt's Current Depth Level if Possible
script_routine_51:
       .call @_52315                   ; CALL 52315        ; Swap Drutt's current depth level if possible
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute

* Swap Drutt's Current Depth Level if Possible
* 
* Used by the routine at #R52309. Input:  IX  Address of complex state data (current level) for Drutt
_52315:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's depth is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  _52351                     ; JR NZ,52351       ; ...then skip ahead to #R52351
* Drutt's depth is 1
       movb @tmp_room_dim_data,a       ; LD A,(34230)      ; If Drutt's current depth is the same as number of available depth levels in current room...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...i.e. room has depth of 1...
       jne  !                          ; RET Z             ; ...then return (as there is no other depth level for Drutt to move to)
       .ret                            ;                   
!
* The following collision check is usually only satisfied by Berk. This prevents Drutt from jumping back a depth
* level while in front of (at same depth level as) Berk.
       bl    @chk_coll_same_depth_rev  ; CALL 54878        ; Check Drutt for collision with another entity (only those defined before, and in reverse
                                                           ; order) at same depth level whose Interaction (11,7) Flag is set...
       joc  !                          ; RET NC            ; ...and if a collision occurred, then return
       .ret                            ;                   
!
* The following collision check prevents Drutt from jumping back when there is an obstruction (e.g. the brick
* columns in the pit room, level 1) behind him.
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check Drutt for collision with another entity (in reverse order) at next depth level into
                                                           ; screen whose Interaction (11,7) Flag is set...
       joc  _52341                     ; JR C,52341        ; ...and if no collision occurred, then skip ahead to #R52341
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
_52341:
       equ  $
       ab   one,@1(ix)                 ; INC (IX+1)        ; Increase Drutt's depth (i.e. move backward away from screen)
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Decrease Drutt's top and bottom y-coordinates...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       .ret                            ; RET               ; Return
* Drutt's depth is not 1
_52351:
       movb @1(ix),a                   ; LD A,(IX+1)       ; If Drutt's current depth is 1... (see trivia)
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
* The following collision check prevents Drutt from jumping forward a depth level while in behind an obstruction
* (e.g. Berk).
       bl   @chk_coll_next_depth       ; CALL 54764        ; Check Drutt for collision with another entity at next depth level out of screen whose
                                                           ; Interaction (11,6) Flag is set...
       joc  !                          ; RET NC            ; ...and if a collision occurred, then return
       .ret                            ;                   
!
       sb   one,@1(ix)                 ; DEC (IX+1)        ; Decrease Drutt's depth (i.e. move forward towards screen)
       ab   one,@4(ix)                 ; INC (IX+4)        ; Increase Drutt's top and bottom y-coordinates...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       .ret                            ; RET               ; Return

* Update State of Worm and Store Current Position in Script Data
* 
* Used by the routine at #R51739.
update_worm_state:
       .proc
       mov  @worm_state_addr,ix        ; LD IX,(34244)     ; Load IX with address of current level's complex state data for worm
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       mov  @worms_script_data_pos,hl  ; LD HL,(52726)     ; Load current position in worm's script data from #R52726 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_worm_state_1       ; CALL 52860        ; Update state of worm
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@worms_script_data_pos  ; LD (52726),HL     ; ...at #R52726 as current position in worm's script data
       .endproc                        ; RET               ; Return

* Update State of Worm
* 
* Used by the routine at #R52837. Input:  IX  Address of complex state data (current level) for Worm
update_worm_state_1:
       .proc
       movb @1(ix),a                   ; LD A,(IX+1)       ; If worm's depth is zero (i.e. not currently active)...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,53083        ; ...then attempt to spawn a new worm...
       b    @spawn_new_worm            ;
!
       b    @inct_execute_script       ; JP 48096          ; ...otherwise advance HL to next script instruction and execute

* Script Routine (53) Move Worm Left if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
script_routine_53:
       bl    @chk_coll_left            ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52908                     ; JR NC,52908       ; ...and if a collision occurred, then have worm choose new direction
       bl   @move_into_left_room       ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; ...and if worm can't enter new room then have worm choose new direction
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move worm left one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Script Routine (54) Move Worm Right if Possible, Otherwise Choose New Direction Input:  IX  Address of complex
* state data for an entity
script_routine_54:
       bl   @chk_coll_right            ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52908                     ; JR NC,52908       ; ...and if a collision occurred, then have worm choose new direction
       bl   @move_into_right_room      ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52908                     ; JR NC,52908       ; ...and if worm can't enter new room then have worm choose new direction
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move worm right one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute

* Execute Script Data for Worm Choosing Next Direction
* 
* Used by the routines at #R52870 and #R52889.
_52908:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @execute_script            ; JP 48098          ; ...and execute

* Script Routine (55) Choose New Direction and Start Crawling (Worm) Input:  IX  Address of complex state data for
* an entity
script_routine_55:
       .call @_53057                   ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       movb @bytes+20,a                ; LD A,20           ; Load A with a random number, 5-24...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   @bytes+5,a                 ; ADD A,5           ; ...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...and set worm's Time Until Direction Change to this value
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 0-1...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; ...and if zero (1 in 2 chance)...
       jne  _52951                     ; JR NZ,52951       ; ...then skip ahead to #R52951
* Have worm move left
       bl    @chk_coll_left            ; CALL 54666        ; Check worm for collision with another impassable / pushable entity immediately to the left...
       jnc  _52961                     ; JR NC,52961       ; ...and if a collision occurred, then start worm crawling right
       bl   @move_into_left_room       ; CALL 54348        ; Move worm into room to the left, if appropriate...
       jnc  _52961                     ; JR NC,52961       ; ...and if worm can't enter new room then start worm crawling right
_52945:
       li   hl,_52765                  ; LD HL,52765       ; Point HL at script data for worm, crawling left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Have worm move right
_52951:
       bl   @chk_coll_right            ; CALL 54569        ; Check worm for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  _52945                     ; JR NC,52945       ; ...and if a collision occurred, then start worm crawling left
       bl   @move_into_right_room      ; CALL 54313        ; Move worm into room to the right, if appropriate...
       jnc  _52945                     ; JR NC,52945       ; ...and if worm can't enter new room then start worm crawling left
_52961:
       li   hl,_52781                  ; LD HL,52781       ; Point HL at script data for worm, crawling right...
       b    @execute_script            ; JP 48098          ; ...and execute

* Script Routine (52) Increase Worm's Age and Decrease Time Until Direction Change, or React to Drutt's Presence
* 
* When both Drutt and the worm are in the same room, and the worm is alerted to Drutt's presence, then the worm will
* take on its alarmed appearance and start fleeing in the direction away from Drutt. As long as Drutt remains in the
* same room as the worm, and within the "alerting" distance, the worm will continue fleeing in the same direction,
* and its Time Until Direction Change will be frozen. Input:  IX  Address of complex state data for an entity
* Output: HL  Address of next script instruction to execute
script_routine_52:
       .call @_53057                   ; CALL 53057        ; Increase Worm's Age and, if it has expired, set its depth to zero and return
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt
       movb *ix,a                      ; LD A,(IX+0)       ; If Drutt and the worm are in the same room...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jeq  _53004                     ; JR Z,53004        ; ...then skip ahead to #R53004
* Drutt and worm in different rooms, so countdown to next direction change resumes as worm out of danger
_52982:
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset In Danger Flag
       movb @12(ix),a                  ; LD A,(IX+12)      ; If worm's Time Until Direction Change is zero...
       socb a,a                        ; OR A              ; ...
       jeq  _52998                     ; JR Z,52998        ; ...then skip ahead to #R52998 (have worm choose new direction)
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease worm's Time Until Direction Change
       b    @inct_execute_script                    ; JP 48096          ; Advance HL to next script instruction and execute
_52998:
       li   hl,_52747                  ; LD HL,52747       ; Point HL at script data for worm, choosing next direction...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt and worm in same room, so worm potentially in danger
_53004:
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of worm's left edge...
       ab   one,a                      ; INC A             ; ...plus one...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...minus x-coordinate of Drutt's left edge
       jlt  _53034                     ; JR C,53034        ; If negative then skip ahead to #R53034
       cb   a,@bytes+10                ; CP 10             ; If worm's left edge is 9 characters or more to the right of Drutt's...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52817                  ; LD HL,52817       ; Point HL at script data for worm, fleeing right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt's left edge more than one character to the right of worm's left edge
_53034:
       neg a                           ; NEG               ; If worm's left edge is 11 characters or more to the left of Drutt's...
       cb   a,@bytes+10                ; CP 10             ; ...
       jhe  _52982                     ; JR NC,52982       ; ...then jump back to #R52982
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If In Danger Flag is set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       socb @bits+1,@9(ix)             ; SET 1,(IX+9)      ; Set In Danger Flag
       li   hl,_52797                  ; LD HL,52797       ; Point HL at script data for worm, fleeing left...
       b    @execute_script                    ; JP 48098          ; ...and execute

* Increase Worm's Age and Set its Depth to Zero if it has Expired
* 
* Used by the routines at #R52914 and #R52967. Input:  IX  Address of complex state data (current level) for Worm
_53057:
       movb @worms_age,a                  ; LD A,(52728)      ; Increase current Worm Age value...
       ab   one,a                      ; INC A             ; ...
       movb a,@worms_age                  ; LD (52728),A      ; ...
       movb a,tmp0                     ; BIT 7,A           ; If Worm Age is less than 128...
       andi tmp0,128*256               ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       movb @current_characters_room,a                  ; LD A,(34218)      ; If current character's room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is the same as the worm's...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; Set the worm's depth to zero...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...
       movb a,@worms_age                  ; LD (52728),A      ; Reset Worm Age to zero
       .pop bc                         ; POP BC            ; Remove top value from stack (return address in calling routine)
       .ret                            ; RET               ; Return (to routine that called the calling routine)

* Attempt to Spawn a New Worm
* 
* Used by the routine at #R52860. Input:  IX  Address of complex state data (current level) for Worm
spawn_new_worm:
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If random number is not zero (59 in 60 chance)...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @current_characters_room,a                  ; LD A,(34218)      ; Set worm's current room to same as current character's...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 99...
       sb   @bytes+100,a               ; SUB 100           ; ...and subtract 100 to get x-coordinate (zero-based) of right side of the room
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random x-coordinate within current room
       ab   @bytes+100,a               ; ADD A,100         ; Add 100 to restore coordinate system
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set this as the worm's left x-coordinate
       ab   @bytes+2,a                 ; ADD A,2           ; Add two to this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as the worm's right x-coordinate
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 1-2...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and assign the worm this depth
       movb @bytes+124,a               ; LD A,124          ; Load A with 124 (y-coordinate of character row below bottom of room)
       sb   @1(ix),a                   ; SUB (IX+1)        ; Subtract worm's depth value to get its bottom y-coordinate...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and assign
       .push af                        ; PUSH AF           ; Store AF (A = bottom y-coordinate of worm)
       movb @bytes+121,@4(ix)          ; LD (IX+4),121     ; Set worm's top y-coordinate to 121
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
       jnc  !                                              ; Flag is set
       .pop bc
       jmp  !!
!      .pop bc                         ; POP BC            ; Store AF (B = bottom y-coordinate of worm)
       jmp  _53154                     ; JR NC,53154       ; If a collision occurred then set worm's depth to zero and return
!      movb b,@4(ix)                   ; LD (IX+4),B       ; Set worm's top y-coordinate to same as its bottom y-coordinate
       li   hl,_52735                  ; LD HL,52735       ; Point HL at script data for worm rising from floor...
       b    @execute_script            ; JP 48098          ; ...and execute
_53154:
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set worm's depth to zero
       .ret                            ; RET               ; Return

* Load A with Value Indicating Which Direction Room A Lies Relative to Room in State Data at IX
* 
* Direction index value in A denotes which direction (left or right), e.g. Drutt, has to travel to reach the target
* room: Input:  A  Target room index (e.g. Berk's room or worm's room) IX  Address of complex state data (current
* level) for Drutt Output: A  Direction index
find_direction_to_room:
       .proc
       .push hl                        ; PUSH HL           ; Store HL
       .push ix                        ; PUSH IX           ; Store IX
       movb a,@e                       ; LD E,A            ; Load E with target room index
       movb *ix,a                      ; LD A,(IX+0)       ; Load D with Drutt's current room...
       movb a,d                        ; LD D,A            ; ...
       li   hl,pathfinding_data_table  ; LD HL,53159       ; Set first two bytes of header to 255 (Start Marker)...
       movb @bytes+255,*hl+            ; LD (HL),255       ; ...
                                       ; INC HL            ; ...
       movb @bytes+255,*hl+            ; LD (HL),255       ; ...
                                       ; INC HL            ; Set third byte of header to index of Drutt's current room...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; Advance HL to first byte of first entry
       bl   @get_left_room_index_1     ; CALL 54542        ; Load B with index of room to left of Drutt's current room...
       jeq  find_direction_to_room_1   ; JR Z,53228        ; ...and if there is no such room then skip ahead to #R53228
       movb @e,a                       ; LD A,E            ; If room to left of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb @bytes+2,a                 ; LD A,2            ; Load A with 2 ("go left")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to left is target room) then restore registers and return
       b    @find_direction_to_room_7                    ;
!
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to left of Drutt is to the left
find_direction_to_room_1:
       bl   @get_right_room_index_1    ; CALL 54508        ; Load B with index of room to right of Drutt's room...
       jeq  find_direction_to_room_2                     ; JR Z,53243        ; ...and if there is no such room then skip ahead to #R53243
       movb @e,a                       ; LD A,E            ; If room to right of Drutt's current room is the target room...
       cb   a,b                        ; CP B              ; ...then set Zero Flag
       movb one,a                      ; LD A,1            ; Load A with 1 ("go right")
       jne  !                          ; JP Z,53336        ; If Zero Flag is set (room to right is target room) then restore registers and return
       b    @find_direction_to_room_7                    ;
!
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table stating room to right of Drutt is to the right
* Now the Pathfinding Data Table has a header and zero, one or two records, depending upon the horizontal
* connectivity of Drutt's current room.
find_direction_to_room_2:
       li   ix,pathfinding_1st_entry   ; LD IX,53162       ; Load IX with address of first entry in Pathfinding Data Table
find_direction_to_room_3:
       movb @1(ix),d                   ; LD D,(IX+1)       ; Load D with index of room from current entry in Pathfinding Data Table
       bl   @get_left_room_index_1     ; CALL 54542        ; Load B with index of room to left of room D...
       jeq  find_direction_to_room_4                     ; JR Z,53271        ; ...and if there is no such room then skip ahead to #R53271
       movb @e,a                       ; LD A,E            ; If room to left of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @find_direction_to_room_6                    ;
!
       bl   @find_pathfinding_entry    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  find_direction_to_room_4   ; JR Z,53271        ; ...then skip ahead to #R53271
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
find_direction_to_room_4:
       bl   @get_right_room_index_1    ; CALL 54508        ; Load B with index of room to right of room D...
       jeq  find_direction_to_room_5                     ; JR Z,53292        ; ...and if there is no such room then skip ahead to #R53292
       movb @e,a                       ; LD A,E            ; If room to right of room D is the target room...
       cb   a,b                        ; CP B              ; ...
       jne  !                          ; JP Z,53333        ; ...then load A with direction index for room D, restore registers and return
       b    @find_direction_to_room_6                    ;
!
       bl   @find_pathfinding_entry    ; CALL 53317        ; If room B already has an entry in Pathfinding Data Table...
       jeq  find_direction_to_room_5   ; JR Z,53292        ; ...then skip ahead to #R53292
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with current entry's direction index (room B must lie in same direction as room D)
       bl   @add_pathfinding_entry     ; CALL 53309        ; Add entry to Pathfinding Data Table for room B lying in direction A
find_direction_to_room_5:
       inct ix                         ; INC IX            ; Advance IX by two bytes to next entry in Pathfinding Data Table...
                                       ; INC IX            ; ...
       movb *ix,a                      ; LD A,(IX+0)       ; If byte at this location is not 255 (End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jne  find_direction_to_room_3   ; JP NZ,53247       ; ...then loop back to #R53247
* At this point, the search has checked all rooms and not found the target room.
       sb   a,a                        ; XOR A             ; Set A to zero
                                       ; POP IX            ; Restore IX
                                       ; POP HL            ; Restore HL
       jmp  find_direction_to_room_7   ; RET               ; Return
* Load A with Direction Index in Pathfinding Data Table entry at Address in IX, Restore Registers and Return
* 
* Used by the routine at #R53194. Input:  IX  Address of an entry in Pathfinding Data Table
find_direction_to_room_6:
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with direction index for entry at IX
* This entry point is used by the routine at #R53194.
find_direction_to_room_7:
       .pop ix                         ; POP IX            ; Restore IX
       .pop hl                         ; POP HL            ; Restore HL
       .endproc                        ; RET               ; Return

* Add Entry to Pathfinding Data Table for Room B in Direction A
* 
* B contains the room the pathfinding routine is currently looking at, and A contains a value that denotes which
* direction this room lies in relative to Drutt's current room. Input:  A  Direction index (1 or 2) B  Index of room
* being examined HL  Current address of end of Pathfinding Data Table
add_pathfinding_entry:
       movb a,*hl+                     ; LD (HL),A         ; Store direction index
                                       ; INC HL            ; Advance by one byte
       movb b,a                        ; LD A,B            ; Store index of room being examined...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; Advance by one byte
       movb @bytes+255,*hl             ; LD (HL),255       ; Store 255 (End Marker)
       rt                              ; RET               ; Return

* Set Zero Flag if Room B Has an Entry in Pathfinding Data Table, Otherwise Reset
* 
* Used by the routine at #R53194. Input:  HL  Address of end of Pathfinding Data Table B  Index of room to check
* table for Output: F  (Zero Flag) Set if room B is already stored in Pathfinding Data Table, reset otherwise
find_pathfinding_entry:
       .push hl                        ; PUSH HL           ; Store HL (address of end of Pathfinding Data Table)
find_pathfinding_entry_1:
       dec  hl                         ; DEC HL            ; Move HL back to previous entry's room index...
       movb *hl,a                      ; LD A,(HL)         ; ...load into A...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (Start Marker, so room B not found)...
       jeq  find_pathfinding_entry_2   ; JR Z,53330        ; ...then skip ahead to #R53330
       dec  hl                         ; DEC HL            ; Move HL back to entry's direction index
       cb   a,b                        ; CP B              ; If room to search for not the same as current entry's room...
       jne  find_pathfinding_entry_1   ; JR NZ,53318       ; ...then loop back to #R53318 to test next entry
* At this point, the room we're looking for (in B) is already stored in the Pathfinding Data Table and the Zero Flag
* is set.
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       cb   a,a                                            ; Set zero flag
       jmp  find_pathfinding_entry_3   ; RET               ; Return
find_pathfinding_entry_2:
       .pop hl                         ; POP HL            ; Restore HL (address of end of Pathfinding Data Table)
       sb   one,a                      ; DEC A             ; Reset Zero Flag
find_pathfinding_entry_3:
       rt                              ; RET               ; Return

* Cycle Attributes (Long, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R53723.
cycle_attributes_long:
       .proc
       movb @bytes+21,b                ; LD B,21           ; Set repeat counter to 21
       jmp  cycle_attributes           ; JR 53583          ; Flash screen when Berk is "killed"

* Cycle Attributes (Short, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R36616.
cycle_attributes_short:
       .proc
       movb @bytes+7,b                 ; LD B,7            ; Set repeat counter to 7
       jmp  cycle_attributes

* This entry point is used by the routine at #R53577.
cycle_attributes:
       li   r0,color_table
       li   r1,>f000
       li   r2,>1600
       bl   @vsmw
       li   r0,color_table
       li   r1,>e000
       li   r2,>1600
       bl   @vsmw
;       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of iterations required)
;       li   hl,zx_attributes           ; LD HL,22528       ; Point HL at start of Attribute File
;       li   bc,704                     ; LD BC,704         ; Set BC to 704 (i.e. gap between start of Attribute File and start of second-last row (timer
;                                                           ; figures))
;cycle_attributes_1:
;       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
;       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
;       jeq  cycle_attributes_2         ; JR Z,53602        ; If value is zero (black INK) then skip ahead to #R53602
;       ab   one,a                      ; INC A             ; Increase INK value to next colour
;       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
;       jne  cycle_attributes_2         ; JR NZ,53602       ; If value is not zero (black INK) then skip ahead to #R53602
;       movb one,a                      ; LD A,1            ; INK value was zero, so set now to blue INK
;cycle_attributes_2:
;       movb a,@e                       ; LD E,A            ; Load new INK value into E
;       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
;       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
;       jeq  cycle_attributes_3         ; JR Z,53616        ; If black PAPER, then skip ahead to #R53616
;       ab   @bytes+8,a                 ; ADD A,8           ; Increase to next PAPER colour
;       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
;       jne  cycle_attributes_3         ; JR NZ,53616       ; If PAPER component is not black then skip ahead to #R53616
;       movb @bytes+8,a                 ; LD A,8            ; PAPER value was zero, so set now to blue PAPER
;cycle_attributes_3:
;       socb @e,a                       ; OR E              ; Add INK component back in
;       socb @bytes+64,a                ; OR 64             ; Set BRIGHT flag
;       movb a,*hl                      ; LD (HL),A         ; Paint new attribute back to current position in Attribute File
;       andi a,16*256                   ; AND 16            ; Set / reset speaker bit
;       socb @bytes+2,a                 ; OR 2              ; Set RED bit to maintain red border
;       ; OUT (254),A                   ; OUT (254),A       ; Set border and set / reset speaker state
;       inc  hl                         ; INC HL            ; Advance to next byte of Attribute File
;       dec  bc                         ; DEC BC            ; Decrease remaining number of character blocks to process
;       movb b,a                        ; LD A,B            ; If number of remaining character blocks is not zero...
;       socb @c,a                       ; OR C              ; ...
;       jne  cycle_attributes_1         ; JR NZ,53590       ; ...then loop back to #R53590
;       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of iterations required)
       sb   one,b                      ; DJNZ 53583        ; Loop back for next iteration
       jne  cycle_attributes                     ;
       jmp  !
* This entry point is used by the routine at #R53887.
clear_display_buffers:
       .proc
!      li   hl,display_buffer_1        ; LD HL,61312       ; Clear Display Buffers 1 and 2...
       li   bc,>1080                   ; LD BC,4224        ; ...
clear_display_buffers_1:
       clr  *hl+                       ; LD (HL),0         ; ...
                                       ; LD D,H            ; ...
                                       ; LD E,L            ; ...
       dect bc                         ; INC DE            ; ...
       jne  clear_display_buffers_1    ; LDIR              ; ...
       .endproc                        ; RET               ; Return

* Fill Top 22 Rows of Attribute File with Attribute Value in A
* 
* Used by the routines at #R46830 and #R53723. Input:  A  Attribute
fill_screen:
       .proc
       bl   @ti_color
       mov  tmp0,r1
       li   r0,color_table
       li   r2,22*256
       bl   @vsmw
;       li   hl,22528                   ; LD HL,22528       ; Point HL at start of Attribute File
;       movb @l,@e                      ; LD E,L            ; Point DE one byte after this...
;       movb h,d                        ; LD D,H            ; ...
;       inc  de                         ; INC DE            ; ...
;       li   bc,703                     ; LD BC,703         ; Set counter to 703, as we are filling 704 characters (32*22)
;       movb a,*hl                      ; LD (HL),A         ; Set first byte to A...
;       .ldir                           ; LDIR              ; ...and repeat for remaining 703 bytes
;       movb @bytes+3,b                 ; LD B,3            ; Pause for three iterations...
;       .call @_34675                   ; CALL 34675        ; ...
       .endproc                         ; RET               ; Return

* Set "Berk Has Been Killed" Flag
* 
* Used by the routines at #R36116, #R36390, #R37085, #R37639, #R38074, #R38219, #R38540, #R38592, #R39934, #R41498,
* #R41633, #R41961, #R42064, #R42266 and #R42486.
_53667:
       movb @game_flags,a                  ; LD A,(34208)      ; Set "Berk Has Been Killed" Flag...
       socb @bits+2,a                  ; SET 2,A           ; ...
       movb a,@game_flags                  ; LD (34208),A      ; ...
       .ret                            ; RET               ; Return

* If Berk Has Been Killed then Reset his Position and State, Flash Screen and Decrease Time / Lives
* 
* Used by the routine at #R34438.
check_berk_killed:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; Point HL at Game Flags
       szcb @bits+3,*hl                ; RES 3,(HL)        ; Reset "Reset Spiders to Initial State" Flag
       movb *hl,tmp0                   ; BIT 2,(HL)        ; If "Berk Has Been Killed" Flag is not set...
       andi tmp0,4*256                 ;                   
       jeq  check_berk_killed_1        ; RET Z             ; ...then return
       szcb @bits+2,*hl                ; RES 2,(HL)        ; Reset "Berk Has Been Killed" Flag
       socb @bits+3,*hl                ; SET 3,(HL)        ; Set "Reset Spiders to Initial State" Flag
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       .call @_36296                   ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   de,berk_reset_table-2      ; LD DE,53674       ; Point DE at location two bytes (1 WORD) before start of Table of Addresses of Berk Reset Data
       movb @current_level,a           ; LD A,(34207)      ; Load current level number into A
       bl   @load_table_addr           ; CALL 53814        ; Load DE with that level's address (from table at #R53676) for complex state data to revert
                                                           ; Berk to after he is killed
       .ex_de_hl                       ; EX DE,HL          ; Swap HL (now address of complex state data to revert to) and DE
       mov  @berk_state_addr,de        ; LD DE,(34240)     ; Load DE with address of current level's complex state data for Berk
       li   bc,13                      ; LD BC,13          ; Overwrite Berk's current complex state data...
       .ldir                           ; LDIR              ; ...with reset data from table at #R53684 for current level
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       mov  hl,@berk_script_pos        ; LD (35687),HL     ; ...and store at #R35687 (as current position in Berk's script data)
       bl   @cycle_attributes_long     ; CALL 53577        ; Cycle attributes (long, full-screen) and clear display buffers
       movb @bytes+127,a               ; LD A,127          ; Fill top 22 rows of Attribute File with white PAPER and white INK, BRIGHT...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .call @_47485                   ; CALL 47485        ; Decrease current time / lives by one if greater than zero and redraw Timer Figures
check_berk_killed_1:
       .endproc                        ; RET               ; Return

* Set Each Value in Primary Display Buffer Within Play Area to Zero
* 
* Used by the routine at #R34438.
clear_prim_disp_buf_area:
       .proc
       mov  @prim_disp_buffer_addr,hl  ; LD HL,(34279)     ; Load HL with start address of Primary Display Buffer
       li   bc,704                     ; LD BC,704         ; Set BC to 704, as there are 704 entries in a Display Buffer
       li   de,3                       ; LD DE,3           ; Load DE with 3 as each entry in the Display Buffer is three bytes wide
clear_prim_disp_buf_area_1:
       movb *hl,a                      ; LD A,(HL)         ; Read first byte in Display Buffer...
       ab   one,a                      ; INC A             ; ...and add one
       jeq  clear_prim_disp_buf_area_2 ; JP Z,53806        ; If value is now zero (i.e. was previously 255 and therefore outside normal play area), then
                                                           ; skip ahead to #R53806
       sb   a,a                        ; XOR A             ; Set all values in current entry to zero...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       movb a,*hl+                     ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       jmp  clear_prim_disp_buf_area_3 ; JP 53807          ; Skip ahead to #R53807
clear_prim_disp_buf_area_2:
       a    de,hl                      ; ADD HL,DE         ; Advance current position in Display Buffer to next entry
clear_prim_disp_buf_area_3:
       dec  bc                         ; DEC BC            ; Decrease remaining number of entries to process
                                       ; LD A,B            ; If remaining number of entries is not zero...
                                       ; OR C              ; ...
       jne  clear_prim_disp_buf_area_1 ; JP NZ,53791       ; ...then loop back to #R53791
       .endproc                        ; RET               ; Return

* Advance DE by 2xA Bytes and Load WORD at this Location into DE
* 
* Used by the routines at #R49010, #R51779 and #R53723. Input:  A  Index DE  Base address Output: DE  WORD value at
* DE (input) + 2 x A (input)
load_table_addr:
                                       ; PUSH HL           ; Store HL
       ab   a,a                        ; ADD A,A           ; Load HL with double index...
       clr  tmp0
       movb a,@r0lb                    ; LD L,A            ; ...
                                       ; LD H,0            ; ...
       a    de,tmp0                    ; ADD HL,DE         ; Add HL to DE as offset, in HL
       mov  *tmp0,de                   ; LD E,(HL)         ; Load address at HL into DE...
                                       ; INC HL            ; ...
                                       ; LD D,(HL)         ; ...
                                       ; POP HL            ; Restore HL
       rt                              ; RET               ; Return

* Copy Room Dimension Data Entry for Current Character / Entity's Current Room to Temporary Store Location (34230)
* 
* Used by the routines at #R34916 and #R53887. Input:  IX  (Entry at #R53848 only) Address of complex state data for
* an entity
copy_room_dim_data_to_tmp:
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  copy_room_dim_data_to_tmp_1 ; JR Z,53838        ; ...then skip ahead to #R53838
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       jmp  copy_room_dim_data_to_tmp_2 ; JR 53842          ; Skip ahead to #R53842
copy_room_dim_data_to_tmp_1:
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
copy_room_dim_data_to_tmp_2:
       movb *ix,@current_characters_room ; LD A,(IX+0)       ; Store current character's current room at 34218...
                                       ; LD (34218),A      ; ...
* This entry point is used by the routines at #R35689, #R37062, #R39278, #R51739, #R52837, #R53083, #R54480 and
* #R55525.
copy_room_dim_data_to_tmp_3:
       movb *ix,a                      ; LD A,(IX+0)       ; Load entity's current room into A
       sb   one,a                      ; DEC A             ; Subtract 1...
       movb a,@e                       ; LD E,A            ; ...and multiply by 5...
       ab   a,a                        ; ADD A,A           ; ...
       ab   a,a                        ; ADD A,A           ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@c                       ; LD C,A            ; Load into BC...
       sb   b,b                        ; LD B,0            ; ...
       mov  @room_dim_data,hl          ; LD HL,(34248)     ; Load start address of current level's room dimension data into HL...
       a    bc,hl                      ; ADD HL,BC         ; ...and add BC as offset
       mov  hl,@room_dim_data_addr     ; LD (34262),HL     ; Store HL at #R34262
       movb @bytes+5,@c                ; LD C,5            ; Set BC to 5 (as entries are 5 bytes wide)
       li   de,tmp_room_dim_data       ; LD DE,34230       ; Copy data entry in room dimension data for entity's current room to #R34230...
       .ldir                           ; LDIR              ; ...
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room into E...
       movb a,@e                       ; LD E,A            ; ...
       movb @tmp_room_dim_data+2,a     ; LD A,(34232)      ; Subtract position (chars) of right side of current room in A...
       sb   @e,a                       ; SUB E             ; ...
       ab   @bytes+100,a               ; ADD A,100         ; ...and add 100
       movb a,@_34235                  ; LD (34235),A      ; Store value (width of current room + 99) at #R34235
       rt                              ; RET               ; Return

* Paint Red Areas Outside Accessible Areas of Current Character's Current Room
* 
* Used by the routines at #R34438, #R34916, #R36616, #R48791, #R53723 and #R54456.
paint_red_areas:
       .proc
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .push ix                        ; PUSH IX           ; Store IX
       bl    @clear_display_buffers    ; CALL 53635        ; Clear Display Buffers 1 & 2
       .exx                            ; EXX               ; Switch registers
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       .exx                            ; EXX               ; Switch registers
       movb @tmp_room_dim_data+1,@l    ; LD HL,(34231)     ; For current character's current room, set H = room's right edge position and L = room's left
       movb @tmp_room_dim_data+2,h     ; edge position (chars)
       movb @tmp_room_dim_data+3,@e    ; LD DE,(34233)     ; For current character's current room, set D = room's bottom edge position and E = room's top
       movb @tmp_room_dim_data+4,d     ; edge position (chars)
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       sb   b,b                        ; LD B,0            ; Set initial y-coordinate (characters) to zero
paint_red_areas_1:
       movb b,a                        ; LD A,B            ; Load A with current y-coordinate
       cb   a,@e                       ; CP E              ; If y-coordinate of top of room is greater than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb d,a                        ; LD A,D            ; Load A with y-coordinate of bottom of room
       cb   a,b                        ; CP B              ; If y-coordinate of bottom of room is less than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb @bytes+0,@c                ; LD C,0            ; Set initial x-coordinate to zero
paint_red_areas_2:
       movb @c,a                       ; LD A,C            ; Load A with current x-coordinate
       cb   a,@l                       ; CP L              ; If x-coordinate of left of room is greater than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
       movb h,a                        ; LD A,H            ; Load A with x-coordinate of right of room
       cb   a,@c                       ; CP C              ; If x-coordinate of right of room is less than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
       .exx                            ; EXX               ; Switch registers
       bl   @print_red_cell_1          ; CALL 53977        ; Advance pointers in Display Buffers and Attribute File address to next character
       jmp  paint_red_areas_4          ; JR 53943          ; Skip ahead to #R53943
* Current x-coordinate, C, is outside range of x-coordinates spanned by room
paint_red_areas_3:
       bl   @print_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
paint_red_areas_4:
       ab   one,@c                     ; INC C             ; Advance C by one (move right one character)
       movb @c,tmp0                    ; BIT 5,C           ; If bit 5 is not set (x-coordinate has not reached 32)...
       andi tmp0,32*256                ;                   
       jeq  paint_red_areas_2          ; JR Z,53926        ; ...then loop back to #R53926
       jmp  paint_red_areas_7          ; JR 53959          ; Skip ahead to #R53959
* Current y-coordinate, B, is outside range of y-coordinates spanned by room
paint_red_areas_5:
       .push bc                        ; PUSH BC           ; Store BC (B = current y-coordinate, C = current x-coordinate)
       movb @bytes+32,b                ; LD B,32           ; Load counter with 32 (as there are 32 characters per row)
paint_red_areas_6:
       bl   @print_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
       sb   one,b                      ; DJNZ 53953        ; Loop back to #R53953 for next character block
       jne  paint_red_areas_6                     ;
       .pop bc                         ; POP BC            ; Restore BC (B = current y-coordinate, C = current x-coordinate)
paint_red_areas_7:
       ab   one,b                      ; INC B             ; Increase current y-coordinate by one
       movb b,a                        ; LD A,B            ; If y-coordinate has not reached 22...
       cb   a,@bytes+22                ; CP 22             ; ...
       jne  paint_red_areas_1          ; JR NZ,53916       ; ...then loop back to #R53916
       .pop ix                         ; POP IX            ; Restore IX
       .endproc                        ; RET               ; Return

* Print Red Cell to Current Attribute File Position (Outside Play Area) and Mark as Unused in Display Buffers
* 
* Used by the routine at #R53887. Input:  IX  Address of start of Attribute File (22528) HL'  Current position in
* display buffer 1 (at #R61312) DE'  Current position in display buffer 2 (at #R63424)
print_red_cell:
       .proc
;       movb @bytes+18,*ix              ; LD (IX+0),18      ; Set attribute to red INK, red PAPER
       li   a,18*256
       mov  ix,tmp0
       bl   @draw_attribute
       .exx                            ; EXX               ; Switch registers
       movb @bytes+255,a               ; LD A,255          ; Load 255 into current positions in Display Buffers 1 and 2...
       movb a,*hl                      ; LD (HL),A         ; ...
       movb a,*de                      ; LD (DE),A         ; ...
       jmp  !
* This entry point is used by the routine at #R53887.
print_red_cell_1:
       .proc
!      inct hl                         ; INC HL            ; Advance display buffer 1 pointer by three bytes to next entry...
                                       ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inct de                         ; INC DE            ; Advance display buffer 2 pointer by three bytes to next entry...
                                       ; INC DE            ; ...
       inc  de                         ; INC DE            ; ...
       .exx                            ; EXX               ; Switch registers
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return

* Reset Complex State Data for First Entity of Class A to that Stored in Initial-State Table at 59821
* 
* Used by the routines at #R37639 and #R48417. Input:  A  Entity class value IX  (Entry at #R53994 only) Address of
* complex state data for an entity
_53987:
       .call @_54019                   ; CALL 54019        ; Load IX with address of complex state data for first entry in current level that has class
                                                           ; A...
       .push iy                        ; PUSH IY           ; ...
       .pop ix                         ; POP IX            ; ...
* This entry point is used by the routine at #R42064.
_53994:
       li   iy,initial_entity_states   ; LD IY,59821       ; Point IY at start of Table of Initial-State Data for Complex Entities
       .call @_54023                   ; CALL 54023        ; Advance IY to first entry in copied complex state data that has class A
       .push ix                        ; PUSH IX           ; Store IX (address of entry in complex state data to overwrite)
       movb @e,b                       ; LD B,E            ; Load B with 13 (DE set to 13 in routine at #R54019)
_54004:
       movb *iy,a                      ; LD A,(IY+0)       ; Overwrite IX data entry with IY data...
       movb a,*ix+                     ; LD (IX+0),A       ; ...
                                       ; INC IX            ; ...
       inc  iy                         ; INC IY            ; ...
       sb   one,b                      ; DJNZ 54004        ; ...
       jne  _54004                     ;                   
       .pop ix                         ; POP IX            ; Restore IX (address of entry in complex state data just overwritten)
       .ret                            ; RET               ; Return

* Point IY at First Entry in Current Level's Complex State Data that has Class A
* 
* Used by the routines at #R36753 and #R53987. Input:  A  Value of an entity class Output: IY  Address of complex
* state data for first entity of class A
_54019:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
* This entry point is used by the routine at #R53987.
_54023:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
_54026:
       cb   a,@8(iy)                   ; CP (IY+8)         ; If current IY entity has class A...
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
       a    de,iy                      ; ADD IY,DE         ; Advance to entry for next entity
       jmp  _54026                     ; JR 54026          ; Loop back to #R54026

* Draw Contents of Primary Display Buffer to Display
* 
* If either the graphic index, or the graphic set index for the current entry in the Primary Display Buffer is zero,
* then only the attribute from that entry is rendered; the currently displayed bitmap data (from the previous frame)
* is preserved.
draw_display_buffer:
       .proc
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a                  ; LD A,(34271)      ; If "Display Buffer 2 is Primary" Flag is reset...
                                       ; OR A              ; ...i.e. Display Buffer 1 is Primary...
       jeq  draw_display_buffer_1      ; JP Z,54052        ; ...then skip ahead to #R54052
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
draw_display_buffer_1:
       mov de,iy                       ; PUSH DE           ; Copy address of Secondary Display Buffer into IY...
                                       ; POP IY            ; ...
draw_display_buffer_2:
       movb *hl+,a                     ; LD A,(HL)         ; Read Graphic Set Index from Primary Display Buffer into A
                                       ; INC HL            ; Advance HL to next byte (Graphic Index) in Primary Display Buffer
                                       ; OR A              ; If Graphic Set Index is zero...
       jeq  draw_display_buffer_8      ; JP Z,54130        ; ...then skip ahead to #R54130
       cb   a,@bytes+255               ; CP 255            ; If Graphic Set Index is 255 (character block outside room's dimensions)...
       jeq  draw_display_buffer_9      ; JP Z,54140        ; ...then skip ahead to #R54140
       movb a,b                        ; LD B,A            ; Transfer Graphic Set Index into B
       movb @bytes+0,@e                ; LD E,0            ; Set E to zero
       cb   a,*iy                      ; CP (IY+0)         ; If Graphic Set Index in Primary Display Buffer entry is different to Graphic Set Index in
                                                           ; Secondary Display Buffer entry...
       jne  draw_display_buffer_3      ; JP NZ,54076       ; ...then skip ahead to #R54076
       ab   one,@e                     ; INC E             ; Increase E
draw_display_buffer_3:
       movb *hl,a                      ; LD A,(HL)         ; Load Graphic Index from Primary Display Buffer
                                       ; OR A              ; If Graphic Index is zero...
       jeq  draw_display_buffer_8      ; JP Z,54130        ; ...then skip ahead to #R54130
       movb a,@c                       ; LD C,A            ; Transfer Graphic Index into C
       cb   a,@1(iy)                   ; CP (IY+1)         ; If Graphic Index in Primary Display Buffer is different to Graphic Index in Secondary Display
                                                           ; Buffer...
       jne  draw_display_buffer_4      ; JP NZ,54089       ; ...then skip ahead to #R54089
       ab   one,@e                     ; INC E             ; Increase E
draw_display_buffer_4:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Read attribute from Primary Display Buffer
       cb   a,@2(iy)                   ; CP (IY+2)         ; If attribute in Display Buffer entry A is different to attribute in Secondary Display Buffer
                                                           ; entry...
       jne  draw_display_buffer_5      ; JP NZ,54102       ; ...then skip ahead to #R54102
       movb @e,tmp0                    ; BIT 1,E           ; If E is 2 (i.e. both Graphic Set Index and Graphic Index are the same)...
       andi tmp0,2*256                 ;                   
       jne  draw_display_buffer_6      ; JP NZ,54107       ; ...then skip ahead to #R54107, over drawing instructions (no need to redraw what is already
                                                           ; there)
draw_display_buffer_5:
       .push hl                        ; PUSH HL           ; Store HL (pointer to current position in Primary Display Buffer)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
       .pop hl                         ; POP HL            ; Restore HL (pointer to current position in Primary Display Buffer)
draw_display_buffer_6:
       inc  hl                         ; INC HL            ; Advance HL to next byte in Primary Display Buffer (start of next entry)
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       mov ix,de                       ; PUSH IX           ; Copy current Attribute File address from IX to DE...
                                       ; POP DE            ; ...
       movb @e,a                       ; LD A,E            ; If current Attribute File address is not at the start of the seventh row of a third of the
                                                           ; display (i.e. row 7, 15 or 23)...
       cb   a,@bytes+192               ; CP 192            ; ...
       jne  draw_display_buffer_7      ; JR NZ,54122       ; ...then skip ahead to #R54122
       movb d,a                        ; LD A,D            ; If current Attribute File address is 23232 (256*90 + 192, i.e. at start of second last
                                                           ; display character row)...
       cb   a,@bytes+90                ; CP 90             ; ...
       jeq  draw_display_buffer_10      ; RET Z             ; ...then return, as only timer figures appear in last two rows
draw_display_buffer_7:
       li   de,3                       ; LD DE,3           ; Advance current position in Secondary Display Buffer by 3 bytes...
       a    de,iy                      ; ADD IY,DE         ; ...
       b    @draw_display_buffer_2     ; JP 54055          ; Loop back to #R54055
draw_display_buffer_8:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Load attribute into A
       socb @bits+6,a                  ; SET 6,A           ; Set BRIGHT flag
       mov  ix,tmp0                    ; LD (IX+0),A       ; Place attribute at current position in Attribute File
       bl   @draw_attribute
       jmp  draw_display_buffer_6      ; JP 54107          ; Loop back to #R54107
draw_display_buffer_9:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       jmp  draw_display_buffer_6      ; JP 54107          ; Loop back to #R54107
draw_display_buffer_10:
       .endproc
*// draw_display_buffer

* Draw a Graphic Character Block to Display
* 
* This routine uses the same technique as seen in the routine at #R47709 to convert from an Attribute File address
* to a Display File address. See the notes in #R47709 for more details. Input:  A  Attribute value (bit 7 is
* "mirror" flag, rather than FLASH) B  Graphic set index C  Graphic index IX  Address in Attribute File
draw_character_block:
       .proc
*      VDP address
       mov  ix,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
*      Graphics address
       mov  bc,tmp1
       srl  tmp1,8
       sla  tmp1,1
       mov  @graphic_sets_table(tmp1),hl
       mov  bc,tmp0
       andi tmp0,>00ff
       sla  tmp0,3
       a    tmp0,hl
*      Draw mirrored?
       socb @bits+6,a                  ; SET 6,A           ; Set Bright Flag
       jlt  draw_character_block_1
*      Draw normal block
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       movb *hl+,*tmp2
       jmp  draw_character_block_3
*      Draw mirrored
draw_character_block_1:
       clr  tmp1
       li   bc,8
draw_character_block_2:
       movb *hl+,@r1lb
       movb @byte_mirror_table(tmp1),*tmp2
       dec  bc
       jne  draw_character_block_2
*      Draw attribute
draw_character_block_3:
       mov  ix,tmp0
       bl   @draw_attribute
;       movb a,*ix                      ; LD (IX+0),A       ; Load attribute value into current Attribute File address
;       sb   a,a                        ; XOR A             ; Load graphic set index into HL..
;       movb b,@l                       ; LD L,B            ; ...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Double (as start address entries in table at #R27000 are two bytes wide)...
;       li   de,graphic_sets_table      ; LD DE,27000       ; ...and add as offset to #R27000 (in HL)...
;       a    de,hl                      ; ADD HL,DE         ; ...
;       movb *hl,@e                     ; LD E,(HL)         ; Load start address for this graphic set into DE...
;       inc  hl                         ; INC HL            ; ...
;       movb *hl,d                      ; LD D,(HL)         ; ...
;       movb @c,@l                      ; LD L,C            ; Load graphic index into HL...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Multiply by eight, as graphic blocks are eight bytes long...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    de,hl                      ; ADD HL,DE         ; Add to address of start of this graphic set as an offset in HL
;       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to required graphic data) and HL (now address of start of graphic set
;                                                           ; from table at #R27000)
;       .push ix                        ; PUSH IX           ; Switch Attribute File address into HL...
;       .pop hl                         ; POP HL            ; ...
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       ab   a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now Display File address) and HL (now pointer to graphic data)
;       movb *ix,tmp0                   ; BIT 7,(IX+0)      ; If mirror flag is set for Attribute File at current location...
;       andi tmp0,128*256               ;
;       jeq  !                          ; JP NZ,54194       ; ...then skip to #R54194 to draw mirrored version
;       b    @draw_mirrored_block       ;
;!
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54187:
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       movb a,*de                      ; LD (DE),A         ; ...and load into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 54187        ; Loop back for next row of pixels
;       jne  _54187                     ;
       .endproc                         ; RET               ; Return

* Draw Mirrored Graphic Character Block to Display File
* 
* Used by the routine at #R54144. Input:  HL  Address of bitmap data to draw IX  Address in Attribute File
;draw_mirrored_block:
;       szcb @bits+7,*ix                ; RES 7,(IX+0)      ; Reset Bit 7 (Mirror Flag, shared with FLASH flag so would cause graphic to flash)
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54200:
;       .push bc                        ; PUSH BC           ; Store BC (B = current counter value)
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       .push hl                        ; PUSH HL           ; Store HL (pointer to graphic data)
;       li   hl,byte_mirror_table       ; LD HL,27030       ; Point HL at mirror graphic lookup table
;       movb a,@c                       ; LD C,A            ; Load graphic "value" into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,hl                      ; ADD HL,BC         ; ...and add to HL as offset
;       movb *hl,a                      ; LD A,(HL)         ; Read byte at this location (mirror image of graphic data read by instruction at 54201)
;       .pop hl                         ; POP HL            ; Restore HL (pointer to graphic data)
;       movb a,*de                      ; LD (DE),A         ; Load (mirrored) graphic data into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       .pop bc                         ; POP BC            ; Restore BC (B = current counter value)
;       sb   one,b                      ; DJNZ 54200        ; Loop back for next row of pixels
;       jne  _54200                     ;
;       rt                               ; RET               ; Return

* Load A with a Pseudo-Random Number Between 0 and the Higher of 2 and A (Input)
* 
* This routine uses a linear congruential generator to generate a new pseudo-random number based upon a seed value.
* The seed value is stored at #R54219, is initially set to the value in the least significant byte of the system
* variable FRAMES, and subsequently set to the previously generated pseudo-random number. On entering this routine,
* the A register holds the range for the random number (e.g. 5 means this routine will generate a random number in
* the range 0-4 inclusive). A range of less than 2 is not allowed, so if A is less than this then it will be set to
* 2. Input:  A  Range Output: A  Generated random number
rnd_no:
       .proc
       cb   a,@bytes+2                 ; CP 2              ; If range is less than 2...
       jhe  rnd_no_1                   ; JP NC,54229       ; ...then set range to 2...
       movb @bytes+2,a                 ; LD A,2            ; ...
rnd_no_1:
       bl   @randl
;       movb a,@rnd_range               ; LD (54221),A      ; Store range at #R54211
;       .push hl                        ; PUSH HL           ; Store HL
;       .push de                        ; PUSH DE           ; Store DE
;       .push bc                        ; PUSH BC           ; Store BC
;       mov  @rnd_seed,de               ; LD DE,(54219)     ; Load DE with seed
;       movb @e,h                       ; LD H,E            ; Load least significant byte of random seed into H
;       movb @bytes+253,@l              ; LD L,253          ; Set L to 253
;       movb d,a                        ; LD A,D            ; Load most significant byte (MSB) of random seed into A
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (256 * seed + 253)
;                                       ; OR A              ; Reset carry flag
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (254 * seed + 253)
;       movb a,@e                       ; LD E,A            ; Calculate (AHL mod 65,537)...
;       movb @bytes+0,d                 ; LD D,0            ; ...loading result into HL...
;       s    de,hl                      ; SBC HL,DE         ; ...
;       joc  !                          ; JP NC,54261       ; ...and if this is negative...
;       b    @rnd_no_2                  ;
;!
;       inc  hl                         ; INC HL            ; ...then add one (as zero in HL can represent both zero and 65,536)
;rnd_no_2:
;       mov  hl,@rnd_seed               ; LD (54219),HL     ; Store HL (new seed) at #R54219
;* At this point, HL contains a new pseudo-random 16-bit number
;       .push hl                        ; PUSH HL           ; Copy 16-bit pseudo-random number from HL into DE...
;       .pop de                         ; POP DE            ; ...
;       movb @rnd_range,a               ; LD A,(54221)      ; Load A with range as stored previously
;       sb   one,a                      ; DEC A             ; Decrease range by 1 to get maximum value as we want the output to range from 0 to (A-1)...
;       movb a,b                        ; LD B,A            ; ...and load into B (loop counter)
;* In the following loop we are obtaining the number of times that 65,536 goes into RANGE x DE. In other words,
;* (RANGE x DE) is divided by 65,536 and the integer part of the result is loaded into A. A is therefore limited to
;* values between zero, and the value A had on entering this routine minus one, inclusive.
;       sb   a,a                        ; XOR A             ; Set A to zero
;rnd_no_3:
;       a    de,hl                      ; ADD HL,DE         ; Add DE to HL
;       joc  !                          ; JP NC,54277       ; If DE has not crossed the 65,535 - 0 boundary then skip ahead to #R54277
;       b    @rnd_no_4                  ;
;!
;       ab   one,a                      ; INC A             ; Increase A (count of number of times DE rolls over from 65,535 to 0)
;rnd_no_4:
;       sb   one,b                      ; DJNZ 54272        ; Decrease B and loop back to #R54272
;       jne  rnd_no_3                   ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop de                         ; POP DE            ; Restore DE
;       .pop hl                         ; POP HL            ; Restore HL
       .endproc                         ; RET               ; Return

* Move Entity at IX into New Room (Left or Right) if it is at the Edge of its Current Room
* 
* Used by the routines at #R35735 and #R55041. Input:  IX  Address of complex state data for an entity
move_into_new_room:
       .proc
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 97...
       sb   one,a                      ; DEC A             ; ...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of left side (+100) of entity is greater than this...
       jl   _54306                     ; JR C,54306        ; ...then skip ahead to #R54306
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of right side (+100) of entity is not less than 102...
       cb   a,@bytes+102               ; CP 102            ; ...
       jhe  move_into_new_room_1       ; RET NC            ; ...then return
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       jmp  move_into_new_room_1       ; RET               ; Return
_54306:
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
move_into_new_room_1:
       .endproc                        ; RET               ; Return

* Move Entity at IX into Room to the Right, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading side (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading side crosses the boundary.
* This routine (along with its counterpart at #R54348) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the right, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_right_room:
       .proc
       movb @_34235,a                  ; LD A,(34235)      ; Load C with width of entity's current room (chars) + 99...
       movb a,@c                       ; LD C,A            ; ...
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  move_into_right_room_1     ; JR Z,54329        ; ...then skip ahead to #R54329
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of Drutt's left edge
       jmp  move_into_right_room_2     ; JR 54332          ; Skip ahead to #R54332
move_into_right_room_1:
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right edge
move_into_right_room_2:
       cb   a,@c                       ; CP C              ; If x-coordinate of room's right edge is greater than x-coordinate in A...
       jl   move_into_right_room_3     ; RET C             ; ...then return
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       jeq  move_into_right_room_4     ; JR Z,54381        ; If there is no room to the right, then jump to #R54381
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
       bl   @chk_coll_right            ; CALL 54569        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  move_into_right_room_4     ; JR NC,54381       ; ...and if a collision occurred, then jump to #R54381
move_into_right_room_3:
       b    @return_with_carry         ; RET               ; Return
move_into_right_room_4:
       sb   a,a
       b    @return_without_carry

* Move Entity at IX into Room to the Left, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading edge (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading edge crosses the boundary.
* This routine (along with its counterpart at #R54313) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the left, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_left_room:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  move_into_left_room_1      ; JR Z,54363        ; ...then skip ahead to #R54363
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Drutt's right edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
       jmp  move_into_left_room_2      ; JR 54369          ; Skip ahead to #R54369
move_into_left_room_1:
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Berk's left edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
move_into_left_room_2:
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       jeq  move_into_left_room_4      ; JR Z,54381        ; If there is no room to the left, then jump to #R54381
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       bl    @chk_coll_left            ; CALL 54666        ; Set Carry Flag if entity at IX has not collided with another impassable / pushable entity
                                                           ; immediately to the left, reset otherwise
move_into_left_room_3:
       bl   @return_with_carry         ; RET               ; Return
move_into_left_room_4:
       sb   a,a                        ; XOR A             ; Set A to zero
       bl   @return_without_carry      ; RET               ; Return

* Move Entity at IX into Room to Right of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48593, #R54283 and #R54313. Input:  IX  Address of complex state data for an entity
do_move_into_right_room:
       .proc
       .call @_54398                   ; CALL 54398        ; Set character's position to be left-hand side of new room to right
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;                   
       jne  do_move_into_right_room_1  ; RET NZ            ; ...then return
       .call @_48727                   ; CALL 48727        ; If entity is Berk then move carried entity to Berk's right as he faces right
do_move_into_right_room_1:
       .endproc                        ; RET               ; Return

* Set Entity's Position to be Left-Hand Side of New Room to Right
* 
* Used by the routine at #R54383. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
_54398:
       movb @_34235,a                  ; LD A,(34235)      ; Load D with i.e. x-coordinate of right edge of room (width of current room (chars) + 99)
                                                           ; minus x-coordinate of right-edge of current character...
       sb   @7(ix),a                   ; SUB (IX+7)        ; ...(i.e. [negative] distance by which entity's right edge is to the right of right edge of
                                                           ; room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @bytes+99,a                ; LD A,99           ; Load A with x-coordinate of left edge of current (new) room
       sb   d,a                        ; SUB D             ; Subtract D (negative)...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as new x-coordinate of entity's right edge
       sb   @e,a                       ; SUB E             ; Subtract (width - 1) of entity...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set this as x-coordinate of entity's left edge
       .ret                            ; RET               ; Return

* Move Entity at IX into Room to Left of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48641, #R54283 and #R54348.
do_move_into_left_room:
       .proc
       .call @_54434                   ; CALL 54434        ; Set entity's position to be right-hand side of new room to left
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;                   
       jne  do_move_into_left_room_1   ; RET NZ            ; ...then return
       .call @_48738                   ; CALL 48738        ; If entity is Berk then move carried entity to Berk's left as he faces left
do_move_into_left_room_1:
       .endproc                        ; RET               ; Return

* Set Entity's Position to be Right-Hand Side of New Room to Left
* 
* Used by the routine at #R54419. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
_54434:
       movb @bytes+100,a               ; LD A,100          ; Load D with x-coordinate of left edge of room minus x-coordinate of left edge of current
                                                           ; entity...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...(i.e. distance by which entity's left edge is to the left of left edge of room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @_34235,a                  ; LD A,(34235)      ; Load A with width of current (new) room (chars) + 99
       sb   d,a                        ; SUB D             ; Subtract D...
       ab   one,a                      ; INC A             ; ...and add one to get x-coordinate of entity's left edge in new room
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set entity's left edge to this position
       ab   @e,a                       ; ADD A,E           ; Add (width - 1) of entity...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set this as x-coordinate of entity's right edge
       .ret                            ; RET               ; Return

* Paint Red Areas Outside Current Character's Room if IX Points to Current Character's Complex State Data
* 
* Used by the routines at #R54383, #R54419, #R55433 and #R55616. Input:  IX  Address of complex state data for an
* entity
paint_red_areas_char:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; Set Zero Flag if Drutt Mode Flag is reset...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       movb @8(ix),a                   ; LD A,(IX+8)       ; Load Entity Class Value of entity at IX into A
       mov  tmp0,tmp0
       jne  paint_red_areas_char_1     ; JR NZ,54471       ; If Zero Flag is reset (i.e. Drutt Mode) then skip ahead to #R54471
       cb   a,@bytes+31                ; CP 31             ; If Entity Class is 31 (i.e. Berk)...
       jeq  paint_red_areas_char_2     ; JR Z,54474        ; ...then paint red areas outside accessible areas of current character's current room and
                                                           ; return
       jmp  paint_red_areas_char_3     ; RET               ; Return
paint_red_areas_char_1:
       cb   a,@bytes+18                ; CP 18             ; If Entity Class is not 18 (i.e. Drutt)...
       jne  paint_red_areas_char_3     ; RET NZ            ; ...then return
paint_red_areas_char_2:
       .push hl                        ; PUSH HL           ; Store HL
       bl @paint_red_areas             ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
paint_red_areas_char_3:
       .endproc                        ; RET               ; Return

* Set Room of Entity at IX to B, Store Room Size Data for New Room and Load E with Entity's Width Minus One
* 
* Used by the routines at #R54398, #R54434, #R55433 and #R55616. Input:  B  Destination room index IX  Address of
* complex state data for an entity Output: E  Entity's width, minus one (characters)
set_room_of_entity:
       .proc
       movb b,a                        ; LD A,B            ; Set entity's current room to be destination room...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       .push hl                        ; PUSH HL           ; Store HL
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for entity's current room
       .pop de                         ; POP DE            ; Restore DE
       .pop hl                         ; POP HL            ; Restore HL
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of entity's right...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...subtract x-coordinate of entity's left...
       movb a,@e                       ; LD E,A            ; ...and load result (entity's width minus one) into E
       .endproc                        ; RET               ; Return

* Unused routine
* 
* This routine is not used. It is assumed, since this routine flows into the routine at #R54505, that this unused
* routine was also intended to deal with room connectivity. As there are routines to deal with vertical and
* horizontal (left-right) connectivity, it is possible that this routine was originally intended to handle
* horizontal (forward-back) connectivity.
;_54499:
;       mov  @_34252,iy                 ; LD IY,(34252)     ; Load IY with address of Unused Data Block (09)
;       jmp  get_right_room_index_2                     ; JR 54512          ; Load B with index of room, as related to room of index D via data in Unused Data Block (09)

* Load B with Index of Room to Right of an Entity's Current Room
* 
* Used by the routines at #R48593, #R52193, #R54283 and #R54313. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54512 only) An entry in a room connectivity table D  (entry at #R54508 and #R54512 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the right, reset otherwise
get_right_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_right_room_index_1:
       mov  @_34250,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
* This entry point is used by the routine at #R54499.
get_right_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (left room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_right_room_index_3     ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  _54527                     ; JR NZ,54527       ; ...then skip ahead to #R54527
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (right room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_right_room_index_3     ; RET               ; Return
_54527:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_right_room_index_2                         ; JR 54512          ; Loop back to #R54512
get_right_room_index_3:
       rt

* Unused routine
* 
* This routine is not used. It is assumed, since this routine flows into the routine at #R54539, that this unused
* routine was also intended to deal with room connectivity. As there are routines to deal with vertical and
* horizontal (left-right) connectivity, it is possible that this routine was originally intended to handle
* horizontal (forward-back) connectivity.
;_54533:
;       mov  @_34252,iy                 ; LD IY,(34252)     ; Load IY with address of Unused Data Block (09)
;       jmp  get_left_room_index_0      ; JR 54546          ; Load B with index of room, as related to room of index D via data in Unused Data Block (09)

* Load B with Index of Room to Left of an Entity's Current Room
* 
* Used by the routines at #R48641, #R52098, #R54283 and #R54348. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54546 only) An entry in a room connectivity table D  (entry at #R54542 and #R54546 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the left, reset otherwise
get_left_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_left_room_index_1:
       mov  @_34250,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
       movb @bytes+255,b                                   ; Init result to not found
* This entry point is used by the routine at #R54533.
get_left_room_index_0:
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (right room index) of first entry
get_left_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (right room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_left_room_index_4      ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  get_left_room_index_3      ; JR NZ,54563       ; ...then skip ahead to #R54563
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (left room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_left_room_index_4      ; RET               ; Return
get_left_room_index_3:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_left_room_index_2                          ; JR 54548          ; Loop back to #R54548
get_left_room_index_4:
       rt

* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Right
* 
* Used by the routines at #R36116, #R52148, #R52193, #R52889, #R52914, #R54313 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_right:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_right_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_right_2           ; JR NZ,54585       ; ...then skip ahead to #R54585
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_right_2:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_right_4           ; JP NZ,54662       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_right_4           ; JR Z,54662        ; ...then advance IY to next entity
       movb a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128*256               ;                   
       jne  chk_coll_right_3           ; JR NZ,54620       ; ...then skip over depth check to #R54620
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
chk_coll_right_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Rightwards" Flag reset...
       andi a,32*256                   ; AND 32            ; ...
       jeq  chk_coll_right_4           ; JP Z,54662        ; ...then advance IY to next entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity at IX...
       ab   one,a                      ; INC A             ; ...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is not immediately to the left of the left side of the entity at IY...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_right_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_right_1           ; JR 54576          ; Loop back to #R54576

* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Left
* 
* Used by the routines at #R36116, #R52053, #R52098, #R52870, #R52914, #R54348 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_left:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_left_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_left_2            ; JR NZ,54682       ; ...then skip ahead to #R54682
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_left_2:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_left_4            ; JP NZ,54760       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       movb a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128*256               ;                   
       jne  chk_coll_left_3            ; JR NZ,54718       ; ...then skip over depth check to #R54620
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
chk_coll_left_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Leftwards" Flag reset...
       andi a,16*256                   ; AND 16            ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       movb @5(ix),a                   ; LD A,(IX+5)       ; If the left side of entity at IX...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...is not immediately to the right of the right side of the entity at IY...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_left_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_left_1            ; JR 54673          ; Loop back to #R54673

* Check Entity at IX for Collision With Another Entity at Next Depth Level Out Of Screen Whose Interaction (11,6)
* Flag is Set
* 
* Used by the routines at #R37639 and #R52315. Input:  IX  Address of complex state data for an entity Output: F
* Carry Flag set if no entity found, reset otherwise A  Class of entity, if found, otherwise 255 IY  Address of
* complex state data for colliding entity
chk_coll_next_depth:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level out of screen)
       jmp  chk_coll_same_depth_1      ; JR 54770          ; Jump to collision detection routine

* Check Entity at IX for Collision With Another Entity at Same Depth Whose Interaction (11,6) Flag is Set
* 
* Used by the routines at #R36036, #R36542, #R37085, #R38074, #R38219, #R38540, #R38592, #R41498, #R41633, #R41961,
* #R42064, #R42266, #R42486, #R48487, #R51779, #R53083, #R55196 and #R55525. Input:  IX  Address of complex state
* data for an entity C  (Entry at #R54770 only) Depth offset Output: F  Carry Flag set if no entity found, reset
* otherwise A  Class of entity, if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_same_depth:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
* This entry point is used by the routine at #R54764.
chk_coll_same_depth_1:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
chk_coll_same_depth_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_same_depth_3      ; JR NZ,54786       ; ...then skip ahead to #R54786
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return
chk_coll_same_depth_3:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  chk_coll_same_depth_6      ; JR NZ,54874       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jeq  !                          ; JP NZ,54874       ; ...then advance IY to next entity
       b    @chk_coll_same_depth_6     ;
!
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_same_depth_6      ; JR Z,54874        ; ...then advance IY to next entity
       movb a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128*256               ;                   
       jne  chk_coll_same_depth_4          ; JR NZ,54822       ; ...then skip over depth check to #R54822
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       ab   @c,a                       ; ADD A,C           ; ...plus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_same_depth_6 ; JR NZ,54874       ; ...then advance IY to next entity
chk_coll_same_depth_4:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,6) Flag reset...
       andi a,64*256                   ; AND 64            ; ...
       jne  !                          ; JP Z,54874        ; ...then advance IY to next entity
       b    @chk_coll_same_depth_6     ;
!
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
* This entry point is used by the routines at #R55196 and #R55525.
chk_coll_same_depth_5:
       li   de,13                      ; LD DE,13          ; Load DE with 13, as entries in complex state data are 13 bytes wide
chk_coll_same_depth_6:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_same_depth_2      ; JR 54777          ; Loop back to #R54777

* Check Entity at IX for Collision With Another Entity (Only those Defined Before, and in Reverse Order) at Same
* Depth Level Whose Interaction (11,7) Flag is Set
* 
* Used by the routine at #R52315. Input:  IX  Address of complex state data for an entity Output: F  Carry Flag set
* if no entity found, reset otherwise A  Class of entity, if found, otherwise 254 IY  Address of complex state data
* for colliding entity
chk_coll_same_depth_rev:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
       mov  ix,iy                      ; PUSH IX           ; Load IY with address in IX...
                                       ; POP IY            ; ...
       li   de,-13                     ; LD DE,65523       ; Load DE with -13
       jmp  chk_coll_next_depth_rev_3  ; JP 54987          ; Move IY back to previous entity in complex state data and jump into collision check routine

* Check Entity at IX for Collision With Another Entity (in Reverse Order) at Next Depth Level Into Screen Whose
* Interaction (11,7) Flag is Set
* 
* The address stored at #R34246 is the address of complex state data for the entity to start with when doing
* collision checks in reverse order. On levels 2, 3 and 4, the value stored here is the address of the complex state
* data of the last entity, which means that on these levels, all entities are checked. On Level 1, however, the
* value stored is the address of the complex state data of the sixth-last entity. The remaining five entities after
* this address on Level 1 are the three spiders, their webs and their arches. This means that on Level 1, these
* spiders, webs and arches are excluded from certain collision checks. Input:  IX  Address of complex state data for
* an entity C  (Entry at #R54899 only) Depth offset Output: F  Carry Flag set if no entity found, reset otherwise A
* Class of entity, if found, otherwise 254 IY  Address of complex state data for colliding entity
chk_coll_next_depth_rev:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level into screen)
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (as entries in complex state data are 13 bytes wide)
       mov  @_34246,iy                 ; LD IY,(34246)     ; Load IY with current level's start address for reverse-order collision checks
chk_coll_next_depth_rev_1:
       movb *ix,a                      ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   a,*iy                      ; CP (IY+0)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_next_depth_rev_3  ; JP NZ,54987       ; ...then move IY back to previous entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_next_depth_rev_3  ; JR Z,54987        ; ...then move IY back to previous entity
       movb a,tmp0                     ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       andi tmp0,128*256               ;                   
       jne  chk_coll_next_depth_rev_2  ; JR NZ,54935       ; ...then skip over depth check to #R54935
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       sb   @c,a                       ; SUB C             ; ...minus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
chk_coll_next_depth_rev_2:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,7) Flag reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  chk_coll_next_depth_rev_3  ; JP Z,54987        ; ...then move IY back to previous entity
       movb @6(ix),a                   ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   a,@4(iy)                   ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
       movb @6(iy),a                   ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
       movb @7(iy),a                   ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
       sb   a,a                        ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (?)
* This entry point is used by the routine at #R54878.
chk_coll_next_depth_rev_3:
       movb @-1(iy),a                  ; LD A,(IY-1)       ; If byte before current IY position is 254 (i.e. end marker for simple state data)...
       cb   a,@bytes+254               ; CP 254            ; ...
       jeq  chk_coll_next_depth_rev_4  ; JP Z,55000        ; ...then skip ahead to #R55000
       a    de,iy                      ; ADD IY,DE         ; Move IY back 13 bytes (i.e. to start of previous entry)
       b    @chk_coll_next_depth_rev_1 ; JP 54899          ; Jump to #R54899
chk_coll_next_depth_rev_4:
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return

* Unused routine
* 
* This routine seems to be involved with the relative positioning of two different entities, assuming that IX
* contains a complex state data address.
;       mov  @_34258,iy                 ; LD IY,(34258)     ; Load IY with address of complex state data for entity involved in last collision check
;       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of this entity, minus one...
;       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
;       srl  a,1                        ; SRL A             ; Divide result by two, clearing remainder...
;       sb   one,a                      ; DEC A             ; ...and subtract one
;       ab   @5(iy),a                   ; ADD A,(IY+5)      ; Add x-coordinate of entity's left edge
;       cb   a,@5(ix)                   ; CP (IX+5)         ; 
;       .ret                            ; RET               ; Return

* Handle Drutt's Jump, and Load E with Jump State Index As Appropriate
* 
* See description of routine at #R55041 for details. Output: E  (via routine at #R55041) Jump state index (see
* #R55041)
_55023:
       mov  @drutt_state_addr,ix                 ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       movb @12(ix),tmp0               ; BIT 7,(IX+12)     ; If Drutt's Is Jumping Flag is reset...
       andi tmp0,128*256               ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
* Drutt's Is Jumping Flag is set
       movb @game_flags,a                  ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  _55065                     ; JR Z,55065        ; ...then handle Drutt's jump, and load E with jump state index as appropriate based upon no
                                                           ; control input
       jmp  _55060                     ; JR 55060          ; Handle Drutt's jump, and load E with jump state index as appropriate based upon current
                                                           ; control input

* Handle Berk's Jump, and Load E with Jump State Index As Appropriate
* 
* This routine updates the position, direction and velocity of a jumping character (Berk if entry at #R55041 or
* Drutt if entry via routine at #R55023) based upon various conditions (control input, collisions with obstructions
* and the character's current position, direction and velocity). Register E is loaded (either by this routine, or
* the CALLed routine at #R55196) with a value determined by these conditions. The value in E in turn determines how
* the character's jump will progress. A given numeric value may result from more than one set of conditions.
* Possible output values in E are: Input:  IX  Address of complex state data (current level) for Berk (entry via
* #R55041) or Drutt (entry via #R55060 and #R55065) Output: E  Jump state index (see table above)
_55041:
       bl   @move_into_new_room        ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       movb @12(ix),tmp0               ; BIT 7,(IX+12)     ; If Berk's Is Jumping Flag is reset...
       andi tmp0,128*256               ;                   
       jne  !                          ; RET Z             ; ...then return
       .ret                            ;                   
!
* Berk's Is Jumping Flag is set
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is set...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jne  _55065                     ; JR NZ,55065       ; ...then skip ahead to #R55065
* From this point onwards, IX points to either Berk's complex state data (entry via #R55041) or Drutt's complex
* state data (entry via #R55060 or #R55065). This entry point is used by the routine at #R55023.
_55060:
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       jmp  _55066                     ; JR 55066          ; Skip ahead to #R55066
* This entry point is used by the routine at #R55023.
_55065:
       sb   a,a                        ; XOR A             ; Load A with zero
_55066:
       movb a,@cached_control_input                  ; LD (55022),A      ; Store value in A at #R55022
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If jumper's Walking Right Flag is reset...
       andi tmp0,1*256                 ;                   
       jeq  _55128                     ; JR Z,55128        ; ...then skip ahead to #R55128
* Walking Right Flag is set
       movb @bytes+2,b                 ; LD B,2            ; Load B with 2 (as Berk and Drutt jump right by two characters)
_55077:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of characters to move)
       bl   @chk_coll_right            ; CALL 54569        ; Check jumper for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       joc  _55108                     ; JR C,55108        ; ...and if a collision has not occurred, then skip ahead to #R55108
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class less than 22 (can be picked up)...
       jl   _55108                     ; JR C,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55108                     ; JR Z,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _55108                     ; JR Z,55108        ; ...then skip ahead to #R55108
       cb   a,@bytes+159               ; CP 159            ; If collision was not with entity of class 159 (Berk floating)...
       jne  _55124                     ; JR NZ,55124       ; ...then skip ahead to #R55124
* Collision with Berk, floating
       movb @bytes+241,@11(iy)         ; LD (IY+11),241    ; Set Berk's Walking Right, Impassable Leftwards, Impassable Rightwards, Interaction (11,6)
                                                           ; and Interaction (11,7) flags and reset his Walking Left, Unused (11,2) and Unused (11,3)
                                                           ; flags
       .call @_55187                   ; CALL 55187        ; Set Character Swap Pending Flag
       jmp  _55124                     ; JR 55124          ; Skip ahead to #R55124
* No collision, or collision with entity of class 50, 129 or less than 22
_55108:
       bl   @move_into_right_room      ; CALL 54313        ; Move jumper into room to the right, if appropriate...
       jnc  _55124                     ; JR NC,55124       ; ...and if jumper can't enter new room then skip ahead to #R55124
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move jumper right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       sb   one,b                      ; DJNZ 55077        ; Decrease remaining number of characters to move, and if not zero, loop back to #R55077
       jne  _55077                     ;                   
       jmp  _55196                     ; JR 55196          ; Handle vertical component of jumper's jump, load E with Jump State Index and return
* Collision with other class of entity
_55124:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       movb @bytes+4,@e                ; LD E,4            ; Load E with 4 (jumper has bounced off an obstruction to the right while jumping right)
       .ret                            ; RET               ; Return
* Walking Right Flag is reset
_55128:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If jumper's Walking Left Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  _55196                     ; JR Z,55196        ; ...then skip ahead to #R55196 (handle vertical component of jumper's jump, load E with Jump
                                                           ; State Index and return)
* Walking Left Flag is set
       movb @bytes+2,b                 ; LD B,2            ; Load B with 2 (as Berk and Drutt jump left by two characters)
_55136:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of characters to move)
       bl    @chk_coll_left            ; CALL 54666        ; Check jumper for collision with another impassable / pushable entity immediately to the
                                                           ; left...
       joc  _55167                     ; JR C,55167        ; ...and if a collision has not occurred, then skip ahead to #R55167
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class less than 22 (can be picked up)...
       jl   _55167                     ; JR C,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55167                     ; JR Z,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  _55167                     ; JR Z,55167        ; ...then skip ahead to #R55167
       cb   a,@bytes+159               ; CP 159            ; If collision was not with entity of class 159 (Berk floating)...
       jne  _55183                     ; JR NZ,55183       ; ...then skip ahead to #R55183
* Collision with Berk, floating
       movb @bytes+242,@11(iy)         ; LD (IY+11),242    ; Set Berk's Walking Left, Impassable Leftwards, Impassable Rightwards, Interaction (11,6) and
                                                           ; Interaction (11,7) flags and reset his Walking Right and Unused (11,2) and Unused (11,3)
                                                           ; flags
       .call @_55187                   ; CALL 55187        ; Set Character Swap Pending Flag
       jmp  _55183                     ; JR 55183          ; Skip ahead to #R55183
* No collision, or collision with entity of class 50, 129 or less than 22
_55167:
       bl   @move_into_left_room       ; CALL 54348        ; Move jumper into room to the left, if appropriate...
       jnc  _55183                     ; JR NC,55183       ; ...and if jumper can't enter new room then skip ahead to #R55183
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move jumper left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       sb   one,b                      ; DJNZ 55136        ; Decrease remaining number of characters to move, and if not zero, loop back to #R55136
       jne  _55136                     ;                   
       jmp  _55196                     ; JR 55196          ; Handle vertical component of jumper's jump, load E with Jump State Index and return
* Collision with other class of entity
_55183:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of characters to move)
       movb @bytes+5,@e                ; LD E,5            ; Load E with 5 (jumper has bounced off an obstruction to the left while jumping left)
       .ret                            ; RET               ; Return

* Set Character Swap Pending Flag
* 
* Used by the routine at #R55041.
_55187:
       movb @game_flags,a              ; LD A,(34208)      ; Set Character Swap Pending Flag...
       socb @bits+6,a                  ; SET 6,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       .ret                            ; RET               ; Return

* Handle Vertical Component of Character's Jump, and Load E with Jump State Index As Appropriate
* 
* This routine handles the vertical component of Berk's or Drutt's jumping, checking for collisions (e.g. Berk or
* Drutt hitting an obstruction above, or Drutt knocking down an entity such as a key). The routine also checks the
* cached control input value at #R55022 to determine the outcome of the next "bounce" if the jumper is on the floor
* (for example, start a leftward jump if left was pressed). Input:  IX  Address of complex state data (current
* level) for Berk or Drutt Output: E  Jump state index (see table in description of routine at #R55041)
_55196:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load A with current velocity of jumper's jump...
       andi a,15*256                   ; AND 15            ; ...
       movb @12(ix),tmp0               ; BIT 6,(IX+12)     ; If Downward Jump Phase Flag is set...
       andi tmp0,64*256                ;                   
       jne  _55281                     ; JR NZ,55281       ; ...then skip ahead to #R55281
* Downward Jump Phase Flag is reset, i.e. in upward phase of jump
       socb a,a                        ; OR A              ; If current velocity of jumper's jump is at least one...
       jne  _55234                     ; JR NZ,55234       ; ...then skip ahead to #R55234
* Current velocity of jumper's jump is zero
       movb @cached_control_input,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       movb a,tmp0                     ; BIT 3,A           ; ...and if Back Bit is reset...
       andi tmp0,8*256                 ;                   
       jeq  _55223                     ; JR Z,55223        ; ...then skip ahead to #R55223
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move jumper up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
_55223:
       socb @bits+6,@12(ix)            ; SET 6,(IX+12)     ; Set Downward Jump Phase Flag
       .call @_55421                   ; CALL 55421        ; Increase current velocity of jumper's jump if less than 7
       movb one,a                      ; LD A,1            ; Prepare to set velocity of jumper's jump to one, downwards
       jmp  _55284                     ; JR 55284          ; Skip ahead to #R55284 (handle downward phase of jump)
* Current velocity of jumper's jump is at least 1
_55234:
       movb a,b                        ; LD B,A            ; Load B with current velocity of jumper's jump
_55235:
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move jumper up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  _55258                     ; JR C,55258        ; ...and if no collision occurred, then skip ahead to #R55258
       cb   a,@bytes+130               ; CP 130            ; If collision was not with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jne  _55258                     ; JR NZ,55258       ; ...then skip ahead to #R55258
* Jumper has banged his head
       movb @bytes+6,a                 ; LD A,6            ; Set pending sound index to 6 (banging head) if it is currently zero, or lower priority...
       .call @request_sound            ; CALL 59613        ; ...
       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 (jumper has banged his head on something above him)
       .ret                            ; RET               ; Return
* No collision, or collision with entity other than that of class 130
_55258:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up, or 255 for no
                                                           ; collision)...
       jhe  _55270                     ; JR NC,55270       ; ...then skip ahead to #R55270
* Drutt has knocked down an entity, e.g. Red Sweet on Level 1
       movb @bytes+2,@12(iy)           ; LD (IY+12),2      ; Set initial velocity factor of entity jumper collided with to 2...
       socb @bits+6,@10(iy)            ; SET 6,(IY+10)     ; ...and set its "Can Fall" flag
_55270:
       .call @change_room_up                   ; CALL 55433        ; Change jumper's room up one if appropriate
       sb   one,b                      ; DJNZ 55235        ; Decrease B (remaining number of characters to move up) and loop back to #R55235 if not zero
       jne  _55235                     ;                   
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease current velocity of jumper's jump, slowing ascent
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (jumper jumping upwards, no collision)
       .ret                            ; RET               ; Return
* Downward Jump Phase Flag is set, i.e. in downward phase of jump
_55281:
       .call @_55421                   ; CALL 55421        ; Increase current velocity of jumper's jump if less than 7, speeding descent, and load into A
_55284:
       movb a,b                        ; LD B,A            ; Load B with velocity of jumper's jump
_55285:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move jumper down one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check jumper for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
       joc  _55300                     ; JR C,55300        ; ...and if no collision occurred, then skip ahead to #R55300
       cb   a,@bytes+35                ; CP 35             ; If collision was with an entity of class 35 (platform, Level 1 or Level 3)...
       jeq  _55363                     ; JR Z,55363        ; ...then skip ahead to #R55363
* No collision, or collision with entity other than that of class 35
_55300:
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load A with y-coordinate of jumper's bottom edge...
       ab   @1(ix),a                   ; ADD A,(IX+1)      ; ...and add jumper's depth
       cb   a,@bytes+122               ; CP 122            ; If A is 122 (i.e. jumper is at bottom of screen)...
       jeq  _55320                     ; JR Z,55320        ; ...then skip ahead to #R55320
       sb   one,b                      ; DJNZ 55285        ; Decrease B (remaining number of characters to move down) and loop back to #R55285 if not zero
       jne  _55285                     ;                   
       .push hl                        ; PUSH HL           ; Store HL
       .call @change_room_down                   ; CALL 55616        ; Change jumper's room down one if appropriate
       .pop hl                         ; POP HL            ; Restore HL
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (jumper jumping downwards, no collision)
       .ret                            ; RET               ; Return
* Jumper is at the bottom of the screen
_55320:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check jumper for collision with another entity at same depth whose Interaction (11,6) Flag is
                                                           ; set...
_55323:
       joc  _55363                     ; JR C,55363        ; ...and if no collision occurred, then skip ahead to #R55363
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55334                     ; JR Z,55334        ; ...then skip ahead to #R55334
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that jumper did collide with
       bl  @chk_coll_same_depth_5      ; CALL 54871        ; Resume checking jumper for collision with another entity at same depth whose Interaction
                                                           ; (11,6) Flag is set
       jmp  _55323                     ; JR 55323          ; ...and jump back to #R55323
* Collision with entity of class 129
_55334:
       movb @8(ix),a                   ; LD A,(IX+8)       ; If jumper is not Berk...
       cb   a,@bytes+31                ; CP 31             ; ...(class = 31).....
       jne  _55285                     ; JR NZ,55285       ; ...then jump back to #R55285 (continue moving downwards)
       movb @5(ix),a                   ; LD A,(IX+5)       ; If Berk's left edge...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is at or to the right of the colliding entity's left edge...
       jhe  _55352                     ; JR NC,55352       ; ...then skip ahead to #R55352
* Berk's left edge is to the left of colliding entity's left edge
       movb @bytes+7,@e                ; LD E,7            ; Load E with 7 (jumper is Berk, his left edge is to the left of colliding, class=129, entity's
                                                           ; left edge)
       .ret                            ; RET               ; Return
* Berk's left edge is at, or to the right of, colliding entity's left edge
_55352:
       movb @7(iy),a                   ; LD A,(IY+7)       ; If Berk's right edge...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...is at or to the right of the colliding entity's right edge...
       jhe  _55285                     ; JR NC,55285       ; ...then jump back to #R55285 (continue moving downwards)
* Berk's right edge is to the left of colliding entity's right edge
       movb @bytes+8,@e                ; LD E,8            ; Load E with 8 (jumper is Berk, and he is between left and right edges of colliding,
                                                           ; class=129, entity)
       .ret                            ; RET               ; Return
* Downward phase, and collision with entity of class 35 (platform, Level 1 or Level 3) or no collision at bottom of
* screen
_55363:
       szcb @bits+6,@12(ix)            ; RES 6,(IX+12)     ; Reset Downward Jump Phase Flag (i.e. prepare to jump up again)
       movb @cached_control_input,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       movb a,tmp0                     ; BIT 3,A           ; ...and if Back Bit is reset...
       andi tmp0,8*256                 ;                   
       jeq  _55377                     ; JR Z,55377        ; ...then skip ahead to #R55377
       movb one,@e                     ; LD E,1            ; Load E with 1 (jumper landed on floor / platform and Back Control Input Bit set)
       .ret                            ; RET               ; Return
* Back Bit is reset
_55377:
       movb @12(ix),a                  ; LD A,(IX+12)      ; If current velocity of jumper's jump is at least 4...
       andi a,15*256                   ; AND 15            ; ...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jhe  _55393                     ; JR NC,55393       ; ...then skip ahead to #R55393
       movb @bytes+0,@12(ix)           ; LD (IX+12),0      ; Reset jumper's Is Jumping Flag and set current velocity of jump to zero
       movb @bytes+3,@e                ; LD E,3            ; Load E with 3 (jumper's jump velocity less than 4, and back not pressed, i.e. terminate
                                                           ; jumping)
       .ret                            ; RET               ; Return
* Current velocity of jumper's jump is at least 4, and Back Bit is reset
_55393:
       movb @cached_control_input,a                  ; LD A,(55022)      ; Load A with Cached Control Input...
       movb a,tmp0                     ; BIT 1,A           ; ...and if Left Bit is reset...
       andi tmp0,2*256                 ;                   
       jeq  _55404                     ; JR Z,55404        ; ...then skip ahead to #R55404
* Left Bit is set
       movb @bytes+4,@e                ; LD E,4            ; Load E with 4 (jumper's jump velocity at least 4 and Left Control Input Bit set)
       jmp  _55410                     ; JR 55410          ; Decrease current velocity of jumper's jump by two and return
* Left Bit is reset
_55404:
       movb a,tmp0                     ; BIT 0,A           ; If Right Bit is reset...
       andi tmp0,1*256                 ;                   
       jeq  _55417                     ; JR Z,55417        ; ...then skip ahead to #R55417
* Right Bit is set
       movb @bytes+5,@e                ; LD E,5            ; Load E with 5 (jumper's jump velocity at least 4 and Right Control Input Bit set)
_55410:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease current velocity of jumper's jump by two...
       sb   one,@12(ix)                ; DEC (IX+12)       ; ...
       .ret                            ; RET               ; Return
* Right Bit (and Left and Back bits) reset
_55417:
       movb @bytes+0,@e                ; LD E,0            ; Load E with zero (current velocity of jumper's jump is at least 4 and Back, Left and Right
                                                           ; Control Input bits are reset)
       jmp  _55410                     ; JR 55410          ; Decrease current velocity of jumper's jump by two and return

* Increase Current Velocity of Character's Jump if Less Than 7
* 
* See pokes Input:  IX  Address of complex state data (current level) for Berk or Drutt
_55421:
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load A with current velocity of character's jump...
       andi a,15*256                   ; AND 15            ; ...
       cb   a,@bytes+7                 ; CP 7              ; ...and if this is 7 or more...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       ab   one,@12(ix)                ; INC (IX+12)       ; Increase velocity of character's jump
       .ret                            ; RET               ; Return

* Change Entity's Room Up One if Appropriate
* 
* Used by the routines at #R36542, #R48487 and #R55196. Input:  IX  Address of complex state data for an entity
change_room_up:
       movb @bytes+99,a                ; LD A,99           ; If y-coordinate of top of entity is larger than 99 (i.e. top of entity is below top of
                                                           ; room)...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...
       jhe  !                          ; RET C             ; ...then return
       .ret                            ;                   
!
       .push hl                        ; PUSH HL           ; Store HL
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @_34254,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (lower room index) of first entry
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
_55451:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (lower room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  _55512                     ; JR Z,55512        ; ...then skip ahead to #R55512
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  _55467                     ; JR Z,55467        ; ...then skip ahead to #R55467
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  _55451                     ; JR 55451          ; Loop back to #R55451
_55467:
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (upper room index) of current entry into B
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       ab   @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Add 22 to y-coordinate of top of entity...
       ab   @bytes+22,a                ; ADD A,22          ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Add 22 to y-coordinate of bottom of entity...
       ab   @bytes+22,a                ; ADD A,22          ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
_55512:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .pop hl                         ; POP HL            ; Restore HL
       .ret                            ; RET               ; Return

* Set Can Fall Flag and Set Initial Velocity Factor of 2 for Entity Defined at Address in IX
* 
* Used by the routines at #R36638, #R39760, #R48417, #R51779, #R52098, #R52193 and #R52243. Input:  IX  Address of
* complex state data for an entity
_55516:
       socb @bits+6,@10(ix)            ; SET 6,(IX+10)     ; Set entity's "Can Fall" flag
       movb @bytes+2,@12(ix)           ; LD (IX+12),2      ; Set entity's initial velocity factor to 2
       .ret                            ; RET               ; Return

* Move All Falling Entities Down by Distances Appropriate to their Current Velocity Factors
* 
* If an entity's "velocity factor" is equal to its height in characters plus 3 (a proxy for its mass), then it has
* reached its terminal velocity.
move_falling_entities:
       .proc
       mov  @cmplx_state_data_addr,ix  ; LD IX,(34238)     ; Load IX with start address of current level's complex state data
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
_55532:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of entry is 255 (i.e. End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jne  !                          ; RET Z             ; ...then return
       .endproc                        ;
!
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If current entity's "Can Fall" flag is reset...
       andi tmp0,64*256                ;                   
       jeq  _55592                     ; JR Z,55592        ; ...then skip ahead to #R55592 (advance to next entity)
* Current entity's "Can Fall" Flag is set
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for current entity's current room
       .pop de                         ; POP DE            ; Restore DE
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height (of entity defined by entry) + 3...
       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
       ab   @bytes+4,a                 ; ADD A,4           ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load B with velocity factor...
       movb a,b                        ; LD B,A            ; ...
       cb   a,@c                       ; CP C              ; If C is less than or equal to this (i.e. "terminal velocity" reached)...
       jhe  _55569                     ; JR NC,55569       ; ...then skip ahead to #R55569
       ab   one,a                      ; INC A             ; Increase velocity factor by one and store for next pass (i.e. acceleration)...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...
_55569:
       srl  b,1                        ; SRL B             ; Divide current (i.e. not increased) velocity factor by 2
_55571:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If sum of y-coordinate of entity's bottom and entity's depth is 122...
       ab   @1(ix),a                   ; ADD A,(IX+1)      ; ...(i.e. entity is at ground-level)...
       cb   a,@bytes+122               ; CP 122            ; ...
       jeq  _55596                     ; JR Z,55596        ; ...then skip ahead to #R55596
_55581:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       .call @change_room_down                   ; CALL 55616        ; Change entity's room down one if appropriate
       sb   one,b                      ; DJNZ 55571        ; Decrease B (current velocity factor, i.e. remaining number of characters to drop entity) and
       jne  _55571                     ;                   
                                                           ; if non-zero, loop back to #R55571
_55592:
       a    de,ix                      ; ADD IX,DE         ; Advance IX by 13 bytes to next entry
       jmp  _55532                     ; JR 55532          ; Loop back to #R55532
* Entity's position is such that sum of y-coordinate of bottom + depth = 122 (i.e. at ground-level)
_55596:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
_55599:
       joc  _55610                     ; JR C,55610        ; ...and if no collision occurred, then skip ahead to #R55610
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  _55581                     ; JR Z,55581        ; ...then jump to #R55581 (entity may fall down into next room)
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that character did collide with
       bl   @chk_coll_same_depth_5     ; CALL 54871    ; Resume checking entity for collision with another entity at same depth whose Interaction
                                                           ; (11,6) Flag is set...
       jmp  _55599                     ; JR 55599          ; ...
* Entity has landed (i.e. is at ground-level and has not collided with a marker of class 129)
_55610:
       szcb @bits+6,@10(ix)            ; RES 6,(IX+10)     ; Reset entity's "Can Fall" flag as entity has landed
       jmp  _55592                     ; JR 55592          ; Loop back for next entity

* Change Entity's Room Down One if Appropriate
* 
* Used by the routines at #R55196 and #R55525. Input:  IX  Address of complex state data for an entity
change_room_down:
       movb @bytes+122,a               ; LD A,122          ; If y-coordinate of bottom of entity is smaller than 122 (i.e. bottom of entity is above
                                                           ; bottom of room)...
       cb   a,@6(ix)                   ; CP (IX+6)         ; ...
       jl   !                          ; RET NC            ; ...then return
       .ret                            ;                   
!
       .push bc                        ; PUSH BC           ; Store BC
       .push de                        ; PUSH DE           ; Store DE
       mov  @_34254,iy                 ; LD IY,(34254)     ; Load start address of current level's Vertical Room Connectivity Data into IY
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity into D
_55631:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (upper room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  _55695                     ; JR Z,55695        ; ...then skip ahead to #R55695
       cb   a,d                        ; CP D              ; If byte is the same as the entity's current room...
       jeq  _55647                     ; JR Z,55647        ; ...then skip ahead to #R55647
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  _55631                     ; JR 55631          ; Loop back to #R55631
_55647:
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (lower room index) of current entry into B
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (old, that entity is leaving) into D...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room (new, that entity has entered) into A
       sb   d,a                        ; SUB D             ; Subtract x-coordinate of old room's left edge from x-coordinate of new room's left edge...
       movb a,d                        ; LD D,A            ; ...and place result in D
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of left of entity...
       sb   d,a                        ; SUB D             ; ...subtract difference in positions of rooms' left edges...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and store
       ab   @e,a                       ; ADD A,E           ; Update x-coordinate of right of entity by adding entity's (width - 1) value...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       movb @4(ix),a                   ; LD A,(IX+4)       ; Subtract 20 from y-coordinate of top of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@4(ix)                   ; LD (IX+4),A       ; ...
       movb @6(ix),a                   ; LD A,(IX+6)       ; Subtract 20 from y-coordinate of bottom of entity...
       sb   @bytes+20,a                ; SUB 20            ; ...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .ret                            ; RET               ; Return
_55695:
       .pop de                         ; POP DE            ; Restore DE
       .pop bc                         ; POP BC            ; Restore BC
       .ret                            ; RET               ; Return

* If Current Character is in Same Room as Target Entity at IX then Set Pending Sound to A
* 
* If the requested sound has a lower index than the sound already pending then the requested sound overrides the
* pending sound (i.e. lower index has higher priority). Input:  A  Index of requested sound IX  Address of complex
* state data for target entity
request_entity_sound:
       .proc
       .push af                        ; PUSH AF           ; Store AF (A = index of requested sound)
       movb @current_characters_room,a ; LD A,(34218)      ; If current character's current room is the same as current room of target entity...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  request_entity_sound_1     ; JR Z,59612        ; ...then skip ahead to #R59612
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       .endproc                        ; RET               ; Return
request_entity_sound_1:
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       jmp  !
* At this point, A will hold the index of a requested sound, and RAM address #R34273 will contain the index of a
* pending sound. If the index of the requested sound is lower than the index of the pending sound, then the pending
* sound's index at #R34273 will be overwritten by the index of the requested sound in A. Sounds with lower indices
* therefore take priority over sounds with higher indices. This entry point is used by the routines at #R46284,
* #R55196 and #R59722.
request_sound_pri:
       .proc
!      socb a,a                        ; OR A              ; If index of requested sound is zero...
       jeq  request_sound_pri_2        ; RET Z             ; ...then return
       .push de                        ; PUSH DE           ; Store DE
       movb a,@e                       ; LD E,A            ; Load E with index of requested sound
       movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero (i.e. no sound pending)...
       jeq  request_sound_pri_1        ; JR Z,59628        ; ...then skip ahead to #R59628
       cb   a,@e                       ; CP E              ; If index of requested sound is less than or equal to index of pending sound...
       jhe  request_sound_pri_1        ; JR NC,59628       ; ...then skip ahead to #R59628
       .pop de                         ; POP DE            ; Restore DE
       jmp  request_sound_pri_2        ; RET               ; Return
request_sound_pri_1:
       movb @e,a                       ; LD A,E            ; Set requested sound to be new pending sound...
       movb a,@idx_pending_sound       ; LD (34273),A      ; ...
       .pop de                         ; POP DE            ; Restore DE
request_sound_pri_2:
       .endproc                        ; RET               ; Return

* Set Sound of Index A as Pending if Appropriate, then Play and Clear Pending Sound
*
* The sound with index A will become the pending sound if the currently pending sound index is either zero, or of
* higher index than A (i.e. lower priority). Input:  A  Sound index L  Undefined, pseudo-random value
request_sound:
       .proc
       bl   @request_sound_pri         ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
       jmp  !
* This entry point is used by the routine at #R34438.
play_sound:
       .proc
!      movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero...
       jeq  play_sound_1               ; RET Z             ; ...then return
;       sb   one,a                      ; DEC A             ; Decrease A to give zero-based sound index
;       .push ix                        ; PUSH IX           ; Store IX
;       li   ix,sound_table+1           ; LD IX,59635       ; Point IX at second byte of first entry in Sound Parameters Table
;       a    a,a                        ; ADD A,A           ; Multiply sound index by eight...
;       a    a,a                        ; ADD A,A           ; ...as sound data entries in table at #R59634 are eight bytes wide...
;       a    a,a                        ; ADD A,A           ; ...
;       movb a,@c                       ; LD C,A            ; ...and load into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,ix                      ; ADD IX,BC         ; Add BC to IX as offset to point to sound data for pending sound
;       movb b,a                        ; LD A,B            ; Set index of pending sound to zero...
;       movb a,@_34273                  ; LD (34273),A      ; ...
;       movb *ix,@c                     ; LD C,(IX+0)       ; Load outer repeat count into C
;_59752:
;       movb @1(ix),b                   ; LD B,(IX+1)       ; Load inner repeat count into B
;       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load delay constant E into E
;       movb @3(ix),d                   ; LD D,(IX+3)       ; Load delay constant D into D
;       movb @6(ix),h                   ; LD H,(IX+6)       ; Load most significant byte of pseudo-random address into H
;_59764:
;       .push bc                        ; PUSH BC           ; Store BC (B = inner repeat count, C = outer repeat count)
;       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
;       socb @bits+4,a                  ; SET 4,A           ; Set Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb d,b                        ; LD B,D            ; Apply delay based upon delay constant D...
;_59773:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59773        ; ...
;       jne  _59773                     ;
;       movb h,tmp0                     ; BIT 7,H           ; If No Pause Flag is set...
;       andi tmp0,128*256               ;
;       jne  _59794                     ; JR NZ,59794       ; ...then skip ahead to #R59794
;       movb *hl,b                      ; LD B,(HL)         ; Load B with value from pseudo-random address
;       inc  hl                         ; INC HL            ; Advance HL
;_59782:
;       movb *ix,tmp0                   ; BIT 0,(IX+0)      ; Do nothing (pause) for period B...
;       andi tmp0,1*256                 ;
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59782        ; ...
;       jne  _59782                     ;
;_59794:
;       szcb @bits+4,a                  ; RES 4,A           ; Reset Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb @e,b                       ; LD B,E            ; Do nothing for E cycles...
;_59799:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59799        ; ...
;       jne  _59799                     ;
;       movb @4(ix),a                   ; LD A,(IX+4)       ; Adjust value of delay constant D...
;       a    d,a                        ; ADD A,D           ; ...
;       movb a,d                        ; LD D,A            ; ...
;       movb @5(ix),a                   ; LD A,(IX+5)       ; Adjust value of delay constant E...
;       a    @e,a                       ; ADD A,E           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       .pop bc                         ; POP BC            ; Restore BC (B = inner repeat count, C = outer repeat count)
;       sb   one,b                      ; DJNZ 59764        ; Loop back to #R59764
;       jne  _59764                     ;
;       sb   one,@c                     ; DEC C             ; Decrease outer repeat count
;       jne  _59752                     ; JR NZ,59752       ; If non-zero (i.e. more repeats to process) then loop back to #R59752
;       .pop ix                         ; POP IX            ; Restore IX
play_sound_1:
       .endproc                         ; RET               ; Return
