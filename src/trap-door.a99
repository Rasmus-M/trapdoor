*********************************************************************************
* SkoolKit disassembly for Through the Trap Door
* 
* Copyright (c) 2017 Philip M. Anderson (this disassembly)
* Copyright (c) 1987 Don Priestley / Piranha / Alternative Software Ltd (Through the Trap Door)
*
* TI-99/4A version by Rasmus Moustgaard 2023.
*
*********************************************************************************
*
* Set Up Random Seed and Disable Interrupts
*
start:
       limi 0                           ; DI                ; Disable interrupts
       lwpi wrksp
       mov @rndsd,@rnd_seed            ; LD A,(23672)      ; Store the least significant byte of the system variable FRAMES...
                                        ; LD (54219),A      ; ...at 54219 as the seed for the pseudo-random number generator
       li   one,>0100
       li   sp,stack                   ; LD SP,34426       ; Set Stack Pointer
       bl   @init_bits
       bl   @graphics_mode
       bl   @copy_initial_state_data   ; CALL 34695        ; Copy State Data for all resettable complex entities into Table of Initial-State Data

*********************************************************************************
* Display Main Menu and Handle Main Game Loop
main:
       movb one,@current_level         ; LD A,1            ; Set current level to 1...
                                       ; LD (34207),A      ; ...
       bl   @main_menu                 ; CALL 46830        ; Display and handle Main Menu
       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
       bl   @set_border_color          ; OUT (254),A       ; Set border colour
       bl   @init_level_data           ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @draw_timer_bar            ; CALL 47241        ; Reset Show Score Flag and draw timer figures bar
*      Debug: start at other level
       .ifne start_at_level,1
       .ifeq start_at_level,2
       li   tmp0,level_1_exit_door
       .endif
       .ifeq start_at_level,3
       li   tmp0,rev_col_check_addr_2
       .endif
       .ifeq start_at_level,4
       li   tmp0,state_data_complex_3
       .endif
       .ifeq start_at_level,5
       socb @bits+3,@flying_skeleton+9 ; Set Berk and Drutt through the trap door flag
       li   tmp0,level_4_door
       .endif
       mov  tmp0,@bert_interaction_state
       bl   @next_level
       .endif
*      Debug - end
* Start of main loop
main_loop:
       bl   @check_berk_killed         ; CALL 53723        ; If Berk has been killed then reset his state, flash screen and decrease time / lives
       bl   @update_berk_state         ; CALL 35689        ; Update state of Berk and store current position in script data
       bl   @update_drutt_worm_state   ; CALL 51739        ; Update states of Drutt and worm and store current positions in script data
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 1...
       cb   a,one                      ; CP 1              ; ...
       jne  main_check_level_2         ; JR NZ,34527       ; ...then skip ahead to #R34527
* Level 1
       bl   @update_level_1_entities   ; CALL 36791        ; Update states of all Level 1 entities
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       movb @10(ix),tmp0               ; BIT 2,(IX+10)     ; If "Back to Level 1" Flag is reset...
       andi tmp0,4*256                 ;                   
       jeq  main_all_levels            ; JR Z,34557        ; ...then skip ahead to #R34557
* Back to Level 1 Flag is set
       movb @bonis_state_data_1+6,a    ; LD A,(43612)      ; If y-coordinate of Boni's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1+6,a   ; LD A,(43677)      ; If y-coordinate of Drutt's bottom edge is not 121...
       cb   a,@bytes+121               ; CP 121            ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @drutts_state_data_1,a     ; LD A,(43671)      ; If Drutt's room is not 1...
       cb   a,one                      ; CP 1              ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
       movb @bytes+2,a                 ; LD A,2            ; Set depth of "Home Sweet Home" brickwork to 2...
       movb a,@state_data_simple_1+13  ; LD (43159),A      ; ...
       socb @bits+3,@10(ix)            ; SET 3,(IX+10)     ; Set "All Home" Flag
       jmp  main_all_levels            ; JR 34557          ; Skip ahead to #R34557
main_check_level_2:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 2...
       cb   a,@bytes+2                 ; CP 2              ; ...
       jne  main_check_level_3         ; JR NZ,34537       ; ...then skip ahead to #R34537
* Level 2
       bl   @update_level_2_entities   ; CALL 38009        ; Update states of all Level 2 entities
main_check_level_3:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 3...
       cb   a,@bytes+3                 ; CP 3              ; ...
       jne  main_check_level_4         ; JR NZ,34547       ; ...then skip ahead to #R34547
* Level 3
       bl @update_level_3_entities     ; CALL 39137        ; Update states of all Level 3 entities
main_check_level_4:
       movb @current_level,a           ; LD A,(34207)      ; If current level is not Level 4...
       cb   a,@bytes+4                 ; CP 4              ; ...
       jne  main_all_levels            ; JR NZ,34557       ; ...then skip ahead to #R34557
* Level 4
       bl   @update_level_4_entities   ; CALL 41211        ; Update states of all Level 4 entities
* All levels
main_all_levels:
       bl   @check_control_input       ; CALL 47893        ; Check for control input and store at #R34219
       bl   @move_falling_entities     ; CALL 55525        ; Move all falling entities down by distances appropriate to their current velocity factors
       bl   @swap_characters           ; CALL 34916        ; If Fire Pressed, or Character Swap Pending Flag set, then swap characters
       bl   @clear_display_buffer      ; CALL 53782        ; Set each value in Primary Display Buffer within play area to zero
       bl   @populate_display_buffer   ; CALL 45899        ; Populate Primary Display Buffer with layout data for current character's current room
       bl   @draw_display_buffer       ; CALL 54034        ; Draw contents of Primary Display Buffer to display
       bl   @play_sound                ; CALL 59725        ; Play and clear pending sound (index as stored at #R34273)
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
       socb a,a                        ; OR A              ; If no time / lives are left...
       jeq  time_out                   ; JR Z,34645        ; ...then jump to #R34645
       movb @berks_state_data_1+10,a   ; LD A,(43603)      ; If "All Home" Flag is set...
       andi a,8*256                    ; BIT 3,A           ; ...
       jne  all_home                   ; JR NZ,34658       ; ...then skip ahead to #R34658
       bl   @update_timer              ; CALL 47363        ; Update eyes of a randomly selected timer figure, increase Timer Tick Counter and process
                                                           ; timer figure blinking
       li   hl,game_flags              ; LD HL,34208       ; If Update Scores and Display Flag is reset...
       movb *hl,tmp0                   ; BIT 5,(HL)        ; ...
       andi tmp0,32*256                ;
       jeq  skip_update_score          ; JR Z,34606        ; ...then skip ahead to #R34606
       szcb @bits+5,*hl                ; RES 5,(HL)        ; Reset Update Scores and Display Flag
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
skip_update_score:
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a     ; LD A,(34271)      ; Invert "Display Buffer 2 is Primary" Flag...
       xor  one,a                      ; XOR 1             ; ...
       movb a,@display_buffer_flag     ; LD (34271),A      ; ...
       jeq  skip_swap_buffers          ; JR Z,34623        ; If "Display Buffer 2 is Primary" Flag is reset then skip ahead to #R34623 (Display Buffer 1
                                                           ; is Primary, Display Buffer 2 is Secondary)
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
skip_swap_buffers:
       mov  hl,@prim_disp_buffer_addr  ; LD (34279),HL     ; Store address of Primary Display Buffer at #R34279
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       andi a,64*256                   ; BIT 6,A           ; If Restart hasn't been pressed...
       jne  restart                    ; JP Z,34466        ; ...then jump to #R34466 (start of main loop)
       jmp  main_loop                  ;
* Restart has been pressed
restart:
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound             ; CALL 59722        ; ...
       bl   @reset_game_data           ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
* No time/lives left
time_out:
       bl   @update_and_print_score    ; CALL 47499        ; Update scores and display
       bl   @print_times_up            ; CALL 47185        ; Print "SORRY BERK,  BUT YOUR TIME IS UP" string
       movb one,a                      ; LD A,1            ; Set sound 1 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound             ; CALL 59722        ; ...
       jmp  wait_key_and_restart       ; JR 34666          ; Skip ahead to #R34666
* "All Home" Flag is set
all_home:
       bl   @print_home_sweet_home     ; CALL 47213        ; Print "HOME SWEET HOME" string
       movb @bytes+3,a                 ; LD A,3            ; Set sound 3 as pending if appropriate, then play and clear pending sound...
       bl   @request_sound             ; CALL 59722        ; ...
wait_key_and_restart:
       bl   @wait_release_and_keypress ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
       bl   @reset_game_data           ; CALL 34751        ; Reset all game data in preparation for new game
       b    @main                      ; JP 34438          ; Jump back to #R34438 (return to Main Menu)
*// main

*********************************************************************************
* Pause
*
* Used by the routine at #R53649. Input:  B  Repeat count for outer loop C  Additional repeat count for inner loop
;pause:
;       .push bc                        ; PUSH BC           ; Store BC
;       movb @bytes+10,b                ; LD B,10           ; Set B to 10
;pause_1:
;       dec  bc                         ; DEC BC            ; Decrease BC
;       movb b,a                        ; LD A,B            ; If BC is not zero...
;       socb @c,a                       ; OR C              ; ...
;       jne  pause_1                     ; JR NZ,34678       ; ...then loop back to #R34678
;       .pop bc                         ; POP BC            ; Restore BC
;       sb   one,b                      ; DJNZ 34675        ; Loop back for next pass
;       jne  pause                     ;
;       .ret                            ; RET               ; Return
;*// pause

*********************************************************************************
* Display and Handle Main Menu
*
* Used by the routine at #R34438.
main_menu:
       .proc
       movb one,a                      ; LD A,1            ; Load A with 1 (blue)
       movb a,@border_color            ; LD (34217),A      ; Store at #R34217 and...
       bl   @set_border_color          ; OUT (254),A       ; ...set border to this value (blue)
       movb @bytes+9,a                 ; LD A,9            ; Fill top 22 rows of Attribute File with blue PAPER & blue INK...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @print_title               ; CALL 47140        ; Print "THROUGH the TRAPDOOR" string
       bl   @print_score_strings       ; CALL 47628        ; Print SCORE / TOTAL / HI-SC string in current character's colours
       li   ix,main_menu_addrs         ; LD IX,46690       ; Point IX at Table of Attribute File Addresses for Main Menu Strings
       li   iy,main_menu_strings       ; LD IY,46710       ; Point IY at start of Table of Main Menu Strings
       movb @bytes+112,a               ; LD A,112          ; Load A with 112 (black INK on yellow PAPER)
       movb a,@print_attr              ; LD (34269),A      ; Store at #R34269
       movb @bytes+10,b                ; LD B,10           ; Load B with 10 as there are 10 strings to print (loop counter)
main_menu_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of strings to print)
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address at which to print text into HL...
                                       ; LD H,(IX+1)       ; ...
       movb @bytes+12,b                ; LD B,12           ; Load B with 12 as there are 12 characters to print (loop counter)
main_menu_2:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining characters to print)
       movb *iy,@e                     ; LD E,(IY+0)       ; Load E with text character to print
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  iy                         ; INC IY            ; Advance IY to next character in text to print
       inc  hl                         ; INC HL            ; Advance to next Attribute File location
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining characters to print)
       sb   one,b                      ; DJNZ 46872        ; Loop back for next character
       jne  main_menu_2                ;
       inct ix                         ; INC IX            ; Advance IX to next entry in list of Attribute File addresses to print to...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of strings to print)
       sb   one,b                      ; DJNZ 46863        ; Loop back for next string
       jne  main_menu_1                ;
;       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
* This entry point is used by the routine at #R46968.
main_menu_3:
       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
;       cb   a,@bytes+83                ; CP 83             ; If pressed key was not 83 (S)...
;       jne  main_menu_4                ; JR NZ,46915       ; ...then skip ahead to #R46915
;       movb @bytes+2,a                 ; LD A,2            ; Set current border colour to red...
;       movb a,@border_color            ; LD (34217),A      ; ...
       bl   @set_border_color          ; OUT (254),A       ; ...
       .endproc                        ; RET               ; Return
;main_menu_4:
;       cb   a,@bytes+74                ; CP 74             ; If pressed key was not 74 (J)...
;       jne  _46968                     ; JR NZ,46968       ; ...then jump to #R46968 (if "K" pressed then redefine controls)
;       movb @joystick_mode_flag,a      ; LD A,(34298)      ; If we are in Joystick Mode...
;       socb a,a                        ; OR A              ; ...
;       jne  main_menu_5                ; JR NZ,46937       ; ...then skip ahead to #R46937
;       bl   @check_for_joystick        ; CALL 47043        ; If Kempston Interface not present, or Kempston Joystick moved / fire pressed...
;       joc  main_menu_3                ; JR C,46900        ; ...then jump to #R46900
;       movb one,a                      ; LD A,1            ; Set Joystick Mode to On...
;       movb a,@joystick_mode_flag      ; LD (34298),A      ; ...(see trivia)
;       jmp  main_menu_6                ; JR 46938          ; Skip ahead to #R46938
;main_menu_5:
;       sb   one,a                      ; DEC A             ; Set Joystick Mode to Off...
;main_menu_6:
;       movb a,@joystick_mode_flag      ; LD (34298),A      ; ...
;       bl   @draw_joystick_j           ; CALL 46946        ; Draw Joystick "J" (Main Menu) in colour depending upon Joystick Mode
;       jmp  main_menu_3                ; JR 46900          ; Loop back to #R46900

* Draw Joystick "J" (Main Menu) in Colour Depending Upon Joystick Mode
*
* Used by the routine at #R46830.
;draw_joystick_j:
;       .proc
;       movb @joystick_mode_flag,a      ; LD A,(34298)      ; If Joystick Mode Flag is set...
;                                       ; OR A              ; ...
;       jne  draw_joystick_j_1          ; JR NZ,46956       ; ...then skip ahead to #R46956
;       movb @bytes+112,a               ; LD A,112          ; Load A with attribute value for black INK, yellow PAPER, BRIGHT
;       jmp  draw_joystick_j_2          ; JR 46958          ; Skip ahead to #R46958
;draw_joystick_j_1:
;       movb @bytes+114,a               ; LD A,114          ; Load A with attribute value for red INK, yellow PAPER, BRIGHT
;draw_joystick_j_2:
;       movb @bytes+74,@e               ; LD E,74           ; Load E with 74 (index for character "J")
;       li   ix,main_menu_addrs_kempston ; LD IX,46694       ; Point IX at entry for "J +KEMPSTON " in table of Attribute File addresses at which to print
;                                                           ; menu strings
;       bl   @set_and_print_dbl_height  ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;       .endproc                        ; RET               ; Return

;* If "K" Pressed then Redefine Controls
;*
;* Used by the routine at #R46830. Input:  A  ASCII code of pressed key
;_46968:
;       cb   a,@bytes+75                ; CP 75             ; If pressed key was not 75 (K)...
;       jne  main_menu_3                     ; JR NZ,46900       ; ...then jump to Main Menu handling routine at #R46900
;       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at start of Table of Current Keyboard Controls
;_46977:
;       movb @bytes+63,*hl              ; LD (HL),63        ; Set current entry in table to 63 (ASCII code for "?")
;       inc  hl                         ; INC HL            ; Advance HL to next entry
;       sb   one,b                      ; DJNZ 46977        ; Decrease remaining number of controls to change and loop back to #R46977 if not zero
;       jne  _46977                     ;
;       movb @bytes+112,a               ; LD A,112          ; Load A with the attribute value for black INK, yellow PAPER, BRIGHT
;       bl   @print_keyboard_controls   ; CALL 47084        ; Print keyboard controls on main menu
;       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
;       li   ix,main_menu_addrs_dirs                  ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
;                                                           ; print for main menu
;       movb @bytes+7,b                 ; LD B,7            ; Load B with 7 (as there are seven controls to define)
;_46997:
;       .push bc                        ; PUSH BC           ; Store BC (remaining number of controls to define)
;       movb @bytes+198,a               ; LD A,198          ; Load A with 198 (yellow INK, black PAPER, BRIGHT, FLASH)
;       movb @bytes+32,@e               ; LD E,32           ; Load E with 32 (" ")
;       bl  @set_and_print_dbl_height   ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;_47005:
;       bl   @wait_keypress             ; CALL 47955        ; Wait for key-press, store pressed key code in A and play Main Menu Sound
;       bl   @is_direction_key          ; CALL 47060        ; If key pressed matches a direction, or the Berk / Drutt key...
;       jeq  _47005                     ; JR Z,47005        ; ...then loop back to #R47005
;       movb a,@e                       ; LD E,A            ; Load keycode of pressed control into E...
;       movb @e,*iy+                    ; LD (IY+0),E       ; ...and store in Table of Current Keyboard Controls
;                                       ; INC IY            ; Advance IY to next control
;       movb @bytes+113,a               ; LD A,113          ; Load A with 113 (blue INK, yellow PAPER, BRIGHT)
;       bl @set_and_print_dbl_height    ; CALL 47071        ; Set attribute to A and location to (IX) and print double-height character in E
;       inct ix                         ; INC IX            ; Advance IX to next entry in table of Attribute File addresses...
;                                       ; INC IX            ; ...
;       .pop bc                         ; POP BC            ; Restore BC (remaining number of controls to define)
;       sb   one,b                      ; DJNZ 46997        ; Decrease remaining number of controls to define and loop back to #R46997 if not zero
;       jne  _46997                     ;
;       sb   a,a                        ; XOR A             ; Switch Joystick Mode to Off...
;       movb a,@joystick_mode_flag                  ; LD (34298),A      ; ...
;       movb @bytes+114,a               ; LD A,114          ; Load A with the attribute value for red INK, yellow PAPER, BRIGHT
;       bl @print_keyboard_controls     ; CALL 47084        ; Print keyboard controls on main menu
;       b    @main_menu_3                    ; JP 46900          ; Jump to Main Menu handling routine at #R46900

* Set Carry Flag if Kempston Interface not Present, or Kempston Joystick Moved / Fire Pressed
*
* Used by the routine at #R46830. Output: F  Carry Flag set if Kempston Interface not present, Kempston Joystick
* moved or fire pressed, reset otherwise
check_for_joystick:
       .proc
;       sb   b,b                        ; LD B,0            ; Set B to zero (to repeat check loop 256 times)
;_47045:
;       ; IN A,(31)                     ; IN A,(31)         ; Read value from Port 31 into A (Kempston Interface)
;       socb a,a                        ; OR A              ; If retrieved value is not zero (i.e. Kempston Interface not present, or Kempston Joystick not
;                                                           ; centred / fire button pressed)...
;       jne  _47053                     ; JR NZ,47053       ; ...then skip ahead to #R47053
;       sb   one,b                      ; DJNZ 47045        ; Decrease B (loop counter) and loop back to #R47045 to check Kempston status again if counter
;       jne  _47045                     ;
;                                                           ; not zero
;       .ret                            ; RET               ; Return
;_47053:
;       movb @bytes+6,a                 ; LD A,6            ; Set sound 6 as pending if appropriate, then play and clear pending sound...
;       bl   @request_sound           ; CALL 59722        ; ...
;       ; SCF                           ; SCF               ; Set Carry Flag
;       .ret                            ; RET               ; Return
;       b    @return_without_carry

*********************************************************************************
* Set Zero Flag if Key Whose Index is in A Matches a Direction, or the Berk / Drutt Key
*
* Used by the routine at #R46968. Input:  A  Index of pressed key Output: F  Zero Flag set if input key index
* matches an entry in table at #R46683, reset otherwise HL  Address of matching entry in table at #R46683 (if match
* found)
;is_direction_key:
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
;       movb @bytes+5,b                 ; LD B,5            ; Load B with 5 (as we are checking the first five defined keys, see bugs)
;is_direction_key_1:
;       cb   a,*hl                      ; CP (HL)           ; If character code at current HL position matches the key we are checking...
;       jeq  is_direction_key_2         ; RET Z             ; ...then return with Zero Flag set
;       inc  hl                         ; INC HL            ; Advance HL to next character in keyboard controls table
;       sb   one,b                      ; DJNZ 47065        ; Loop back to #R47065 to check next control
;       jne  is_direction_key_1                     ;
;is_direction_key_2:
;       rt                              ; RET               ; Return
*// is_direction_key

*********************************************************************************
* Set Attribute and Location and Print Double-Height Character in E
*
* Used by the routines at #R46946 and #R46968. Input:  A  Attribute for character to print E  Character to print IX
* Points to memory location holding Attribute File address at which to print character
set_and_print_dbl_height:
       .proc
       movb a,@print_attr              ; LD (34269),A      ; Set text printing attribute to value in A
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load Attribute File address to print character to into HL...
                                       ; LD H,(IX+1)       ; ...
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       .endproc                            ; RET               ; Return
*// set_and_print_dbl_height

*********************************************************************************
* Print Keyboard Controls on Main Menu
*
* Used by the routines at #R46830 and #R46968. Input:  A  Attribute for printing text
print_keyboard_controls:
       .proc
       movb a,@print_attr              ; LD (34269),A      ; Set attribute for printing text
       li   ix,main_menu_addrs_dirs                  ; LD IX,46696       ; Point IX at entry for "   RIGHT    " text in table of Attribute File addresses at which to
                                                           ; print
       li   iy,current_keyboard_ctrls  ; LD IY,46683       ; Point IY at Table of Current Keyboard Controls
       movb @bytes+7,b                 ; LD B,7            ; Load B with 7, as there are 7 keyboard controls (loop counter)
_47097:
       .push bc                        ; PUSH BC           ; Store BC (B = number of remaining control keys)
       mov  *ix+,hl                    ; LD L,(IX+0)       ; Load HL with Attribute File address at which to print character...
                                       ; LD H,(IX+1)       ; ...
       movb *iy+,@e                    ; LD E,(IY+0)       ; Load E with character to print (current keyboard control)
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IY            ; Advance IY to next keyboard control
                                       ; INC IX            ; Advance IX to next entry in list of Attribute File addresses...
                                       ; INC IX            ; ...
       .pop bc                         ; POP BC            ; Restore BC (B = number of remaining control keys)
       sb   one,b                      ; DJNZ 47097        ; Loop back to #R47097 for next keyboard control
       jne  _47097                     ;
       .endproc                        ; RET               ; Return
*// print_keyboard_controls

*********************************************************************************
* Print "THROUGH the TRAPDOOR" String
*
* Used by the routine at #R46830.
print_title:
       .proc
       movb @bytes+20,b                ; LD B,20           ; Load B with 20 (length of string to print)
       li   hl,22566                   ; LD HL,22566       ; Point HL at position to start printing text in Attribute File
       movb @bytes+79,a                ; LD A,79           ; Load A with 79, for blue PAPER, white INK, BRIGHT
       li   ix,title_text              ; LD IX,47120       ; Point IX to text to print
       jmp  print_text                 ; JR 47224          ; Print the text and return
*// print_title

*********************************************************************************
* Print "SORRY BERK,  BUT YOUR TIME IS UP" String
*
* Used by the routine at #R34438.
print_times_up:
       .proc
       movb @bytes+32,b                ; LD B,32           ; Load B with 32 (length of string to print)
       movb @bytes+199,a               ; LD A,199          ; Load A with 199, for black PAPER, white INK, BRIGHT, FLASH
       li   ix,sorry_berk_text         ; LD IX,47153       ; Point IX to text to print
       li   hl,23232                   ; LD HL,23232       ; Point HL at position at which to start printing text in Attribute File (start of second-last
                                                           ; row)
       jmp  print_text                 ; JR 47224          ; Print the text and return
*// print_times_up

*********************************************************************************
* Print "HOME SWEET HOME" String
*
* Used by the routine at #R34438.
print_home_sweet_home:
       .proc
       movb @bytes+15,b                ; LD B,15           ; Set string length to 15
       movb @bytes+68,a                ; LD A,68           ; Set attribute to green INK on black PAPER, BRIGHT
       li   ix,home_sweet_home_text                  ; LD IX,47198       ; Point IX at "HOME SWEET HOME" text
       li   hl,22792                   ; LD HL,22792       ; Point HL at Attribute File address at which to print text
*// print_home_sweet_home:

*********************************************************************************
* This entry point is used by the routines at #R47140 and #R47185.
print_text:
       movb a,@print_attr              ; LD (34269),A      ; Store attribute at #R34269
print_text_1:
       .push bc                        ; PUSH BC           ; Store BC (B=remaining length of text)
       movb *ix+,@e                    ; LD E,(IX+0)       ; Load character of text to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
                                       ; INC IX            ; Advance IX to next text character to print
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address at which to print
       .pop bc                         ; POP BC            ; Restore BC (B = remaining length of text)
       sb   one,b                      ; DJNZ 47227        ; Decrease remaining length of text by one and repeat loop for next character
       jne  print_text_1               ;
       .endproc                        ; RET               ; Return
*// print_text

*********************************************************************************
* Copy State Data for all Resettable Complex Entities into Table of Initial-State Data for Complex Entities
* 
* Used by the routine at #R34438.
copy_initial_state_data:
       li   iy,level_state_data_table  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   de,initial_entity_states   ; LD DE,59821       ; Point DE at start of Table of Initial-State Data for Complex Entities
       li   bc,4                       ; LD B,4            ; Set B to 4 (as there are 4 levels)
copy_initial_state_data_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       mov  *iy+,ix                    ; LD L,(IY+0)       ; Load start address of current level's complex state data into HL...
                                       ; LD H,(IY+1)       ; ...
                                       ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
                                       ; INC IY            ; ...
                                       ; PUSH HL           ; Transfer start address of current level's complex state data into IX...
                                       ; POP IX            ; ...
copy_initial_state_data_2:
                                       ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   *ix,@bytes+255             ; CP 255            ; ...
       jeq  copy_initial_state_data_4  ; JR Z,34747        ; ...then skip ahead to #R34747
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  copy_initial_state_data_3  ; JR Z,34740        ; ...then advance IX by 13 bytes to next entry and loop back to #R34718
       mov  ix,hl                      ; PUSH IX           ; Transfer start address of current entry in complex state data into HL...
                                       ; POP HL            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in complex state data into Table of Initial-State Data for Complex
                                                           ; Entities at #R59821
copy_initial_state_data_3:
       ai   ix,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
                                       ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  copy_initial_state_data_2  ; JR 34718          ; Loop back to #R34718
copy_initial_state_data_4:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       dec  bc                         ; DJNZ 34704        ; Decrease B and loop back to #R34704 to process next level
       jne  copy_initial_state_data_1  ;
       rt                              ; RET               ; Return

*********************************************************************************
* Reset All Game Data in Preparation for New Game
* 
* Used by the routine at #R34438.
reset_game_data:
       .proc
       li   iy,level_state_data_table  ; LD IY,34687       ; Point IY at start of Table of Start Addresses of Levels' State Data for Complex Entities
       li   hl,initial_entity_states   ; LD HL,59821       ; Point HL at start of Table of Initial-State Data for Complex Entities
       li   bc,4                       ; LD B,4            ; Set B to 4 (as there are 4 levels)
reset_game_data_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of levels to process)
       mov  *iy+,ix                    ; LD E,(IY+0)       ; Load start address of current level's complex state data into DE...
                                       ; LD D,(IY+1)       ; ...
                                       ; INC IY            ; Advance IY to next entry in list of addresses of complex state data...
                                       ; INC IY            ; ...
                                       ; PUSH DE           ; Transfer start address of current level's complex state data into IX...
                                       ; POP IX            ; ...
reset_game_data_2:
                                       ; LD A,(IX+0)       ; If first byte in current complex state data entry is 255 (End Marker)...
       cb   *ix,@bytes+255             ; CP 255            ; ...
       jeq  reset_game_data_4          ; JR Z,34803        ; ...then skip ahead to #R34803
       movb @10(ix),a                  ; LD A,(IX+10)      ; If entity's Can Be Reset Flag is reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  reset_game_data_3          ; JR Z,34796        ; ...then advance IX by 13 bytes to next entry and loop back to #R34774
       mov  ix,de                      ; PUSH IX           ; Transfer start address of current entry in complex state data into DE...
                                       ; POP DE            ; ...
       li   bc,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
       .ldir                           ; LDIR              ; Copy current entry in Table of Initial-State Data for Complex Entities at #R59821 into
                                                           ; complex state data
reset_game_data_3:
       ai   ix,13                      ; LD BC,13          ; Load BC with 13 (as entries in complex state data are 13 bytes wide)
                                       ; ADD IX,BC         ; Advance IX to next entry in complex state data
       jmp  reset_game_data_2          ; JR 34774          ; Loop back to #R34774
reset_game_data_4:
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of levels to process)
       dec  bc                         ; DJNZ 34760        ; Decrease B and loop back to #R34760 to process next level
       jne  reset_game_data_1          ;
                                       ; LD HL,34298       ; Point HL at Joystick Mode Flag
                                       ; LD DE,34207       ; Point DE at store for current level number
       sb   a,a                        ; XOR A             ; Set A to zero and reset Carry Flag
                                       ; SBC HL,DE         ; Subtract DE from HL to leave HL = 91
       li   bc,clear_data_end-clear_data_start ; LD B,L            ; Load B with 91
       li   hl,clear_data_start        ; LD HL,34207       ; Point HL at store for current level number...
reset_game_data_5:
       movb a,*hl+                     ; LD (HL),A         ; ...and set 91 bytes from here onwards to zero...
                                       ; INC HL            ; ...
       dec  bc                         ; DJNZ 34819        ; ...
       jne  reset_game_data_5          ;
       movb @bytes+16,@time_left       ; LD A,16           ; Set time / lives to 16...
                                       ; LD (34210),A      ; ...
       movb one,@current_level         ; LD A,1            ; Set current level to Level 1...
                                       ; LD (34207),A      ; ...
       bl   @reset_skeleton_and_bat    ; CALL 36778        ; Initialise script data positions for Flying Skeleton Creature and Bat (Level 1)
       bl   @reset_apebeasts           ; CALL 38468        ; Reset current positions in apebeasts' script data to initial values
       bl   @reset_skeleton            ; CALL 41354        ; Reset Skeleton to initial state
       bl   @reset_drutt               ; CALL 51732        ; Reset Drutt to initial state
       movb one,a                      ; LD A,1            ; Set room of "Closed Trap Door" and impassable marker to 1 (i.e. starting room)...
       movb a,@closed_trap_door        ; LD (43188),A      ; ...
       movb a,@marker                  ; LD (43450),A      ; ...
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of current character to 1 (blue, Berk)
       sb   one,a                      ; DEC A             ; Set room of "Open Trap Door" and "Home Sweet Home" brickwork to 0...
       movb a,@opened_trap_door        ; LD (43437),A      ; ...i.e. remove from game...
       movb a,@home_sweet_home+1       ; LD (43159),A      ; ...
       .endproc                        ; RET               ; Return
*// reset_game_data

*********************************************************************************
* Copy Start Addresses of Current Level's Data Blocks to 34236 and Clean Up Old Data
* 
* Used by the routines at #R34438 and #R36753.
init_level_data:
       .proc
       .push de                        ; PUSH DE           ; Store DE
       .push hl                        ; PUSH HL           ; Store HL
       mov  @worm_state_addr,hl        ; LD HL,(34244)     ; Load HL with address of complex state data (current level) for worm
       movb @bytes+0,*hl               ; LD (HL),0         ; Set worm's current room to zero
       clr  hl
       movb @current_level,@l          ; LD A,(34207)      ; Load current level into A
       dec  hl
       sla  hl,1                       ; LD HL,34281       ; Point HL at position 20 bytes before start of list of start addresses of level 1's data
       mov  @level_data_table(hl),hl                       ; blocks
       li   bc,20                      ; LD BC,20          ; Set data length to 20, as there are 10 data blocks per level (so 10 addresses)

                                       ; ADD HL,BC         ; Advance HL to start of data block address list for next level
                                       ; DEC A             ; Decrease level counter
                                       ; JR NZ,34880       ; Loop back if we have not reached data for required level
* At this point, HL points to the start of the list of start addresses of the current level's data blocks
       li   de,current_data_addrs      ; LD DE,34236       ; Copy this level's data block start addresses to #R34236...
       .ldir                           ; LDIR              ; ...
       li   bc,6                       ; LD B,9            ; Clear Store for Script Instruction Loop Data...
       li   hl,script_23_24_loop_count ; LD HL,34285       ; ...
init_level_data_2:
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       dec  bc                         ; DJNZ 34894        ; ...
       jne  init_level_data_2                     ;
       .pop hl                         ; POP HL            ; Restore HL
       .pop de                         ; POP DE            ; Restore DE
       .endproc                        ; RET               ; Return

*********************************************************************************
* If Fire Pressed, or Character Swap Pending Flag Set, then Swap Characters
* 
* Used by the routine at #R34438.
swap_characters:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; If Character Swap Pending Flag is reset...
       movb *hl,tmp0                   ; BIT 6,(HL)        ; ...
       andi tmp0,64*256                ;                   
       jeq  swap_characters_1          ; JR Z,34927        ; ...then skip ahead to #R34927
       szcb @bits+6,*hl                ; RES 6,(HL)        ; Reset Character Swap Pending Flag
       jmp  swap_characters_4                     ; JR 34944          ; Skip ahead to #R34944
swap_characters_1:
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 4,A           ; If fire was pressed...
       andi tmp0,16*256                ;                   
       jne  swap_characters_3          ; JR NZ,34940       ; ...then skip ahead to #R34940
       szcb @bits+1,*hl                ; RES 1,(HL)        ; Reset Characters Already Swapped Flag
swap_characters_2:
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .endproc                        ; RET               ; Return
* [Fire pressed]
swap_characters_3:
       movb *hl,tmp0                   ; BIT 1,(HL)        ; If Characters Already Swapped Flag set (i.e. FIRE hasn't been released since last swap)...
       andi tmp0,2*256                 ;                   
       jne  swap_characters_2          ; JR NZ,34936       ; ...then jump back to #R34936
swap_characters_4:
       socb @bits+1,*hl                ; SET 1,(HL)        ; Set Characters Already Swapped Flag
       movb *hl,a                      ; LD A,(HL)         ; Load Game Flags into A
       xor  one,a                      ; XOR 1             ; Flip bit 7 (Berk / Drutt flag)...
       movb a,*hl                      ; LD (HL),A         ; ...
       movb *hl,tmp0                   ; BIT 0,(HL)        ; If current character is now Berk (0)...
       andi tmp0,1*256                 ;                   
       jeq  swap_characters_5          ; JR Z,34958        ; ...then jump ahead to #R34958
       movb @bytes+6,a                 ; LD A,6            ; Load A with 6 (attribute for Drutt's timer indicator figures)
       jmp  swap_characters_6          ; JR 34960          ; Skip ahead to #R34960
swap_characters_5:
       movb one,a                      ; LD A,1            ; Load A with 1 (attribute for Berk's timer indicator figures)
swap_characters_6:
       movb a,@current_character_attr  ; LD (34226),A      ; Set attribute of timer indicator figures to value in A
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       li   hl,game_flags              ; LD HL,34208       ; If Show Score Flag is set...
       movb *hl,tmp0                   ; BIT 7,(HL)        ; ...
       andi tmp0,128*256               ;                   
       jeq  !                          ; JP NZ,47628       ; ...then print SCORE / TOTAL / HI-SC string in current character's colours and return
       b    @print_score_strings_0     ;
!
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, draw timer figures bar and return
*// swap_characters

*********************************************************************************
* Change Direction Berk is Facing Depending Upon Relative Position of Drutt
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
* jump nor call
change_berk_direction:
       movb @current_characters_room,a                  ; LD A,(34218)      ; If Drutt's current room...
       cb   a,*ix                      ; CP (IX+0)         ; ...is not the same as Berk's current room...
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
       movb @11(ix),a                  ; LD A,(IX+11)      ; Reset Berk's Walking Right, Walking Left, Unused (11,2) and Unused (11,3) flags...
       andi a,240*256                  ; AND 240           ; ...
       movb a,@11(ix)                  ; LD (IX+11),A      ; ...
       movb @9(ix),@e                  ; LD E,(IX+9)       ; Load Berk's Flags into E
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of complex state data (current level) for Drutt
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with x-coordinate of Drutt's right side...
       ab   one,a                      ; INC A             ; ...and increase by one
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of Berk's left side is greater than this (i.e. Drutt is to the left of
                                                           ; Berk)...
       jl   _35653                     ; JR C,35653        ; ...then skip ahead to #R35653
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right side
       ab   one,a                      ; INC A             ; Increase A by one
       cb   a,@5(iy)                   ; CP (IY+5)         ; If x-coordinate of Drutt's left side is greater than this (i.e. Drutt is to the right of
                                                           ; Berk)...
       jl   _35670                     ; JR C,35670        ; ...then skip ahead to #R35670
* Drutt is between Berk's left and right sides
       movb @1(iy),a                   ; LD A,(IY+1)       ; If Drutt's depth is 1...
       cb   a,one                      ; CP 1              ; ...
       jne  !                          ; JP Z,35642        ; ...then skip ahead to #R35642
       b    @_35642                    ;                   
!
* Drutt is behind Berk
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,14*256                   ; AND 14            ; If Berk's Facing into Screen, Facing Left and Facing Right flags are all reset...
       jne  !                          ; JP Z,35636        ; ...then skip ahead to #R35636
       b    @_35636                    ;                   
!
* Drutt is behind Berk and at least one of Berk's Facing into Screen, Facing Left and Facing Right flags is set
       b    @update_berk_state_5                    ; JP 35815          ; Point HL at script data for Berk facing into screen, ready to respond to control input and
                                                           ; execute
* Drutt is behind Berk and Berk's Facing into Screen, Facing Left and Facing Right flags are all reset
_35636:
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is in front of Berk
_35642:
       movb @e,tmp0                    ; BIT 1,E           ; If Berk's Facing into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jne  !                          ; JP Z,35821        ; ...then point HL at script data for Berk facing out of screen, ready to respond to control
       b    @update_berk_state_6                    ;
!
                                                           ; input and execute
* Drutt is in front of Berk and Berk's Facing into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk
_35653:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,6*256                    ; AND 6             ; If either of Berk's Facing into Screen or Facing Left flags are set...
       jne  _35664                     ; JR NZ,35664       ; ...then skip ahead to #R35664
* Drutt is to the left of Berk, and Berk's Facing into Screen and Facing Left flags are both reset
       li   hl,_34977                  ; LD HL,34977       ; Point HL at script data for Berk turning to face left...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the left of Berk and either of Berk's Facing into Screen or Facing Left flags are set
_35664:
       li   hl,_34985                  ; LD HL,34985       ; Point HL at script data for Berk facing left...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk
_35670:
       movb @e,a                       ; LD A,E            ; Load A with Berk's flags
       andi a,10*256                   ; AND 10            ; If either of Berk's Facing into Screen or Facing Right flags are set...
       jne  _35681                     ; JR NZ,35681       ; ...then skip ahead to #R35681
* Drutt is to the right of Berk, and Berk's Facing into Screen and Facing Right flags are both reset
       li   hl,_34997                  ; LD HL,34997       ; Point HL at script data for Berk turning to face right...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Drutt is to the right of Berk and either of Berk's Facing into Screen or Facing Right flags are set
_35681:
       li   hl,_35005                  ; LD HL,35005       ; Point HL at script data for Berk facing right...
       b    @execute_script                    ; JP 48098          ; ...and execute
*// change_berk_direction

*********************************************************************************
* Update State of Berk and Store Current Position in Script Data
* 
* Used by the routine at #R34438.
update_berk_state:
       .proc
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of complex state data (current level) for Berk
       bl   @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Berk's current room
       movb @9(ix),tmp0                ; BIT 5,(IX+9)      ; If Berk's "Do Not Update State" Flag is set...
       andi tmp0,32*256                ;                   
       jne  update_berk_state_1        ; RET NZ            ; ...then return
       mov  @berk_script_pos,hl        ; LD HL,(35687)     ; Load current position in Berk's script data from #R35687 into HL...
       mov  hl,@current_script_addr    ; ...and store at #R34277 as position in script currently running
       bl  @update_berk_state_2        ; CALL 35735        ; Update state of Berk depending upon currently selected character, control input and currently
                                                           ; active power
       mov  @current_script_addr,@berk_script_pos ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
                                       ; LD (35687),HL     ; ...at #R35687 as current position in Berk's script data
                                       ; If Berk's current power is not invisibility (level 3)...
       cb   @berks_current_power,@bytes+11 ; CP 11             ; ...
       jne  update_berk_state_1        ; RET NZ            ; ...then return
* Current power is invisibility (Level 3)
       li   bc,_50800                  ; LD BC,50800       ; Load BC with address of blank graphic layout data...
       movb @c,@2(ix)                  ; LD (IX+2),C       ; ...and set this as Berk's current graphic layout data address...
       movb b,@3(ix)                   ; LD (IX+3),B       ; ...
       bl   @dec_power_duration        ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
update_berk_state_1:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Update State of Berk Depending Upon Currently Selected Character, Control Input and Currently Active Power
* 
* Used by the routine at #R35689. Input:  IX  Address of complex state data (current level) for Berk
update_berk_state_2:
       .proc
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If Berk's Moving Upwards Flag (floating power) is set...
       andi tmp0,128*256               ;                   
       jeq  !                          ; JP NZ,36542       ; ...then jump to #R36542 (update state of Berk,  floating power active)
       b    @update_berk_floating_power                    ;
!
       movb @9(ix),tmp0                ; BIT 0,(IX+9)      ; If Berk's Must Process Current Script Data Flag is set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is set...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,35577       ; ...then jump to #R35577 (change direction Berk is facing depending upon relative position of
       b    @change_berk_direction                         ; Drutt)
!
* Drutt Mode Flag is reset (i.e. Berk Mode)
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 0,A           ; If right has been pressed...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,36214       ; ...then skip ahead to #R36214 (move Berk right if appropriate)
       b    @attempt_to_move_right                    ;
!
       movb a,tmp0                     ; BIT 1,A           ; If left has been pressed...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,36137       ; ...then skip ahead to #R36137 (move Berk left if appropriate)
       b    @move_berk_closer_1                    ;
!
       bl   @move_into_new_room        ; CALL 54283        ; Move Berk into new room (left or right) if he is at the edge of his current room
       movb @control_input,a           ; LD A,(34219)      ; Load A with control input
       movb a,tmp0                     ; BIT 2,A           ; If forward has been pressed...
       andi tmp0,4*256                 ;                   
       jeq  !                          ; JP NZ,36036       ; ...then skip ahead to #R36036 (update state of Berk, forward pressed)
       b    @update_berk_state_16                    ;
!
       movb a,tmp0                     ; BIT 3,A           ; If back has been pressed...
       andi tmp0,8*256                 ;                   
       jeq  !                          ; JP NZ,35827       ; ...then skip ahead to #R35827
       b    @update_berk_state_7                    ;
!
* At this point, no control has been pressed. This entry point is used by the routines at #R35577, #R36036 and
* #R36116.
update_berk_state_3:
       equ  $
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is not flying...
       andi tmp0,64*256                ;                   
       jeq  update_berk_state_4        ; JR Z,35802        ; ...then skip ahead to #R35802
* Berk is flying
       szcb @bits+6,@9(ix)             ; RES 6,(IX+9)      ; Reset Berk's Is Flying Flag
       li   hl,berk_fall_script        ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script            ; JP 48098          ; ...and execute
* No control pressed and Berk not flying
update_berk_state_4:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jeq  update_berk_state_6        ; JR Z,35821        ; ...then skip ahead to #R35821
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is set
       movb @11(ix),tmp0               ; BIT 3,(IX+11)     ; If Berk's Unused (11,3) Flag is reset...
       andi tmp0,8*256                 ;                   
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
* No control pressed, Berk not flying, Berk's Facing Into Screen and Unused (11,3) flags are set This entry point is
* used by the routine at #R35577.
update_berk_state_5:
       equ  $
       li   hl,_35113                  ; LD HL,35113       ; Point HL at script data for Berk facing into screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* No control pressed, Berk not flying and Berk's Facing Into Screen Flag is reset This entry point is used by the
* routine at #R35577.
update_berk_state_6:
       li   hl,_35081                  ; LD HL,35081       ; Point HL at script data for Berk facing out of screen, ready to respond to control input...
       b    @execute_script            ; JP 48098          ; ...and execute
* Back Pressed
update_berk_state_7:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       bl   @eat                       ; CALL 36008        ; If Berk is holding an edible entity them make him eat it, process appropriate script data
                                                           ; and return to calling routine
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Temporarily decrease y-coordinate of Berk's top edge
       bl   @chk_coll_next_depth_rev   ; CALL 54890        ; Check entity at IX for collision with another entity (in reverse order) at next depth level
                                       ; into screen whose Interaction (11,7) Flag is set
       stst tmp0                       ; PUSH AF           ; Store AF
       ab   one,@4(ix)                 ; INC (IX+4)        ; Restore y-coordinate of Berk's top edge
       andi tmp0,>1000                 ; POP AF            ; Restore AF
       jne  update_berk_state_12       ; JR C,35953        ; If no collision occurred, then skip ahead to #R35953
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  update_berk_state_8        ; JR NZ,35870       ; ...then skip ahead #R35870
* Collision with door
       bl    @move_berk_closer         ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of complex state data for door at #R34256
       li   hl,_35017                  ; LD HL,35017       ; Point HL at script data for Berk interacting with a door behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
update_berk_state_8:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jhe  update_berk_state_11       ; JR NC,35924       ; ...then skip ahead to #R35924
* Collision with entity that can be picked up
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is already carrying something...
       andi tmp0,16*256                ;                   
       jeq  !                          ; JP NZ,35953       ; ...then skip ahead to #R35953
       b    @update_berk_state_12                    ;
!
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with entity then move him closer and exit this routine
* Berk is now horizontally aligned with entity pointed to by IY
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of complex state data for entity at #R34256
       movb @6(ix),b                   ; LD B,(IX+6)       ; Load B with y-coordinate of Berk's bottom edge...
       sb   one,b                      ; DEC B             ; ...minus 1 (to take into account different depth)
       movb @6(iy),a                   ; LD A,(IY+6)       ; Load A with y-coordinate of entity's bottom edge...
       cb   a,@4(ix)                   ; CP (IX+4)         ; ...and if this is less than the y-coordinate of Berk's top edge...
       jl   update_berk_state_10       ; JR C,35918        ; ...then skip ahead to #R35918
* Entity is not above Berk
       cb   a,b                        ; CP B              ; If entity's bottom edge is level with Berk's (taking into account different depth)...
       jeq  update_berk_state_9        ; JR Z,35912        ; ...then skip ahead to #R35912
* Entity is above floor and below Berk's top edge
       li   hl,_35163                  ; LD HL,35163       ; Point HL at script data for Berk picking up an entity that is above floor and below Berk's
                                                           ; top edge and behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Entity is on floor behind Berk
update_berk_state_9:
       li   hl,_35135                  ; LD HL,35135       ; Point HL at script data for Berk picking up an entity on floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Entity is above Berk
update_berk_state_10:
       li   hl,_35149                  ; LD HL,35149       ; Point HL at script data for Berk picking up an entity above and behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something that can't be picked up
update_berk_state_11:
       cb   a,@bytes+32                ; CP 32             ; If collision was not with entity of class 32 (coloured creatures' slots, Level 3)...
       jne  update_berk_state_12       ; JR NZ,35953       ; ...then skip ahead to #R35953
* Collision with a coloured creature slot
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jeq  update_berk_state_12       ; JR Z,35953        ; ...then skip ahead to #R35953
* Berk is carrying something
       bl   @move_berk_closer          ; CALL 36116        ; If Berk is not horizontally aligned with coloured creature slot then move him closer and
                                                           ; exit this routine
* Berk is now horizontally aligned with coloured creature slot and carrying something
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       movb @4(iy),a                   ; LD A,(IY+4)       ; Load A with y-coordinate of top edge of coloured creature slot... (see trivia)
       sb   one,a                      ; DEC A             ; ...minus 1...
       movb a,@berk_coloured_creature  ; LD (34222),A      ; ...and store at #R34222
       li   hl,_35235                  ; LD HL,35235       ; Point HL at script data for Berk putting an entity down above floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision, collision with non-interactive entity or interaction conditions not met
update_berk_state_12:
       movb @berks_current_power,a     ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  update_berk_state_13       ; JR Z,35969        ; ...then skip ahead to #R35969
       cb   a,@bytes+4                 ; CP 4              ; If Berk's current power is 1-3 (jumping)...
       jhe  !                          ; JP C,35995        ; ...then skip ahead to #R35995
       b    @update_berk_state_15      ;
!
       cb   a,@bytes+9                 ; CP 9              ; If Berk's current power is 4-8 (flying)...
       jhe  !                          ; JP C,35985        ; ...then skip ahead to #R35985
       b    @update_berk_state_14      ;
!
* Berk has neither jumping nor flying power
update_berk_state_13:
       equ  $
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen
       b    @update_berk_state_3                           ; as appropriate)
!

* Berk is carrying something
       bl   @turn_into_screen          ; CALL 36367        ; If Berk is neither facing into the screen nor walking then exit this routine and have Berk
                                                           ; turn into screen
       li   hl,_35219                  ; LD HL,35219       ; Point HL at script data for Berk putting an entity down on floor behind him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk's current power is flying
update_berk_state_14:
       socb @bits+6,@9(ix)             ; SET 6,(IX+9)      ; Set Berk's Is Flying Flag
       li   hl,_35417                  ; LD HL,35417       ; Point HL at script data for Berk starting to fly...
       b    @execute_script            ; JP 48098          ; ...and execute
* Berk's current power is jumping
update_berk_state_15:
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       movb @bytes+129,@12(ix)         ; LD (IX+12),129    ; Set Berk's Is Jumping Flag and set initial jump velocity to 1
       li   hl,_35441                  ; LD HL,35441       ; Point HL at script data for Berk starting to jump straight up...
       b    @execute_script            ; JP 48098          ; ...and execute

* Update State of Berk (Forward Pressed)
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
update_berk_state_16:
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is reset...
       andi tmp0,2*256                 ;                   
       jne  !                          ; JP Z,36049        ; ...then skip ahead to #R36049
       b    @update_berk_state_17                    ;
!
* Berk's Facing Into Screen Flag is set
       li   hl,_35073                  ; LD HL,35073       ; Point HL at script data for Berk turning (facing into screen to facing out of screen)...
       b    @execute_script                    ; JP 48098          ; ...and execute
* Berk's Facing Into Screen Flag is reset
update_berk_state_17:
       li   de,0                       ; LD DE,0           ; Clear pointer to complex state data for entity involved in last collision check...
       mov  de,@coll_entity_addr       ; LD (34258),DE     ; ...
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       joc  update_berk_state_19                     ; JR C,36103        ; ...and if no collision occurred, then skip ahead to #R36103
* Collision occurred
       cb   a,@bytes+33                ; CP 33             ; If collision was not with an entity of class 33 (door)...
       jne  update_berk_state_18                     ; JR NZ,36078       ; ...then skip ahead to #R36078
* Collision with door
       bl   @move_berk_closer                   ; CALL 36116        ; If Berk is not horizontally aligned with door then move him closer and exit this routine
* Berk is now horizontally aligned with door
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of door's complex state data at #R34256
       li   hl,_35045                  ; LD HL,35045       ; Point HL at script data for Berk interacting with a door in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision with something other than door
update_berk_state_18:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk's Carrying Something Flag is set...
       andi tmp0,16*256                ;                   
       jeq  !                          ; JP NZ,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of 22 or greater (can't be picked up)...
       jl   !                          ; JP NC,35786       ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
* At this point, Berk is not carrying anything, and the entity he is colliding with is one which can be picked up
       bl   @move_berk_closer                   ; CALL 36116        ; If Berk is not horizontally aligned with entity at IY then move him closer and exit this
                                                           ; routine
* Berk is now horizontally aligned with entity pointed to by IY
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; Store address of entity's complex state data at #R34256
       li   hl,_35187                  ; LD HL,35187       ; Point HL at script data for Berk picking up an entity on floor in front of him...
       b    @execute_script            ; JP 48098          ; ...and execute
* No collision occurred
update_berk_state_19:
       movb @9(ix),tmp0                ; BIT 4,(IX+9)      ; If Berk is not carrying anything...
       andi tmp0,16*256                ;                   
       jne  !                          ; JP Z,35786        ; ...then jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
       b    @update_berk_state_3                    ;
!
                                                           ; appropriate)
* Berk is carrying something
       li   hl,_35205                  ; LD HL,35205       ; Point HL at script data for Berk putting an entity down on floor in front of him...
       b    @execute_script                    ; JP 48098          ; ...and execute
*// update_berk_state - cont

*********************************************************************************
* Make Berk Eat the Entity He is Holding, if Edible, and Exit Calling Routine
*
* Used by the routine at #R35735.
eat:
       .proc
       movb @berk_entity_held,a        ; LD A,(34221)      ; If Berk is not holding anything...
       socb a,a                        ; OR A              ; ...
       jeq  eat_1                      ; RET Z             ; ...then return
       cb   a,@bytes+12                ; CP 12             ; If class value of entity held by Berk is greater than 12...
       jhe  eat_1                      ; RET NC            ; ...then return
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @move_carried_to_front    ; CALL 48710         ; Move carried entity in front of Berk as he faces out of screen
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity held by Berk
       sb   one,@4(iy)                 ; DEC (IY+4)        ; Move entity up one character to level of Berk's mouth...
       sb   one,@6(iy)                 ; DEC (IY+6)        ; ...
       li   hl,_35493                  ; LD HL,35493       ; Point HL at script data for Berk eating an entity...
       b    @execute_script            ; JP 48098          ; ...and execute
eat_1:
       .endproc
*// eat

*********************************************************************************
* If Berk is Not Horizontally Aligned with Entity at IY then Move Berk Closer and Exit Calling Routine
* 
* Used by the routines at #R35735 and #R36036. Input:  IX  Address of complex state data (current level) for Berk IY
* Address of complex state data for entity with which Berk has collided
move_berk_closer:
       .proc
       movb @7(iy),a                   ; LD A,(IY+7)       ; Load A with width of entity at IY, minus 1...
       sb   @5(iy),a                   ; SUB (IY+5)        ; ...
       srl  a,1                        ; SRL A             ; ...divide value by 2...
       sb   @bytes+2,a                 ; SUB 2             ; ...and subtract 2
       ab   @5(iy),a                   ; ADD A,(IY+5)      ; Add result to x-coordinate of entity's left edge
* At this point, A holds the x-coordinate of the middle of the entity at IY, minus two
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate in A is the same as Berk's left side x-coordinate...
       jne  !                          ; RET Z             ; ...then return
       .endproc                            ;
!
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       cb   a,@5(ix)
       jl   move_berk_closer_1         ; JP NC,36214       ; If x-coordinate in A is the less than Berk's left side x-coordinate then skip ahead to
       b    @attempt_to_move_right     ;                   ; #R36214

* This entry point is used by the routine at #R35735. Attempt to move Berk left
move_berk_closer_1:
       equ  $
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jne  attempt_to_move_left       ; JR NZ,36200       ; ...then skip ahead to #R36200
* Attempt to move Berk left (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  move_berk_closer_3         ; JR NC,36171       ; ...and if a collision occurred, then skip ahead to #R36171
* No collision
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk into room to the left, if appropriate...
       joc  move_berk_closer_2         ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @update_berk_state_3       ;                   ; him (turn to) face out of screen as appropriate)
move_berk_closer_2:
       equ  $
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is already set...
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_35263                  ; LD HL,35263       ; Point HL at script data for Berk starting to walk left...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision occurred with entity to the left
move_berk_closer_3:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  move_berk_closer_4         ; JR NZ,36184       ; ...then skip ahead to #R36184
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   hl,_35291                  ; LD HL,35291       ; Point HL at script data for Berk starting to fall to the left...
       b    @execute_script            ; JP 48098          ; ...and execute
move_berk_closer_4:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   move_berk_closer_2         ; JR C,36158        ; ...then jump back to #R36158
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  move_berk_closer_2         ; JR Z,36158        ; ...then jump back to #R36158
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @set_berk_killed           ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk left (flying)
attempt_to_move_left:
       bl    @chk_coll_left            ; CALL 54666        ; Check Berk for collision with another impassable / pushable entity immediately to the left...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;                   
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;                   
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* This entry point is used by the routine at #R35735. Attempt to move Berk right
attempt_to_move_right:
       movb @9(ix),tmp0                ; BIT 6,(IX+9)      ; If Berk is flying...
       andi tmp0,64*256                ;                   
       jeq  !                          ; JP NZ,36282       ; ...then skip ahead to #R36282
       b    @move_berk_closer_8                    ;
!
* Attempt to move Berk right (not flying) (see bugs)
       szcb @bits+1,@9(ix)             ; RES 1,(IX+9)      ; Reset Berk's Facing Into Screen Flag
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  move_berk_closer_6         ; JR NC,36249       ; ...and if a collision occurred, then skip ahead to #R36249
* No collision
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk into room to the right, if appropriate...
       joc  !                          ; JP NC,35786       ; ...and if Berk can't enter new room then jump to #R35786 (terminate Berk's flight, or have
       b    @update_berk_state_3                           ; him (turn to) face out of screen as appropriate)
!

move_berk_closer_5:
       equ  $
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is already set...
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,48096       ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_35251                  ; LD HL,35251       ; Point HL at script data for Berk starting to walk right...
       b    @execute_script            ; JP 48098          ; ...and execute
* Collision occurred with entity to the right
move_berk_closer_6:
       cb   a,@bytes+129               ; CP 129            ; If collision was not with entity of class 129 (causes other entities to start falling)...
       jne  move_berk_closer_7         ; JR NZ,36266       ; ...then skip ahead to #R36266
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       mov  @bert_held_state,iy        ; LD IY,(34260)     ; Load IY with address of complex state data for entity last held by Berk (see trivia)
       li   hl,_35327                  ; LD HL,35327       ; Point HL at script data for Berk starting to fall to the right...
       b    @execute_script            ; JP 48098          ; ...and execute
move_berk_closer_7:
       cb   a,@bytes+22                ; CP 22             ; If collision was with an entity of class of less than 22 (can be picked up)...
       jl   move_berk_closer_5         ; JR C,36236        ; ...then jump back to #R36236
       cb   a,@bytes+50                ; CP 50             ; If collision was with entity of class 50 (causes Drutt to swap depth levels)...
       jeq  move_berk_closer_5         ; JR Z,36236        ; ...then jump back to #R36236
       cb   a,@bytes+25                ; CP 25             ; If collision was with entity of class 25 (Green Apebeast, Level 2)...
       jne  !                          ; CALL Z,53667      ; ...then set "Berk Has Been Killed" Flag
       bl   @set_berk_killed           ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
* Attempt to move Berk right (flying)
move_berk_closer_8:
       bl   @chk_coll_right            ; CALL 54569        ; Check Berk for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  !                          ; JP C,48096        ; ...and if a collision has not occurred, then jump to #R48096 (advance HL to next script
       b    @inct_execute_script       ;
!
                                                           ; instruction and execute)
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       b    @update_berk_state_3       ; JP 35786          ; Jump to #R35786 (terminate Berk's flight, or have him (turn to) face out of screen as
                                                           ; appropriate)
*// move_berk_closer

*********************************************************************************
* If Berk is Neither Facing into the Screen nor Walking then Exit Calling Routine and Have Berk Turn into Screen
* 
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
turn_into_screen:
       .proc
       movb @9(ix),tmp0                ; BIT 1,(IX+9)      ; If Berk's Facing Into Screen Flag is set...
       andi tmp0,2*256                 ;                   
       jne  turn_into_screen_1         ; RET NZ            ; ...then return
       movb @11(ix),a                  ; LD A,(IX+11)      ; If either of Berk's Walking Left or Walking Right flags is set...
       andi a,3*256                    ; AND 3             ; ...
       jne  turn_into_screen_1         ; RET NZ            ; ...then return
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       li   hl,_35105                  ; LD HL,35105       ; Point HL at script data for Berk turning (facing out of screen to facing into screen)...
       b    @execute_script            ; JP 48098          ; ...and execute
turn_into_screen_1:
       .endproc
*// turn_into_screen

*********************************************************************************
* Update State of Berk (Floating Power Active)
*
* Used by the routine at #R35735. Input:  IX  Address of complex state data (current level) for Berk
update_berk_floating_power:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
       cb   a,@bytes+130               ; CP 130            ; ...and if collision was with entity of class 130 (causes Berk and Drutt to bounce off or bang
                                                           ; head)...
       jeq  _36558                     ; JR Z,36558        ; ...then skip ahead to #R36558
* No collision with entity of class 130
       sb   one,@4(ix)                 ; DEC (IX+4)        ; Move Berk up one character...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @change_room_up                   ; CALL 55433        ; Change Berk's room up one if appropriate
_36558:
       movb @11(ix),tmp0               ; BIT 1,(IX+11)     ; If Berk's Walking Left Flag is set...
       andi tmp0,2*256                 ;
       jne  _36587                     ; JR NZ,36587       ; ...then skip ahead to #R36587
       movb @11(ix),tmp0               ; BIT 0,(IX+11)     ; If Berk's Walking Right Flag is set...
       andi tmp0,1*256                 ;
       jne  _36576                     ; JR NZ,36576       ; ...then skip ahead to #R36576
       bl    @dec_power_duration                   ; CALL 48388        ; Decrease remaining time for current power and if zero, exit this routine and run script data
                                                           ; for removal of power
       b    @inct_execute_script       ; JP 48096          ; Advance HL to next script instruction and execute
* Berk's Walking Right Flag is set (i.e. Drutt has pushed Berk right)
_36576:
       ab   one,@5(ix)                 ; INC (IX+5)        ; Move Berk's left and right sides right by one character...
       ab   one,@7(ix)                 ; INC (IX+7)        ; ...
       bl   @move_into_right_room      ; CALL 54313        ; Move Berk at IX into room to the right, if appropriate
       jmp  _36596                     ; JR 36596          ; Skip ahead to #R36596
* Berk's Walking Left Flag is set (i.e. Drutt has pushed Berk left)
_36587:
       sb   one,@5(ix)                 ; DEC (IX+5)        ; Move Berk's left and right sides left by one character...
       sb   one,@7(ix)                 ; DEC (IX+7)        ; ...
       bl   @move_into_left_room       ; CALL 54348        ; Move Berk at IX into room to the left, if appropriate
_36596:
       sb   one,@12(ix)                ; DEC (IX+12)       ; Decrease remaining horizontal distance from Drutt's push...
       jeq  !                          ; JP NZ,48096       ; ...and if not zero then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script       ;
!
       movb one,a                      ; LD A,1            ; Set remaining power duration to 1...
       movb a,@remaining_power_groups  ; LD (34225),A      ; ...
       b    @script_routine_10         ; JP 48212          ; Reset Berk's Walking Left and Walking Right flags, advance HL to next script instruction and
                                                           ; execute
*********************************************************************************
* Advance to Next Level and if Back to Level 1 then Exit Calling Routine and Make Berk Start Falling
* 
* Used by the routine at #R36390.
next_level:
       .proc
                                       ; LD A,(34208)      ; Set Update Scores and Display Flag...
       socb @bits+5,@game_flags        ; SET 5,A           ; ...
                                       ; LD (34208),A      ; ...
       mov  @bert_interaction_state,iy ; LD IY,(34256)     ; Load IY with address of complex state data for Door just interacted with
       movb @9(iy),a                   ; LD A,(IY+9)       ; Load A with destination level from Door's state data...
       movb a,@current_level           ; LD (34207),A      ; ...and set current level to this value
       cb   a,one                      ; CP 1              ; If destination level is not Level 1...
       jne  next_level_1               ; JR NZ,36725       ; ...then skip ahead to #R36725
* Destination level is Level 1 (i.e. Level 4 completed)
       bl   @align_with_level_1_door   ; CALL 36753        ; Load IX with address of Berk's complex state data and set his horizontal position to match
                                                           ; Level 1's entry door
       socb @bits+2,@10(ix)            ; SET 2,(IX+10)     ; Set "Back to Level 1" Flag
       movb @bytes+10,*ix              ; LD (IX+0),10      ; Set Berk's room to 10
       movb @bytes+103,@4(ix)          ; LD (IX+4),103     ; Set y-coordinate of Berk's top edge to 103
       movb @bytes+109,@6(ix)          ; LD (IX+6),109     ; Set y-coordinate of Berk's bottom edge to 109
       li   iy,bonis_state_data_1      ; LD IY,43606       ; Load IY with address of Boni's entry in Level 1's State Data for Complex Entities...
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       bl   @position_carried_item     ; CALL 48850        ; Have Berk hold Boni, and position him appropriately between Berk's hands
       movb one,@1(iy)                 ; LD (IY+1),1       ; Set Boni's depth to 1
       movb @bytes+10,*iy              ; LD (IY+0),10      ; Set Boni's room to 10
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       bl   @prepare_falling           ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
       bl   @lock_level_1_exit_door    ; CALL 36739        ; Lock Level 1's exit door and cycle attributes (full-screen)
       .ifne start_at_level,5
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       .endif
       li   hl,init_drutts_state_data_1 ; LD HL,36625       ; Overwrite Drutt's entry in Level 1's State Data for Complex Entities with data at #R36625...
       li   de,drutts_state_data_1     ; LD DE,43671       ; ...
       li   bc,13                      ; LD BC,13          ; ...
       .ldir                           ; LDIR              ; ...
       li   hl,berk_fall_script        ; LD HL,35359       ; Point HL at script data for Berk starting to fall downwards...
       b    @execute_script            ; JP 48098          ; ...and execute
* Destination level is not Level 1
next_level_1:
       bl   @align_with_level_1_door   ; CALL 36753        ; Set Berk's horizontal position to match Level 1's entry door
       mov  @drutt_state_addr,iy       ; LD IY,(34242)     ; Load IY with address of current level's complex state data for Drutt...
       mov  iy,@bert_interaction_state ; LD (34256),IY     ; ...and store at #R34256
       bl   @position_carried_item     ; CALL 48850        ; Have Berk hold Drutt, and position him appropriately between Berk's hands
       jmp  !
lock_level_1_exit_door:
       .proc
!      li   hl,game_flags              ; LD HL,34208       ; Reset Level Exit Door Unlocked Flag...
       szcb @bits+4,*hl                ; RES 4,(HL)        ; ...
       movb @bytes+5,a                 ; LD A,5            ; Set door colour to 5 (cyan, i.e. locked)...
       movb a,@_50711+1                ; LD (50712),A      ; ...
       bl   @cycle_colors_and_refresh  ; CALL 36616        ; Cycle attributes (full-screen), clear display buffers and paint red areas outside current
                                                           ; room
       .endproc                        ; RET               ; Return

*********************************************************************************
* Set Berk's Horizontal Position to Match Level 1's Entry Door
* 
* Used by the routine at #R36638.
align_with_level_1_door:
       .proc
       bl   @init_level_data           ; CALL 34864        ; Copy start addresses of current level's data blocks to #R34236 and clean up old data
       movb @bytes+33,a                ; LD A,33           ; Load IY with address of complex state data for first entity that has class of 33 (Entry
                                                           ; Door)...
       bl   @find_1st_entity_of_class                   ; CALL 54019        ; ...
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with start address of current level's complex state data for Berk
       movb @5(iy),a                   ; LD A,(IY+5)       ; Load A with x-coordinate of left of Entry Door...
       ab   one,a                      ; INC A             ; ...and add one
       movb a,@5(ix)                   ; LD (IX+5),A       ; Adjust Berk's horizontal position so that his left side is at coordinate in A...
       ab   @bytes+5,a                 ; ADD A,5           ; ...and his right side is 5 characters to the right of this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...
       .endproc                        ; RET               ; Return

*********************************************************************************
* Initialise Script Data Positions for Flying Skeleton Creature and Bat (Level 1)
* 
* Used by the routine at #R34751.
reset_skeleton_and_bat:
       li   hl,boni_kidnap_script      ; LD HL,36803       ; Load HL with start address of script data for Boni's kidnap...
       mov  hl,@boni_kidnap_script_pos ; LD (36801),HL     ; ...and store this as the current script data position at #R36801
       li   hl,bat_script              ; LD HL,37018       ; Load HL with start address of script data for Bat (not attacking)...
       mov  hl,@bat_script_pos         ; LD (37016),HL     ; ...and store this as the current script data position at #R37016
       rt                              ; RET               ; Return
*// reset_skeleton_and_bat

*********************************************************************************
* Reset Skeleton to Initial State
* 
* Used by the routine at #R34751.
reset_skeleton:
       li   hl,skeleton_idling_script  ; LD HL,41232       ; Set current position in Skeleton's script data...
       mov  hl,@skeleton_script_pos    ; LD (41230),HL     ; ...to #R41232 (Skeleton Idling)
       li   ix,_41412                  ; LD IX,41412       ; Load IX with address of Table of Addresses of Attribute Data in Skeleton's GLD Blocks
       li   bc,6                       ; LD B,6            ; Load B with 6 (as there are six blocks of graphic layout data to modify)
reset_skeleton_1:
       mov  *ix,hl                     ; LD L,(IX+0)       ; Load HL with address of attribute data in current block...
                                       ; LD H,(IX+1)       ; ...
       movb @bytes+7,*hl               ; LD (HL),7         ; Set the attribute value to 7 (white)
       inct ix                         ; INC IX            ; Advance IX to next address...
                                       ; INC IX            ; ...
       dec  bc                         ; DJNZ 41366        ; Decrease remaining number of blocks to modify and loop back to #R41366 if not zero
       jne  reset_skeleton_1           ;
       rt                              ; RET               ; Return
*// reset_skeleton

*********************************************************************************
* Populate Primary Display Buffer with Layout Data for Current Character's Current Room
* 
* Used by the routine at #R34438.
populate_display_buffer:
       .proc
       ; LD HL,(34279)                 ; Modify instruction at #R46045 with address of Primary Display Buffer..
                                       ; LD (46046),HL     ; ...
       movb @tmp_room_dim_data,@c      ; LD A,(34230)      ; Load C with depth of current character's current room...
                                       ; LD C,A            ; ...
       movb @current_characters_room,b ; LD A,(34218)      ; Load B with index of current character's current room...
                                       ; LD B,A            ; ...
       sb   d,d                        ; LD D,0            ; Load D with zero
* Start drawing simple entities
populate_display_buffer_1:
       mov  @current_data_addrs,ix     ; LD IX,(34236)     ; Load IX with start address of current level's simple state data
       movb @bytes+6,@e                ; LD E,6            ; Load DE with 6 (as simple state data entries are 6 bytes wide)
populate_display_buffer_2:
       movb *ix,a                      ; LD A,(IX+0)       ; Load first byte of current simple state data entry into A
       cb   a,@bytes+255               ; CP 255            ; If this is 255 (end marker for complex state data)...
       jeq  populate_display_buffer_5  ; JR Z,45961        ; ...then skip ahead to #R45961
       cb   a,@bytes+254               ; CP 254            ; If it is not 254 (end marker for level's simple state data)...
       jne  populate_display_buffer_3  ; JR NZ,45939       ; ...then skip ahead to #R45939
* At this point, we have passed the end marker for the simple state data block and are now at the start of the
* complex state data block whose entries are 13 bytes wide.
       movb @bytes+13,@e               ; LD E,13           ; Load DE with 13
       inc  ix                         ; INC IX            ; Advance IX to start of complex state data block
       movb *ix,a                      ; LD A,(IX+0)       ; Load A with entity's room index
* At this point, A holds the index of the room to which the simple or complex entity belongs
populate_display_buffer_3:
       cb   a,b                        ; CP B              ; If entity's room is not the same as the current character's current room...
       jne  populate_display_buffer_4  ; JR NZ,45957       ; ...then skip ahead to #R45957
       movb @c,a                       ; LD A,C            ; If entity's depth is not the same as current depth in C...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  populate_display_buffer_4  ; JR NZ,45957       ; ...then skip ahead to #R45957
       .exx                            ; EXX               ; Switch registers
       .push ix                        ; PUSH IX           ; Store IX (pointer to current entry in simple/complex state data)
       bl   @draw_entity               ; CALL 45965        ; Load Primary Display Buffer with graphic layout data for current entity
       .pop ix                         ; POP IX            ; Restore IX (pointer to current entry in simple/complex state data)
       .exx                            ; EXX               ; Switch registers
populate_display_buffer_4:
       a    de,ix                      ; ADD IX,DE         ; Advance IX to next entity's state data
       jmp  populate_display_buffer_2  ; JR 45921          ; Loop back to #R45921
populate_display_buffer_5:
       sb   one,@c                     ; DEC C             ; Decrease current depth (i.e. closer to screen)
       jne  populate_display_buffer_1  ; JR NZ,45915       ; If depth is not zero (i.e. still depth levels to process) then loop back to #R45915
       .endproc                        ; RET               ; Return

*********************************************************************************
* Populate Primary Display Buffer with Graphic Layout Data for Entity Whose Simple / Complex State Data is at
* Address in IX
* 
* Used by the routine at #R45899. Input:  IX  Address of complex state data for an entity IX  (Entry at #R45999,
* #R46001 or #R46003 only) Address of graphic layout data to draw B  (Entry at #R45999, #R46001 or #R46003 only) 0
* if current position in Display Buffer needs to be recalculated. 1 otherwise.
draw_entity:
       .proc
       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load DE with address of graphic layout data for entity...
       movb @3(ix),d                   ; LD D,(IX+3)       ; ...
       movb @tmp_room_dim_data+3,a     ; LD A,(34233)      ; Load A with y-coordinate of top edge of current character's current room...
       ab   @4(ix),a                   ; ADD A,(IX+4)      ; ...add y-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,@l                       ; LD L,A            ; ...and load into L
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load A with x-coordinate of left edge of current character's current room...
       ab   @5(ix),a                   ; ADD A,(IX+5)      ; ...add x-coordinate of graphic element to draw as offset...
       sb   @bytes+100,a               ; SUB 100           ; ...subtract 100...
       movb a,h                        ; LD H,A            ; ...and load into H
       swpb hl                         ; Big endian
       mov  hl,@draw_coordinates       ; LD (34281),HL     ; Store x- and y-coordinates at #R34281
       swpb hl                         ; Little endian
       mov  de,ix                      ; PUSH DE           ; Transfer address of graphic layout data in simple/complex state data from DE...
                                       ; POP IX            ; ...into IX
       sb   b,b                        ; LD B,0            ; Reset Do Not Recalculate Display Buffer Address Flag, as address not yet calculated
       jmp  execute_gfx_script         ; JR 46003          ; Jump to #R46003 (read / process data at address in IX)
* This entry point is used by the routines at #R46427, #R46442, #R46460 and #R46599.
inct_execute_gfx_script:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46284, #R46295 and #R46306.
inc_execute_gfx_script:
       inc  ix                         ; INC IX            ; Advance IX by one byte
* This entry point is used by the routines at #R46317, #R46347, #R46363, #R46460, #R46481, #R46495, #R46611,
* #R46628, #R46647 and #R46664.
execute_gfx_script:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of graphic layout data entry is at least 236...
       cb   a,@bytes+236               ; CP 236            ; ...i.e. IX points to an instruction...
       jl   draw_graphics              ; JP NC,46218       ; ...then jump to appropriate graphic layout routine
       b    @jump_to_graphics_routine                    ;
* For recursive call
process_data_in_ix_call:
       .proc
       jmp  execute_gfx_script

*********************************************************************************
* At this point, the graphic layout data pointed to by IX is graphical data, not an instruction. We only draw the
* graphics if they lie within the display area (i.e. have x- and y-coordinates less than 32 and 24 respectively, see
* trivia).
draw_graphics:
                                       ; LD A,H            ; If x-coordinate of graphic to draw is 32 or more...
       cb   h,@bytes+32                ; CP 32             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
                                       ; LD A,L            ; If y-coordinate of graphic to draw is 24 or more...
       cb   @l,@bytes+22               ; CP 24             ; ...
       jhe  draw_graphics_9            ; JP NC,46151       ; ...then skip ahead to #R46151
       .push hl                        ; PUSH HL           ; Store HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
       sb   one,b                      ; DEC B             ; Decrease value of Don't Recalculate Display Buffer Address Flag
       jeq  draw_graphics_1            ; JP Z,46051        ; If B is zero (i.e. we don't need to recalculate current position in display buffer), then
                                       ;                   ; skip ahead to #R46051
* If B was 1, then we need to load DE with the address of the current position in the Primary Display Buffer.
       clr  de
       movb h,@e
       mov  de,tmp0
       a    tmp0,tmp0
       a    tmp0,de
       movb @l,@r0lb
       mpy  @w96,tmp0
       a    tmp1,de
;       movb h,a                        ; LD A,H            ; Load C with three times entity's x-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   h,a                        ; ADD A,H           ; ...
;       movb a,@c                       ; LD C,A            ; ...
;       movb @l,a                       ; LD A,L            ; Load DE with double entity's y-coordinate...
;       ab   a,a                        ; ADD A,A           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       sb   d,d                        ; LD D,0            ; ...
;       movb d,b                        ; LD B,D            ; Set B to zero (BC now holds three times x-coordinate)
;       li   hl,multiples_of_96         ; LD HL,46170       ; Point HL at start of Table of Multiples of 96
;       a    de,hl                      ; ADD HL,DE         ; Add double y-coordinate as offset
;       mov  *hl,de                     ; LD E,(HL)         ; Load DE with corresponding multiple of 96...
;                                       ; INC HL            ; ...
;                                       ; LD D,(HL)         ; ...
* The operand of the instruction at #R46045 represents the address of the Primary Display Buffer. This is modified
* by the instruction at #R45902.
       a    @prim_disp_buffer_addr,de
;       li   hl,0                       ; LD HL,0           ; Load HL with start address of Primary Display Buffer
;       a    de,hl                      ; ADD HL,DE         ; Move HL to position in Primary Display Buffer corresponding to x- and y-coordinates of
;                                                           ; entity...
;       a    bc,hl                      ; ADD HL,BC         ; ...
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now points to position in Primary Display Buffer for current entity) and HL
draw_graphics_1:
       movb *de,a                      ; LD A,(DE)         ; Load A with Graphic Set Index plus one from this entry in Primary Display Buffer...
                                       ; INC A             ; ...and if value is now zero (i.e. old value was 255 corresponding to a block outside
                                                           ; dimensions of room)...
       jlt  draw_graphics_8            ; JP Z,46150        ; ...then skip ahead to #R46150
       movb @graphic_set_index,*de+    ; LD A,(34268)      ; Load current Graphic Set Index into this location in Primary Display Buffer...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to Graphic Index in current character block's entry in Primary Display Buffer
       movb *ix,*de+                   ; LD A,(IX+0)       ; Load Graphic Index into current Display Buffer location...
                                       ; LD (DE),A         ; ...
                                       ; INC DE            ; Advance to next byte in current character block's display buffer entry (Attribute)
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_2            ; JR NZ,46077       ; ...then skip ahead to #R46077
* Current Attribute is zero (i.e. not set) so DE points to attribute data
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)...
       movb *ix,a                      ; LD A,(IX+0)       ; ...and load into A
* At this point, A holds an attribute value either from the graphic layout data, or the Current Attribute as stored
* at #R34270. This attribute is to be applied to the current display buffer location. IX (current position in
* graphic layout data) is pointing to either the graphic index (if the Current Attribute at #R34270 is set) or the
* attribute data (if the Current Attribute is not set). In either case, IX+1 is the address of the Cursor Shift
* byte. Bit 7 of the Cursor Shift byte is the Override Attribute Flag.
draw_graphics_2:
       movb @1(ix),tmp0                ; BIT 7,(IX+1)      ; If bit 7 (Override Attribute Flag) is set...
                                       ;
       jlt  draw_graphics_4            ; JP NZ,46111       ; ...then skip ahead to #R46111
* Override Attribute Flag reset
       movb a,tmp0                     ; LD L,A            ; Load L with attribute value
       czc  @paper_bits,a
                                       ; AND 56            ; Check PAPER bits
                                       ; LD A,L            ; Restore attribute value to A
       jne  draw_graphics_4            ; JP NZ,46111       ; If PAPER is not zero (i.e. black) then skip ahead to #R46111
* The instructions between #R46091 and #R46110 (inclusive) are executed only when the PAPER component of the
* attribute in A (and L) is black. If the Preserve INK Flag is reset in the attribute value loaded (at #R46098) from
* the Display Buffer, then the instruction at #R46107 will leave the reset (i.e. black) PAPER bits in A. If the
* Preserve INK Flag is set, then the instructions between #R46104 and #R46106 (inclusive) will shift the bits used
* for INK into the PAPER positions and this PAPER colour (originally INK colour) will be preserved when the
* instruction at #R46107 is executed.
       andi a,192*256                  ; AND 192           ; Reset all bits except Preserve INK and Mirror flags
       movb a,b                        ; LD B,A            ; Load B with Preserve INK and Mirror flags
                                       ; LD A,L            ; Restore attribute value to A
       andi tmp0,63*256                ; AND 63            ; Reset bits Preserve INK and Mirror flags
                                       ; LD C,A            ; Load C with INK and PAPER bits of attribute value
       movb *de,a                      ; LD A,(DE)         ; Load value currently in Display Buffer into A...
       czc  @preserve_ink_flag,a       ; BIT 6,A           ; ...and if Preserve INK Flag is reset...
                                       ;
       jeq  draw_graphics_3            ; JP Z,46107        ; ...then skip ahead to #R46107
* Preserve INK Flag set in Display Buffer
       sla  a,3                        ; ADD A,A           ; Shift INK bits into PAPER bits...
                                       ; ADD A,A           ; ...
                                       ; ADD A,A           ; ...
draw_graphics_3:
       andi a,56*256                   ; AND 56            ; Reset all except PAPER bits
       socb b,a                        ; OR B              ; (Re)set Preserve INK and Mirror flags as stored in B previously
       socb tmp0,a                     ; OR C              ; Set INK bits as stored in C previously (PAPER was black)
draw_graphics_4:
       movb a,*de                      ; LD (DE),A         ; Load attribute in A into Display Buffer
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
* Read Cursor Shift byte. Bits 0-6 of this byte control where the cursor to write to Primary Display Buffer is moved
* to after writing the current character block. A value of 33 advances the cursor right by one character. A value,
* n, less than 33 moves the cursor down a character row, and left by 33-(n+1) characters. A value greater than 33
* moves the cursor right by (n+1)-33 characters. Bit 7 is the Override Attribute Flag.
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       cb   a,@bytes+255               ; CP 255            ; ...and if this is 255 (End Marker)...
       jne  draw_graphics_4a           ; JP Z,46418        ; ...then jump to #R46418 (load HL with stored coordinates from #R34281 and return from
       b    @graphics_routine_255                          ; drawing)
draw_graphics_4a:
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33, and if remaining value is 0 (i.e. original value was 33)...
       jeq  draw_graphics_7            ; JP Z,46140        ; ...then skip ahead to #R46140...
draw_graphics_5:
       cb   tmp0,@bytes+33
       jhe  draw_graphics_6            ; JP NC,46132       ; ...else, if value was greater than 33 then skip ahead to #R46132
* Cursor Shift byte was less than 33 (move the cursor down a character row, and left by 33-(n+1) characters)
       ab   one,@l                     ; INC L             ; Increase y-coordinate
draw_graphics_6:
       ab   one,a                      ; INC A             ; Increase A (x-coordinate offset) and add to x-coordinate...
       ab   h,a                        ; ADD A,H           ; ...
       movb a,h                        ; LD H,A            ; ...
       sb   b,b                        ; LD B,0            ; Prepare to recalculate Display Buffer address as change in coordinates is non-trivial
       b    @inct_execute_gfx_script     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* Cursor Shift byte was 33 (move the cursor right by one character)
draw_graphics_7:
       inc  de                         ; INC DE            ; Advance pointer to start of next entry in Primary Display Buffer
       ab   one,h                      ; INC H             ; Increase x-coordinate by one
                                       ; JP Z,46135        ; If x-coordinate is zero then jump back to #R46135 (see trivia)
       movb one,b                      ; LD B,1            ; Prepare to skip over recalculation of Display Buffer address as we moved right one character
       b    @inct_execute_gfx_script     ; JP 45999          ; Advance graphic layout data pointer by two bytes and read / process next data
* First byte in Primary Display Buffer entry for current position is 255 (i.e. outside dimensions of room)
draw_graphics_8:
       .pop hl                         ; POP HL            ; Restore HL (H = x-coordinate to draw to, L = y-coordinate to draw to)
draw_graphics_9:
       movb @current_attr,a            ; LD A,(34270)      ; Load Current Attribute into A...
                                       ; OR A              ; ...and if not zero...
       jne  draw_graphics_10           ; JP NZ,46160       ; ...then skip ahead to #R46160
       inc  ix                         ; INC IX            ; Advance IX to next byte in graphic layout data (attribute)
draw_graphics_10:
       movb @1(ix),a                   ; LD A,(IX+1)       ; Load A with Cursor Shift byte...
       andi a,127*256                  ; AND 127           ; Reset bit 7 (Override Attribute Flag)
       mov  a,tmp0                     ; required
       sb   @bytes+33,a                ; SUB 33            ; Subtract 33...
       jmp  draw_graphics_5            ; JP 46128          ; ...and jump back to #R46128 to update current drawing position

*********************************************************************************
* Jump to Appropriate Graphic Layout Routine
* 
* Used by the routine at #R45965. Input:  A  Index of graphic layout data instruction IX  Address of current graphic
* layout data instruction
jump_to_graphics_routine:
       inc  ix                         ; INC IX            ; Advance IX to first parameter byte in graphic layout data
       sb   @bytes+236,a               ; SUB 236           ; Subtract 236 to get zero-based index of required instruction
       ab   a,a                        ; ADD A,A           ; Load double index of graphic layout data instruction into BC...
       movb a,@c                       ; LD C,A            ; ...
       sb   b,b                        ; LD B,0            ; ...
                                       ; PUSH HL           ; Store HL
       mov  @graphic_routines_jmp_tbl(bc),bc ; LD HL,46244       ; Point HL at start of Table of Addresses of Graphic Layout Data Handling Routines
       b    *bc                        ; ADD HL,BC         ; Add doubled instruction index as offset to HL to point to address of required routine
                                       ; LD A,(HL)         ; Modify JP instruction at #R46241 with this address...
                                       ; LD (46242),A      ; ...
                                       ; INC HL            ; ...
                                       ; LD A,(HL)         ; ...
                                       ; LD (46243),A      ; ...
                                       ; POP HL            ; Restore HL

*********************************************************************************
* Reset Show Score Flag and Draw Timer Figures Bar
* 
* Used by the routines at #R34438, #R34916 and #R47468.
draw_timer_bar:
       .proc
draw_timer_bar_0:
       movb @game_flags,a              ; LD A,(34208)      ; Reset Show Score Flag...
       szcb @bits+7,a                  ; RES 7,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       li   ix,zx_attributes+(22*32)   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
                                       ; OR A              ; ...and if zero...
       jeq  draw_timer_bar_2           ; JR Z,47267        ; ...then skip ahead 47267
       movb a,b                        ; LD B,A            ; Load number of lives into B
draw_timer_bar_1:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of open eyes to draw)
       bl   @draw_open_eyes            ; CALL 47315        ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of open eyes to draw)
       sb   one,b                      ; DJNZ 47260        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47260 if not
       jne  draw_timer_bar_1           ;                   ; zero          
                                                           
draw_timer_bar_2:
       movb @time_left,@e              ; LD A,(34210)      ; Load remaining time / lives into E...
                                       ; LD E,A            ; ...
       movb @bytes+16,a                ; LD A,16           ; Load A with number of lives lost by subtracting E from 16...
       sb   @e,a                       ; SUB E             ; ...
       jeq  draw_timer_bar_4           ; JR Z,47284        ; If zero, then skip ahead to #R47284
       movb a,b                        ; LD B,A            ; Load number of lost lives into B as counter for loop
draw_timer_bar_3:
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of pairs of closed eyes to draw)
       bl   @draw_closed_eyes         ; CALL 47302         ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address in IX and advance by two bytes
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of pairs of closed eyes to draw)
       sb   one,b                      ; DJNZ 47277        ; Decrease B (remaining number of pairs of open eyes to draw) and loop back to #R47277 if not
       jne  draw_timer_bar_3           ;                   ; zero
                                                           
draw_timer_bar_4:
       movb @bytes+27,@c               ; LD C,27           ; Set graphic index to 27 (timer figures' bodies)
       movb @current_character_attr,a  ; LD A,(34226)      ; Load attribute of current character into A
       movb @bytes+16,b                ; LD B,16           ; Load B with 16 (as 16 timer figures' bodies to draw)
draw_timer_bar_5:
       .push bc                        ; PUSH BC           ; Store B (remaining number of timer figure bodies to draw)
       bl   @draw_timer_part          ; CALL 47333         ; Draw left half of timer figure's body and invert mirror flag on attribute
       bl   @draw_timer_part          ; CALL 47333         ; Draw right half of timer figure's body
       .pop bc                         ; POP BC            ; Restore B (remaining number of timer figure bodies to draw)
       sb   one,b                      ; DJNZ 47291        ; Decrease B and loop back to #R47291
       jne  draw_timer_bar_5           ;                   
       .endproc                        ; RET               ; Return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Closed) at Attribute File Address IX and Advance IX
* by Two Bytes
* 
* Used by the routines at #R47241 and #R47363. Input:  IX  Pointer to a location in Attribute File
draw_closed_eyes:
       .proc
       bl   @ret_if_show_score_flag    ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47305
       movb @current_character_attr,a  ; LD A,(34226)      ; Load A with the attribute of the current character
       movb @bytes+28,@c               ; LD C,28           ; Load C with 28 (graphic index of timer figures' closed eyes)
       bl   @draw_timer_part           ; CALL 47333        ; Draw the left (closed) eye at Attribute File address in IX and advance IX by one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw the right (closed) eye at Attribute File address in IX, advance IX by one byte and
                                                           ; return

* If Show Score Flag Reset then Draw Pair of Timer Figure Eyes (Open, Random Frame) at Attribute File Address IX and
* Advance IX by Two Bytes
* 
* Used by the routines at #R47241, #R47363 and #R47431. Input:  IX  Attribute File address at which to draw pair of
* eyes Output: IX  Attribute File address two bytes on from initial IX
draw_open_eyes:
       .proc
draw_open_eyes_0:
       bl  @ret_if_show_score_flag     ; CALL 47355        ; If Show Score Flag is set then return, else proceed ahead to #R47318
       bl  @draw_eye                   ; CALL 47323        ; Draw Timer Figure's left eye (random frame) at Attribute File address in IX and advance IX by
                                                           ; one byte
       jmp  draw_timer_part_0          ; JR 47333          ; Draw Timer Figure's right eye (same frame as above), advance IX by one byte then return

* Draw a Timer Figure's Eye (Random Frame) at Attribute File Address in IX and Advance IX by One Byte
* 
* Used by the routine at #R47315. Input:  IX  (Entry at #R47323 and #R47333) Pointer to a location in Attribute File
* A  (Entry at #R47333 only) Attribute C  (Entry at #R47333 only) Graphic Index (e.g. 27 for timer figures' bodies)
* Output: A  Attribute (including inverted mirror flag) IX  Pointer to next location in Attribute File
draw_eye:
       .proc
       movb @bytes+5,a                 ; LD A,5            ; Load A with a random number, 0-4...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   @bytes+29,a                ; ADD A,29          ; Add 29 (as 29 is the index of the first of five eye direction graphics) in C...
       movb a,@c                       ; LD C,A            ; ...
       movb @bytes+7,a                 ; LD A,7            ; Set attribute for timer indicator figures' eyes to white INK on black PAPER
       jmp  draw_timer_part_0

* This entry point is used by the routines at #R47241, #R47302 and #R47315.
draw_timer_part:
       .proc
draw_timer_part_0:
       movb @bytes+4,b                 ; LD B,4            ; Set Graphic Set Index to 4
       .push af                        ; PUSH AF           ; Store AF (A = attribute)
       .push bc                        ; PUSH BC           ; Store BC (B = graphic set index, C = graphic index)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
       .pop bc                         ; POP BC            ; Restore BC (B = graphic set index, C = graphic index)
       movb @c,a                       ; LD A,C            ; Load Graphic Index into A
       cb   a,@bytes+32                ; CP 32             ; If graphic index is less than 32 (i.e. we're not dealing with #32 - eyes looking right or #33
                                                           ; - eyes looking left and don't need to cancel inversion at 47350)...
       jl   _47348                     ; JR C,47348        ; ...then skip ahead to #R47348
       xor  one,a                      ; XOR 1             ; Add or subtract 1 if Graphic Index is 32 or 33 respectively (Timer Figures' Eyes looking
                                                           ; right or left respectively) to cancel out inversion at 47350
_47348:
       movb a,@c                       ; LD C,A            ; Load Graphic Index into C
       .pop af                         ; POP AF            ; Restore AF (A = attribute)
       li   tmp0,128*256               ; XOR 128           ; Flip mirror flag to prepare to draw mirror image of just-drawn character block
       xor  tmp0,a                     ;                   
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return

* If Show Score Flag is Reset then Return to Calling Routine, else Return to Routine that Called Calling Routine
* 
* Used by the routines at #R47302 and #R47315.
ret_if_show_score_flag:
       movb @game_flags,a              ; LD A,(34208)      ; If Show Score Flag is reset...
       movb a,tmp0                     ; BIT 7,A           ; ...
       andi tmp0,128*256               ;                   
       jne  !                          ; RET Z             ; ...then return
       rt                              ;
!
       .pop bc                         ; POP BC            ; Remove return address from stack...
       .endproc                        ; RET               ; ...and return to routine that called the calling routine

*********************************************************************************
* Update Eyes of a Randomly Selected Timer Figure, Increase Timer Tick Counter and Process Timer Figure Blinking
* 
* Used by the routine at #R34438.
update_timer:
       .proc
       bl   @update_rnd_timer_figure   ; CALL 47431        ; Select a remaining Timer Figure at random and update its eyes to a random (open-eyed) frame
       bl   @reduce_remaining_time     ; CALL 47468        ; Increase Timer Tick Counter and reduce remaining time if Counter > 767
       movb @blink_duration_counter,a  ; LD A,(34227)      ; If Blink Duration Counter is zero...
                                       ; OR A              ; ...
       jeq  update_timer_1             ; JR Z,47388        ; ...then skip ahead to #R47388
       sb   one,a                      ; DEC A             ; Decrease Blink Duration Counter by one...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
                                       ; OR A              ; If decreased Blink Duration Counter is not zero...
       jne  update_timer_2             ; RET NZ            ; ...then return
       mov  @blinking_eye_attr_addr,ix ; LD IX,(34264)     ; Restore Attribute File address of eyes of currently blinking timer figure into IX
       b    @draw_open_eyes_0          ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
* Make a randomly chosen timer figure blink
update_timer_1:
       movb @bytes+10,a                ; LD A,10           ; Load A with a random number, 0-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If A is not zero (9 in 10 chance)...
       jne  update_timer_2             ; RET NZ            ; ...then return
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A
       cb   a,@bytes+2                 ; CP 2              ; If less than two time / lives remain...
       jl   update_timer_2             ; RET C             ; ...then return
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(x-1) (where x is remaining time / lives)
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. point to a random "awake" timer figure)
       mov  ix,@blinking_eye_attr_addr ; LD (34264),IX     ; Store Attribute File address of eyes of currently blinking timer figure at 34264
       bl   @draw_closed_eyes          ; CALL 47302        ; If Show Score Flag reset then draw pair of Timer Figure eyes (closed) at Attribute File
                                                           ; address IX and advance IX by two bytes
       movb @bytes+10,a                ; LD A,10           ; Set Blink Duration Counter to a random number, 1-9...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@blink_duration_counter  ; LD (34227),A      ; ...
update_timer_2:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Select a Remaining Timer Figure at Random and Update its Eyes to a Random (Open-Eyed) Frame
* 
* Used by the routine at #R47363.
update_rnd_timer_figure:
       .proc
       movb @time_left,a               ; LD A,(34210)      ; Load remaining time / lives into A...
       socb a,a                        ; OR A              ; ...and if none remain...
       jeq  update_rnd_timer_figure_1  ; RET Z             ; ...then return
       movb a,@e                       ; LD E,A            ; Load remaining time / lives into E
       movb @bytes+18,a                ; LD A,18           ; Load A with 18 minus remaining time / lives (i.e. number in range 2 to 18)...
       sb   @e,a                       ; SUB E             ; ...
* As the value of x (Remaining Time / Lives) decreases, the probability that a randomly generated number between 0
* and (18-x) is 2 or more increases. This probability is used to ensure that the rate at which each timer figure is
* updated remains roughly constant.
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random number, 0-(17 minus remaining time / lives)
       cb   a,@bytes+2                 ; CP 2              ; If generated number is 2 or more...
       jhe  update_rnd_timer_figure_1  ; RET NC            ; ...then return
       li   ix,23232                   ; LD IX,23232       ; Point IX to start of second-last row of Attribute File
       movb @e,a                       ; LD A,E            ; Load remaining time / lives into A
* If remaining time / lives is one, then there is only one Timer Figure to update
       cb   a,one                      ; CP 1              ; If this is 1...
       jne  !                          ; JP Z,47315        ; ...then jump to #R47315 (If Show Score Flag reset then draw pair of Timer Figure eyes and
       b    @draw_open_eyes_0          ;                   ; return)
!
* Otherwise, randomly select one of the remaining Timer Figures to update
       bl   @rnd_no                    ; CALL 54222        ; Load A with random number between 0 and (x-1) where x is remaining time / lives
       ab   a,a                        ; ADD A,A           ; Double A...
       movb a,@c                       ; LD C,A            ; ...and load into BC...
       sb   b,b                        ; LD B,0            ; ...
       a    bc,ix                      ; ADD IX,BC         ; Add BC as offset to IX (i.e. advance IX to point to left eye of randomly chosen Timer Figure)
       b    @draw_open_eyes_0          ; JP 47315          ; If Show Score Flag reset then draw pair of Timer Figure eyes (open, random frame) at
                                                           ; Attribute File address IX, advance IX by two bytes then return
update_rnd_timer_figure_1:
       .endproc

*********************************************************************************
* Increase Timer Tick Counter and Reduce Remaining Time if Counter > 767
* 
* Used by the routine at #R47363.
reduce_remaining_time:
       .proc
       mov  @timer_tick,hl             ; LD HL,(34211)     ; Increase Timer Tick Counter by one...
       inc  hl                         ; INC HL            ; ...
       mov  hl,@timer_tick             ; LD (34211),HL     ; ...
       ci   hl,768                     ; LD A,H            ; If Timer Tick Counter is less than 768 (i.e. 3 x 256)...
                                       ; CP 3              ; ...
       jl   reduce_remaining_time_2    ; RET C             ; ...then return
       clr  @timer_tick                ; LD HL,0           ; Reset Timer Tick Counter to zero...
                                       ; LD (34211),HL     ; ...
       jmp  !
* This entry point is used by the routine at #R53723.
reduce_remaining_time_1:
       .proc
!      movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,47241        ; ...then reset Show Score Flag, draw timer figures bar and return
       b    @draw_timer_bar_0          ;
!
       sb   one,a                      ; DEC A             ; Decrease current time / lives by one...
       movb a,@time_left               ; LD (34210),A      ; ...
       b    @draw_timer_bar_0          ; JP 47241          ; Reset Show Score Flag, and draw timer figures bar and return
reduce_remaining_time_2:
       .endproc

*********************************************************************************
* Update Scores and Display
* 
* Used by the routine at #R34438.
update_and_print_score:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; Set Show Score Flag...
       socb @bits+7,*hl                ; SET 7,(HL)        ; ...
       li   hl,0                       ; LD HL,0           ; Set HL to zero
       movb @time_left,a               ; LD A,(34210)      ; If no time / lives remain...
                                       ; OR A              ; ...
       jeq  update_and_print_score_2 ; JR Z,47526          ; ...then skip ahead to #R47526
       movb a,b                        ; LD B,A            ; Load HL with 1000 x current remaining time / lives...
       li   de,1000                    ; LD DE,1000        ; ...
update_and_print_score_1:
       a    de,hl                      ; ADD HL,DE         ; ...
       sb   one,b                      ; DJNZ 47517        ; ...
       jne  update_and_print_score_1                       ;                   
       mov  @timer_tick,de             ; LD DE,(34211)     ; Subtract value of Timer Tick Counter (i.e. Score Penalty) from current level's score...
       s    de,hl                      ; SBC HL,DE         ; ...
update_and_print_score_2:
       mov  hl,@score_level            ; LD (34213),HL     ; Set score for current level
       mov  @score_total,de            ; LD DE,(34215)     ; Load DE with current total score
       a    de,hl                      ; ADD HL,DE         ; Add score for current level to total score...
       mov  hl,@score_total            ; LD (34215),HL     ; ...and store
       mov  @high_score,de             ; LD DE,(34299)     ; Load current high score into DE
       s    de,hl                      ; SBC HL,DE         ; Subtract high score from current total score...
       jlt  update_and_print_score_3   ; JR C,47551        ; ...and if this is less than zero (i.e. high score is higher than current total score) then
                                                           ; skip ahead to #R47551
       mov  @score_total,hl            ; LD HL,(34215)     ; Load current total score into HL...
       mov  hl,@high_score             ; LD (34299),HL     ; ...and store as new high score
update_and_print_score_3:
       movb @bytes+16,a                ; LD A,16           ; Set time / lives to 16...
       movb a,@time_left               ; LD (34210),A      ; ...
       li   iy,score_text+7            ; LD IY,47596       ; Point IY at "numeric (score)" part of string at 47589
       mov  @score_level,hl            ; LD HL,(34213)     ; Load HL with current score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+20           ; LD IY,47609       ; Point IY at "numeric (total)" part of string at 47589
       mov  @score_total,hl            ; LD HL,(34215)     ; Load HL with current total score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       li   iy,score_text+33           ; LD IY,47622       ; Point IY at "numeric (high score)" part of string at 47589
       mov  @high_score,hl             ; LD HL,(34299)     ; Load HL with current high score...
       bl   @num_to_str                ; CALL 47741        ; ...and convert to string at IY
       b    @print_score_strings_0     ; JP 47628          ; Print SCORE / TOTAL / HI-SC string in current character's colours and return

*********************************************************************************
* Print Score / Total / High Score String in Current Character's Colours
* 
* Used by the routines at #R34916, #R46830 and #R47499.
print_score_strings:
       .proc
print_score_strings_0
       li   iy,score_text              ; LD IY,47589       ; Point IY at SCORE / TOTAL / HI-SC text
       li   hl,23232                   ; LD HL,23232       ; Set Attribute File address at which to print text to start of second-last character row
print_score_strings_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load a character from the string into A
       cb   a,@bytes+36                ; CP 36             ; If the character is 36 (end marker)...
       jeq  print_score_strings_6      ; RET Z             ; ...then return
       cb   a,@bytes+42                ; CP 42             ; If character is not 42 ("set attribute to current character's colours" marker)...
       jne  print_score_strings_3      ; JR NZ,47660       ; ...then skip ahead to #R47660
       movb @current_character_attr,a  ; LD A,(34226)      ; Load current character's attribute into A (blue for Berk, yellow for Drutt)
       cb   a,one                      ; CP 1              ; If blue (Berk)...
       jeq  print_score_strings_2      ; JR Z,47656        ; ...then skip ahead to #R47656
       movb @bytes+112,a               ; LD A,112          ; Load A with value for black INK, yellow PAPER, BRIGHT (Drutt's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_2:
       movb @bytes+79,a                ; LD A,79           ; Load A with value for white INK, blue PAPER, BRIGHT (Berk's colours)
       jmp  print_score_strings_4      ; JR 47666          ; Skip ahead to #R47666
print_score_strings_3:
       cb   a,@bytes+35                ; CP 35             ; If character is not 35 ("set attribute to standard" marker)...
       jne  print_score_strings_5      ; JR NZ,47673       ; ...then skip ahead to #R47673
       movb @bytes+71,a                ; LD A,71           ; Load A with value for white INK, black PAPER, BRIGHT
print_score_strings_4:
       movb a,@print_attr              ; LD (34269),A      ; Store this value as the attribute to print text
       inc  iy                         ; INC IY            ; Advance IY to next character in string to print
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_5:
       movb a,@e                       ; LD E,A            ; Load character to print into E
       bl   @print_dbl_height          ; CALL 47682        ; Print double-height text character in E
       inc  hl                         ; INC HL            ; Advance HL to next Attribute File address
       inc  iy                         ; INC IY            ; Advance IY to next character to process
       jmp  print_score_strings_1      ; JR 47635          ; Loop back to #R47635 for next character
print_score_strings_6
       .endproc

*********************************************************************************
* Print a Double-Height Text Character
* 
* Used by the routines at #R46830, #R47071, #R47084, #R47213 and #R47628. Input:  HL  Attribute File address at
* which to print character E  Character to print
print_dbl_height:
       .proc
       li   bc,32                      ; LD BC,32          ; Load BC with 32 (width of a row in Attribute File)
       .push hl                        ; PUSH HL           ; Store HL (Attribute File address at which to print character)
       sb   d,d                        ; LD D,0            ; Set D to zero
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now Attribute File address at which to print character) and HL (now H = 0, L =
                                                           ; character to print)
       sla  hl,3                       ; ADD HL,HL         ; Multiply index of character to print by eight in HL, as each character's graphic data is
                                                           ; eight bytes long...
                                       ; ADD HL,HL         ; ...
                                       ; ADD HL,HL         ; ...
       li   de,font-(32*8)             ; LD DE,15360       ; Add eight times character index to 15360 in HL, to point to graphic of character in ROM...
       a    de,hl                      ; ADD HL,DE         ; ...
       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to graphic of character in ROM) and HL (now 15360)
       .pop hl                         ; POP HL            ; Restore HL (Attribute File address at which to print character)
       bl   @print_half_dbl_height     ; CALL 47709        ; Print top half of a double-height text character
       a    bc,hl                      ; ADD HL,BC         ; Add BC to HL to advance down a character row
       bl   @print_half_dbl_height     ; CALL 47709        ; Print bottom half of a double-height text character
                                       ; AND A             ; Reset Carry Flag
       s    bc,hl                      ; SBC HL,BC         ; Subtract 32 from HL to restore to value it had upon starting this routine
       .endproc                        ; RET               ; Return
*// print_dbl_height

*********************************************************************************
* Print Half of a Double-Height Text Character
* 
* The most significant byte of the Attribute File address starts off as 88 for the top third of the screen. In the
* middle third it becomes 89 and in the lower third it reaches 90. The most significant byte of the Display File
* address (for the top pixel row of each character row) is 64 in the top third, 72 in the middle third and 80 in the
* lower third. Generally speaking, therefore, the most significant byte in the Display File address increases by
* eight for every increase of one in the attribute address most significant byte, so multiplying the latter by eight
* (giving 192, 200 or 208, values roll over 255-0 boundary with excess truncated) would put it on the same scale as
* the former (64, 72 or 80). Input:  DE  15360 + 8 x character index [+4 for second run-through] (i.e. points to ROM
* graphic data for the character of interest) HL  Attribute File address at which to print character
print_half_dbl_height:
       .proc
       mov  hl,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
       movb *de,*tmp2                  ; de must be advanced
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
       movb *de,*tmp2
       movb *de+,*tmp2
*      Draw attribute
       movb @print_attr,a
       mov  hl,tmp0
       bl   @draw_attribute
;       .push hl                        ; PUSH HL           ; Store HL
;       .push bc                        ; PUSH BC           ; Store BC
;       movb @print_attr,a              ; LD A,(34269)      ; Load stored attribute into A
;       movb a,*hl                      ; LD (HL),A         ; Write this to Attribute File
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       a    a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       a    a,a                        ; ADD A,A           ; ...
;       a    a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File
;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       movb @bytes+4,b                 ; LD B,4            ; Set B to 4 (loop counter)
;_47724:
;       movb *de,a                      ; LD A,(DE)         ; Load a byte from the graphic data into C...
;       movb a,@c                       ; LD C,A            ; ...
;       ; SRL C                         ; SRL C             ; Shift bitmap data left one pixel in C
;       socb @c,a                       ; OR C              ; Merge this into bitmap data already in A to give a "bold" typeface appearance
;       andi a,127*256                  ; AND 127           ; Drop the leftmost bit to prevent one character touching the next (space between letters)
;       movb a,*hl                      ; LD (HL),A         ; Load the bitmap data into two consecutive rows to provide double-height (2 chars) text...
;       ab   one,h                      ; INC H             ; ...
;       movb a,*hl                      ; LD (HL),A         ; ...
;       ab   one,h                      ; INC H             ; ...
;       inc  de                         ; INC DE            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 47724        ; Repeat for next row of graphic data
;       jne  _47724                     ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop hl                         ; POP HL            ; Restore HL
        .endproc                        ; RET               ; Return

*********************************************************************************
* Convert Number in HL to String at IY
* 
* Used by the routine at #R47499. Input:  HL  A number to convert to string IY  A location in memory to store a
* number converted to a string
num_to_str:
       .proc
       li   de,10000                   ; LD DE,10000       ; Convert the ten thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,1000                    ; LD DE,1000        ; Convert the thousands to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,100                     ; LD DE,100         ; Convert the hundreds to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       li   de,10                      ; LD DE,10          ; Convert the tens to a character...
       bl   @digit_to_str              ; CALL 47772        ; ...
       movb @l,a                       ; LD A,L            ; Load remainder (units) into L
       ab   @bytes+48,a                ; ADD A,48          ; Add as offset to 48 (ASCII code for "0")
       movb a,*iy                      ; LD (IY+0),A       ; Load ASCII character code into units position in string
       .endproc                        ; RET               ; Return

*********************************************************************************
* Convert a Digit of Numeric Data to its String Equivalent
* 
* Used by the routine at #R47741. Input:  DE  Current power of ten HL  A number to convert to string IY  A location
* in memory to store a current digit converted to a string
digit_to_str:
       movb @bytes+47,*iy              ; LD (IY+0),47      ; Set character in string to "/" (character immediately before "0")
                                       ; AND A             ; Reset Carry Flag
digit_to_str_1:
       ab   one,*iy                    ; INC (IY+0)        ; Advance character at current string position to next numeric character up
       s    de,hl                      ; SBC HL,DE         ; Subtract current power of ten from number to convert
       jgt  digit_to_str_1             ; JR NC,47777       ; TODO: check code. If number to convert has not dropped below 0 (i.e. we have not yet subtracted too many of the
       jeq  digit_to_str_1                                 ; current power of ten) then loop back to #R47777
       a    de,hl                      ; ADD HL,DE         ; We have subtracted one too many of the current power of ten, so add it back to make the
                                                           ; remainder positive
       inc  iy                         ; INC IY            ; Advance to next character in the string as we are finished dealing with the current power of
                                                           ; ten
       rt                              ; RET               ; Return

*********************************************************************************
* Read Keyboard and Load Pressed Key Character into A
* 
* Used by the routines at #R47893 and #R47942. Output: A  Index of the key that was pressed
; read_keyboard:
;       .exx                            ; EXX               ; Swap registers
;       li   bc,65278                   ; LD BC,65278       ; Load B and C with 254
;       li   hl,ret_val_keyboard        ; LD HL,47853       ; Point HL at list of return values
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard) [IN 65278 reads the half row CAPS SHIFT to V]
;       socb @bits+0,a                  ; SET 0,A           ; Set bit 0 of A (i.e. clear pressing of CAPS SHIFT)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       li   de,5                       ; LD DE,5           ; Advance HL by five characters in list of return values string...
;       a    de,hl                      ; ADD HL,DE         ; ...
;       movb @bytes+6,@e                ; LD E,6            ; Load E with 6 as there are 6 keyboard half-rows to test (loop counter)
;_47811:
;       sra  b,1                        ; RLC B             ; With each loop, change BC from 65278 -> 65022 -> 64510 -> 63486 -> 61438 -> 57342 -> 49150
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       inc  hl                         ; INC HL            ; Advance HL by five characters in list of return values string...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       inc  hl                         ; INC HL            ; ...
;       sb   one,@e                     ; DEC E             ; Decrease number of remaining keyboard half-rows to check
;       jne  _47811                     ; JR NZ,47811       ; If there are any more half rows to check then loop back to #R47811
;       sra  b,1                        ; RLC B             ; Set BC to 32766 for final keyboard half-row
;       ; IN A,(C)                      ; IN A,(C)          ; Read from port 254 into A (i.e. read keyboard)
;       socb @bits+1,a                  ; SET 1,A           ; Set bit 1 of A (i.e. clear pressing of SYMBOL SHIFT)
;       andi a,31*256                   ; AND 31            ; Strip out all but the five bits representing key presses
;       li   tmp0,31*256                ; XOR 31            ; Invert all of the lowest five bits
;       xor  tmp0,a                     ;
;       jne  _47843                     ; JR NZ,47843       ; If this value is non-zero, then a key has been pressed, so skip ahead to #R47843
;       .exx                            ; EXX               ; Swap registers
;       .ret                            ; RET               ; Return [no key pressed]
;_47843:
;       srl  a,1                        ; SRL A             ; Shift bits right
;       mov  af,tmp0
;       andi tmp0,>0080
;       jne  _47850                     ; JR C,47850        ; If carry flag is set, then this is the key that was pressed, so skip ahead to #R47850
;       inc  hl                         ; INC HL            ; Advance HL to check next character
;       jmp  _47843                     ; JR 47843          ; Loop back to #R47843
;_47850:
;       movb *hl,a                      ; LD A,(HL)         ; Load current character in list of return values string into A as this is the key that was
;                                                           ; pressed
;       .exx                            ; EXX               ; Swap registers

*********************************************************************************
* Check for Control Key Press and Store at 34219
* 
* Used by the routine at #R34438.
check_control_input:
       .proc
       sb   a,a                        ; XOR A             ; Clear previously stored control input...
       li   r0,JOY_RT
       bl   @check_key
       jeq  check_control_input_1
       socb @bits+0,a
check_control_input_1:
       li   r0,JOY_LT
       bl   @check_key
       jeq  check_control_input_2
       socb @bits+1,a
check_control_input_2:
       li   r0,JOY_DN
       bl   @check_key
       jeq  check_control_input_3
       socb @bits+2,a
check_control_input_3:
       li   r0,JOY_UP
       bl   @check_key
       jeq  check_control_input_4
       socb @bits+3,a
check_control_input_4:
       li   r0,JOY_FI
       bl   @check_key
       jeq  check_control_input_5
       socb @bits+4,a
check_control_input_5:
       movb  a,a
       jne   check_control_input_10
       li   r0,KEY_D
       bl   @check_key
       jeq  check_control_input_6
       socb @bits+0,a
check_control_input_6:
       li   r0,KEY_S
       bl   @check_key
       jeq  check_control_input_7
       socb @bits+1,a
check_control_input_7:
       li   r0,KEY_X
       bl   @check_key
       jeq  check_control_input_8
       socb @bits+2,a
check_control_input_8:
       li   r0,KEY_E
       bl   @check_key
       jeq  check_control_input_9
       socb @bits+3,a
check_control_input_9:
       li   r0,KEY_C
       bl   @check_key
       jeq  check_control_input_10
       socb @bits+4,a
check_control_input_10:
       li   r0,KEY_P
       bl   @check_key
       jeq  check_control_input_11
       bl   @release_keypress
       bl   @wait_keypress
check_control_input_11:
       li   r0,KEY_R
       bl   @check_key
       jeq  check_control_input_12
       socb @bits+6,a
check_control_input_12:
;       movb a,@control_input           ; LD (34219),A      ; ...
;       .call @_47788                   ; CALL 47788        ; Read keyboard and load character of pressed key into A
;       socb a,a                        ; OR A              ; If no key was pressed...
;       jeq  _47930                     ; JR Z,47930        ; ...then read joystick input and return
;       movb one,@e                     ; LD E,1            ; Set least significant bit of E as we are testing the first keyboard control first
;       movb @bytes+7,b                 ; LD B,7            ; Set B to 7 as there are 7 keyboard controls to check (loop counter)
;       li   hl,current_keyboard_ctrls  ; LD HL,46683       ; Point HL at Table of Current Keyboard Controls
;_47910:
;       cb   a,*hl                      ; CP (HL)           ; If pressed key is the same as the current keyboard control...
;       jeq  _47921                     ; JR Z,47921        ; ...then skip ahead to #R47921
;       inc  hl                         ; INC HL            ; Advance HL to next keyboard control
;       ; SLA E                         ; SLA E             ; Shift E left
;       sb   one,b                      ; DJNZ 47910        ; Loop back to #R47910 for next keyboard control
;       jne  _47910                     ;
;       sb   a,a                        ; XOR A             ; Set A to zero
;       jmp  _47926                     ; JR 47926          ; Skip ahead to #R47926
;_47921:
;       movb @e,a                       ; LD A,E            ; Load input bitmap into A (bit that is set represents the control that has been pressed)
;       movb a,tmp0                     ; BIT 5,A           ; If bit 5 is set (i.e. Berk / Drutt key has been pressed)...
;       andi tmp0,32*256                ;
;       jne  _47942                     ; JR NZ,47942       ; ...then jump to #R47942 (Wait for current key to be released and another to be pressed,
;                                                           ; storing in A) and return
;* This entry point is used by the routine at #R47930.
;_47926:
       movb a,@control_input           ; LD (34219),A      ; Store control input at #R34219
       .endproc                        ; RET               ; Return

* If Joystick Mode is On, then Read Joystick Input
* 
* Used by the routine at #R47893.
_47930:
;       movb @_34298,a                  ; LD A,(34298)      ; If Joystick Mode is Off...
;       socb a,a                        ; OR A              ; ...
;       jne  !                          ; RET Z             ; ...then return
;       .ret                            ;
;!
;       ; IN A,(31)                     ; IN A,(31)         ; Read state of Kempston joystick into A
;       andi a,31*256                   ; AND 31            ; If joystick input is non-zero...
;       jne  _47926                     ; JR NZ,47926       ; ...then jump to #R47926
;       .ret                            ; RET               ; Return

*********************************************************************************
* Wait for Current Key to Be Released and Another to Be Pressed, Storing in A
* 
* Used by the routines at #R34438, #R47893 and #R47955.
wait_release_and_keypress:
       .proc
wait_release_and_keypress_1:
       bl   @release_keypress          ; CALL 47788        ; Read keyboard and load character of pressed key into A
                                       ; OR A              ; If a key is pressed...
                                       ; JR NZ,47942       ; ...then loop back to #R47942
wait_release_and_keypress_2:
       bl   @wait_keypress             ; CALL 47788        ; Read keyboard and load character of pressed key into A
                                       ; OR A              ; If a key is not pressed...
                                       ; JR Z,47948        ; ...then loop back to #R47948
       .endproc                        ; RET               ; Return

*********************************************************************************
* Wait for release keypress
*
release_keypress:
       .proc
release_keypress_1:
       li   r0,KEY_S
       bl   @check_key
       jne  release_keypress_1
       li   r0,JOY_FI
       bl   @check_key
       jne  release_keypress_1
       .endproc
*// release_keypress

*********************************************************************************
* Wait for Key-Press, Store Pressed Key Code in A and Play Main Menu Sound
* 
* Used by the routines at #R46830 and #R46968. Output: A  code of pressed key
wait_keypress:
       .proc
wait_keypress_1:
       li   r0,KEY_S
       bl   @check_key
       jne  wait_keypress_2
       li   r0,JOY_FI
       bl   @check_key
       jeq  wait_keypress_1
;       .call @_47942                   ; CALL 47942        ; Wait for current key to be released and another to be pressed, storing in A
;       .push af                        ; PUSH AF           ; Store AF (A = last pressed key)
;       movb @bytes+2,a                 ; LD A,2            ; Set sound 2 as pending if appropriate, then play and clear pending sound...
;       bl   @request_sound_a           ; CALL 59722        ; ...
;       .pop af                         ; POP AF            ; Restore AF (A = last pressed key)
wait_keypress_2:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Advance HL to Next Script Instruction and Execute
* 
* Used by the routines at #R35735, #R36116, #R36390, #R36471, #R36542, #R36610, #R36947, #R36950, #R36984, #R36990,
* #R37085, #R37639, #R37753, #R38074, #R38165, #R38540, #R38554, #R41498, #R41617, #R48133, #R48142, #R48148,
* #R48158, #R48220, #R48246, #R48260, #R48267, #R48274, #R48307, #R48336, #R48365, #R48487, #R48567, #R48593,
* #R48641, #R48686, #R48692, #R48698, #R48704, #R48920, #R49010, #R51765, #R52029, #R52038, #R52047, #R52142,
* #R52243, #R52309, #R52860, #R52870, #R52889 and #R52967. Input:  IX  (Entry at #R48096 and #R48098) Address of
* complex state data for an entity Output: HL  Current position in script data
inct_execute_script:                   ; Always branch here
       inct hl                         ; INC HL            ; Advance Script Data Pointer by two bytes...
                                       ; INC HL            ; ...
* This entry point is used by the routines at #R35577, #R35735, #R36008, #R36036, #R36116, #R36367, #R36390,
* #R36471, #R36638, #R37085, #R37639, #R37718, #R37753, #R37778, #R38074, #R38554, #R41550, #R48285, #R48295,
* #R48307, #R48324, #R48336, #R48353, #R48365, #R48388, #R48934, #R48976, #R49010, #R51765, #R51779, #R51904,
* #R51924, #R51944, #R51954, #R51960, #R52053, #R52148, #R52243, #R52908, #R52914, #R52967 and #R53083.
execute_script:                        ; Always branch here
                                       ; INC HL            ; Advance Script Data Pointer by one byte
       movb @1(hl),a                   ; LD A,(HL)         ; Load byte at this location into A
                                       ; DEC HL            ; Move HL back one byte
                                       ; OR A              ; If byte loaded into A was zero (i.e. a script instruction)...
       jeq  execute_script_1           ; JR Z,48117        ; ...then skip ahead to #R48117
* HL pointing to a graphic layout data address, rather than a script instruction
       mov  hl,@current_script_addr    ; LD (34277),HL     ; Store address in HL at #R34277 as position in script currently running
       movb *hl+,@2(ix)                ; LD A,(HL)         ; Load word at location HL into Graphic Layout Address in current entity's complex state data
                                                           ; entry (IX)...
                                       ; LD (IX+2),A       ; ...
                                       ; INC HL            ; ...
       movb *hl,@3(ix)                 ; LD A,(HL)         ; ...
                                       ; LD (IX+3),A       ; ...
       .endproc                        ; RET               ; Return
* HL pointing to a script instruction
execute_script_1:
       movb *hl,a                      ; LD A,(HL)         ; Load script "instruction" into A
                                       ; PUSH HL           ; Store HL (pointer to current position in script data)
                                       ; LD HL,47966       ; Point HL at Table of Script Routine Start Addresses
       ab   a,a                        ; ADD A,A           ; Load double index of script instruction into BC...
       movb a,@c                       ; LD C,A            ; ...
       sb   b,b                        ; LD B,0            ; ...
                                       ; ADD HL,BC         ; ...and add as offset in HL to point to start address of required script routine
       mov bc,bc
       jeq  error
       ci   bc,64*2
       jle  !
error: jmp  error
!
       mov  @script_routines_jmp_table(bc),bc ; LD C,(HL)         ; Load address at this location into BC...
                                       ; INC HL            ; ...
                                       ; LD B,(HL)         ; ...
                                       ; POP HL            ; Restore HL (pointer to current position in script data)
                                       ; PUSH BC           ; Push address in BC onto stack...
       b    *bc                        ; RET               ; ...and RET to this address

*********************************************************************************
* Decrease Remaining Time for Current Power and if Zero, Exit Calling Routine and Run Script Data for Removal of
* Power
* 
* Used by the routines at #R35689, #R36542 and #R48487.
dec_power_duration:
       .proc
       mov  @remaining_power_cycles,de ; LD DE,(34224)     ; Load remaining power time into DE
       swpb de                         ; Little endian
       movb @e,a                       ; LD A,E            ; Increase E (number of game-cycles power has been in use in current block)...
       ab   one,a                      ; INC A             ; ...
       movb a,@e                       ; LD E,A            ; ...
       cb   a,@bytes+15                ; CP 15             ; If 16 game-cycles of power use have not yet elapsed...
       jne  dec_power_duration_1       ; JR NZ,48402       ; ...then skip ahead to #R48402
       movb @bytes+0,@e                ; LD E,0            ; Reset number of game-cycles power has been in use to zero...
       sb   one,d                      ; DEC D             ; ...and decrease remaining number of 16-game-cycles
dec_power_duration_1:
       swpb de                         ; Big endian
       mov  de,@remaining_power_cycles ; LD (34224),DE     ; Store updated remaining power time...
       jne  dec_power_duration_2       ; RET NZ            ; ...and return if this is not zero
       .pop bc                         ; POP BC            ; Remove top value from stack (i.e. return address to routine that called this routine)
       bl   @remove_current_power      ; CALL 48417        ; Remove Berk's current power and reset sweet / mushroom / edible eyes / sausage to its
                                                           ; original position
       li   hl,_35275                  ; LD HL,35275       ; Point HL at script data for Berk's power expiring...
       b    @execute_script            ; JP 48098          ; ...and execute
dec_power_duration_2:
       .endproc

*********************************************************************************
* Remove Berk's Current Power and Reset Sweet / Mushroom / Edible Eyes / Sausage to its Original Position
* 
* Used by the routines at #R36390, #R36471, #R39151 and #R48388.
remove_current_power:
       .proc
       movb @berks_current_power,a                  ; LD A,(34220)      ; If Berk has no current power...
       socb a,a                        ; OR A              ; ...
       jeq  remove_current_power_3     ; RET Z             ; ...then return
       .push ix                        ; PUSH IX           ; Store IX
       cb   a,@bytes+6                 ; CP 6              ; If Berk's current power is not 6 (flying, level 3, 2)...
       jne  remove_current_power_1                     ; JR NZ,48445       ; ...then skip ahead to #R48445
       movb @bytes+13,a                ; LD A,13           ; Reset complex state data for Red Coloured Creature to that stored in Initial-State Table...
       bl   @reset_1st_entity_of_class                   ; CALL 53987        ; ...
       movb @bytes+14,a                ; LD A,14           ; Reset complex state data for Yellow Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @reset_1st_entity_of_class                   ; CALL 53987        ; ...
       movb @bytes+15,a                ; LD A,15           ; Reset complex state data for White Coloured Creature to that stored in Initial-State
                                                           ; Table...
       bl   @reset_1st_entity_of_class                   ; CALL 53987        ; ...
       jmp  remove_current_power_2                     ; JR 48474          ; Skip ahead to #R48474
remove_current_power_1:
       cb   a,@bytes+10                ; CP 10             ; If Berk's current power is not 10 (floating)...
       jne  remove_current_power_2                     ; JR NZ,48474       ; ...then skip ahead to #R48474
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       szcb @bits+7,@9(ix)             ; RES 7,(IX+9)      ; Reset Berk's Moving Upwards Flag
       movb @bytes+192,@11(ix)         ; LD (IX+11),192    ; Reset Berk's Walking Right, Walking Left, Unused (11,2), Unused (11,3), Impassable Leftwards
                                                           ; and Impassable Rightwards flags and set his Interaction (11,6) and Interaction (11,7) flags
       szcb @bits+7,@8(ix)             ; RES 7,(IX+8)      ; Reset bit 7 of Berk's class value (change from 159 to 31)
       sb   one,@6(ix)                 ; DEC (IX+6)        ; Decrease Berk's bottom y-coordinate by two...
       sb   one,@6(ix)                 ; DEC (IX+6)        ; ...
       bl   @prepare_falling           ; CALL 55516        ; Set Berk's Can Fall Flag and set his initial velocity factor to 2
remove_current_power_2:
       movb @berks_current_power,a     ; LD A,(34220)      ; Reset complex state data for entity responsible for Berk's current power to that stored in
                                                           ; Initial-State Table...
       bl   @reset_1st_entity_of_class                   ; CALL 53987        ; ...
       sb   a,a                        ; XOR A             ; Clear Berk's current power...
       movb a,@berks_current_power     ; LD (34220),A      ; ...
       .pop ix                         ; POP IX            ; Restore IX
remove_current_power_3:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Reset Drutt to Initial State
* 
* Used by the routine at #R34751.
reset_drutt:
       li   hl,drutt_facing_out_script ; LD HL,51524       ; Set current position in Drutt's script data...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...to #R51524 (Drutt facing out of screen)
       rt                              ; RET               ; Return
*// reset_drutt

*********************************************************************************
* Update States of Drutt and Worm and Store Current Positions in Script Data
* 
* Used by the routine at #R34438.
update_drutt_worm_state:
       .proc
       bl   @update_worm_state         ; CALL 52837        ; Update state of Worm and store current position in script data
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for Drutt's current room
       mov  @drutts_script_pos,hl      ; LD HL,(51518)     ; Load current position in Drutt's script data from #R51518 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_drutt_state        ; CALL 51765        ; Update state of Drutt
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@drutts_script_pos      ; LD (51518),HL     ; ...at #R51518 as current position in Drutt's script data
       .endproc                        ; RET               ; Return
*// update_drutt_worm_state

*********************************************************************************
* Update State of Drutt
* 
* If Drutt is being carried or falling, then he should be prevented from doing anything. This is accomplished by
* constantly resetting his current script data position to be #R51520. This does nothing except redraw Drutt. Input:
* IX  Address of complex state data (current level) for Drutt Output: HL  Address of next script instruction to
* execute
update_drutt_state:
       .proc
       movb @10(ix),a                  ; LD A,(IX+10)      ; If both Drutt's Being Carried and Can Fall flags are reset...
       andi a,96*256                   ; AND 96            ; ...
       jne  !                          ; JP Z,48096        ; ...then jump to #R48096 (advance HL to next script instruction and execute)
       b    @inct_execute_script                    ;                   
!
       li   hl,_51520                  ; LD HL,51520       ; Point HL at script data for Drutt facing out of screen (falling)...
       b    @execute_script            ; JP 48098          ; ...and execute
*// update_drutt_state

*********************************************************************************
* Update State of Worm and Store Current Position in Script Data
* 
* Used by the routine at #R51739.
update_worm_state:
       .proc
       mov  @worm_state_addr,ix        ; LD IX,(34244)     ; Load IX with address of current level's complex state data for worm
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       mov  @worms_script_data_pos,hl  ; LD HL,(52726)     ; Load current position in worm's script data from #R52726 into HL...
       mov  hl,@current_script_addr    ; LD (34277),HL     ; ...and store at #R34277 as position in script currently running
       bl   @update_worm_state_1       ; CALL 52860        ; Update state of worm
       mov  @current_script_addr,hl    ; LD HL,(34277)     ; Store address (current position in script data) stored at #R34277...
       mov  hl,@worms_script_data_pos  ; LD (52726),HL     ; ...at #R52726 as current position in worm's script data
       .endproc                        ; RET               ; Return

*********************************************************************************
* Update State of Worm
* 
* Used by the routine at #R52837. Input:  IX  Address of complex state data (current level) for Worm
update_worm_state_1:
       .proc
       movb @1(ix),a                   ; LD A,(IX+1)       ; If worm's depth is zero (i.e. not currently active)...
                                       ; OR A              ; ...
       jne  !                          ; JP Z,53083        ; ...then attempt to spawn a new worm...
       b    @spawn_new_worm            ;
!
       b    @inct_execute_script       ; JP 48096          ; ...otherwise advance HL to next script instruction and execute

*********************************************************************************
* Attempt to Spawn a New Worm
* 
* Used by the routine at #R52860. Input:  IX  Address of complex state data (current level) for Worm
spawn_new_worm:
       movb @bytes+60,a                ; LD A,60           ; Load A with a random number, 0-59...
       bl   @rnd_no                    ; CALL 54222        ; ...
       socb a,a                        ; OR A              ; If random number is not zero (59 in 60 chance)...
       jeq  !                          ; RET NZ            ; ...then return
       .ret                            ;                   
!
       movb @current_characters_room,a                  ; LD A,(34218)      ; Set worm's current room to same as current character's...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for worm's current room
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load A with width of current room (chars) + 99...
       sb   @bytes+100,a               ; SUB 100           ; ...and subtract 100 to get x-coordinate (zero-based) of right side of the room
       bl   @rnd_no                    ; CALL 54222        ; Load A with a random x-coordinate within current room
       ab   @bytes+100,a               ; ADD A,100         ; Add 100 to restore coordinate system
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set this as the worm's left x-coordinate
       ab   @bytes+2,a                 ; ADD A,2           ; Add two to this...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as the worm's right x-coordinate
       movb @bytes+2,a                 ; LD A,2            ; Load A with a random number, 1-2...
       bl   @rnd_no                    ; CALL 54222        ; ...
       ab   one,a                      ; INC A             ; ...
       movb a,@1(ix)                   ; LD (IX+1),A       ; ...and assign the worm this depth
       movb @bytes+124,a               ; LD A,124          ; Load A with 124 (y-coordinate of character row below bottom of room)
       sb   @1(ix),a                   ; SUB (IX+1)        ; Subtract worm's depth value to get its bottom y-coordinate...
       movb a,@6(ix)                   ; LD (IX+6),A       ; ...and assign
       .push af                        ; PUSH AF           ; Store AF (A = bottom y-coordinate of worm)
       movb @bytes+121,@4(ix)          ; LD (IX+4),121     ; Set worm's top y-coordinate to 121
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
       jnc  !                                              ; Flag is set
       .pop bc
       jmp  !!
!      .pop bc                         ; POP BC            ; Store AF (B = bottom y-coordinate of worm)
       jmp  _53154                     ; JR NC,53154       ; If a collision occurred then set worm's depth to zero and return
!      movb b,@4(ix)                   ; LD (IX+4),B       ; Set worm's top y-coordinate to same as its bottom y-coordinate
       li   hl,_52735                  ; LD HL,52735       ; Point HL at script data for worm rising from floor...
       b    @execute_script            ; JP 48098          ; ...and execute
_53154:
       movb @bytes+0,@1(ix)            ; LD (IX+1),0       ; Set worm's depth to zero
       .ret                            ; RET               ; Return

*********************************************************************************
* Cycle Attributes (Long, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R53723.
cycle_attributes_long:
       .proc
       movb @bytes+21,b                ; LD B,21           ; Set repeat counter to 21
       jmp  cycle_attributes           ; JR 53583          ; Flash screen when Berk is "killed"

*********************************************************************************
* Cycle Attributes (Short, Full-Screen) and Clear Display Buffers
* 
* Used by the routine at #R36616.
cycle_attributes_short:
       .proc
       movb @bytes+7,b                 ; LD B,7            ; Set repeat counter to 7
       jmp  cycle_attributes

* This entry point is used by the routine at #R53577.
cycle_attributes:
       .ifeq optimize_attr_drawing,1
       .push bc                        ; PUSH BC           ; Store BC (B = remaining number of iterations required)
       li   hl,ti_attributes           ; LD HL,22528       ; Point HL at start of Attribute File
       li   bc,704                     ; LD BC,704         ; Set BC to 704 (i.e. gap between start of Attribute File and start of second-last row (timer
                                                           ; figures))
cycle_attributes_1:
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jeq  cycle_attributes_2         ; JR Z,53602        ; If value is zero (black INK) then skip ahead to #R53602
       ab   one,a                      ; INC A             ; Increase INK value to next colour
       andi a,7*256                    ; AND 7             ; Strip out other components to leave only INK component
       jne  cycle_attributes_2         ; JR NZ,53602       ; If value is not zero (black INK) then skip ahead to #R53602
       movb one,a                      ; LD A,1            ; INK value was zero, so set now to blue INK
cycle_attributes_2:
       movb a,@e                       ; LD E,A            ; Load new INK value into E
       movb *hl,a                      ; LD A,(HL)         ; Load current attribute at memory location HL into A
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jeq  cycle_attributes_3         ; JR Z,53616        ; If black PAPER, then skip ahead to #R53616
       ab   @bytes+8,a                 ; ADD A,8           ; Increase to next PAPER colour
       andi a,56*256                   ; AND 56            ; Strip out other components to leave only PAPER component
       jne  cycle_attributes_3         ; JR NZ,53616       ; If PAPER component is not black then skip ahead to #R53616
       movb @bytes+8,a                 ; LD A,8            ; PAPER value was zero, so set now to blue PAPER
cycle_attributes_3:
       socb @e,a                       ; OR E              ; Add INK component back in
       socb @bytes+64,a                ; OR 64             ; Set BRIGHT flag
       mov  hl,tmp0
       ai   tmp0,zx_attributes-ti_attributes
       bl   @draw_attribute            ; LD (HL),A         ; Paint new attribute back to current position in Attribute File
       andi a,16*256                   ; AND 16            ; Set / reset speaker bit
       socb @bytes+2,a                 ; OR 2              ; Set RED bit to maintain red border
       bl   @set_border_color          ; OUT (254),A       ; Set border and set / reset speaker state
       inc  hl                         ; INC HL            ; Advance to next byte of Attribute File
       dec  bc                         ; DEC BC            ; Decrease remaining number of character blocks to process
       movb b,a                        ; LD A,B            ; If number of remaining character blocks is not zero...
       socb @c,a                       ; OR C              ; ...
       jne  cycle_attributes_1         ; JR NZ,53590       ; ...then loop back to #R53590
       .pop bc                         ; POP BC            ; Restore BC (B = remaining number of iterations required)
       .else
       li   r0,color_table
       li   r1,>f000
       li   r2,>1600
       bl   @vsmw
       li   r0,color_table
       li   r1,>e000
       li   r2,>1600
       bl   @vsmw
       .endif
       sb   one,b                      ; DJNZ 53583        ; Loop back for next iteration
       jne  cycle_attributes                     ;
       jmp  clear_display_buffers_0

*********************************************************************************
* This entry point is used by the routine at #R53887.
clear_display_buffers:
       .proc
clear_display_buffers_0:
       li   hl,display_buffer_1        ; LD HL,61312       ; Clear Display Buffers 1 and 2...
       li   bc,>1080                   ; LD BC,4224        ; ...
clear_display_buffers_1:
       clr  *hl+                       ; LD (HL),0         ; ...
                                       ; LD D,H            ; ...
                                       ; LD E,L            ; ...
       dect bc                         ; INC DE            ; ...
       jne  clear_display_buffers_1    ; LDIR              ; ...
       .endproc                        ; RET               ; Return

*********************************************************************************
* Fill Top 22 Rows of Attribute File with Attribute Value in A
* 
* Used by the routines at #R46830 and #R53723. Input:  A  Attribute
fill_screen:
       .proc
       .ifeq optimize_attr_drawing,1
       li   tmp0,ti_attributes
       li   tmp2,22*32
fill_screen_1:
       movb a,*tmp0+
       dec  tmp2
       jne  fill_screen_1
       .endif
       bl   @ti_color
       mov  tmp0,r1
       li   r0,color_table
       li   r2,22*256
       bl   @vsmw
;       li   hl,22528                   ; LD HL,22528       ; Point HL at start of Attribute File
;       movb @l,@e                      ; LD E,L            ; Point DE one byte after this...
;       movb h,d                        ; LD D,H            ; ...
;       inc  de                         ; INC DE            ; ...
;       li   bc,703                     ; LD BC,703         ; Set counter to 703, as we are filling 704 characters (32*22)
;       movb a,*hl                      ; LD (HL),A         ; Set first byte to A...
;       .ldir                           ; LDIR              ; ...and repeat for remaining 703 bytes
;       movb @bytes+3,b                 ; LD B,3            ; Pause for three iterations...
;       .call @pause                    ; CALL 34675        ; ...
       .endproc                         ; RET               ; Return
*// fill_screen

*********************************************************************************
* Set "Berk Has Been Killed" Flag
* 
* Used by the routines at #R36116, #R36390, #R37085, #R37639, #R38074, #R38219, #R38540, #R38592, #R39934, #R41498,
* #R41633, #R41961, #R42064, #R42266 and #R42486.
set_berk_killed:
       movb @game_flags,a              ; LD A,(34208)      ; Set "Berk Has Been Killed" Flag...
       .ifeq berk_cant_die,0
       socb @bits+2,a                  ; SET 2,A           ; ...
       .endif
       movb a,@game_flags              ; LD (34208),A      ; ...
       rt                              ; RET               ; Return
*// set_bert_killed:

*********************************************************************************
* If Berk Has Been Killed then Reset his Position and State, Flash Screen and Decrease Time / Lives
* 
* Used by the routine at #R34438.
check_berk_killed:
       .proc
       li   hl,game_flags              ; LD HL,34208       ; Point HL at Game Flags
       szcb @bits+3,*hl                ; RES 3,(HL)        ; Reset "Reset Spiders to Initial State" Flag
       movb *hl,tmp0                   ; BIT 2,(HL)        ; If "Berk Has Been Killed" Flag is not set...
       andi tmp0,4*256                 ;                   
       jeq  check_berk_killed_1        ; RET Z             ; ...then return
       szcb @bits+2,*hl                ; RES 2,(HL)        ; Reset "Berk Has Been Killed" Flag
       socb @bits+3,*hl                ; SET 3,(HL)        ; Set "Reset Spiders to Initial State" Flag
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
       bl   @drop_item                 ; CALL 36296        ; Make Berk drop the entity he is holding and load IY with its complex state data address
       li   de,berk_reset_table-2      ; LD DE,53674       ; Point DE at location two bytes (1 WORD) before start of Table of Addresses of Berk Reset Data
       movb @current_level,a           ; LD A,(34207)      ; Load current level number into A
       bl   @load_table_addr           ; CALL 53814        ; Load DE with that level's address (from table at #R53676) for complex state data to revert
                                                           ; Berk to after he is killed
       .ex_de_hl                       ; EX DE,HL          ; Swap HL (now address of complex state data to revert to) and DE
       mov  @berk_state_addr,de        ; LD DE,(34240)     ; Load DE with address of current level's complex state data for Berk
       li   bc,13                      ; LD BC,13          ; Overwrite Berk's current complex state data...
       .ldir                           ; LDIR              ; ...with reset data from table at #R53684 for current level
       li   hl,_35363                  ; LD HL,35363       ; Load HL with address of script data for Berk starting to fall...
       mov  hl,@berk_script_pos        ; LD (35687),HL     ; ...and store at #R35687 (as current position in Berk's script data)
       bl   @cycle_attributes_long     ; CALL 53577        ; Cycle attributes (long, full-screen) and clear display buffers
       movb @bytes+127,a               ; LD A,127          ; Fill top 22 rows of Attribute File with white PAPER and white INK, BRIGHT...
       bl   @fill_screen               ; CALL 53649        ; ...
       bl   @paint_red_areas           ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       bl   @reduce_remaining_time_1                   ; CALL 47485        ; Decrease current time / lives by one if greater than zero and redraw Timer Figures
check_berk_killed_1:
       .endproc                        ; RET               ; Return
*// check_berk_killed

*********************************************************************************
* Set Each Value in Primary Display Buffer Within Play Area to Zero
* 
* Used by the routine at #R34438.
; TODO: Use room boundaries instead
clear_display_buffer:
       .proc
       mov  @prim_disp_buffer_addr,hl  ; LD HL,(34279)     ; Load HL with start address of Primary Display Buffer
       li   bc,704                     ; LD BC,704         ; Set BC to 704, as there are 704 entries in a Display Buffer
       li   de,3                       ; LD DE,3           ; Load DE with 3 as each entry in the Display Buffer is three bytes wide
       clr  tmp0
clear_display_buffer_1:
       movb *hl,a                      ; LD A,(HL)         ; Read first byte in Display Buffer...
                                       ; INC A             ; ...and add one
       jlt  clear_display_buffer_1a    ; JP Z,53806        ; If value is now zero (i.e. was previously 255 and therefore outside normal play area), then
                                                           ; skip ahead to #R53806
*      Even
                                       ; XOR A             ; Set all values in current entry to zero...
       clr  *hl+                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
                                       ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       movb tmp0,*hl+                  ; LD (HL),A         ; ...
                                       ; INC HL            ; ...
       jmp  clear_display_buffer_1b
clear_display_buffer_1a:
       a    de,hl
clear_display_buffer_1b:
       movb *hl,a
       jlt  clear_display_buffer_2
*      Odd
       movb tmp0,*hl+
       clr  *hl+
       jmp  clear_display_buffer_3     ; JP 53807          ; Skip ahead to #R53807
clear_display_buffer_2:
       a    de,hl                      ; ADD HL,DE         ; Advance current position in Display Buffer to next entry
clear_display_buffer_3:
       dect bc                         ; DEC BC            ; Decrease remaining number of entries to process
                                       ; LD A,B            ; If remaining number of entries is not zero...
                                       ; OR C              ; ...
       jne  clear_display_buffer_1     ; JP NZ,53791       ; ...then loop back to #R53791
       .endproc                        ; RET               ; Return
*// clear_display_buffer

*********************************************************************************
* Advance DE by 2xA Bytes and Load WORD at this Location into DE
* 
* Used by the routines at #R49010, #R51779 and #R53723. Input:  A  Index DE  Base address Output: DE  WORD value at
* DE (input) + 2 x A (input)
load_table_addr:
                                       ; PUSH HL           ; Store HL
       ab   a,a                        ; ADD A,A           ; Load HL with double index...
       clr  tmp0
       movb a,@r0lb                    ; LD L,A            ; ...
                                       ; LD H,0            ; ...
       a    de,tmp0                    ; ADD HL,DE         ; Add HL to DE as offset, in HL
       mov  *tmp0,de                   ; LD E,(HL)         ; Load address at HL into DE...
                                       ; INC HL            ; ...
                                       ; LD D,(HL)         ; ...
                                       ; POP HL            ; Restore HL
       rt                              ; RET               ; Return
*// load_table_addr

*********************************************************************************
* Copy Room Dimension Data Entry for Current Character / Entity's Current Room to Temporary Store Location (34230)
* 
* Used by the routines at #R34916 and #R53887. Input:  IX  (Entry at #R53848 only) Address of complex state data for
* an entity
copy_room_dim_data_to_tmp:
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  copy_room_dim_data_to_tmp_1 ; JR Z,53838        ; ...then skip ahead to #R53838
       mov  @drutt_state_addr,ix       ; LD IX,(34242)     ; Load IX with address of current level's complex state data for Drutt
       jmp  copy_room_dim_data_to_tmp_2 ; JR 53842          ; Skip ahead to #R53842
copy_room_dim_data_to_tmp_1:
       mov  @berk_state_addr,ix        ; LD IX,(34240)     ; Load IX with address of current level's complex state data for Berk
copy_room_dim_data_to_tmp_2:
       movb *ix,@current_characters_room ; LD A,(IX+0)       ; Store current character's current room at 34218...
                                       ; LD (34218),A      ; ...
* This entry point is used by the routines at #R35689, #R37062, #R39278, #R51739, #R52837, #R53083, #R54480 and
* #R55525.
copy_room_dim_data_to_tmp_3:
       movb *ix,a                      ; LD A,(IX+0)       ; Load entity's current room into A
       sb   one,a                      ; DEC A             ; Subtract 1...
       movb a,@e                       ; LD E,A            ; ...and multiply by 5...
       ab   a,a                        ; ADD A,A           ; ...
       ab   a,a                        ; ADD A,A           ; ...
       ab   @e,a                       ; ADD A,E           ; ...
       movb a,@c                       ; LD C,A            ; Load into BC...
       sb   b,b                        ; LD B,0            ; ...
       mov  @room_dim_data,hl          ; LD HL,(34248)     ; Load start address of current level's room dimension data into HL...
       a    bc,hl                      ; ADD HL,BC         ; ...and add BC as offset
       mov  hl,@room_dim_data_addr     ; LD (34262),HL     ; Store HL at #R34262
       movb @bytes+5,@c                ; LD C,5            ; Set BC to 5 (as entries are 5 bytes wide)
       li   de,tmp_room_dim_data       ; LD DE,34230       ; Copy data entry in room dimension data for entity's current room to #R34230...
       .ldir                           ; LDIR              ; ...
       movb @tmp_room_dim_data+1,a     ; LD A,(34231)      ; Load position (chars) of left side of current room into E...
       movb a,@e                       ; LD E,A            ; ...
       movb @tmp_room_dim_data+2,a     ; LD A,(34232)      ; Subtract position (chars) of right side of current room in A...
       sb   @e,a                       ; SUB E             ; ...
       ab   @bytes+100,a               ; ADD A,100         ; ...and add 100
       movb a,@tmp_width_current_room  ; LD (34235),A      ; Store value (width of current room + 99) at #R34235
       rt                              ; RET               ; Return
*// copy_room_dim_data_to_tmp

*********************************************************************************
* Paint Red Areas Outside Accessible Areas of Current Character's Current Room
* 
* Used by the routines at #R34438, #R34916, #R36616, #R48791, #R53723 and #R54456.
paint_red_areas:
       .proc
       bl   @copy_room_dim_data_to_tmp ; CALL 53825        ; Copy room dimension data entry for current character's current room to temporary store
                                                           ; location (#R34230)
       .push ix                        ; PUSH IX           ; Store IX
       bl    @clear_display_buffers    ; CALL 53635        ; Clear Display Buffers 1 & 2
       .exx                            ; EXX               ; Switch registers
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       .exx                            ; EXX               ; Switch registers
       movb @tmp_room_dim_data+1,@l    ; LD HL,(34231)     ; For current character's current room, set H = room's right edge position and L = room's left
       movb @tmp_room_dim_data+2,h     ; edge position (chars)
       movb @tmp_room_dim_data+3,@e    ; LD DE,(34233)     ; For current character's current room, set D = room's bottom edge position and E = room's top
       movb @tmp_room_dim_data+4,d     ; edge position (chars)
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       sb   b,b                        ; LD B,0            ; Set initial y-coordinate (characters) to zero
paint_red_areas_1:
       movb b,a                        ; LD A,B            ; Load A with current y-coordinate
       cb   a,@e                       ; CP E              ; If y-coordinate of top of room is greater than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb d,a                        ; LD A,D            ; Load A with y-coordinate of bottom of room
       cb   a,b                        ; CP B              ; If y-coordinate of bottom of room is less than current y-coordinate...
       jl   paint_red_areas_5          ; JR C,53950        ; ...then skip ahead to #R53950
       movb @bytes+0,@c                ; LD C,0            ; Set initial x-coordinate to zero
paint_red_areas_2:
       movb @c,a                       ; LD A,C            ; Load A with current x-coordinate
       cb   a,@l                       ; CP L              ; If x-coordinate of left of room is greater than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
       movb h,a                        ; LD A,H            ; Load A with x-coordinate of right of room
       cb   a,@c                       ; CP C              ; If x-coordinate of right of room is less than current x-coordinate...
       jl   paint_red_areas_3          ; JR C,53940        ; ...then skip ahead to #R53940
       .exx                            ; EXX               ; Switch registers
       bl   @print_red_cell_1          ; CALL 53977        ; Advance pointers in Display Buffers and Attribute File address to next character
       jmp  paint_red_areas_4          ; JR 53943          ; Skip ahead to #R53943
* Current x-coordinate, C, is outside range of x-coordinates spanned by room
paint_red_areas_3:
       bl   @print_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
paint_red_areas_4:
       ab   one,@c                     ; INC C             ; Advance C by one (move right one character)
       movb @c,tmp0                    ; BIT 5,C           ; If bit 5 is not set (x-coordinate has not reached 32)...
       andi tmp0,32*256                ;                   
       jeq  paint_red_areas_2          ; JR Z,53926        ; ...then loop back to #R53926
       jmp  paint_red_areas_7          ; JR 53959          ; Skip ahead to #R53959
* Current y-coordinate, B, is outside range of y-coordinates spanned by room
paint_red_areas_5:
       .push bc                        ; PUSH BC           ; Store BC (B = current y-coordinate, C = current x-coordinate)
       movb @bytes+32,b                ; LD B,32           ; Load counter with 32 (as there are 32 characters per row)
paint_red_areas_6:
       bl   @print_red_cell            ; CALL 53968        ; Print red cell to current Attribute File position (outside play area) and mark as unused in
                                                           ; Display Buffers
       sb   one,b                      ; DJNZ 53953        ; Loop back to #R53953 for next character block
       jne  paint_red_areas_6                     ;
       .pop bc                         ; POP BC            ; Restore BC (B = current y-coordinate, C = current x-coordinate)
paint_red_areas_7:
       ab   one,b                      ; INC B             ; Increase current y-coordinate by one
       movb b,a                        ; LD A,B            ; If y-coordinate has not reached 22...
       cb   a,@bytes+22                ; CP 22             ; ...
       jne  paint_red_areas_1          ; JR NZ,53916       ; ...then loop back to #R53916
       .pop ix                         ; POP IX            ; Restore IX
       .endproc                        ; RET               ; Return
*// paint_red_areas

*********************************************************************************
* Print Red Cell to Current Attribute File Position (Outside Play Area) and Mark as Unused in Display Buffers
* 
* Used by the routine at #R53887. Input:  IX  Address of start of Attribute File (22528) HL'  Current position in
* display buffer 1 (at #R61312) DE'  Current position in display buffer 2 (at #R63424)
print_red_cell:
       .proc
;       movb @bytes+18,*ix              ; LD (IX+0),18      ; Set attribute to red INK, red PAPER
       li   a,18*256
       mov  ix,tmp0
       bl   @draw_attribute
       .exx                            ; EXX               ; Switch registers
       movb @bytes+255,a               ; LD A,255          ; Load 255 into current positions in Display Buffers 1 and 2...
       movb a,*hl                      ; LD (HL),A         ; ...
       movb a,*de                      ; LD (DE),A         ; ...
       jmp  !
* This entry point is used by the routine at #R53887.
print_red_cell_1:
       .proc
!      inct hl                         ; INC HL            ; Advance display buffer 1 pointer by three bytes to next entry...
                                       ; INC HL            ; ...
       inc  hl                         ; INC HL            ; ...
       inct de                         ; INC DE            ; Advance display buffer 2 pointer by three bytes to next entry...
                                       ; INC DE            ; ...
       inc  de                         ; INC DE            ; ...
       .exx                            ; EXX               ; Switch registers
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
       .endproc                        ; RET               ; Return
*// print_red_cell

*********************************************************************************
* Reset Complex State Data for First Entity of Class A to that Stored in Initial-State Table at 59821
* 
* Used by the routines at #R37639 and #R48417. Input:  A  Entity class value IX  (Entry at #R53994 only) Address of
* complex state data for an entity
reset_1st_entity_of_class:
       .proc
       bl   @find_1st_entity_of_class                      ; CALL 54019        ; Load IX with address of complex state data for first entry in current level that has class
                                                           ; A...
       mov iy,ix                       ; PUSH IY           ; ..
                                       ; POP IX            ; ...
       jmp  reset_1st_entity_of_class_1
* This entry point is used by the routine at #R42064.
reset_1st_entity_of_class_0:
       .proc
reset_1st_entity_of_class_1:
       li   iy,initial_entity_states   ; LD IY,59821       ; Point IY at start of Table of Initial-State Data for Complex Entities
       bl   @find_1st_entity_of_class_0                   ; CALL 54023        ; Advance IY to first entry in copied complex state data that has class A
       .push ix                        ; PUSH IX           ; Store IX (address of entry in complex state data to overwrite)
       movb @e,b                       ; LD B,E            ; Load B with 13 (DE set to 13 in routine at #R54019)
reset_1st_entity_of_class_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Overwrite IX data entry with IY data...
       movb a,*ix+                     ; LD (IX+0),A       ; ...
                                       ; INC IX            ; ...
       inc  iy                         ; INC IY            ; ...
       sb   one,b                      ; DJNZ 54004        ; ...
       jne  reset_1st_entity_of_class_2                     ;
       .pop ix                         ; POP IX            ; Restore IX (address of entry in complex state data just overwritten)
       .endproc                        ; RET               ; Return
*// reset_1st_entity_of_class

*********************************************************************************
* Point IY at First Entry in Current Level's Complex State Data that has Class A
* 
* Used by the routines at #R36753 and #R53987. Input:  A  Value of an entity class Output: IY  Address of complex
* state data for first entity of class A
find_1st_entity_of_class:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
* This entry point is used by the routine at #R53987.
find_1st_entity_of_class_0:
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
find_1st_entity_of_class_1:
       cb   a,@8(iy)                   ; CP (IY+8)         ; If current IY entity has class A...
       jeq  find_1st_entity_of_class_2 ; RET Z             ; ...then return
       a    de,iy                      ; ADD IY,DE         ; Advance to entry for next entity
       jmp  find_1st_entity_of_class_1 ; JR 54026          ; Loop back to #R54026
find_1st_entity_of_class_2:
       rt
*// find_1st_entity_of_class

*********************************************************************************
* Draw Contents of Primary Display Buffer to Display
* 
* If either the graphic index, or the graphic set index for the current entry in the Primary Display Buffer is zero,
* then only the attribute from that entry is rendered; the currently displayed bitmap data (from the previous frame)
* is preserved.
draw_display_buffer:
       .proc
       li   ix,zx_attributes           ; LD IX,22528       ; Point IX at first byte of Attribute File
       li   hl,display_buffer_1        ; LD HL,61312       ; Point HL at Display Buffer 1
       li   de,display_buffer_2        ; LD DE,63424       ; Point DE at Display Buffer 2
       movb @display_buffer_flag,a     ; LD A,(34271)      ; If "Display Buffer 2 is Primary" Flag is reset...
                                       ; OR A              ; ...i.e. Display Buffer 1 is Primary...
       jeq  draw_display_buffer_1      ; JP Z,54052        ; ...then skip ahead to #R54052
       .ex_de_hl                       ; EX DE,HL          ; Switch DE and HL (Display Buffer 1 is Secondary, Display Buffer 2 is Primary)
draw_display_buffer_1:
       mov de,iy                       ; PUSH DE           ; Copy address of Secondary Display Buffer into IY...
                                       ; POP IY            ; ...
       li   de_,3
draw_display_buffer_2:
       movb *hl+,b                     ; LD A,(HL)         ; Read Graphic Set Index from Primary Display Buffer into A
                                       ; INC HL            ; Advance HL to next byte (Graphic Index) in Primary Display Buffer
                                       ; OR A              ; If Graphic Set Index is zero...
       jeq  draw_display_buffer_8      ; JP Z,54130        ; ...then skip ahead to #R54130
                                       ; CP 255            ; If Graphic Set Index is 255 (character block outside room's dimensions)...
       jlt  draw_display_buffer_9      ; JP Z,54140        ; ...then skip ahead to #R54140
                                       ; LD B,A            ; Transfer Graphic Set Index into B
       clr  de                         ; LD E,0            ; Set E to zero
       mov  iy,hl_
       cb   b,*hl_+                    ; CP (IY+0)         ; If Graphic Set Index in Primary Display Buffer entry is different to Graphic Set Index in
                                                           ; Secondary Display Buffer entry...
       jne  draw_display_buffer_3      ; JP NZ,54076       ; ...then skip ahead to #R54076
       inc  de                         ; INC E             ; Increase E
draw_display_buffer_3:
       movb *hl,@c                     ; LD A,(HL)         ; Load Graphic Index from Primary Display Buffer
                                       ; OR A              ; If Graphic Index is zero...
       jeq  draw_display_buffer_8      ; JP Z,54130        ; ...then skip ahead to #R54130
                                       ; LD C,A            ; Transfer Graphic Index into C
       cb   @c,*hl_+                   ; CP (IY+1)         ; If Graphic Index in Primary Display Buffer is different to Graphic Index in Secondary Display
                                                           ; Buffer...
       jne  draw_display_buffer_4      ; JP NZ,54089       ; ...then skip ahead to #R54089
       inc  de                         ; INC E             ; Increase E
draw_display_buffer_4:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Read attribute from Primary Display Buffer
       cb   a,*hl_                     ; CP (IY+2)         ; If attribute in Display Buffer entry A is different to attribute in Secondary Display Buffer
                                                           ; entry...
       jne  draw_display_buffer_5      ; JP NZ,54102       ; ...then skip ahead to #R54102
       dect de                         ; BIT 1,E           ; If E is 2 (i.e. both Graphic Set Index and Graphic Index are the same)...
                                       ;
       jeq  draw_display_buffer_6      ; JP NZ,54107       ; ...then skip ahead to #R54107, over drawing instructions (no need to redraw what is already
                                                           ; there)
draw_display_buffer_5:
                                       ; PUSH HL           ; Store HL (pointer to current position in Primary Display Buffer)
       bl   @draw_character_block      ; CALL 54144        ; Draw a graphic character block to display
                                       ; POP HL            ; Restore HL (pointer to current position in Primary Display Buffer)
draw_display_buffer_6:
       inc  hl                         ; INC HL            ; Advance HL to next byte in Primary Display Buffer (start of next entry)
draw_display_buffer_7:
       inc  ix                         ; INC IX            ; Advance IX to next byte in Attribute File
                                       ; PUSH IX           ; Copy current Attribute File address from IX to DE...
                                       ; POP DE            ; ...
                                       ; LD A,E            ; If current Attribute File address is not at the start of the seventh row of a third of the
                                                           ; display (i.e. row 7, 15 or 23)...
                                       ; CP 192            ; ...
                                       ; JR NZ,54122       ; ...then skip ahead to #R54122
                                       ; LD A,D            ; If current Attribute File address is 23232 (256*90 + 192, i.e. at start of second last
                                                           ; display character row)...
       ci   ix,zx_attributes+(22*32)   ; CP 90             ; ...
       jeq  draw_display_buffer_10     ; RET Z             ; ...then return, as only timer figures appear in last two rows
                                       ; LD DE,3           ; Advance current position in Secondary Display Buffer by 3 bytes...
       a    de_,iy                     ; ADD IY,DE         ; ...
       jmp  draw_display_buffer_2      ; JP 54055          ; Loop back to #R54055
draw_display_buffer_8:
       inc  hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       movb *hl,a                      ; LD A,(HL)         ; Load attribute into A
       socb @bits+6,a                  ; SET 6,A           ; Set BRIGHT flag
       mov  ix,tmp0                    ; LD (IX+0),A       ; Place attribute at current position in Attribute File
       bl   @draw_attribute
       jmp  draw_display_buffer_6      ; JP 54107          ; Loop back to #R54107
draw_display_buffer_9:
       inct hl                         ; INC HL            ; Advance HL to third byte (attribute) in Primary Display Buffer entry
       jmp  draw_display_buffer_7      ; JP 54107          ; Loop back to #R54107
draw_display_buffer_10:
       .endproc
*// draw_display_buffer

*********************************************************************************
* Draw a Graphic Character Block to Display
* 
* This routine uses the same technique as seen in the routine at #R47709 to convert from an Attribute File address
* to a Display File address. See the notes in #R47709 for more details. Input:  A  Attribute value (bit 7 is
* "mirror" flag, rather than FLASH) B  Graphic set index C  Graphic index IX  Address in Attribute File
draw_character_block:
       .proc
*      VDP address
       mov  ix,tmp0
       ai   tmp0,-zx_attributes
       sla  tmp0,3
       bl   @vwad
       li   tmp2,vdpwd
*      Graphics address
       mov  bc,tmp1
       srl  tmp1,8
       sla  tmp1,1
       mov  @graphic_sets_table(tmp1),tmp1
       mov  bc,tmp0
       andi tmp0,>00ff
       sla  tmp0,3
       a    tmp1,tmp0
*      Draw mirrored?
       socb @bits+6,a                  ; SET 6,A           ; Set Bright Flag
       jlt  draw_character_block_1
*      Draw normal block
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       jmp  draw_character_block_3
*      Draw mirrored
draw_character_block_1:
       clr  tmp1
       li   bc,8
draw_character_block_2:
       movb *tmp0+,@r1lb
       movb @byte_mirror_table(tmp1),*tmp2
       dec  bc
       jne  draw_character_block_2
*      Draw attribute
draw_character_block_3:
       mov  ix,tmp0
       bl   @draw_attribute
;       movb a,*ix                      ; LD (IX+0),A       ; Load attribute value into current Attribute File address
;       sb   a,a                        ; XOR A             ; Load graphic set index into HL..
;       movb b,@l                       ; LD L,B            ; ...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Double (as start address entries in table at #R27000 are two bytes wide)...
;       li   de,graphic_sets_table      ; LD DE,27000       ; ...and add as offset to #R27000 (in HL)...
;       a    de,hl                      ; ADD HL,DE         ; ...
;       movb *hl,@e                     ; LD E,(HL)         ; Load start address for this graphic set into DE...
;       inc  hl                         ; INC HL            ; ...
;       movb *hl,d                      ; LD D,(HL)         ; ...
;       movb @c,@l                      ; LD L,C            ; Load graphic index into HL...
;       movb a,h                        ; LD H,A            ; ...
;       a    hl,hl                      ; ADD HL,HL         ; Multiply by eight, as graphic blocks are eight bytes long...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    hl,hl                      ; ADD HL,HL         ; ...
;       a    de,hl                      ; ADD HL,DE         ; Add to address of start of this graphic set as an offset in HL
;       .ex_de_hl                       ; EX DE,HL          ; Swap DE (now points to required graphic data) and HL (now address of start of graphic set
;                                                           ; from table at #R27000)
;       .push ix                        ; PUSH IX           ; Switch Attribute File address into HL...
;       .pop hl                         ; POP HL            ; ...
;       movb h,a                        ; LD A,H            ; Multiply the most significant byte (MSB) of the Attribute File address by eight...
;       ab   a,a                        ; ADD A,A           ; ...to put it on the same scale as the MSB of the Display File address MSB (see notes)...
;       ab   a,a                        ; ADD A,A           ; ...
;       ab   a,a                        ; ADD A,A           ; ...
;       andi a,91*256                   ; AND 91            ; Drop the most significant bit to point to the correct location in Display File;       movb a,h                        ; LD H,A            ; Load back into HL (L is unaffected, as it should be)
;       .ex_de_hl                       ; EX DE,HL          ; Switch DE (now Display File address) and HL (now pointer to graphic data)
;       movb *ix,tmp0                   ; BIT 7,(IX+0)      ; If mirror flag is set for Attribute File at current location...
;       andi tmp0,128*256               ;
;       jeq  !                          ; JP NZ,54194       ; ...then skip to #R54194 to draw mirrored version
;       b    @draw_mirrored_block       ;
;!
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54187:
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       movb a,*de                      ; LD (DE),A         ; ...and load into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       sb   one,b                      ; DJNZ 54187        ; Loop back for next row of pixels
;       jne  _54187                     ;
       .endproc                         ; RET               ; Return
*// draw_character_block

*********************************************************************************
* Draw Mirrored Graphic Character Block to Display File
* 
* Used by the routine at #R54144. Input:  HL  Address of bitmap data to draw IX  Address in Attribute File
;draw_mirrored_block:
;       szcb @bits+7,*ix                ; RES 7,(IX+0)      ; Reset Bit 7 (Mirror Flag, shared with FLASH flag so would cause graphic to flash)
;       movb @bytes+8,b                 ; LD B,8            ; Set counter to 8 rows
;_54200:
;       .push bc                        ; PUSH BC           ; Store BC (B = current counter value)
;       movb *hl,a                      ; LD A,(HL)         ; Read byte from graphic data...
;       .push hl                        ; PUSH HL           ; Store HL (pointer to graphic data)
;       li   hl,byte_mirror_table       ; LD HL,27030       ; Point HL at mirror graphic lookup table
;       movb a,@c                       ; LD C,A            ; Load graphic "value" into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,hl                      ; ADD HL,BC         ; ...and add to HL as offset
;       movb *hl,a                      ; LD A,(HL)         ; Read byte at this location (mirror image of graphic data read by instruction at 54201)
;       .pop hl                         ; POP HL            ; Restore HL (pointer to graphic data)
;       movb a,*de                      ; LD (DE),A         ; Load (mirrored) graphic data into Display File
;       ab   one,d                      ; INC D             ; Move down one pixel row in Display File
;       inc  hl                         ; INC HL            ; Advance to next byte of graphic data
;       .pop bc                         ; POP BC            ; Restore BC (B = current counter value)
;       sb   one,b                      ; DJNZ 54200        ; Loop back for next row of pixels
;       jne  _54200                     ;
;       rt                               ; RET               ; Return

*********************************************************************************
* Load A with a Pseudo-Random Number Between 0 and the Higher of 2 and A (Input)
* 
* This routine uses a linear congruential generator to generate a new pseudo-random number based upon a seed value.
* The seed value is stored at #R54219, is initially set to the value in the least significant byte of the system
* variable FRAMES, and subsequently set to the previously generated pseudo-random number. On entering this routine,
* the A register holds the range for the random number (e.g. 5 means this routine will generate a random number in
* the range 0-4 inclusive). A range of less than 2 is not allowed, so if A is less than this then it will be set to
* 2. Input:  A  Range Output: A  Generated random number
rnd_no:
       .proc
       cb   a,@bytes+2                 ; CP 2              ; If range is less than 2...
       jhe  rnd_no_1                   ; JP NC,54229       ; ...then set range to 2...
       movb @bytes+2,a                 ; LD A,2            ; ...
rnd_no_1:
       bl   @randl
;       movb a,@rnd_range               ; LD (54221),A      ; Store range at #R54211
;       .push hl                        ; PUSH HL           ; Store HL
;       .push de                        ; PUSH DE           ; Store DE
;       .push bc                        ; PUSH BC           ; Store BC
;       mov  @rnd_seed,de               ; LD DE,(54219)     ; Load DE with seed
;       movb @e,h                       ; LD H,E            ; Load least significant byte of random seed into H
;       movb @bytes+253,@l              ; LD L,253          ; Set L to 253
;       movb d,a                        ; LD A,D            ; Load most significant byte (MSB) of random seed into A
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (256 * seed + 253)
;                                       ; OR A              ; Reset carry flag
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;       s    de,hl                      ; SBC HL,DE         ; Subtract seed from HL...
;       sb   @bytes+0,a                 ; SBC A,0           ; ...and decrement A if Carry Flag is set
;* At this point, the three registers A, H and L encode a 24-bit number whose value is (254 * seed + 253)
;       movb a,@e                       ; LD E,A            ; Calculate (AHL mod 65,537)...
;       movb @bytes+0,d                 ; LD D,0            ; ...loading result into HL...
;       s    de,hl                      ; SBC HL,DE         ; ...
;       joc  !                          ; JP NC,54261       ; ...and if this is negative...
;       b    @rnd_no_2                  ;
;!
;       inc  hl                         ; INC HL            ; ...then add one (as zero in HL can represent both zero and 65,536)
;rnd_no_2:
;       mov  hl,@rnd_seed               ; LD (54219),HL     ; Store HL (new seed) at #R54219
;* At this point, HL contains a new pseudo-random 16-bit number
;       .push hl                        ; PUSH HL           ; Copy 16-bit pseudo-random number from HL into DE...
;       .pop de                         ; POP DE            ; ...
;       movb @rnd_range,a               ; LD A,(54221)      ; Load A with range as stored previously
;       sb   one,a                      ; DEC A             ; Decrease range by 1 to get maximum value as we want the output to range from 0 to (A-1)...
;       movb a,b                        ; LD B,A            ; ...and load into B (loop counter)
;* In the following loop we are obtaining the number of times that 65,536 goes into RANGE x DE. In other words,
;* (RANGE x DE) is divided by 65,536 and the integer part of the result is loaded into A. A is therefore limited to
;* values between zero, and the value A had on entering this routine minus one, inclusive.
;       sb   a,a                        ; XOR A             ; Set A to zero
;rnd_no_3:
;       a    de,hl                      ; ADD HL,DE         ; Add DE to HL
;       joc  !                          ; JP NC,54277       ; If DE has not crossed the 65,535 - 0 boundary then skip ahead to #R54277
;       b    @rnd_no_4                  ;
;!
;       ab   one,a                      ; INC A             ; Increase A (count of number of times DE rolls over from 65,535 to 0)
;rnd_no_4:
;       sb   one,b                      ; DJNZ 54272        ; Decrease B and loop back to #R54272
;       jne  rnd_no_3                   ;
;       .pop bc                         ; POP BC            ; Restore BC
;       .pop de                         ; POP DE            ; Restore DE
;       .pop hl                         ; POP HL            ; Restore HL
       .endproc                         ; RET               ; Return
*// rnd_no

*********************************************************************************
* Move Entity at IX into New Room (Left or Right) if it is at the Edge of its Current Room
* 
* Used by the routines at #R35735 and #R55041. Input:  IX  Address of complex state data for an entity
move_into_new_room:
       .proc
       movb @tmp_width_current_room,a  ; LD A,(34235)      ; Load A with width of current room (chars) + 97...
       sb   one,a                      ; DEC A             ; ...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@5(ix)                   ; CP (IX+5)         ; If x-coordinate of left side (+100) of entity is greater than this...
       jl   move_into_new_room_1       ; JR C,54306        ; ...then skip ahead to #R54306
       movb @7(ix),a                   ; LD A,(IX+7)       ; If x-coordinate of right side (+100) of entity is not less than 102...
       cb   a,@bytes+102               ; CP 102            ; ...
       jhe  move_into_new_room_2       ; RET NC            ; ...then return
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       jmp  move_into_new_room_2       ; RET               ; Return
move_into_new_room_1:
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
move_into_new_room_2:
       .endproc                        ; RET               ; Return
*// move_into_new_room

*********************************************************************************
* Move Entity at IX into Room to the Right, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading side (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading side crosses the boundary.
* This routine (along with its counterpart at #R54348) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the right, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_right_room:
       .proc
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load C with width of entity's current room (chars) + 99...
       movb a,@c                       ; LD C,A            ; ...
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  move_into_right_room_1     ; JR Z,54329        ; ...then skip ahead to #R54329
       movb @5(ix),a                   ; LD A,(IX+5)       ; Load A with x-coordinate of Drutt's left edge
       jmp  move_into_right_room_2     ; JR 54332          ; Skip ahead to #R54332
move_into_right_room_1:
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of Berk's right edge
move_into_right_room_2:
       cb   a,@c                       ; CP C              ; If x-coordinate of room's right edge is greater than x-coordinate in A...
       jl   move_into_right_room_3     ; RET C             ; ...then return
       bl   @get_right_room_index      ; CALL 54505        ; Load B with index of room to right of current character's current room
       jeq  move_into_right_room_4     ; JR Z,54381        ; If there is no room to the right, then jump to #R54381
       bl    @do_move_into_right_room  ; CALL 54383        ; Move entity at IX into room to right of its current room and update position of carried
                                                           ; entity if moving entity is Berk
       bl   @chk_coll_right            ; CALL 54569        ; Check entity at IX for collision with another impassable / pushable entity immediately to the
                                                           ; right...
       jnc  move_into_right_room_4     ; JR NC,54381       ; ...and if a collision occurred, then jump to #R54381
move_into_right_room_3:
       b    @return_with_carry         ; RET               ; Return
move_into_right_room_4:
       sb   a,a
       b    @return_without_carry
*// move_into_right_room

*********************************************************************************
* Move Entity at IX into Room to the Left, If Appropriate
* 
* This routine moves an entity (e.g. Berk or Drutt) into the next room to the right, if there is one, in a way that
* is consistent with the point of view of the currently selected character. For example, if Berk is the selected
* character and he moves into a new room, he does so as soon as his leading edge (left or right) crosses the edge of
* the screen. He essentially disappears immediately from his old room. However from Drutt's point of view, Berk
* should move across the boundary smoothly and not just vanish as soon as his leading edge crosses the boundary.
* This routine (along with its counterpart at #R54313) ensures that this happens correctly. Input:  IX  Address of
* complex state data for an entity Output: A  Zero if no room exists to the left, otherwise, x-coordinate of
* character's appropriate edge F  (Carry Flag) Set if entity is not at edge of current room, or has moved into new
* room and has not collided. Reset otherwise (i.e. can't enter new room).
move_into_left_room:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; If Drutt Mode Flag is reset (Berk Mode)...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;                   
       jeq  move_into_left_room_1      ; JR Z,54363        ; ...then skip ahead to #R54363
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Drutt's right edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@7(ix)                   ; CP (IX+7)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
       jmp  move_into_left_room_2      ; JR 54369          ; Skip ahead to #R54369
move_into_left_room_1:
       movb @bytes+100,a               ; LD A,100          ; If x-coordinate of Berk's left edge is greater than 100 (x-coordinate of left-edge of
                                                           ; room)...
       cb   a,@5(ix)                   ; CP (IX+5)         ; ...
       jl   move_into_left_room_3      ; RET C             ; ...then return
move_into_left_room_2:
       bl   @get_left_room_index       ; CALL 54539        ; Load B with index of room to left of entity's current room
       jeq  move_into_left_room_4      ; JR Z,54381        ; If there is no room to the left, then jump to #R54381
       bl   @do_move_into_left_room    ; CALL 54419        ; Move entity at IX into room to left of its current room and update position of carried entity
                                                           ; if moving entity is Berk
       bl    @chk_coll_left            ; CALL 54666        ; Set Carry Flag if entity at IX has not collided with another impassable / pushable entity
       jnc   move_into_left_room_4                         ; immediately to the left, reset otherwise
move_into_left_room_3:
       bl   @return_with_carry         ; RET               ; Return
move_into_left_room_4:
       sb   a,a                        ; XOR A             ; Set A to zero
       bl   @return_without_carry      ; RET               ; Return
*// move_into_left_room

*********************************************************************************
* Move Entity at IX into Room to Right of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48593, #R54283 and #R54313. Input:  IX  Address of complex state data for an entity
do_move_into_right_room:
       .proc
       bl   @move_to_left_of_right_room                    ; CALL 54398        ; Set character's position to be left-hand side of new room to right
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;                   
       jne  do_move_into_right_room_1  ; RET NZ            ; ...then return
       bl   @move_carried_to_right                   ; CALL 48727        ; If entity is Berk then move carried entity to Berk's right as he faces right
do_move_into_right_room_1:
       .endproc                        ; RET               ; Return
*// do_move_into_right_room

*********************************************************************************
* Set Entity's Position to be Left-Hand Side of New Room to Right
* 
* Used by the routine at #R54383. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
move_to_left_of_right_room:
       .proc
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load D with i.e. x-coordinate of right edge of room (width of current room (chars) + 99)
                                                           ; minus x-coordinate of right-edge of current character...
       sb   @7(ix),a                   ; SUB (IX+7)        ; ...(i.e. [negative] distance by which entity's right edge is to the right of right edge of
                                                           ; room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @bytes+99,a                ; LD A,99           ; Load A with x-coordinate of left edge of current (new) room
       sb   d,a                        ; SUB D             ; Subtract D (negative)...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set as new x-coordinate of entity's right edge
       sb   @e,a                       ; SUB E             ; Subtract (width - 1) of entity...
       movb a,@5(ix)                   ; LD (IX+5),A       ; ...and set this as x-coordinate of entity's left edge
       .endproc                        ; RET               ; Return
*// move_to_left_of_right_room

*********************************************************************************
* Move Entity at IX into Room to Left of its Current Room and Update Position of Carried Entity if Moving Entity is
* Berk
* 
* Used by the routines at #R48641, #R54283 and #R54348.
do_move_into_left_room:
       .proc
       bl   @move_to_right_of_left_room                   ; CALL 54434        ; Set entity's position to be right-hand side of new room to left
       bl   @paint_red_areas_char      ; CALL 54456        ; Paint red areas outside current character's room if IX points to current character's complex
                                                           ; state data
       movb @9(ix),tmp0                ; BIT 7,(IX+9)      ; If entity is Berk and his Moving Upwards Flag (floating) is set...
       andi tmp0,128*256               ;                   
       jne  do_move_into_left_room_1   ; RET NZ            ; ...then return
       bl   @move_carried_to_left      ; CALL 48738        ; If entity is Berk then move carried entity to Berk's left as he faces left
do_move_into_left_room_1:
       .endproc                        ; RET               ; Return
*// do_move_into_left_room

*********************************************************************************
* Set Entity's Position to be Right-Hand Side of New Room to Left
* 
* Used by the routine at #R54419. Input:  B  Index of destination room IX  Address of complex state data for an
* entity
move_to_right_of_left_room:
       .proc
       movb @bytes+100,a               ; LD A,100          ; Load D with x-coordinate of left edge of room minus x-coordinate of left edge of current
                                                           ; entity...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...(i.e. distance by which entity's left edge is to the left of left edge of room)...
       movb a,d                        ; LD D,A            ; ...
       bl   @set_room_of_entity        ; CALL 54480        ; Set room of entity to B, store room size data for new room and load E with entity's width
                                                           ; minus one
       movb @tmp_width_current_room,a                  ; LD A,(34235)      ; Load A with width of current (new) room (chars) + 99
       sb   d,a                        ; SUB D             ; Subtract D...
       ab   one,a                      ; INC A             ; ...and add one to get x-coordinate of entity's left edge in new room
       movb a,@5(ix)                   ; LD (IX+5),A       ; Set entity's left edge to this position
       ab   @e,a                       ; ADD A,E           ; Add (width - 1) of entity...
       movb a,@7(ix)                   ; LD (IX+7),A       ; ...and set this as x-coordinate of entity's right edge
       .endproc                        ; RET               ; Return
*// move_to_right_of_left_room

*********************************************************************************
* Paint Red Areas Outside Current Character's Room if IX Points to Current Character's Complex State Data
* 
* Used by the routines at #R54383, #R54419, #R55433 and #R55616. Input:  IX  Address of complex state data for an
* entity
paint_red_areas_char:
       .proc
       movb @game_flags,a              ; LD A,(34208)      ; Set Zero Flag if Drutt Mode Flag is reset...
       movb a,tmp0                     ; BIT 0,A           ; ...
       andi tmp0,1*256                 ;
       movb @8(ix),a                   ; LD A,(IX+8)       ; Load Entity Class Value of entity at IX into A
       mov  tmp0,tmp0
       jne  paint_red_areas_char_1     ; JR NZ,54471       ; If Zero Flag is reset (i.e. Drutt Mode) then skip ahead to #R54471
       cb   a,@bytes+31                ; CP 31             ; If Entity Class is 31 (i.e. Berk)...
       jeq  paint_red_areas_char_2     ; JR Z,54474        ; ...then paint red areas outside accessible areas of current character's current room and
                                                           ; return
       jmp  paint_red_areas_char_3     ; RET               ; Return
paint_red_areas_char_1:
       cb   a,@bytes+18                ; CP 18             ; If Entity Class is not 18 (i.e. Drutt)...
       jne  paint_red_areas_char_3     ; RET NZ            ; ...then return
paint_red_areas_char_2:
       .push hl                        ; PUSH HL           ; Store HL
       bl @paint_red_areas             ; CALL 53887        ; Paint red areas outside accessible areas of current character's current room
       .pop hl                         ; POP HL            ; Restore HL
paint_red_areas_char_3:
       .endproc                        ; RET               ; Return

*********************************************************************************
* Set Room of Entity at IX to B, Store Room Size Data for New Room and Load E with Entity's Width Minus One
* 
* Used by the routines at #R54398, #R54434, #R55433 and #R55616. Input:  B  Destination room index IX  Address of
* complex state data for an entity Output: E  Entity's width, minus one (characters)
set_room_of_entity:
       .proc
       movb b,a                        ; LD A,B            ; Set entity's current room to be destination room...
       movb a,*ix                      ; LD (IX+0),A       ; ...
       .push hl                        ; PUSH HL           ; Store HL
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for entity's current room
       .pop de                         ; POP DE            ; Restore DE
       .pop hl                         ; POP HL            ; Restore HL
       movb @7(ix),a                   ; LD A,(IX+7)       ; Load A with x-coordinate of entity's right...
       sb   @5(ix),a                   ; SUB (IX+5)        ; ...subtract x-coordinate of entity's left...
       movb a,@e                       ; LD E,A            ; ...and load result (entity's width minus one) into E
       .endproc                        ; RET               ; Return

*********************************************************************************
* Load B with Index of Room to Right of an Entity's Current Room
* 
* Used by the routines at #R48593, #R52193, #R54283 and #R54313. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54512 only) An entry in a room connectivity table D  (entry at #R54508 and #R54512 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the right, reset otherwise
get_right_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_right_room_index_1:
       mov  @horz_room_connect_map,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
* This entry point is used by the routine at #R54499.
get_right_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load first byte (left room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_right_room_index_3     ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  _54527                     ; JR NZ,54527       ; ...then skip ahead to #R54527
       movb @1(iy),b                   ; LD B,(IY+1)       ; Load second byte (right room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_right_room_index_3     ; RET               ; Return
_54527:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_right_room_index_2                         ; JR 54512          ; Loop back to #R54512
get_right_room_index_3:
       rt

*********************************************************************************
* Load B with Index of Room to Left of an Entity's Current Room
* 
* Used by the routines at #R48641, #R52098, #R54283 and #R54348. Input:  IX  Address of complex state data for an
* entity IY  (entry at #R54546 only) An entry in a room connectivity table D  (entry at #R54542 and #R54546 only)
* Index of base room for check Output: B  Index of room found if there is one, undefined otherwise F  Zero Flag set
* if there is no room to the left, reset otherwise
get_left_room_index:
       movb *ix,d                      ; LD D,(IX+0)       ; Load current room of entity pointed to by IX into D
* This entry point is used by the routine at #R53194.
get_left_room_index_1:
       mov  @horz_room_connect_map,iy                 ; LD IY,(34250)     ; Load start address of current level's Horizontal Room Connectivity Data into IY
       movb @bytes+255,b                                   ; Init result to not found
* This entry point is used by the routine at #R54533.
get_left_room_index_0:
       inc  iy                         ; INC IY            ; Advance by one byte to second byte (right room index) of first entry
get_left_room_index_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load second byte (right room index) of current entry into A
       cb   a,@bytes+255               ; CP 255            ; If byte is 255 (i.e. the End Marker)...
       jeq  get_left_room_index_4      ; RET Z             ; ...then return
       cb   a,d                        ; CP D              ; If byte is not the same as the room index in D...
       jne  get_left_room_index_3      ; JR NZ,54563       ; ...then skip ahead to #R54563
       movb @-1(iy),b                  ; LD B,(IY-1)       ; Load first byte (left room index) of current entry into B
       cb   a,@bytes+255               ; CP 255            ; Reset zero flag (as current room cannot be 255)
       jmp  get_left_room_index_4      ; RET               ; Return
get_left_room_index_3:
       inct iy                         ; INC IY            ; Advance by two bytes to the next entry...
                                       ; INC IY            ; ...
       jmp  get_left_room_index_2                          ; JR 54548          ; Loop back to #R54548
get_left_room_index_4:
       rt

*********************************************************************************
* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Right
* 
* Used by the routines at #R36116, #R52148, #R52193, #R52889, #R52914, #R54313 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_right:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_right_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_right_2           ; JR NZ,54585       ; ...then skip ahead to #R54585
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_right_2:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_right_4           ; JP NZ,54662       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_right_4           ; JR Z,54662        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_right_3           ; JR NZ,54620       ; ...then skip over depth check to #R54620
                                       ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   @1(iy),@1(ix)              ; CP (IX+1)         ; ...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
chk_coll_right_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Rightwards" Flag reset...
       andi a,32*256                   ; AND 32            ; ...
       jeq  chk_coll_right_4           ; JP Z,54662        ; ...then advance IY to next entity
       movb @7(ix),a                   ; LD A,(IX+7)       ; If the right side of entity at IX...
       ab   one,a                      ; INC A             ; ...
       cb   a,@5(iy)                   ; CP (IY+5)         ; ...is not immediately to the left of the left side of the entity at IY...
       jne  chk_coll_right_4           ; JR NZ,54662       ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_right_4           ; JR C,54662        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_right_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_right_1           ; JR 54576          ; Loop back to #R54576

*********************************************************************************
* Check Entity at IX for Collision With Another (Impassable / Pushable) Entity Immediately to the Left
* 
* Used by the routines at #R36116, #R52053, #R52098, #R52870, #R52914, #R54348 and #R55041. Input:  IX  Address of
* complex state data for an entity Output: F  Carry Flag set if no entity found, reset otherwise A  Class of entity,
* if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_left:
       .proc
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
chk_coll_left_1:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_left_2            ; JR NZ,54682       ; ...then skip ahead to #R54682
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry         ; RET               ; Return
chk_coll_left_2:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_left_4            ; JP NZ,54760       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_left_3            ; JR NZ,54718       ; ...then skip over depth check to #R54620
                                       ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       cb   @1(iy),@1(ix)              ; CP (IX+1)         ; ...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
chk_coll_left_3:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its "Impassable / Pushable Leftwards" Flag reset...
       andi a,16*256                   ; AND 16            ; ...
       jeq  chk_coll_left_4            ; JP Z,54760        ; ...then advance IY to next entity
       movb @5(ix),a                   ; LD A,(IX+5)       ; If the left side of entity at IX...
       sb   one,a                      ; DEC A             ; ...
       cb   a,@7(iy)                   ; CP (IY+7)         ; ...is not immediately to the right of the right side of the entity at IY...
       jne  chk_coll_left_4            ; JR NZ,54760       ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_left_4            ; JR C,54760        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry      ; RET               ; Return
chk_coll_left_4:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_left_1            ; JR 54673          ; Loop back to #R54673

*********************************************************************************
* Check Entity at IX for Collision With Another Entity at Next Depth Level Out Of Screen Whose Interaction (11,6)
* Flag is Set
* 
* Used by the routines at #R37639 and #R52315. Input:  IX  Address of complex state data for an entity Output: F
* Carry Flag set if no entity found, reset otherwise A  Class of entity, if found, otherwise 255 IY  Address of
* complex state data for colliding entity
chk_coll_next_depth:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level out of screen)
       jmp  chk_coll_same_depth_1      ; JR 54770          ; Jump to collision detection routine

* Check Entity at IX for Collision With Another Entity at Same Depth Whose Interaction (11,6) Flag is Set
* 
* Used by the routines at #R36036, #R36542, #R37085, #R38074, #R38219, #R38540, #R38592, #R41498, #R41633, #R41961,
* #R42064, #R42266, #R42486, #R48487, #R51779, #R53083, #R55196 and #R55525. Input:  IX  Address of complex state
* data for an entity C  (Entry at #R54770 only) Depth offset Output: F  Carry Flag set if no entity found, reset
* otherwise A  Class of entity, if found, otherwise 255 IY  Address of complex state data for colliding entity
chk_coll_same_depth:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
* This entry point is used by the routine at #R54764.
chk_coll_same_depth_1:
       mov  @cmplx_state_data_addr,iy  ; LD IY,(34238)     ; Load start address of current level's complex state data into IY
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
chk_coll_same_depth_2:
       movb *iy,a                      ; LD A,(IY+0)       ; Load A with room index for current IY entity
       cb   a,@bytes+255               ; CP 255            ; If this is not 255 (i.e. End Marker)...
       jne  chk_coll_same_depth_3      ; JR NZ,54786       ; ...then skip ahead to #R54786
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return
chk_coll_same_depth_3:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_same_depth_6      ; JR NZ,54874       ; ...then advance IY to next entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_same_depth_6      ; JP NZ,54874       ; ...then advance IY to next entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_same_depth_6      ; JR Z,54874        ; ...then advance IY to next entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_same_depth_4      ; JR NZ,54822       ; ...then skip over depth check to #R54822
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       ab   @c,a                       ; ADD A,C           ; ...plus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_same_depth_6      ; JR NZ,54874       ; ...then advance IY to next entity
chk_coll_same_depth_4:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,6) Flag reset...
       andi a,64*256                   ; AND 64            ; ...
       jeq  chk_coll_same_depth_6      ; JP Z,54874        ; ...then advance IY to next entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   @7(ix),@5(iy)              ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   @7(iy),@5(ix)              ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_same_depth_6      ; JR C,54874        ; ...then advance IY to next entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
* This entry point is used by the routines at #R55196 and #R55525.
chk_coll_same_depth_5:
       li   de,13                      ; LD DE,13          ; Load DE with 13, as entries in complex state data are 13 bytes wide
chk_coll_same_depth_6:
       a    de,iy                      ; ADD IY,DE         ; Advance IY pointer to next entity in complex state data block
       jmp  chk_coll_same_depth_2      ; JR 54777          ; Loop back to #R54777

* Check Entity at IX for Collision With Another Entity (Only those Defined Before, and in Reverse Order) at Same
* Depth Level Whose Interaction (11,7) Flag is Set
* 
* Used by the routine at #R52315. Input:  IX  Address of complex state data for an entity Output: F  Carry Flag set
* if no entity found, reset otherwise A  Class of entity, if found, otherwise 254 IY  Address of complex state data
* for colliding entity
chk_coll_same_depth_rev:
       movb @bytes+0,@c                ; LD C,0            ; Set depth offset to 0 (i.e. check entities at same depth)
       mov  ix,iy                      ; PUSH IX           ; Load IY with address in IX...
                                       ; POP IY            ; ...
       li   de,-13                     ; LD DE,65523       ; Load DE with -13
       jmp  chk_coll_next_depth_rev_3  ; JP 54987          ; Move IY back to previous entity in complex state data and jump into collision check routine

*********************************************************************************
* Check Entity at IX for Collision With Another Entity (in Reverse Order) at Next Depth Level Into Screen Whose
* Interaction (11,7) Flag is Set
* 
* The address stored at #R34246 is the address of complex state data for the entity to start with when doing
* collision checks in reverse order. On levels 2, 3 and 4, the value stored here is the address of the complex state
* data of the last entity, which means that on these levels, all entities are checked. On Level 1, however, the
* value stored is the address of the complex state data of the sixth-last entity. The remaining five entities after
* this address on Level 1 are the three spiders, their webs and their arches. This means that on Level 1, these
* spiders, webs and arches are excluded from certain collision checks. Input:  IX  Address of complex state data for
* an entity C  (Entry at #R54899 only) Depth offset Output: F  Carry Flag set if no entity found, reset otherwise A
* Class of entity, if found, otherwise 254 IY  Address of complex state data for colliding entity
chk_coll_next_depth_rev:
       movb one,@c                     ; LD C,1            ; Set depth offset to 1 (i.e. check entities at next depth level into screen)
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (as entries in complex state data are 13 bytes wide)
       mov  @addr_rev_col_check,iy                 ; LD IY,(34246)     ; Load IY with current level's start address for reverse-order collision checks
chk_coll_next_depth_rev_1:
                                       ; LD A,(IX+0)       ; If room of entity at IX is not the same as room of entity at IY...
       cb   *ix,*iy                    ; CP (IY+0)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
       movb @10(iy),tmp0               ; BIT 5,(IY+10)     ; If current entity at IY has its Is Being Carried Flag set...
       andi tmp0,32*256                ;                   
       jne  chk_coll_next_depth_rev_3  ; JP NZ,54987       ; ...then move IY back to previous entity
       movb @8(iy),a                   ; LD A,(IY+8)       ; If current entity at IY has a class which is the same as the entity at IX...
       cb   a,@8(ix)                   ; CP (IX+8)         ; ...
       jeq  chk_coll_next_depth_rev_3  ; JR Z,54987        ; ...then move IY back to previous entity
       andi a,128*256                  ; BIT 7,A           ; If entity at IY has its "Spans Full Depth" Flag is set...
       jne  chk_coll_next_depth_rev_2  ; JR NZ,54935       ; ...then skip over depth check to #R54935
       movb @1(iy),a                   ; LD A,(IY+1)       ; If entity at IY has a depth which is not the same as the depth of the entity at IX...
       sb   @c,a                       ; SUB C             ; ...minus depth offset...
       cb   a,@1(ix)                   ; CP (IX+1)         ; ...
       jne  chk_coll_next_depth_rev_3  ; JR NZ,54987       ; ...then move IY back to previous entity
chk_coll_next_depth_rev_2:
       movb @11(iy),a                  ; LD A,(IY+11)      ; If entity at IY has its Interaction (11,7) Flag reset...
       andi a,128*256                  ; AND 128           ; ...
       jeq  chk_coll_next_depth_rev_3  ; JP Z,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IX+6)       ; If the bottom of the entity at IX...
       cb   @6(ix),@4(iy)              ; CP (IY+4)         ; ...is above the top of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IY+6)       ; If the bottom of the entity at IY...
       cb   @6(iy),@4(ix)              ; CP (IX+4)         ; ...is above the top of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IX+7)       ; If the right side of entity IX...
       cb   @7(ix),@5(iy)              ; CP (IY+5)         ; ...is to the left of the left side of the entity at IY...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; LD A,(IY+7)       ; If the right side of entity IY...
       cb   @7(iy),@5(ix)              ; CP (IX+5)         ; ...is to the left of the left side of the entity at IX...
       jl   chk_coll_next_depth_rev_3  ; JR C,54987        ; ...then move IY back to previous entity
                                       ; XOR A             ; Set A to zero to reset Carry Flag
       mov  iy,@coll_entity_addr       ; LD (34258),IY     ; Store pointer to current entity at #R34258
       movb @8(iy),a                   ; LD A,(IY+8)       ; Load A with class of entity at IY
       b    @return_without_carry_1    ; RET               ; Return
       li   de,-13                     ; LD DE,65523       ; Load DE with -13 (?)
* This entry point is used by the routine at #R54878.
chk_coll_next_depth_rev_3:
       movb @-1(iy),a                  ; LD A,(IY-1)       ; If byte before current IY position is 254 (i.e. end marker for simple state data)...
       cb   a,@bytes+254               ; CP 254            ; ...
       jeq  chk_coll_next_depth_rev_4  ; JP Z,55000        ; ...then skip ahead to #R55000
       a    de,iy                      ; ADD IY,DE         ; Move IY back 13 bytes (i.e. to start of previous entry)
       b    @chk_coll_next_depth_rev_1 ; JP 54899          ; Jump to #R54899
chk_coll_next_depth_rev_4:
                                       ; SCF               ; Set Carry Flag
       b    @return_with_carry_1       ; RET               ; Return

*********************************************************************************
* Set Character Swap Pending Flag
* 
* Used by the routine at #R55041.
set_swap_pending_flag:
       movb @game_flags,a              ; LD A,(34208)      ; Set Character Swap Pending Flag...
       socb @bits+6,a                  ; SET 6,A           ; ...
       movb a,@game_flags              ; LD (34208),A      ; ...
       rt                              ; RET               ; Return

*********************************************************************************
* Move All Falling Entities Down by Distances Appropriate to their Current Velocity Factors
* 
* If an entity's "velocity factor" is equal to its height in characters plus 3 (a proxy for its mass), then it has
* reached its terminal velocity.
move_falling_entities:
       .proc
       mov  @cmplx_state_data_addr,ix  ; LD IX,(34238)     ; Load IX with start address of current level's complex state data
       li   de,13                      ; LD DE,13          ; Load DE with 13 (as entries in complex state data are 13 bytes wide)
move_falling_entities_1:
       movb *ix,a                      ; LD A,(IX+0)       ; If first byte of entry is 255 (i.e. End Marker)...
       cb   a,@bytes+255               ; CP 255            ; ...
       jeq  move_falling_entities_9    ; RET Z             ; ...then return
       movb @10(ix),tmp0               ; BIT 6,(IX+10)     ; If current entity's "Can Fall" flag is reset...
       andi tmp0,64*256                ;                   
       jeq  move_falling_entities_5    ; JR Z,55592        ; ...then skip ahead to #R55592 (advance to next entity)
* Current entity's "Can Fall" Flag is set
       .push de                        ; PUSH DE           ; Store DE
       bl @copy_room_dim_data_to_tmp_3 ; CALL 53848        ; Store room size data for current entity's current room
       .pop de                         ; POP DE            ; Restore DE
       movb @6(ix),a                   ; LD A,(IX+6)       ; Load C with height (of entity defined by entry) + 3...
       sb   @4(ix),a                   ; SUB (IX+4)        ; ...
       ab   @bytes+4,a                 ; ADD A,4           ; ...
       movb a,@c                       ; LD C,A            ; ...
       movb @12(ix),a                  ; LD A,(IX+12)      ; Load B with velocity factor...
       movb a,b                        ; LD B,A            ; ...
       cb   a,@c                       ; CP C              ; If C is less than or equal to this (i.e. "terminal velocity" reached)...
       jhe  move_falling_entities_2    ; JR NC,55569       ; ...then skip ahead to #R55569
       ab   one,a                      ; INC A             ; Increase velocity factor by one and store for next pass (i.e. acceleration)...
       movb a,@12(ix)                  ; LD (IX+12),A      ; ...
move_falling_entities_2:
       srl  b,1                        ; SRL B             ; Divide current (i.e. not increased) velocity factor by 2
move_falling_entities_3:
       movb @6(ix),a                   ; LD A,(IX+6)       ; If sum of y-coordinate of entity's bottom and entity's depth is 122...
       ab   @1(ix),a                   ; ADD A,(IX+1)      ; ...(i.e. entity is at ground-level)...
       cb   a,@bytes+122               ; CP 122            ; ...
       jeq  move_falling_entities_6    ; JR Z,55596        ; ...then skip ahead to #R55596
move_falling_entities_4:
       ab   one,@4(ix)                 ; INC (IX+4)        ; Move entity down by one character...
       ab   one,@6(ix)                 ; INC (IX+6)        ; ...
       bl   @change_room_down          ; CALL 55616        ; Change entity's room down one if appropriate
       sb   one,b                      ; DJNZ 55571        ; Decrease B (current velocity factor, i.e. remaining number of characters to drop entity) and
       jne  move_falling_entities_3                     ;
                                                           ; if non-zero, loop back to #R55571
move_falling_entities_5:
       a    de,ix                      ; ADD IX,DE         ; Advance IX by 13 bytes to next entry
       jmp  move_falling_entities_1    ; JR 55532          ; Loop back to #R55532
* Entity's position is such that sum of y-coordinate of bottom + depth = 122 (i.e. at ground-level)
move_falling_entities_6:
       bl    @chk_coll_same_depth      ; CALL 54768        ; Check entity at IX for collision with another entity at same depth whose Interaction (11,6)
                                                           ; Flag is set...
move_falling_entities_7:
       joc  move_falling_entities_8    ; JR C,55610        ; ...and if no collision occurred, then skip ahead to #R55610
       cb   a,@bytes+129               ; CP 129            ; If collision was with entity of class 129 (causes other entities to start falling)...
       jeq  move_falling_entities_4    ; JR Z,55581        ; ...then jump to #R55581 (entity may fall down into next room)
* Collision was not with entity of class 129, so need to resume collision check from current position in entities
* list, i.e. entity that character did collide with
       bl   @chk_coll_same_depth_5     ; CALL 54871    ; Resume checking entity for collision with another entity at same depth whose Interaction
                                       ; (11,6) Flag is set...
       jmp  move_falling_entities_7    ; JR 55599          ; ...
* Entity has landed (i.e. is at ground-level and has not collided with a marker of class 129)
move_falling_entities_8:
       szcb @bits+6,@10(ix)            ; RES 6,(IX+10)     ; Reset entity's "Can Fall" flag as entity has landed
       jmp  move_falling_entities_5    ; JR 55592          ; Loop back for next entity
move_falling_entities_9:
       .endproc
*// move_falling_entities

*********************************************************************************
* If Current Character is in Same Room as Target Entity at IX then Set Pending Sound to A
* 
* If the requested sound has a lower index than the sound already pending then the requested sound overrides the
* pending sound (i.e. lower index has higher priority). Input:  A  Index of requested sound IX  Address of complex
* state data for target entity
request_entity_sound:
       .proc
       .push af                        ; PUSH AF           ; Store AF (A = index of requested sound)
       movb @current_characters_room,a ; LD A,(34218)      ; If current character's current room is the same as current room of target entity...
       cb   a,*ix                      ; CP (IX+0)         ; ...
       jeq  request_entity_sound_1     ; JR Z,59612        ; ...then skip ahead to #R59612
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       .endproc                        ; RET               ; Return
request_entity_sound_1:
       .pop af                         ; POP AF            ; Restore AF (A = index of requested sound)
       jmp  !
* At this point, A will hold the index of a requested sound, and RAM address #R34273 will contain the index of a
* pending sound. If the index of the requested sound is lower than the index of the pending sound, then the pending
* sound's index at #R34273 will be overwritten by the index of the requested sound in A. Sounds with lower indices
* therefore take priority over sounds with higher indices. This entry point is used by the routines at #R46284,
* #R55196 and #R59722.
request_sound_pri:
       .proc
!      socb a,a                        ; OR A              ; If index of requested sound is zero...
       jeq  request_sound_pri_2        ; RET Z             ; ...then return
       .push de                        ; PUSH DE           ; Store DE
       movb a,@e                       ; LD E,A            ; Load E with index of requested sound
       movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero (i.e. no sound pending)...
       jeq  request_sound_pri_1        ; JR Z,59628        ; ...then skip ahead to #R59628
       cb   a,@e                       ; CP E              ; If index of requested sound is less than or equal to index of pending sound...
       jhe  request_sound_pri_1        ; JR NC,59628       ; ...then skip ahead to #R59628
       .pop de                         ; POP DE            ; Restore DE
       jmp  request_sound_pri_2        ; RET               ; Return
request_sound_pri_1:
       movb @e,a                       ; LD A,E            ; Set requested sound to be new pending sound...
       movb a,@idx_pending_sound       ; LD (34273),A      ; ...
       .pop de                         ; POP DE            ; Restore DE
request_sound_pri_2:
       .endproc                        ; RET               ; Return

* Set Sound of Index A as Pending if Appropriate, then Play and Clear Pending Sound
*
* The sound with index A will become the pending sound if the currently pending sound index is either zero, or of
* higher index than A (i.e. lower priority). Input:  A  Sound index L  Undefined, pseudo-random value
request_sound:
       .proc
       bl   @request_sound_pri         ; CALL 59613        ; Set pending sound index to A if it is currently zero, or lower priority
       jmp  !
* This entry point is used by the routine at #R34438.
play_sound:
       .proc
!      movb @idx_pending_sound,a       ; LD A,(34273)      ; Load index of pending sound into A...
       socb a,a                        ; OR A              ; ...and if this is zero...
       jeq  play_sound_1               ; RET Z             ; ...then return
;       sb   one,a                      ; DEC A             ; Decrease A to give zero-based sound index
;       .push ix                        ; PUSH IX           ; Store IX
;       li   ix,sound_table+1           ; LD IX,59635       ; Point IX at second byte of first entry in Sound Parameters Table
;       a    a,a                        ; ADD A,A           ; Multiply sound index by eight...
;       a    a,a                        ; ADD A,A           ; ...as sound data entries in table at #R59634 are eight bytes wide...
;       a    a,a                        ; ADD A,A           ; ...
;       movb a,@c                       ; LD C,A            ; ...and load into BC...
;       sb   b,b                        ; LD B,0            ; ...
;       a    bc,ix                      ; ADD IX,BC         ; Add BC to IX as offset to point to sound data for pending sound
;       movb b,a                        ; LD A,B            ; Set index of pending sound to zero...
;       movb a,@_34273                  ; LD (34273),A      ; ...
;       movb *ix,@c                     ; LD C,(IX+0)       ; Load outer repeat count into C
;_59752:
;       movb @1(ix),b                   ; LD B,(IX+1)       ; Load inner repeat count into B
;       movb @2(ix),@e                  ; LD E,(IX+2)       ; Load delay constant E into E
;       movb @3(ix),d                   ; LD D,(IX+3)       ; Load delay constant D into D
;       movb @6(ix),h                   ; LD H,(IX+6)       ; Load most significant byte of pseudo-random address into H
;_59764:
;       .push bc                        ; PUSH BC           ; Store BC (B = inner repeat count, C = outer repeat count)
;       movb @border_color,a            ; LD A,(34217)      ; Load current border colour into A
;       socb @bits+4,a                  ; SET 4,A           ; Set Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb d,b                        ; LD B,D            ; Apply delay based upon delay constant D...
;_59773:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59773        ; ...
;       jne  _59773                     ;
;       movb h,tmp0                     ; BIT 7,H           ; If No Pause Flag is set...
;       andi tmp0,128*256               ;
;       jne  _59794                     ; JR NZ,59794       ; ...then skip ahead to #R59794
;       movb *hl,b                      ; LD B,(HL)         ; Load B with value from pseudo-random address
;       inc  hl                         ; INC HL            ; Advance HL
;_59782:
;       movb *ix,tmp0                   ; BIT 0,(IX+0)      ; Do nothing (pause) for period B...
;       andi tmp0,1*256                 ;
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59782        ; ...
;       jne  _59782                     ;
;_59794:
;       szcb @bits+4,a                  ; RES 4,A           ; Reset Speaker Bit
;       ; OUT (254),A                   ; OUT (254),A       ; Write Speaker Bit and border colour to Port 254
;       movb @e,b                       ; LD B,E            ; Do nothing for E cycles...
;_59799:
;       nop                             ; NOP               ; ...
;       sb   one,b                      ; DJNZ 59799        ; ...
;       jne  _59799                     ;
;       movb @4(ix),a                   ; LD A,(IX+4)       ; Adjust value of delay constant D...
;       a    d,a                        ; ADD A,D           ; ...
;       movb a,d                        ; LD D,A            ; ...
;       movb @5(ix),a                   ; LD A,(IX+5)       ; Adjust value of delay constant E...
;       a    @e,a                       ; ADD A,E           ; ...
;       movb a,@e                       ; LD E,A            ; ...
;       .pop bc                         ; POP BC            ; Restore BC (B = inner repeat count, C = outer repeat count)
;       sb   one,b                      ; DJNZ 59764        ; Loop back to #R59764
;       jne  _59764                     ;
;       sb   one,@c                     ; DEC C             ; Decrease outer repeat count
;       jne  _59752                     ; JR NZ,59752       ; If non-zero (i.e. more repeats to process) then loop back to #R59752
;       .pop ix                         ; POP IX            ; Restore IX
play_sound_1:
       .endproc                         ; RET               ; Return
